import * as React from 'react';
import { ExtendedPeoplePicker } from 'office-ui-fabric-react/lib/ExtendedPicker';
import { PrimaryButton } from 'office-ui-fabric-react/lib/Button';
import { SuggestionsStore, FloatingPeoplePicker } from 'office-ui-fabric-react/lib/FloatingPicker';
import { SelectedPeopleList } from 'office-ui-fabric-react/lib/SelectedItemsList';
import { FocusZoneTabbableElements } from 'office-ui-fabric-react/lib/FocusZone';
import { mergeStyleSets, getTheme } from 'office-ui-fabric-react/lib/Styling';
import { people, mru, groupOne, groupTwo } from '@uifabric/example-data';
import { useConst } from '@uifabric/react-hooks';
var theme = getTheme();
var startsWith = function (text, filterText) {
    return text.toLowerCase().indexOf(filterText.toLowerCase()) === 0;
};
var classNames = mergeStyleSets({
    picker: { maxWidth: 400, marginBottom: 15 },
    headerItem: {
        borderBottom: '1px solid ' + theme.palette.neutralLight,
        padding: '8px 12px',
    },
    footerItem: {
        borderBottom: '1px solid ' + theme.palette.neutralLight,
        height: 60,
        paddingLeft: 12,
    },
    to: { padding: '0 10px' },
});
var focusZoneProps = {
    shouldInputLoseFocusOnArrowKey: function () { return true; },
    handleTabKey: FocusZoneTabbableElements.all,
};
export var ExtendedPeoplePickerBasicExample = function () {
    var picker = React.useRef(null);
    var _a = React.useState(people), peopleList = _a[0], setPeopleList = _a[1];
    var _b = React.useState(mru), mostRecentlyUsed = _b[0], setMostRecentlyUsed = _b[1];
    var _c = React.useState(true), searchMoreAvailable = _c[0], setSearchMoreAvailable = _c[1];
    var getEditingItemText = function (item) {
        return item.text;
    };
    var onSetFocusButtonClicked = React.useCallback(function () {
        var _a;
        (_a = picker.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    var onExpandItem = function (item) {
        var _a;
        var selectedItemsList = (_a = picker.current) === null || _a === void 0 ? void 0 : _a.selectedItemsList.current;
        if (selectedItemsList) {
            selectedItemsList.replaceItem(item, getExpandedGroupItems(item));
        }
    };
    var onRemoveSuggestion = function (item) {
        var itemIndex = peopleList.indexOf(item);
        var itemMruIndex = mostRecentlyUsed.indexOf(item);
        if (itemIndex >= 0) {
            setPeopleList(peopleList.slice(0, itemIndex).concat(peopleList.slice(itemIndex + 1)));
        }
        if (itemMruIndex >= 0) {
            setMostRecentlyUsed(mostRecentlyUsed.slice(0, itemMruIndex).concat(mostRecentlyUsed.slice(itemMruIndex + 1)));
        }
    };
    var onFilterChanged = function (filterText, currentPersonas) {
        var filteredPersonas = [];
        if (filterText) {
            filteredPersonas = peopleList.filter(function (item) { return startsWith(item.text || '', filterText); });
            filteredPersonas = removeDuplicates(filteredPersonas, currentPersonas);
        }
        return convertResultsToPromise(filteredPersonas);
    };
    var returnMostRecentlyUsed = function () {
        var _a;
        var currentMostRecentlyUsed = mostRecentlyUsed;
        var items = ((_a = picker.current) === null || _a === void 0 ? void 0 : _a.items) || [];
        currentMostRecentlyUsed = removeDuplicates(currentMostRecentlyUsed, items);
        return convertResultsToPromise(currentMostRecentlyUsed);
    };
    var onCopyItems = function (items) {
        return items.map(function (item) { return item.text; }).join(', ');
    };
    var shouldShowForceResolve = function () {
        var _a;
        var floatingPicker = (_a = picker.current) === null || _a === void 0 ? void 0 : _a.floatingPicker.current;
        return !!floatingPicker && validateInput(floatingPicker.inputText) && floatingPicker.suggestions.length === 0;
    };
    var shouldShowSuggestedContacts = function () {
        var _a, _b;
        return ((_b = (_a = picker.current) === null || _a === void 0 ? void 0 : _a.inputElement) === null || _b === void 0 ? void 0 : _b.value) === '';
    };
    var listContainsPersona = function (persona, personas) {
        return !!personas && personas.some(function (item) { return item.text === persona.text; });
    };
    var removeDuplicates = function (personas, possibleDupes) {
        return personas.filter(function (persona) { return !listContainsPersona(persona, possibleDupes); });
    };
    var onInputChanged = function () {
        setSearchMoreAvailable(true);
    };
    var convertResultsToPromise = function (results) {
        return new Promise(function (resolve) { return setTimeout(function () { return resolve(results); }, 150); });
    };
    var validateInput = function (input) {
        return input.indexOf('@') !== -1;
    };
    var getExpandedGroupItems = function (item) {
        return item.text === 'Group One' ? groupOne : item.text === 'Group Two' ? groupTwo : [];
    };
    var suggestionProps = useConst({
        showRemoveButtons: true,
        headerItemsProps: [
            {
                renderItem: function () {
                    var _a, _b;
                    return (React.createElement("div", { className: classNames.headerItem },
                        "Use this address: ",
                        ((_b = (_a = picker.current) === null || _a === void 0 ? void 0 : _a.inputElement) === null || _b === void 0 ? void 0 : _b.value) || ''));
                },
                shouldShow: function () {
                    var _a;
                    return !!((_a = picker.current) === null || _a === void 0 ? void 0 : _a.inputElement) && picker.current.inputElement.value.indexOf('@') > -1;
                },
                onExecute: function () {
                    var _a;
                    var floatingPicker = (_a = picker.current) === null || _a === void 0 ? void 0 : _a.floatingPicker.current;
                    if (floatingPicker) {
                        floatingPicker.forceResolveSuggestion();
                    }
                },
                ariaLabel: 'Use the typed address',
            },
            {
                renderItem: function () {
                    return React.createElement("div", { className: classNames.headerItem }, "Suggested Contacts");
                },
                shouldShow: shouldShowSuggestedContacts,
            },
        ],
        footerItemsProps: [
            {
                renderItem: function () {
                    return React.createElement("div", { className: classNames.footerItem }, "No results");
                },
                shouldShow: function () {
                    var _a;
                    var floatingPicker = (_a = picker.current) === null || _a === void 0 ? void 0 : _a.floatingPicker.current;
                    return !!floatingPicker && floatingPicker.suggestions.length === 0;
                },
            },
            {
                renderItem: function () {
                    return React.createElement("div", { className: classNames.footerItem }, "Search for more");
                },
                onExecute: function () {
                    setSearchMoreAvailable(false);
                },
                shouldShow: function () {
                    return searchMoreAvailable && !shouldShowSuggestedContacts();
                },
                ariaLabel: 'Search more',
            },
        ],
        shouldSelectFirstItem: function () {
            return !shouldShowSuggestedContacts();
        },
    });
    var floatingPickerProps = {
        suggestionsStore: new SuggestionsStore(),
        onResolveSuggestions: onFilterChanged,
        getTextFromItem: function (persona) { return persona.text || ''; },
        pickerSuggestionsProps: suggestionProps,
        key: 'normal',
        onRemoveSuggestion: onRemoveSuggestion,
        onValidateInput: validateInput,
        onZeroQuerySuggestion: returnMostRecentlyUsed,
        showForceResolve: shouldShowForceResolve,
        onInputChanged: onInputChanged,
        onSuggestionsHidden: function () {
            console.log('FLOATINGPICKER: hidden');
        },
        onSuggestionsShown: function () {
            console.log('FLOATINGPICKER: shown');
        },
    };
    var selectedItemsListProps = {
        onCopyItems: onCopyItems,
        onExpandGroup: onExpandItem,
        removeMenuItemText: 'Remove',
        copyMenuItemText: 'Copy name',
        editMenuItemText: 'Edit',
        getEditingItemText: getEditingItemText,
        onRenderFloatingPicker: FloatingPeoplePicker,
        floatingPickerProps: floatingPickerProps,
    };
    return (React.createElement("div", null,
        React.createElement(ExtendedPeoplePicker, { floatingPickerProps: floatingPickerProps, selectedItemsListProps: selectedItemsListProps, onRenderFloatingPicker: FloatingPeoplePicker, onRenderSelectedItems: SelectedPeopleList, className: classNames.picker, key: "normal", inputProps: {
                onBlur: function () { return console.log('onBlur called'); },
                onFocus: function () { return console.log('onFocus called'); },
                'aria-label': 'People Picker',
            }, componentRef: picker, headerComponent: React.createElement("div", { className: classNames.to, "data-is-focusable": true }, "To:"), focusZoneProps: focusZoneProps }),
        React.createElement(PrimaryButton, { text: "Set focus", onClick: onSetFocusButtonClicked })));
};
//# sourceMappingURL=ExtendedPeoplePicker.Basic.Example.js.map