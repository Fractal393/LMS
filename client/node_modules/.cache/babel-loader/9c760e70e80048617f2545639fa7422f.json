{"ast":null,"code":"/**\r\n * DevExtreme (ui/draggable.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar $ = require(\"../core/renderer\");\n\nvar window = require(\"../core/utils/window\").getWindow();\n\nvar eventsEngine = require(\"../events/core/events_engine\");\n\nvar stringUtils = require(\"../core/utils/string\");\n\nvar registerComponent = require(\"../core/component_registrator\");\n\nvar translator = require(\"../animation/translator\");\n\nvar Animator = require(\"./scroll_view/animator\");\n\nvar browser = require(\"../core/utils/browser\");\n\nvar dasherize = require(\"../core/utils/inflector\").dasherize;\n\nvar extend = require(\"../core/utils/extend\").extend;\n\nvar DOMComponent = require(\"../core/dom_component\");\n\nvar getPublicElement = require(\"../core/utils/dom\").getPublicElement;\n\nvar eventUtils = require(\"../events/utils\");\n\nvar pointerEvents = require(\"../events/pointer\");\n\nvar dragEvents = require(\"../events/drag\");\n\nvar positionUtils = require(\"../animation/position\");\n\nvar typeUtils = require(\"../core/utils/type\");\n\nvar noop = require(\"../core/utils/common\").noop;\n\nvar viewPortUtils = require(\"../core/utils/view_port\");\n\nvar commonUtils = require(\"../core/utils/common\");\n\nvar EmptyTemplate = require(\"../core/templates/empty_template\").EmptyTemplate;\n\nvar deferredUtils = require(\"../core/utils/deferred\");\n\nvar getBoundingRect = require(\"../core/utils/position\").getBoundingRect;\n\nvar when = deferredUtils.when;\nvar fromPromise = deferredUtils.fromPromise;\nvar Deferred = deferredUtils.Deferred;\nvar DRAGGABLE = \"dxDraggable\";\nvar DRAGSTART_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, DRAGGABLE);\nvar DRAG_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, DRAGGABLE);\nvar DRAGEND_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, DRAGGABLE);\nvar DRAG_ENTER_EVENT_NAME = eventUtils.addNamespace(dragEvents.enter, DRAGGABLE);\nvar DRAGEND_LEAVE_EVENT_NAME = eventUtils.addNamespace(dragEvents.leave, DRAGGABLE);\nvar POINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, DRAGGABLE);\nvar CLONE_CLASS = \"clone\";\nvar targetDraggable;\nvar sourceDraggable;\nvar ANONYMOUS_TEMPLATE_NAME = \"content\";\n\nvar ScrollHelper = function () {\n  function ScrollHelper(orientation, component) {\n    _classCallCheck(this, ScrollHelper);\n\n    this._preventScroll = true;\n    this._component = component;\n\n    if (\"vertical\" === orientation) {\n      this._scrollValue = \"scrollTop\";\n      this._overFlowAttr = \"overflowY\";\n      this._sizeAttr = \"height\";\n      this._scrollSizeProp = \"scrollHeight\";\n      this._limitProps = {\n        start: \"top\",\n        end: \"bottom\"\n      };\n    } else {\n      this._scrollValue = \"scrollLeft\";\n      this._overFlowAttr = \"overflowX\";\n      this._sizeAttr = \"width\";\n      this._scrollSizeProp = \"scrollWidth\";\n      this._limitProps = {\n        start: \"left\",\n        end: \"right\"\n      };\n    }\n  }\n\n  _createClass(ScrollHelper, [{\n    key: \"updateScrollable\",\n    value: function (elements, mousePosition) {\n      var that = this;\n\n      if (!elements.some(function (element) {\n        return that._trySetScrollable(element, mousePosition);\n      })) {\n        that._$scrollableAtPointer = null;\n        that._scrollSpeed = 0;\n      }\n    }\n  }, {\n    key: \"isScrolling\",\n    value: function () {\n      return !!this._scrollSpeed;\n    }\n  }, {\n    key: \"isScrollable\",\n    value: function ($element) {\n      var that = this;\n      return (\"auto\" === $element.css(that._overFlowAttr) || $element.hasClass(\"dx-scrollable-container\")) && $element.prop(that._scrollSizeProp) > $element[that._sizeAttr]();\n    }\n  }, {\n    key: \"_trySetScrollable\",\n    value: function (element, mousePosition) {\n      var that = this;\n      var $element = $(element);\n      var distanceToBorders;\n\n      var sensitivity = that._component.option(\"scrollSensitivity\");\n\n      var isScrollable = that.isScrollable($element);\n\n      if (isScrollable) {\n        distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);\n\n        if (sensitivity > distanceToBorders[that._limitProps.start]) {\n          if (!that._preventScroll) {\n            that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);\n            that._$scrollableAtPointer = $element;\n          }\n        } else {\n          if (sensitivity > distanceToBorders[that._limitProps.end]) {\n            if (!that._preventScroll) {\n              that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);\n              that._$scrollableAtPointer = $element;\n            }\n          } else {\n            isScrollable = false;\n            that._preventScroll = false;\n          }\n        }\n      }\n\n      return isScrollable;\n    }\n  }, {\n    key: \"_calculateDistanceToBorders\",\n    value: function ($area, mousePosition) {\n      var area = $area.get(0);\n      var areaBoundingRect;\n\n      if (area) {\n        areaBoundingRect = getBoundingRect(area);\n        return {\n          left: mousePosition.x - areaBoundingRect.left,\n          top: mousePosition.y - areaBoundingRect.top,\n          right: areaBoundingRect.right - mousePosition.x,\n          bottom: areaBoundingRect.bottom - mousePosition.y\n        };\n      } else {\n        return {};\n      }\n    }\n  }, {\n    key: \"_calculateScrollSpeed\",\n    value: function (distance) {\n      var component = this._component;\n      var sensitivity = component.option(\"scrollSensitivity\");\n      var maxSpeed = component.option(\"scrollSpeed\");\n      return Math.ceil(Math.pow((sensitivity - distance) / sensitivity, 2) * maxSpeed);\n    }\n  }, {\n    key: \"scrollByStep\",\n    value: function () {\n      var that = this;\n      var nextScrollPosition;\n\n      if (that._$scrollableAtPointer && that._scrollSpeed) {\n        if (that._$scrollableAtPointer.hasClass(\"dx-scrollable-container\")) {\n          var $scrollable = that._$scrollableAtPointer.closest(\".dx-scrollable\");\n\n          var scrollableInstance = $scrollable.data(\"dxScrollable\") || $scrollable.data(\"dxScrollView\");\n\n          if (scrollableInstance) {\n            nextScrollPosition = scrollableInstance.scrollOffset();\n            nextScrollPosition[that._limitProps.start] += that._scrollSpeed;\n            scrollableInstance.scrollTo(nextScrollPosition);\n          }\n        } else {\n          nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;\n\n          that._$scrollableAtPointer[that._scrollValue](nextScrollPosition);\n        }\n\n        var dragMoveArgs = that._component._dragMoveArgs;\n\n        if (dragMoveArgs) {\n          that._component._dragMoveHandler(dragMoveArgs);\n        }\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function () {\n      this._$scrollableAtPointer = null;\n      this._scrollSpeed = 0;\n      this._preventScroll = true;\n    }\n  }, {\n    key: \"isOutsideScrollable\",\n    value: function ($scrollable, event) {\n      if (!$scrollable) {\n        return false;\n      }\n\n      var scrollableSize = getBoundingRect($scrollable.get(0));\n      var start = scrollableSize[this._limitProps.start];\n      var size = scrollableSize[this._sizeAttr];\n      var location = \"width\" === this._sizeAttr ? event.pageX : event.pageY;\n      return location < start || location > start + size;\n    }\n  }]);\n\n  return ScrollHelper;\n}();\n\nvar ScrollAnimator = Animator.inherit({\n  ctor: function (strategy) {\n    this.callBase();\n    this._strategy = strategy;\n  },\n  _step: function () {\n    var horizontalScrollHelper = this._strategy._horizontalScrollHelper;\n    var verticalScrollHelper = this._strategy._verticalScrollHelper;\n    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();\n    verticalScrollHelper && verticalScrollHelper.scrollByStep();\n  }\n});\nvar Draggable = DOMComponent.inherit({\n  reset: noop,\n  dragMove: noop,\n  dragEnter: noop,\n  dragLeave: noop,\n  dragEnd: function (sourceEvent) {\n    var sourceDraggable = this._getSourceDraggable();\n\n    sourceDraggable._fireRemoveEvent(sourceEvent);\n\n    return new Deferred().resolve();\n  },\n  _fireRemoveEvent: noop,\n  _getDefaultOptions: function () {\n    return extend(this.callBase(), {\n      onDragStart: null,\n      onDragMove: null,\n      onDragEnd: null,\n      onDrop: null,\n      immediate: true,\n      dragDirection: \"both\",\n      boundary: void 0,\n      boundOffset: 0,\n      allowMoveByClick: false,\n      itemData: null,\n      container: void 0,\n      dragTemplate: void 0,\n      contentTemplate: \"content\",\n      handle: \"\",\n      filter: \"\",\n      clone: false,\n      autoScroll: true,\n      scrollSpeed: 30,\n      scrollSensitivity: 60,\n      group: void 0,\n      data: void 0\n    });\n  },\n  _setOptionsByReference: function () {\n    this.callBase.apply(this, arguments);\n    extend(this._optionsByReference, {\n      component: true,\n      group: true,\n      itemData: true,\n      data: true\n    });\n  },\n  _init: function () {\n    this.callBase();\n\n    this._attachEventHandlers();\n\n    this._scrollAnimator = new ScrollAnimator(this);\n    this._horizontalScrollHelper = new ScrollHelper(\"horizontal\", this);\n    this._verticalScrollHelper = new ScrollHelper(\"vertical\", this);\n  },\n  _normalizeCursorOffset: function (offset) {\n    if (typeUtils.isObject(offset)) {\n      offset = {\n        h: offset.x,\n        v: offset.y\n      };\n    }\n\n    offset = commonUtils.splitPair(offset).map(function (value) {\n      return parseFloat(value);\n    });\n    return {\n      left: offset[0],\n      top: 1 === offset.length ? offset[0] : offset[1]\n    };\n  },\n  _getNormalizedCursorOffset: function (offset, options) {\n    if (typeUtils.isFunction(offset)) {\n      offset = offset.call(this, options);\n    }\n\n    return this._normalizeCursorOffset(offset);\n  },\n  _calculateElementOffset: function (options) {\n    var elementOffset;\n    var dragElementOffset;\n    var event = options.event;\n    var $element = $(options.itemElement);\n    var $dragElement = $(options.dragElement);\n\n    var isCloned = this._dragElementIsCloned();\n\n    var cursorOffset = this.option(\"cursorOffset\");\n    var normalizedCursorOffset = {\n      left: 0,\n      top: 0\n    };\n    var currentLocate = this._initialLocate = translator.locate($dragElement);\n\n    if (isCloned || options.initialOffset || cursorOffset) {\n      elementOffset = options.initialOffset || $element.offset();\n\n      if (cursorOffset) {\n        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options);\n\n        if (isFinite(normalizedCursorOffset.left)) {\n          elementOffset.left = event.pageX;\n        }\n\n        if (isFinite(normalizedCursorOffset.top)) {\n          elementOffset.top = event.pageY;\n        }\n      }\n\n      dragElementOffset = $dragElement.offset();\n      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;\n      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;\n    }\n\n    return elementOffset;\n  },\n  _initPosition: function (options) {\n    var $dragElement = $(options.dragElement);\n\n    var elementOffset = this._calculateElementOffset(options);\n\n    if (elementOffset) {\n      this._move(elementOffset, $dragElement);\n    }\n\n    this._startPosition = translator.locate($dragElement);\n  },\n  _startAnimator: function () {\n    if (!this._scrollAnimator.inProgress()) {\n      this._scrollAnimator.start();\n    }\n  },\n  _stopAnimator: function () {\n    this._scrollAnimator.stop();\n  },\n  _addWidgetPrefix: function (className) {\n    var componentName = this.NAME;\n    return dasherize(componentName) + (className ? \"-\" + className : \"\");\n  },\n  _getItemsSelector: function () {\n    return this.option(\"filter\") || \"\";\n  },\n  _$content: function () {\n    var $element = this.$element();\n    var $wrapper = $element.children(\".dx-template-wrapper\");\n    return $wrapper.length ? $wrapper : $element;\n  },\n  _attachEventHandlers: function () {\n    var _this = this;\n\n    if (this.option(\"disabled\")) {\n      return;\n    }\n\n    var $element = this._$content();\n\n    var itemsSelector = this._getItemsSelector();\n\n    var allowMoveByClick = this.option(\"allowMoveByClick\");\n    var data = {\n      direction: this.option(\"dragDirection\"),\n      immediate: this.option(\"immediate\"),\n      checkDropTarget: function ($target, event) {\n        var targetGroup = _this.option(\"group\");\n\n        var sourceGroup = _this._getSourceDraggable().option(\"group\");\n\n        var $scrollable = _this._getScrollable($target);\n\n        if (_this._verticalScrollHelper.isOutsideScrollable($scrollable, event) || _this._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {\n          return false;\n        }\n\n        return sourceGroup && sourceGroup === targetGroup;\n      }\n    };\n\n    if (allowMoveByClick) {\n      $element = this._getArea();\n      eventsEngine.on($element, POINTERDOWN_EVENT_NAME, data, this._pointerDownHandler.bind(this));\n    }\n\n    if (\">\" === itemsSelector[0]) {\n      itemsSelector = itemsSelector.slice(1);\n    }\n\n    eventsEngine.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data, this._dragStartHandler.bind(this));\n    eventsEngine.on($element, DRAG_EVENT_NAME, data, this._dragMoveHandler.bind(this));\n    eventsEngine.on($element, DRAGEND_EVENT_NAME, data, this._dragEndHandler.bind(this));\n    eventsEngine.on($element, DRAG_ENTER_EVENT_NAME, data, this._dragEnterHandler.bind(this));\n    eventsEngine.on($element, DRAGEND_LEAVE_EVENT_NAME, data, this._dragLeaveHandler.bind(this));\n  },\n  _dragElementIsCloned: function () {\n    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS));\n  },\n  _getDragTemplateArgs: function ($element, $container) {\n    return {\n      container: getPublicElement($container),\n      model: {\n        itemData: this.option(\"itemData\"),\n        itemElement: getPublicElement($element)\n      }\n    };\n  },\n  _createDragElement: function ($element) {\n    var result = $element;\n    var clone = this.option(\"clone\");\n\n    var $container = this._getContainer();\n\n    var template = this.option(\"dragTemplate\");\n\n    if (template) {\n      template = this._getTemplate(template);\n      result = $(\"<div>\").appendTo($container);\n      template.render(this._getDragTemplateArgs($element, result));\n    } else {\n      if (clone) {\n        result = $(\"<div>\").appendTo($container);\n        $element.clone().css({\n          width: $element.css(\"width\"),\n          height: $element.css(\"height\")\n        }).appendTo(result);\n      }\n    }\n\n    return result.toggleClass(this._addWidgetPrefix(CLONE_CLASS), result.get(0) !== $element.get(0)).toggleClass(\"dx-rtl\", this.option(\"rtlEnabled\"));\n  },\n  _resetDragElement: function () {\n    if (this._dragElementIsCloned()) {\n      this._$dragElement.remove();\n    } else {\n      this._toggleDraggingClass(false);\n    }\n\n    this._$dragElement = null;\n  },\n  _resetSourceElement: function () {\n    this._toggleDragSourceClass(false);\n\n    this._$sourceElement = null;\n  },\n  _detachEventHandlers: function () {\n    eventsEngine.off(this._$content(), \".\" + DRAGGABLE);\n    eventsEngine.off(this._getArea(), \".\" + DRAGGABLE);\n  },\n  _move: function (position, $element) {\n    translator.move($element || this._$dragElement, position);\n  },\n  _getDraggableElement: function (e) {\n    var $sourceElement = this._getSourceElement();\n\n    if ($sourceElement) {\n      return $sourceElement;\n    }\n\n    var allowMoveByClick = this.option(\"allowMoveByClick\");\n\n    if (allowMoveByClick) {\n      return this.$element();\n    }\n\n    var $target = $(e && e.target);\n\n    var itemsSelector = this._getItemsSelector();\n\n    if (\">\" === itemsSelector[0]) {\n      var $items = this._$content().find(itemsSelector);\n\n      if (!$items.is($target)) {\n        $target = $target.closest($items);\n      }\n    }\n\n    return $target;\n  },\n  _getSourceElement: function () {\n    var draggable = this._getSourceDraggable();\n\n    return draggable._$sourceElement;\n  },\n  _pointerDownHandler: function (e) {\n    if (eventUtils.needSkipEvent(e)) {\n      return;\n    }\n\n    var position = {};\n    var $element = this.$element();\n    var dragDirection = this.option(\"dragDirection\");\n\n    if (\"horizontal\" === dragDirection || \"both\" === dragDirection) {\n      position.left = e.pageX - $element.offset().left + translator.locate($element).left - $element.width() / 2;\n    }\n\n    if (\"vertical\" === dragDirection || \"both\" === dragDirection) {\n      position.top = e.pageY - $element.offset().top + translator.locate($element).top - $element.height() / 2;\n    }\n\n    this._move(position, $element);\n\n    this._getAction(\"onDragMove\")(this._getEventArgs(e));\n  },\n  _isValidElement: function (event, $element) {\n    var handle = this.option(\"handle\");\n    var $target = $(event.originalEvent && event.originalEvent.target);\n\n    if (handle && !$target.closest(handle).length) {\n      return false;\n    }\n\n    if (!$element.length) {\n      return false;\n    }\n\n    return !$element.is(\".dx-state-disabled, .dx-state-disabled *\");\n  },\n  _dragStartHandler: function (e) {\n    var $element = this._getDraggableElement(e);\n\n    if (this._$sourceElement) {\n      return;\n    }\n\n    if (!this._isValidElement(e, $element)) {\n      e.cancel = true;\n      return;\n    }\n\n    var dragStartArgs = this._getDragStartArgs(e, $element);\n\n    this._getAction(\"onDragStart\")(dragStartArgs);\n\n    if (dragStartArgs.cancel) {\n      e.cancel = true;\n      return;\n    }\n\n    this.option(\"itemData\", dragStartArgs.itemData);\n\n    this._setSourceDraggable();\n\n    this._$sourceElement = $element;\n    var initialOffset = $element.offset();\n\n    var $dragElement = this._$dragElement = this._createDragElement($element);\n\n    this._toggleDraggingClass(true);\n\n    this._toggleDragSourceClass(true);\n\n    var isFixedPosition = \"fixed\" === $dragElement.css(\"position\");\n\n    this._initPosition(extend({}, dragStartArgs, {\n      dragElement: $dragElement.get(0),\n      initialOffset: isFixedPosition && initialOffset\n    }));\n\n    var $area = this._getArea();\n\n    var areaOffset = this._getAreaOffset($area);\n\n    var boundOffset = this._getBoundOffset();\n\n    var areaWidth = $area.outerWidth();\n    var areaHeight = $area.outerHeight();\n    var elementWidth = $dragElement.width();\n    var elementHeight = $dragElement.height();\n    var startOffset = {\n      left: $dragElement.offset().left - areaOffset.left,\n      top: $dragElement.offset().top - areaOffset.top\n    };\n\n    if ($area.length) {\n      e.maxLeftOffset = startOffset.left - boundOffset.left;\n      e.maxRightOffset = areaWidth - startOffset.left - elementWidth - boundOffset.right;\n      e.maxTopOffset = startOffset.top - boundOffset.top;\n      e.maxBottomOffset = areaHeight - startOffset.top - elementHeight - boundOffset.bottom;\n    }\n\n    if (this.option(\"autoScroll\")) {\n      this._startAnimator();\n    }\n  },\n  _getAreaOffset: function ($area) {\n    var offset = $area && positionUtils.offset($area);\n    return offset ? offset : {\n      left: 0,\n      top: 0\n    };\n  },\n  _toggleDraggingClass: function (value) {\n    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix(\"dragging\"), value);\n  },\n  _toggleDragSourceClass: function (value, $element) {\n    var $sourceElement = $element || this._$sourceElement;\n    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix(\"source\"), value);\n  },\n  _getBoundOffset: function () {\n    var boundOffset = this.option(\"boundOffset\");\n\n    if (typeUtils.isFunction(boundOffset)) {\n      boundOffset = boundOffset.call(this);\n    }\n\n    return stringUtils.quadToObject(boundOffset);\n  },\n  _getArea: function () {\n    var area = this.option(\"boundary\");\n\n    if (typeUtils.isFunction(area)) {\n      area = area.call(this);\n    }\n\n    return $(area);\n  },\n  _getContainer: function () {\n    var container = this.option(\"container\");\n\n    if (void 0 === container) {\n      container = viewPortUtils.value();\n    }\n\n    return $(container);\n  },\n  _dragMoveHandler: function (e) {\n    this._dragMoveArgs = e;\n\n    if (!this._$dragElement) {\n      e.cancel = true;\n      return;\n    }\n\n    var offset = e.offset;\n    var startPosition = this._startPosition;\n\n    this._move({\n      left: startPosition.left + offset.x,\n      top: startPosition.top + offset.y\n    });\n\n    this._updateScrollable(e);\n\n    var eventArgs = this._getEventArgs(e);\n\n    this._getAction(\"onDragMove\")(eventArgs);\n\n    if (true === eventArgs.cancel) {\n      return;\n    }\n\n    var targetDraggable = this._getTargetDraggable();\n\n    targetDraggable.dragMove(e);\n  },\n  _updateScrollable: function (e) {\n    var that = this;\n\n    if (that.option(\"autoScroll\")) {\n      var $window = $(window);\n      var mousePosition = {\n        x: e.pageX - $window.scrollLeft(),\n        y: e.pageY - $window.scrollTop()\n      };\n      var allObjects = that.getElementsFromPoint(mousePosition);\n\n      that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);\n\n      that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);\n    }\n  },\n  getElementsFromPoint: function (position, dragElement) {\n    var ownerDocument = (dragElement || this._$dragElement.get(0)).ownerDocument;\n\n    if (browser.msie) {\n      var msElements = ownerDocument.msElementsFromPoint(position.x, position.y);\n\n      if (msElements) {\n        return Array.prototype.slice.call(msElements);\n      }\n\n      return [];\n    }\n\n    return ownerDocument.elementsFromPoint(position.x, position.y);\n  },\n  _getScrollable: function ($element) {\n    var _this2 = this;\n\n    var $scrollable;\n    $element.parents().toArray().some(function (parent) {\n      var $parent = $(parent);\n\n      if (_this2._horizontalScrollHelper.isScrollable($parent) || _this2._verticalScrollHelper.isScrollable($parent)) {\n        $scrollable = $parent;\n        return true;\n      }\n    });\n    return $scrollable;\n  },\n  _defaultActionArgs: function () {\n    var args = this.callBase.apply(this, arguments);\n    var component = this.option(\"component\");\n\n    if (component) {\n      args.component = component;\n      args.element = component.element();\n    }\n\n    return args;\n  },\n  _getEventArgs: function (e) {\n    var sourceDraggable = this._getSourceDraggable();\n\n    var targetDraggable = this._getTargetDraggable();\n\n    return {\n      event: e,\n      itemData: sourceDraggable.option(\"itemData\"),\n      itemElement: getPublicElement(sourceDraggable._$sourceElement),\n      fromComponent: sourceDraggable.option(\"component\") || sourceDraggable,\n      toComponent: targetDraggable.option(\"component\") || targetDraggable,\n      fromData: sourceDraggable.option(\"data\"),\n      toData: targetDraggable.option(\"data\")\n    };\n  },\n  _getDragStartArgs: function (e, $itemElement) {\n    var args = this._getEventArgs(e);\n\n    return {\n      event: args.event,\n      itemData: args.itemData,\n      itemElement: $itemElement,\n      fromData: args.fromData\n    };\n  },\n  _revertItemToInitialPosition: function () {\n    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);\n  },\n  _dragEndHandler: function (e) {\n    var _this3 = this;\n\n    var d = new Deferred();\n\n    var dragEndEventArgs = this._getEventArgs(e);\n\n    var dropEventArgs = this._getEventArgs(e);\n\n    var targetDraggable = this._getTargetDraggable();\n\n    var needRevertPosition = true;\n\n    try {\n      this._getAction(\"onDragEnd\")(dragEndEventArgs);\n    } finally {\n      when(fromPromise(dragEndEventArgs.cancel)).done(function (cancel) {\n        if (!cancel) {\n          if (targetDraggable !== _this3) {\n            targetDraggable._getAction(\"onDrop\")(dropEventArgs);\n          }\n\n          if (!dropEventArgs.cancel) {\n            needRevertPosition = false;\n            when(fromPromise(targetDraggable.dragEnd(dragEndEventArgs))).always(d.resolve);\n            return;\n          }\n        }\n\n        d.resolve();\n      }).fail(d.resolve);\n      d.done(function () {\n        if (needRevertPosition) {\n          _this3._revertItemToInitialPosition();\n        }\n\n        _this3.reset();\n\n        targetDraggable.reset();\n\n        _this3._stopAnimator();\n\n        _this3._horizontalScrollHelper.reset();\n\n        _this3._verticalScrollHelper.reset();\n\n        _this3._resetDragElement();\n\n        _this3._resetSourceElement();\n\n        _this3._resetTargetDraggable();\n\n        _this3._resetSourceDraggable();\n      });\n    }\n  },\n  _isTargetOverAnotherDraggable: function (e) {\n    var _this4 = this;\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    if (this === sourceDraggable) {\n      return false;\n    }\n\n    if (!sourceDraggable._dragElementIsCloned()) {\n      return true;\n    }\n\n    var $sourceDraggableElement = sourceDraggable.$element();\n    var elements = this.getElementsFromPoint({\n      x: e.pageX,\n      y: e.pageY\n    }, e.target);\n    var firstWidgetElement = elements.filter(function (element) {\n      return $(element).hasClass(_this4._addWidgetPrefix());\n    })[0];\n    return firstWidgetElement !== $sourceDraggableElement.get(0);\n  },\n  _dragEnterHandler: function (e) {\n    if (this._isTargetOverAnotherDraggable(e)) {\n      this._setTargetDraggable();\n    }\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    sourceDraggable.dragEnter(e);\n  },\n  _dragLeaveHandler: function (e) {\n    this._resetTargetDraggable();\n\n    if (this !== this._getSourceDraggable()) {\n      this.reset();\n    }\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    sourceDraggable.dragLeave(e);\n  },\n  _getAction: function (name) {\n    return this[\"_\" + name + \"Action\"] || this._createActionByOption(name);\n  },\n  _getAnonymousTemplateName: function () {\n    return ANONYMOUS_TEMPLATE_NAME;\n  },\n  _initTemplates: function () {\n    if (!this.option(\"contentTemplate\")) {\n      return;\n    }\n\n    this._templateManager.addDefaultTemplates({\n      content: new EmptyTemplate()\n    });\n\n    this.callBase.apply(this, arguments);\n  },\n  _render: function () {\n    this.callBase();\n    this.$element().addClass(this._addWidgetPrefix());\n    var transclude = this._templateManager.anonymousTemplateName === this.option(\"contentTemplate\");\n\n    var template = this._getTemplateByOption(\"contentTemplate\");\n\n    if (template) {\n      $(template.render({\n        container: this.element(),\n        transclude: transclude\n      }));\n    }\n  },\n  _optionChanged: function (args) {\n    var name = args.name;\n\n    switch (name) {\n      case \"onDragStart\":\n      case \"onDragMove\":\n      case \"onDragEnd\":\n      case \"onDrop\":\n        this[\"_\" + name + \"Action\"] = this._createActionByOption(name);\n        break;\n\n      case \"dragTemplate\":\n      case \"contentTemplate\":\n      case \"container\":\n      case \"clone\":\n        break;\n\n      case \"allowMoveByClick\":\n      case \"dragDirection\":\n      case \"disabled\":\n      case \"boundary\":\n      case \"filter\":\n      case \"immediate\":\n        this._resetDragElement();\n\n        this._detachEventHandlers();\n\n        this._attachEventHandlers();\n\n        break;\n\n      case \"autoScroll\":\n        this._verticalScrollHelper.reset();\n\n        this._horizontalScrollHelper.reset();\n\n        break;\n\n      case \"scrollSensitivity\":\n      case \"scrollSpeed\":\n      case \"boundOffset\":\n      case \"handle\":\n      case \"group\":\n      case \"data\":\n      case \"itemData\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _getTargetDraggable: function () {\n    return targetDraggable || this;\n  },\n  _getSourceDraggable: function () {\n    return sourceDraggable || this;\n  },\n  _setTargetDraggable: function () {\n    var currentGroup = this.option(\"group\");\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    if (currentGroup && currentGroup === sourceDraggable.option(\"group\")) {\n      targetDraggable = this;\n    }\n  },\n  _setSourceDraggable: function () {\n    sourceDraggable = this;\n  },\n  _resetSourceDraggable: function () {\n    sourceDraggable = null;\n  },\n  _resetTargetDraggable: function () {\n    targetDraggable = null;\n  },\n  _dispose: function () {\n    this.callBase();\n\n    this._detachEventHandlers();\n\n    this._resetDragElement();\n\n    this._resetTargetDraggable();\n\n    this._resetSourceDraggable();\n\n    this._$sourceElement = null;\n\n    this._stopAnimator();\n  }\n});\nregisterComponent(DRAGGABLE, Draggable);\nmodule.exports = Draggable;\nmodule.exports.default = module.exports;","map":null,"metadata":{},"sourceType":"script"}