{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.scrollable.simulated.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _dom_adapter = require(\"../../core/dom_adapter\");\n\nvar _dom_adapter2 = _interopRequireDefault(_dom_adapter);\n\nvar _events_engine = require(\"../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _inflector = require(\"../../core/utils/inflector\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _window = require(\"../../core/utils/window\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _position = require(\"../../core/utils/position\");\n\nvar _translator = require(\"../../animation/translator\");\n\nvar _translator2 = _interopRequireDefault(_translator);\n\nvar _class = require(\"../../core/class\");\n\nvar _class2 = _interopRequireDefault(_class);\n\nvar _animator = require(\"./animator\");\n\nvar _animator2 = _interopRequireDefault(_animator);\n\nvar _devices = require(\"../../core/devices\");\n\nvar _devices2 = _interopRequireDefault(_devices);\n\nvar _utils = require(\"../../events/utils\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _ui = require(\"./ui.scrollbar\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar realDevice = _devices2.default.real;\nvar isSluggishPlatform = \"android\" === realDevice.platform;\nvar SCROLLABLE_SIMULATED = \"dxSimulatedScrollable\";\nvar SCROLLABLE_STRATEGY = \"dxScrollableStrategy\";\nvar SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + \"Cursor\";\nvar SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + \"Keyboard\";\nvar SCROLLABLE_SIMULATED_CLASS = \"dx-scrollable-simulated\";\nvar SCROLLABLE_SCROLLBARS_HIDDEN = \"dx-scrollable-scrollbars-hidden\";\nvar SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = \"dx-scrollable-scrollbars-alwaysvisible\";\nvar SCROLLABLE_SCROLLBAR_CLASS = \"dx-scrollable-scrollbar\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar ACCELERATION = isSluggishPlatform ? .95 : .92;\nvar OUT_BOUNDS_ACCELERATION = .5;\nvar MIN_VELOCITY_LIMIT = 1;\nvar FRAME_DURATION = Math.round(1e3 / 60);\nvar SCROLL_LINE_HEIGHT = 40;\nvar VALIDATE_WHEEL_TIMEOUT = 500;\nvar BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5;\nvar BOUNCE_DURATION = isSluggishPlatform ? 300 : 400;\nvar BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION;\nvar BOUNCE_ACCELERATION_SUM = (1 - Math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);\nvar KEY_CODES = {\n  PAGE_UP: \"pageUp\",\n  PAGE_DOWN: \"pageDown\",\n  END: \"end\",\n  HOME: \"home\",\n  LEFT: \"leftArrow\",\n  UP: \"upArrow\",\n  RIGHT: \"rightArrow\",\n  DOWN: \"downArrow\",\n  TAB: \"tab\"\n};\n\nvar InertiaAnimator = _animator2.default.inherit({\n  ctor: function (scroller) {\n    this.callBase();\n    this.scroller = scroller;\n  },\n  VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,\n  _isFinished: function () {\n    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;\n  },\n  _step: function () {\n    this.scroller._scrollStep(this.scroller._velocity);\n\n    this.scroller._velocity *= this._acceleration();\n  },\n  _acceleration: function () {\n    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION;\n  },\n  _complete: function () {\n    this.scroller._scrollComplete();\n  },\n  _stop: function () {\n    this.scroller._stopComplete();\n  }\n});\n\nvar BounceAnimator = InertiaAnimator.inherit({\n  VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,\n  _isFinished: function () {\n    return this.scroller._crossBoundOnNextStep() || this.callBase();\n  },\n  _acceleration: function () {\n    return ACCELERATION;\n  },\n  _complete: function () {\n    this.scroller._move(this.scroller._bounceLocation);\n\n    this.callBase();\n  }\n});\n\nvar Scroller = _class2.default.inherit({\n  ctor: function (options) {\n    this._initOptions(options);\n\n    this._initAnimators();\n\n    this._initScrollbar();\n  },\n  _initOptions: function (options) {\n    var _this = this;\n\n    this._location = 0;\n    this._topReached = false;\n    this._bottomReached = false;\n    this._axis = options.direction === HORIZONTAL ? \"x\" : \"y\";\n    this._prop = options.direction === HORIZONTAL ? \"left\" : \"top\";\n    this._dimension = options.direction === HORIZONTAL ? \"width\" : \"height\";\n    this._scrollProp = options.direction === HORIZONTAL ? \"scrollLeft\" : \"scrollTop\";\n    (0, _iterator.each)(options, function (optionName, optionValue) {\n      _this[\"_\" + optionName] = optionValue;\n    });\n  },\n  _initAnimators: function () {\n    this._inertiaAnimator = new InertiaAnimator(this);\n    this._bounceAnimator = new BounceAnimator(this);\n  },\n  _initScrollbar: function () {\n    this._scrollbar = new _ui2.default((0, _renderer2.default)(\"<div>\").appendTo(this._$container), {\n      direction: this._direction,\n      visible: this._scrollByThumb,\n      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),\n      expandable: this._scrollByThumb\n    });\n    this._$scrollbar = this._scrollbar.$element();\n  },\n  _visibilityModeNormalize: function (mode) {\n    return true === mode ? \"onScroll\" : false === mode ? \"never\" : mode;\n  },\n  _scrollStep: function (delta) {\n    var prevLocation = this._location;\n    this._location += delta;\n\n    this._suppressBounce();\n\n    this._move();\n\n    if (Math.abs(prevLocation - this._location) < 1) {\n      return;\n    }\n\n    _events_engine2.default.triggerHandler(this._$container, {\n      type: \"scroll\"\n    });\n  },\n  _suppressBounce: function () {\n    if (this._bounceEnabled || this._inBounds(this._location)) {\n      return;\n    }\n\n    this._velocity = 0;\n    this._location = this._boundLocation();\n  },\n  _boundLocation: function (location) {\n    location = void 0 !== location ? location : this._location;\n    return Math.max(Math.min(location, this._maxOffset), this._minOffset);\n  },\n  _move: function (location) {\n    this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;\n\n    this._moveContent();\n\n    this._moveScrollbar();\n  },\n  _moveContent: function () {\n    var location = this._location;\n\n    this._$container[this._scrollProp](-location / this._getScaleRatio());\n\n    this._moveContentByTranslator(location);\n  },\n  _getScaleRatio: function () {\n    if ((0, _window.hasWindow)() && !this._scaleRatio) {\n      var element = this._$element.get(0);\n\n      var realDimension = this._getRealDimension(element, this._dimension);\n\n      var baseDimension = this._getBaseDimension(element, this._dimension);\n\n      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;\n    }\n\n    return this._scaleRatio || 1;\n  },\n  _getRealDimension: function (element, dimension) {\n    return Math.round((0, _position.getBoundingRect)(element)[dimension]);\n  },\n  _getBaseDimension: function (element, dimension) {\n    var dimensionName = \"offset\" + (0, _inflector.titleize)(dimension);\n    return element[dimensionName];\n  },\n  _moveContentByTranslator: function (location) {\n    var translateOffset;\n    var minOffset = -this._maxScrollPropValue;\n\n    if (location > 0) {\n      translateOffset = location;\n    } else {\n      if (location <= minOffset) {\n        translateOffset = location - minOffset;\n      } else {\n        translateOffset = location % 1;\n      }\n    }\n\n    if (this._translateOffset === translateOffset) {\n      return;\n    }\n\n    var targetLocation = {};\n    targetLocation[this._prop] = translateOffset;\n    this._translateOffset = translateOffset;\n\n    if (0 === translateOffset) {\n      _translator2.default.resetPosition(this._$content);\n\n      return;\n    }\n\n    _translator2.default.move(this._$content, targetLocation);\n  },\n  _moveScrollbar: function () {\n    this._scrollbar.moveTo(this._location);\n  },\n  _scrollComplete: function () {\n    if (this._inBounds()) {\n      this._hideScrollbar();\n\n      if (this._completeDeferred) {\n        this._completeDeferred.resolve();\n      }\n    }\n\n    this._scrollToBounds();\n  },\n  _scrollToBounds: function () {\n    if (this._inBounds()) {\n      return;\n    }\n\n    this._bounceAction();\n\n    this._setupBounce();\n\n    this._bounceAnimator.start();\n  },\n  _setupBounce: function () {\n    var boundLocation = this._bounceLocation = this._boundLocation();\n\n    var bounceDistance = boundLocation - this._location;\n    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;\n  },\n  _inBounds: function (location) {\n    location = void 0 !== location ? location : this._location;\n    return this._boundLocation(location) === location;\n  },\n  _crossBoundOnNextStep: function () {\n    var location = this._location;\n    var nextLocation = location + this._velocity;\n    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;\n  },\n  _initHandler: function (e) {\n    this._stopDeferred = new _deferred.Deferred();\n\n    this._stopScrolling();\n\n    this._prepareThumbScrolling(e);\n\n    return this._stopDeferred.promise();\n  },\n  _stopScrolling: (0, _common.deferRenderer)(function () {\n    this._hideScrollbar();\n\n    this._inertiaAnimator.stop();\n\n    this._bounceAnimator.stop();\n  }),\n  _prepareThumbScrolling: function (e) {\n    if ((0, _utils.isDxMouseWheelEvent)(e.originalEvent)) {\n      return;\n    }\n\n    var $target = (0, _renderer2.default)(e.originalEvent.target);\n\n    var scrollbarClicked = this._isScrollbar($target);\n\n    if (scrollbarClicked) {\n      this._moveToMouseLocation(e);\n    }\n\n    this._thumbScrolling = scrollbarClicked || this._isThumb($target);\n    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);\n\n    if (this._thumbScrolling) {\n      this._scrollbar.feedbackOn();\n    }\n  },\n  _isThumbScrollingHandler: function ($target) {\n    return this._isThumb($target);\n  },\n  _moveToMouseLocation: function (e) {\n    var mouseLocation = e[\"page\" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];\n\n    var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;\n\n    this._scrollStep(-Math.round(location));\n  },\n  _stopComplete: function () {\n    if (this._stopDeferred) {\n      this._stopDeferred.resolve();\n    }\n  },\n  _startHandler: function () {\n    this._showScrollbar();\n  },\n  _moveHandler: function (delta) {\n    if (this._crossThumbScrolling) {\n      return;\n    }\n\n    if (this._thumbScrolling) {\n      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());\n    }\n\n    this._scrollBy(delta);\n  },\n  _scrollBy: function (delta) {\n    delta = delta[this._axis];\n\n    if (!this._inBounds()) {\n      delta *= OUT_BOUNDS_ACCELERATION;\n    }\n\n    this._scrollStep(delta);\n  },\n  _scrollByHandler: function (delta) {\n    this._scrollBy(delta);\n\n    this._scrollComplete();\n  },\n  _containerToContentRatio: function () {\n    return this._scrollbar.containerToContentRatio();\n  },\n  _endHandler: function (velocity) {\n    this._completeDeferred = new _deferred.Deferred();\n    this._velocity = velocity[this._axis];\n\n    this._inertiaHandler();\n\n    this._resetThumbScrolling();\n\n    return this._completeDeferred.promise();\n  },\n  _inertiaHandler: function () {\n    this._suppressInertia();\n\n    this._inertiaAnimator.start();\n  },\n  _suppressInertia: function () {\n    if (!this._inertiaEnabled || this._thumbScrolling) {\n      this._velocity = 0;\n    }\n  },\n  _resetThumbScrolling: function () {\n    this._thumbScrolling = false;\n    this._crossThumbScrolling = false;\n  },\n  _stopHandler: function () {\n    if (this._thumbScrolling) {\n      this._scrollComplete();\n    }\n\n    this._resetThumbScrolling();\n\n    this._scrollToBounds();\n  },\n  _disposeHandler: function () {\n    this._stopScrolling();\n\n    this._$scrollbar.remove();\n  },\n  _updateHandler: function () {\n    this._update();\n\n    this._moveToBounds();\n  },\n  _update: function () {\n    var _this2 = this;\n\n    this._stopScrolling();\n\n    return (0, _common.deferUpdate)(function () {\n      _this2._resetScaleRatio();\n\n      _this2._updateLocation();\n\n      _this2._updateBounds();\n\n      _this2._updateScrollbar();\n\n      (0, _common.deferRender)(function () {\n        _this2._moveScrollbar();\n\n        _this2._scrollbar.update();\n      });\n    });\n  },\n  _resetScaleRatio: function () {\n    this._scaleRatio = null;\n  },\n  _updateLocation: function () {\n    this._location = (_translator2.default.locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();\n  },\n  _updateBounds: function () {\n    this._maxOffset = Math.round(this._getMaxOffset());\n    this._minOffset = Math.round(this._getMinOffset());\n  },\n  _getMaxOffset: function () {\n    return 0;\n  },\n  _getMinOffset: function () {\n    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);\n    return -this._maxScrollPropValue;\n  },\n  _updateScrollbar: (0, _common.deferUpdater)(function () {\n    var _this3 = this;\n\n    var containerSize = this._containerSize();\n\n    var contentSize = this._contentSize();\n\n    var baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);\n\n    var baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);\n\n    (0, _common.deferRender)(function () {\n      _this3._scrollbar.option({\n        containerSize: containerSize,\n        contentSize: contentSize,\n        baseContainerSize: baseContainerSize,\n        baseContentSize: baseContentSize,\n        scaleRatio: _this3._getScaleRatio()\n      });\n    });\n  }),\n  _moveToBounds: (0, _common.deferRenderer)((0, _common.deferUpdater)((0, _common.deferRenderer)(function () {\n    var location = this._boundLocation();\n\n    var locationChanged = location !== this._location;\n    this._location = location;\n\n    this._move();\n\n    if (locationChanged) {\n      this._scrollAction();\n    }\n  }))),\n  _createActionsHandler: function (actions) {\n    this._scrollAction = actions.scroll;\n    this._bounceAction = actions.bounce;\n  },\n  _showScrollbar: function () {\n    this._scrollbar.option(\"visible\", true);\n  },\n  _hideScrollbar: function () {\n    this._scrollbar.option(\"visible\", false);\n  },\n  _containerSize: function () {\n    return this._getRealDimension(this._$container.get(0), this._dimension);\n  },\n  _contentSize: function () {\n    var isOverflowHidden = \"hidden\" === this._$content.css(\"overflow\" + this._axis.toUpperCase());\n\n    var contentSize = this._getRealDimension(this._$content.get(0), this._dimension);\n\n    if (!isOverflowHidden) {\n      var containerScrollSize = this._$content[0][\"scroll\" + (0, _inflector.titleize)(this._dimension)] * this._getScaleRatio();\n\n      contentSize = Math.max(containerScrollSize, contentSize);\n    }\n\n    return contentSize;\n  },\n  _validateEvent: function (e) {\n    var $target = (0, _renderer2.default)(e.originalEvent.target);\n    return this._isThumb($target) || this._isScrollbar($target) || this._isContent($target);\n  },\n  _isThumb: function ($element) {\n    return this._scrollByThumb && this._scrollbar.isThumb($element);\n  },\n  _isScrollbar: function ($element) {\n    return this._scrollByThumb && $element && $element.is(this._$scrollbar);\n  },\n  _isContent: function ($element) {\n    return this._scrollByContent && !!$element.closest(this._$element).length;\n  },\n  _reachedMin: function () {\n    return this._location <= this._minOffset;\n  },\n  _reachedMax: function () {\n    return this._location >= this._maxOffset;\n  },\n  _cursorEnterHandler: function () {\n    this._resetScaleRatio();\n\n    this._updateScrollbar();\n\n    this._scrollbar.cursorEnter();\n  },\n  _cursorLeaveHandler: function () {\n    this._scrollbar.cursorLeave();\n  },\n  dispose: _common.noop\n});\n\nvar hoveredScrollable;\nvar activeScrollable;\n\nvar SimulatedStrategy = _class2.default.inherit({\n  ctor: function (scrollable) {\n    this._init(scrollable);\n  },\n  _init: function (scrollable) {\n    this._component = scrollable;\n    this._$element = scrollable.$element();\n    this._$container = scrollable._$container;\n    this._$wrapper = scrollable._$wrapper;\n    this._$content = scrollable._$content;\n    this.option = scrollable.option.bind(scrollable);\n    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);\n    this._isLocked = scrollable._isLocked.bind(scrollable);\n    this._isDirection = scrollable._isDirection.bind(scrollable);\n    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);\n  },\n  render: function () {\n    this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);\n\n    this._createScrollers();\n\n    if (this.option(\"useKeyboard\")) {\n      this._$container.prop(\"tabIndex\", 0);\n    }\n\n    this._attachKeyboardHandler();\n\n    this._attachCursorHandlers();\n  },\n  _createScrollers: function () {\n    this._scrollers = {};\n\n    if (this._isDirection(HORIZONTAL)) {\n      this._createScroller(HORIZONTAL);\n    }\n\n    if (this._isDirection(VERTICAL)) {\n      this._createScroller(VERTICAL);\n    }\n\n    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, \"always\" === this.option(\"showScrollbar\"));\n\n    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this.option(\"showScrollbar\"));\n  },\n  _createScroller: function (direction) {\n    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));\n  },\n  _scrollerOptions: function (direction) {\n    return {\n      direction: direction,\n      $content: this._$content,\n      $container: this._$container,\n      $wrapper: this._$wrapper,\n      $element: this._$element,\n      scrollByContent: this.option(\"scrollByContent\"),\n      scrollByThumb: this.option(\"scrollByThumb\"),\n      scrollbarVisible: this.option(\"showScrollbar\"),\n      bounceEnabled: this.option(\"bounceEnabled\"),\n      inertiaEnabled: this.option(\"inertiaEnabled\"),\n      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)\n    };\n  },\n  _applyScaleRatio: function (targetLocation) {\n    for (var direction in this._scrollers) {\n      var prop = this._getPropByDirection(direction);\n\n      if ((0, _type.isDefined)(targetLocation[prop])) {\n        var scroller = this._scrollers[direction];\n        targetLocation[prop] *= scroller._getScaleRatio();\n      }\n    }\n\n    return targetLocation;\n  },\n  _isAnyThumbScrolling: function ($target) {\n    var result = false;\n\n    this._eventHandler(\"isThumbScrolling\", $target).done(function (isThumbScrollingVertical, isThumbScrollingHorizontal) {\n      result = isThumbScrollingVertical || isThumbScrollingHorizontal;\n    });\n\n    return result;\n  },\n  handleInit: function (e) {\n    this._suppressDirections(e);\n\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"init\", e).done(this._stopAction);\n  },\n  _suppressDirections: function (e) {\n    if ((0, _utils.isDxMouseWheelEvent)(e.originalEvent)) {\n      this._prepareDirections(true);\n\n      return;\n    }\n\n    this._prepareDirections();\n\n    this._eachScroller(function (scroller, direction) {\n      var isValid = scroller._validateEvent(e);\n\n      this._validDirections[direction] = isValid;\n    });\n  },\n  _prepareDirections: function (value) {\n    value = value || false;\n    this._validDirections = {};\n    this._validDirections[HORIZONTAL] = value;\n    this._validDirections[VERTICAL] = value;\n  },\n  _eachScroller: function (callback) {\n    callback = callback.bind(this);\n    (0, _iterator.each)(this._scrollers, function (direction, scroller) {\n      callback(scroller, direction);\n    });\n  },\n  handleStart: function (e) {\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"start\").done(this._startAction);\n  },\n  _saveActive: function () {\n    activeScrollable = this;\n  },\n  _resetActive: function () {\n    if (activeScrollable === this) {\n      activeScrollable = null;\n    }\n  },\n  handleMove: function (e) {\n    if (this._isLocked()) {\n      e.cancel = true;\n\n      this._resetActive();\n\n      return;\n    }\n\n    this._saveActive();\n\n    e.preventDefault && e.preventDefault();\n\n    this._adjustDistance(e, e.delta);\n\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"move\", e.delta);\n  },\n  _adjustDistance: function (e, distance) {\n    distance.x *= this._validDirections[HORIZONTAL];\n    distance.y *= this._validDirections[VERTICAL];\n\n    var devicePixelRatio = this._tryGetDevicePixelRatio();\n\n    if (devicePixelRatio && (0, _utils.isDxMouseWheelEvent)(e.originalEvent)) {\n      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;\n      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;\n    }\n  },\n  _tryGetDevicePixelRatio: function () {\n    if ((0, _window.hasWindow)()) {\n      return (0, _window.getWindow)().devicePixelRatio;\n    }\n  },\n  handleEnd: function (e) {\n    this._resetActive();\n\n    this._refreshCursorState(e.originalEvent && e.originalEvent.target);\n\n    this._adjustDistance(e, e.velocity);\n\n    this._eventForUserAction = e;\n    return this._eventHandler(\"end\", e.velocity).done(this._endAction);\n  },\n  handleCancel: function (e) {\n    this._resetActive();\n\n    this._eventForUserAction = e;\n    return this._eventHandler(\"end\", {\n      x: 0,\n      y: 0\n    });\n  },\n  handleStop: function () {\n    this._resetActive();\n\n    this._eventHandler(\"stop\");\n  },\n  handleScroll: function () {\n    this._scrollAction();\n  },\n  _attachKeyboardHandler: function () {\n    _events_engine2.default.off(this._$element, \".\".concat(SCROLLABLE_SIMULATED_KEYBOARD));\n\n    if (!this.option(\"disabled\") && this.option(\"useKeyboard\")) {\n      _events_engine2.default.on(this._$element, (0, _utils.addNamespace)(\"keydown\", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));\n    }\n  },\n  _keyDownHandler: function (e) {\n    var _this4 = this;\n\n    clearTimeout(this._updateHandlerTimeout);\n    this._updateHandlerTimeout = setTimeout(function () {\n      if ((0, _utils.normalizeKeyName)(e) === KEY_CODES.TAB) {\n        _this4._eachScroller(function (scroller) {\n          scroller._updateHandler();\n        });\n      }\n    });\n\n    if (!this._$container.is(_dom_adapter2.default.getActiveElement())) {\n      return;\n    }\n\n    var handled = true;\n\n    switch ((0, _utils.normalizeKeyName)(e)) {\n      case KEY_CODES.DOWN:\n        this._scrollByLine({\n          y: 1\n        });\n\n        break;\n\n      case KEY_CODES.UP:\n        this._scrollByLine({\n          y: -1\n        });\n\n        break;\n\n      case KEY_CODES.RIGHT:\n        this._scrollByLine({\n          x: 1\n        });\n\n        break;\n\n      case KEY_CODES.LEFT:\n        this._scrollByLine({\n          x: -1\n        });\n\n        break;\n\n      case KEY_CODES.PAGE_DOWN:\n        this._scrollByPage(1);\n\n        break;\n\n      case KEY_CODES.PAGE_UP:\n        this._scrollByPage(-1);\n\n        break;\n\n      case KEY_CODES.HOME:\n        this._scrollToHome();\n\n        break;\n\n      case KEY_CODES.END:\n        this._scrollToEnd();\n\n        break;\n\n      default:\n        handled = false;\n    }\n\n    if (handled) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  },\n  _scrollByLine: function (lines) {\n    var devicePixelRatio = this._tryGetDevicePixelRatio();\n\n    var scrollOffset = SCROLL_LINE_HEIGHT;\n\n    if (devicePixelRatio) {\n      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;\n    }\n\n    this.scrollBy({\n      top: (lines.y || 0) * -scrollOffset,\n      left: (lines.x || 0) * -scrollOffset\n    });\n  },\n  _scrollByPage: function (page) {\n    var prop = this._wheelProp();\n\n    var dimension = this._dimensionByProp(prop);\n\n    var distance = {};\n    distance[prop] = page * -this._$container[dimension]();\n    this.scrollBy(distance);\n  },\n  _dimensionByProp: function (prop) {\n    return \"left\" === prop ? \"width\" : \"height\";\n  },\n  _getPropByDirection: function (direction) {\n    return direction === HORIZONTAL ? \"left\" : \"top\";\n  },\n  _scrollToHome: function () {\n    var prop = this._wheelProp();\n\n    var distance = {};\n    distance[prop] = 0;\n\n    this._component.scrollTo(distance);\n  },\n  _scrollToEnd: function () {\n    var prop = this._wheelProp();\n\n    var dimension = this._dimensionByProp(prop);\n\n    var distance = {};\n    distance[prop] = this._$content[dimension]() - this._$container[dimension]();\n\n    this._component.scrollTo(distance);\n  },\n  createActions: function () {\n    this._startAction = this._createActionHandler(\"onStart\");\n    this._stopAction = this._createActionHandler(\"onStop\");\n    this._endAction = this._createActionHandler(\"onEnd\");\n    this._updateAction = this._createActionHandler(\"onUpdated\");\n\n    this._createScrollerActions();\n  },\n  _createScrollerActions: function () {\n    this._scrollAction = this._createActionHandler(\"onScroll\");\n    this._bounceAction = this._createActionHandler(\"onBounce\");\n\n    this._eventHandler(\"createActions\", {\n      scroll: this._scrollAction,\n      bounce: this._bounceAction\n    });\n  },\n  _createActionHandler: function (optionName) {\n    var _arguments = arguments,\n        _this5 = this;\n\n    var actionHandler = this._createActionByOption(optionName);\n\n    return function () {\n      actionHandler((0, _extend.extend)(_this5._createActionArgs(), _arguments));\n    };\n  },\n  _createActionArgs: function () {\n    var scrollerX = this._scrollers[HORIZONTAL];\n    var scrollerY = this._scrollers[VERTICAL];\n    var location = this.location();\n    this._scrollOffset = {\n      top: scrollerY && -location.top,\n      left: scrollerX && -location.left\n    };\n    return {\n      event: this._eventForUserAction,\n      scrollOffset: this._scrollOffset,\n      reachedLeft: scrollerX && scrollerX._reachedMax(),\n      reachedRight: scrollerX && scrollerX._reachedMin(),\n      reachedTop: scrollerY && scrollerY._reachedMax(),\n      reachedBottom: scrollerY && scrollerY._reachedMin()\n    };\n  },\n  _eventHandler: function (eventName) {\n    var args = [].slice.call(arguments).slice(1);\n    var deferreds = (0, _iterator.map)(this._scrollers, function (scroller) {\n      return scroller[\"_\" + eventName + \"Handler\"].apply(scroller, args);\n    });\n    return _deferred.when.apply(_renderer2.default, deferreds).promise();\n  },\n  location: function location() {\n    var location = _translator2.default.locate(this._$content);\n\n    location.top -= this._$container.scrollTop();\n    location.left -= this._$container.scrollLeft();\n    return location;\n  },\n  disabledChanged: function () {\n    this._attachCursorHandlers();\n  },\n  _attachCursorHandlers: function () {\n    _events_engine2.default.off(this._$element, \".\".concat(SCROLLABLE_SIMULATED_CURSOR));\n\n    if (!this.option(\"disabled\") && this._isHoverMode()) {\n      _events_engine2.default.on(this._$element, (0, _utils.addNamespace)(\"mouseenter\", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));\n\n      _events_engine2.default.on(this._$element, (0, _utils.addNamespace)(\"mouseleave\", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));\n    }\n  },\n  _isHoverMode: function () {\n    return \"onHover\" === this.option(\"showScrollbar\");\n  },\n  _cursorEnterHandler: function (e) {\n    e = e || {};\n    e.originalEvent = e.originalEvent || {};\n\n    if (activeScrollable || e.originalEvent._hoverHandled) {\n      return;\n    }\n\n    if (hoveredScrollable) {\n      hoveredScrollable._cursorLeaveHandler();\n    }\n\n    hoveredScrollable = this;\n\n    this._eventHandler(\"cursorEnter\");\n\n    e.originalEvent._hoverHandled = true;\n  },\n  _cursorLeaveHandler: function (e) {\n    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {\n      return;\n    }\n\n    this._eventHandler(\"cursorLeave\");\n\n    hoveredScrollable = null;\n\n    this._refreshCursorState(e && e.relatedTarget);\n  },\n  _refreshCursorState: function (target) {\n    if (!this._isHoverMode() && (!target || activeScrollable)) {\n      return;\n    }\n\n    var $target = (0, _renderer2.default)(target);\n    var $scrollable = $target.closest(\".\".concat(SCROLLABLE_SIMULATED_CLASS, \":not(.dx-state-disabled)\"));\n    var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);\n\n    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {\n      hoveredScrollable._cursorLeaveHandler();\n    }\n\n    if (targetScrollable) {\n      targetScrollable._cursorEnterHandler();\n    }\n  },\n  update: function () {\n    var _this6 = this;\n\n    var result = this._eventHandler(\"update\").done(this._updateAction);\n\n    return (0, _deferred.when)(result, (0, _common.deferUpdate)(function () {\n      var allowedDirections = _this6._allowedDirections();\n\n      (0, _common.deferRender)(function () {\n        var touchDirection = allowedDirections.vertical ? \"pan-x\" : \"\";\n        touchDirection = allowedDirections.horizontal ? \"pan-y\" : touchDirection;\n        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? \"none\" : touchDirection;\n\n        _this6._$container.css(\"touchAction\", touchDirection);\n      });\n      return (0, _deferred.when)().promise();\n    }));\n  },\n  _allowedDirections: function () {\n    var bounceEnabled = this.option(\"bounceEnabled\");\n    var verticalScroller = this._scrollers[VERTICAL];\n    var horizontalScroller = this._scrollers[HORIZONTAL];\n    return {\n      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),\n      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)\n    };\n  },\n  updateBounds: function () {\n    this._scrollers[HORIZONTAL] && this._scrollers[HORIZONTAL]._updateBounds();\n  },\n  scrollBy: function (distance) {\n    var verticalScroller = this._scrollers[VERTICAL];\n    var horizontalScroller = this._scrollers[HORIZONTAL];\n\n    if (verticalScroller) {\n      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;\n    }\n\n    if (horizontalScroller) {\n      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;\n    }\n\n    this._prepareDirections(true);\n\n    this._startAction();\n\n    this._eventHandler(\"scrollBy\", {\n      x: distance.left,\n      y: distance.top\n    });\n\n    this._endAction();\n  },\n  validate: function (e) {\n    if (this.option(\"disabled\")) {\n      return false;\n    }\n\n    if (this.option(\"bounceEnabled\")) {\n      return true;\n    }\n\n    return (0, _utils.isDxMouseWheelEvent)(e) ? this._validateWheel(e) : this._validateMove(e);\n  },\n  _validateWheel: function (e) {\n    var _this7 = this;\n\n    var scroller = this._scrollers[this._wheelDirection(e)];\n\n    var reachedMin = scroller._reachedMin();\n\n    var reachedMax = scroller._reachedMax();\n\n    var contentGreaterThanContainer = !reachedMin || !reachedMax;\n    var locatedNotAtBound = !reachedMin && !reachedMax;\n    var scrollFromMin = reachedMin && e.delta > 0;\n    var scrollFromMax = reachedMax && e.delta < 0;\n    var validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);\n    validated = validated || void 0 !== this._validateWheelTimer;\n\n    if (validated) {\n      clearTimeout(this._validateWheelTimer);\n      this._validateWheelTimer = setTimeout(function () {\n        _this7._validateWheelTimer = void 0;\n      }, VALIDATE_WHEEL_TIMEOUT);\n    }\n\n    return validated;\n  },\n  _validateMove: function (e) {\n    if (!this.option(\"scrollByContent\") && !(0, _renderer2.default)(e.target).closest(\".\".concat(SCROLLABLE_SCROLLBAR_CLASS)).length) {\n      return false;\n    }\n\n    return this._allowedDirection();\n  },\n  getDirection: function (e) {\n    return (0, _utils.isDxMouseWheelEvent)(e) ? this._wheelDirection(e) : this._allowedDirection();\n  },\n  _wheelProp: function () {\n    return this._wheelDirection() === HORIZONTAL ? \"left\" : \"top\";\n  },\n  _wheelDirection: function (e) {\n    switch (this.option(\"direction\")) {\n      case HORIZONTAL:\n        return HORIZONTAL;\n\n      case VERTICAL:\n        return VERTICAL;\n\n      default:\n        return e && e.shiftKey ? HORIZONTAL : VERTICAL;\n    }\n  },\n  verticalOffset: function () {\n    return 0;\n  },\n  dispose: function () {\n    this._resetActive();\n\n    if (hoveredScrollable === this) {\n      hoveredScrollable = null;\n    }\n\n    this._eventHandler(\"dispose\");\n\n    this._detachEventHandlers();\n\n    this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);\n\n    this._eventForUserAction = null;\n    clearTimeout(this._validateWheelTimer);\n    clearTimeout(this._updateHandlerTimeout);\n  },\n  _detachEventHandlers: function () {\n    _events_engine2.default.off(this._$element, \".\".concat(SCROLLABLE_SIMULATED_CURSOR));\n\n    _events_engine2.default.off(this._$container, \".\".concat(SCROLLABLE_SIMULATED_KEYBOARD));\n  }\n});\n\nexports.SimulatedStrategy = SimulatedStrategy;\nexports.Scroller = Scroller;","map":null,"metadata":{},"sourceType":"script"}