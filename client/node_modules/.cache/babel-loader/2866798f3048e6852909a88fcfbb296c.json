{"ast":null,"code":"import { isNullOrUndefined, attributes } from '@syncfusion/ej2-base';\nimport { iterateArrayOrObject } from '../base/util';\nimport { CellType } from '../base/enum';\n/**\n * `CellMergeRender` module.\n * @hidden\n */\n\nvar CellMergeRender =\n/** @class */\nfunction () {\n  function CellMergeRender(serviceLocator, parent) {\n    this.serviceLocator = serviceLocator;\n    this.parent = parent;\n  }\n\n  CellMergeRender.prototype.render = function (cellArgs, row, i, td) {\n    var cellRendererFact = this.serviceLocator.getService('cellRendererFactory');\n    var cellRenderer = cellRendererFact.getCellRenderer(row.cells[i].cellType || CellType.Data);\n    var colSpan = row.cells[i].cellSpan ? row.cells[i].cellSpan : cellArgs.colSpan + i <= row.cells.length ? cellArgs.colSpan : row.cells.length - i;\n    var rowSpan = cellArgs.rowSpan;\n    var visible = 0;\n    var spannedCell;\n\n    if (row.index > 0) {\n      var cells = this.parent.groupSettings.columns.length > 0 && !this.parent.getRowsObject()[row.index - 1].isDataRow ? this.parent.getRowsObject()[row.index].cells : this.parent.getRowsObject()[row.index - 1].cells;\n      var targetCell_1 = row.cells[i];\n      var uid_1 = 'uid';\n      spannedCell = cells.filter(function (cell) {\n        return cell.column.uid === targetCell_1.column[uid_1];\n      })[0];\n    }\n\n    var colSpanLen = spannedCell && spannedCell.colSpanRange > 1 && spannedCell.rowSpanRange > 1 ? spannedCell.colSpanRange : colSpan;\n\n    for (var j = i + 1; j < i + colSpanLen && j < row.cells.length; j++) {\n      if (row.cells[j].visible === false) {\n        visible++;\n      } else {\n        row.cells[j].isSpanned = true;\n      }\n    }\n\n    if (visible > 0) {\n      for (var j = i + colSpan; j < i + colSpan + visible && j < row.cells.length; j++) {\n        row.cells[j].isSpanned = true;\n      }\n\n      if (i + colSpan + visible >= row.cells.length) {\n        colSpan -= i + colSpan + visible - row.cells.length;\n      }\n    }\n\n    if (row.cells[i].cellSpan) {\n      row.data[cellArgs.column.field] = row.cells[i].spanText;\n      td = cellRenderer.render(row.cells[i], row.data, {\n        'index': !isNullOrUndefined(row.index) ? row.index.toString() : ''\n      });\n    }\n\n    if (colSpan > 1) {\n      attributes(td, {\n        'colSpan': colSpan.toString(),\n        'aria-colSpan': colSpan.toString()\n      });\n    }\n\n    if (rowSpan > 1) {\n      attributes(td, {\n        'rowspan': rowSpan.toString(),\n        'aria-rowspan': rowSpan.toString()\n      });\n      row.cells[i].isRowSpanned = true;\n      row.cells[i].rowSpanRange = Number(rowSpan);\n\n      if (colSpan > 1) {\n        row.cells[i].colSpanRange = Number(colSpan);\n      }\n    }\n\n    if (row.index > 0 && spannedCell.rowSpanRange > 1) {\n      row.cells[i].isSpanned = true;\n      row.cells[i].rowSpanRange = Number(spannedCell.rowSpanRange - 1);\n      row.cells[i].colSpanRange = spannedCell.rowSpanRange > 0 ? spannedCell.colSpanRange : 1;\n    }\n\n    if (this.parent.enableColumnVirtualization && !row.cells[i].cellSpan && !this.containsKey(cellArgs.column.field, cellArgs.data[cellArgs.column.field])) {\n      this.backupMergeCells(cellArgs.column.field, cellArgs.data[cellArgs.column.field], cellArgs.colSpan);\n    }\n\n    return td;\n  };\n\n  CellMergeRender.prototype.backupMergeCells = function (fName, data, span) {\n    this.setMergeCells(this.generteKey(fName, data), span);\n  };\n\n  CellMergeRender.prototype.generteKey = function (fname, data) {\n    return fname + '__' + data.toString();\n  };\n\n  CellMergeRender.prototype.splitKey = function (key) {\n    return key.split('__');\n  };\n\n  CellMergeRender.prototype.containsKey = function (fname, data) {\n    return this.getMergeCells().hasOwnProperty(this.generteKey(fname, data));\n  };\n\n  CellMergeRender.prototype.getMergeCells = function () {\n    return this.parent.mergeCells;\n  };\n\n  CellMergeRender.prototype.setMergeCells = function (key, span) {\n    this.parent.mergeCells[key] = span;\n  };\n\n  CellMergeRender.prototype.updateVirtualCells = function (rows) {\n    var mCells = this.getMergeCells();\n\n    for (var _i = 0, _a = Object.keys(mCells); _i < _a.length; _i++) {\n      var key = _a[_i];\n      var value = mCells[key];\n      var merge = this.splitKey(key);\n      var columnIndex = this.getIndexFromAllColumns(merge[0]);\n      var vColumnIndices = this.parent.getColumnIndexesInView();\n      var span = value - (vColumnIndices[0] - columnIndex);\n\n      if (columnIndex < vColumnIndices[0] && span > 1) {\n        for (var _b = 0, rows_1 = rows; _b < rows_1.length; _b++) {\n          var row = rows_1[_b];\n\n          if (row.data[merge[0]].toString() === merge[1].toString()) {\n            row.cells[0].cellSpan = span;\n            row.cells[0].spanText = merge[1];\n            break;\n          }\n        }\n      }\n    }\n\n    return rows;\n  };\n\n  CellMergeRender.prototype.getIndexFromAllColumns = function (field) {\n    var index = iterateArrayOrObject(this.parent.getVisibleColumns(), function (item, index) {\n      if (item.field === field) {\n        return index;\n      }\n\n      return undefined;\n    })[0];\n    return index;\n  };\n\n  return CellMergeRender;\n}();\n\nexport { CellMergeRender };","map":null,"metadata":{},"sourceType":"module"}