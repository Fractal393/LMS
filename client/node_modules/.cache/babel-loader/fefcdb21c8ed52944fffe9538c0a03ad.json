{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Component, Event, Property, NotifyPropertyChanges } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined, formatUnit, getValue, setValue, addClass, detach } from '@syncfusion/ej2-base';\nimport { removeClass, Browser, closest } from '@syncfusion/ej2-base';\nimport { Input } from '../../input/input';\nimport { regularExpressions, createMask, applyMask, wireEvents, unwireEvents, unstrippedValue, strippedValue } from '../base/index';\nimport { setMaskValue, setElementValue, bindClearEvent } from '../base/index';\nimport { maskInputBlurHandler } from '../base/mask-base';\nvar ROOT = 'e-control-wrapper e-mask';\nvar INPUT = 'e-input';\nvar COMPONENT = 'e-maskedtextbox';\nvar CONTROL = 'e-control';\nvar MASKINPUT_FOCUS = 'e-input-focus';\nvar wrapperAttr = ['title', 'style', 'class'];\n/**\n * The MaskedTextBox allows the user to enter the valid input only based on the provided mask.\n * ```html\n * <input id=\"mask\" type=\"text\" />\n * ```\n * ```typescript\n * <script>\n * var maskObj = new MaskedTextBox({ mask: \"(999) 9999-999\" });\n * maskObj.appendTo('#mask');\n * </script>\n * ```\n */\n\nvar MaskedTextBox =\n/** @class */\nfunction (_super) {\n  __extends(MaskedTextBox, _super);\n\n  function MaskedTextBox(options, element) {\n    var _this = _super.call(this, options, element) || this;\n\n    _this.initInputValue = '';\n    _this.maskOptions = options;\n    return _this;\n  }\n  /**\n   * Gets the component name\n   * @private\n   */\n\n\n  MaskedTextBox.prototype.getModuleName = function () {\n    return 'maskedtextbox';\n  };\n  /**\n   * Initializes the event handler\n   * @private\n   */\n\n\n  MaskedTextBox.prototype.preRender = function () {\n    this.promptMask = '';\n    this.hiddenMask = '';\n    this.escapeMaskValue = '';\n    this.regExpCollec = regularExpressions;\n    this.customRegExpCollec = [];\n    this.undoCollec = [];\n    this.redoCollec = [];\n    this.changeEventArgs = {};\n    this.focusEventArgs = {};\n    this.blurEventArgs = {};\n    this.maskKeyPress = false;\n    this.isFocus = false;\n    this.isInitial = false;\n    this.isIosInvalid = false;\n    var ejInstance = getValue('ej2_instances', this.element);\n    this.cloneElement = this.element.cloneNode(true);\n    removeClass([this.cloneElement], [CONTROL, COMPONENT, 'e-lib']);\n    this.angularTagName = null;\n    this.formElement = closest(this.element, 'form');\n\n    if (this.element.tagName === 'EJS-MASKEDTEXTBOX') {\n      this.angularTagName = this.element.tagName;\n      var input = this.createElement('input');\n\n      for (var i = 0; i < this.element.attributes.length; i++) {\n        input.setAttribute(this.element.attributes[i].nodeName, this.element.attributes[i].nodeValue);\n        input.innerHTML = this.element.innerHTML;\n      }\n\n      if (this.element.hasAttribute('id')) {\n        this.element.removeAttribute('id');\n      }\n\n      this.element.classList.remove('e-control', 'e-maskedtextbox');\n      this.element.classList.add('e-mask-container');\n      this.element.appendChild(input);\n      this.element = input;\n      setValue('ej2_instances', ejInstance, this.element);\n    }\n\n    this.updateHTMLAttrToElement();\n    this.checkHtmlAttributes(false);\n\n    if (this.formElement) {\n      this.initInputValue = this.value;\n    }\n  };\n  /**\n   * Gets the properties to be maintained in the persisted state.\n   * @return {string}\n   */\n\n\n  MaskedTextBox.prototype.getPersistData = function () {\n    var keyEntity = ['value'];\n    return this.addOnPersist(keyEntity);\n  };\n  /**\n   * Initializes the component rendering.\n   * @private\n   */\n\n\n  MaskedTextBox.prototype.render = function () {\n    if (this.element.tagName.toLowerCase() === 'input') {\n      if (this.floatLabelType === 'Never') {\n        addClass([this.element], INPUT);\n      }\n\n      this.createWrapper();\n      this.updateHTMLAttrToWrapper();\n\n      if (this.element.name === '') {\n        this.element.setAttribute('name', this.element.id);\n      }\n\n      this.isInitial = true;\n      this.resetMaskedTextBox();\n      this.isInitial = false;\n      this.setMaskPlaceholder(true, false);\n      this.setWidth(this.width);\n      this.preEleVal = this.element.value;\n\n      if (!Browser.isDevice && (Browser.info.version === '11.0' || Browser.info.name === 'edge')) {\n        this.element.blur();\n      }\n\n      if (Browser.isDevice && Browser.isIos) {\n        this.element.blur();\n      }\n\n      if (this.element.getAttribute('value') || this.value) {\n        this.element.setAttribute('value', this.element.value);\n      }\n\n      this.renderComplete();\n    }\n  };\n\n  MaskedTextBox.prototype.updateHTMLAttrToElement = function () {\n    if (!isNullOrUndefined(this.htmlAttributes)) {\n      for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (wrapperAttr.indexOf(key) < 0) {\n          this.element.setAttribute(key, this.htmlAttributes[key]);\n        }\n      }\n    }\n  };\n\n  MaskedTextBox.prototype.updateCssClass = function (newClass, oldClass) {\n    Input.setCssClass(this.getValidClassList(newClass), [this.inputObj.container], this.getValidClassList(oldClass));\n  };\n\n  MaskedTextBox.prototype.getValidClassList = function (maskClassName) {\n    var result = maskClassName;\n\n    if (!isNullOrUndefined(maskClassName) && maskClassName !== '') {\n      result = maskClassName.replace(/\\s+/g, ' ').trim();\n    }\n\n    return result;\n  };\n\n  MaskedTextBox.prototype.updateHTMLAttrToWrapper = function () {\n    if (!isNullOrUndefined(this.htmlAttributes)) {\n      for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (wrapperAttr.indexOf(key) > -1) {\n          if (key === 'class') {\n            var updatedClassValues = this.htmlAttributes[key].replace(/\\s+/g, ' ').trim();\n\n            if (updatedClassValues !== '') {\n              addClass([this.inputObj.container], updatedClassValues.split(' '));\n            }\n          } else if (key === 'style') {\n            var maskStyle = this.inputObj.container.getAttribute(key);\n            maskStyle = !isNullOrUndefined(maskStyle) ? maskStyle + this.htmlAttributes[key] : this.htmlAttributes[key];\n            this.inputObj.container.setAttribute(key, maskStyle);\n          } else {\n            this.inputObj.container.setAttribute(key, this.htmlAttributes[key]);\n          }\n        }\n      }\n    }\n  };\n\n  MaskedTextBox.prototype.resetMaskedTextBox = function () {\n    this.promptMask = '';\n    this.hiddenMask = '';\n    this.escapeMaskValue = '';\n    this.customRegExpCollec = [];\n    this.undoCollec = [];\n    this.redoCollec = [];\n\n    if (this.promptChar.length > 1) {\n      this.promptChar = this.promptChar[0];\n    }\n\n    createMask.call(this);\n    applyMask.call(this);\n\n    if (this.mask === null || this.mask === '' && this.value !== undefined) {\n      setElementValue.call(this, this.value);\n    }\n\n    var val = strippedValue.call(this, this.element);\n    this.prevValue = val;\n    this.value = val;\n\n    if (!this.isInitial) {\n      unwireEvents.call(this);\n    }\n\n    wireEvents.call(this);\n  };\n\n  MaskedTextBox.prototype.setMaskPlaceholder = function (setVal, dynamicPlaceholder) {\n    if (dynamicPlaceholder || this.placeholder) {\n      Input.setPlaceholder(this.placeholder, this.element);\n\n      if (this.element.value === this.promptMask && setVal && this.floatLabelType !== 'Always') {\n        setElementValue.call(this, '');\n      }\n\n      if (this.floatLabelType === 'Never') {\n        maskInputBlurHandler.call(this);\n      }\n    }\n  };\n\n  MaskedTextBox.prototype.setWidth = function (width) {\n    if (!isNullOrUndefined(width)) {\n      if (typeof width === 'number') {\n        this.inputObj.container.style.width = formatUnit(width);\n        this.element.style.width = formatUnit(width);\n      } else if (typeof width === 'string') {\n        var elementWidth = width.match(/px|%|em/) ? width : formatUnit(width);\n        this.inputObj.container.style.width = elementWidth;\n        this.element.style.width = elementWidth;\n      }\n    }\n  };\n\n  MaskedTextBox.prototype.checkHtmlAttributes = function (isDynamic) {\n    var attributes = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ['placeholder', 'disabled', 'value', 'readonly'];\n\n    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n      var key = attributes_1[_i];\n\n      if (!isNullOrUndefined(this.element.getAttribute(key))) {\n        switch (key) {\n          case 'placeholder':\n            // tslint:disable-next-line\n            if (isNullOrUndefined(this.maskOptions) || this.maskOptions['placeholder'] === undefined || isDynamic) {\n              this.setProperties({\n                placeholder: this.element.placeholder\n              }, !isDynamic);\n            }\n\n            break;\n\n          case 'disabled':\n            // tslint:disable-next-line\n            if (isNullOrUndefined(this.maskOptions) || this.maskOptions['enabled'] === undefined || isDynamic) {\n              var enabled = this.element.getAttribute(key) === 'disabled' || this.element.getAttribute(key) === '' || this.element.getAttribute(key) === 'true' ? false : true;\n              this.setProperties({\n                enabled: enabled\n              }, !isDynamic);\n            }\n\n            break;\n\n          case 'value':\n            // tslint:disable-next-line\n            if (isNullOrUndefined(this.maskOptions) || this.maskOptions['value'] === undefined || isDynamic) {\n              this.setProperties({\n                value: this.element.value\n              }, !isDynamic);\n            }\n\n            break;\n\n          case 'readonly':\n            // tslint:disable-next-line\n            if (isNullOrUndefined(this.maskOptions) || this.maskOptions['readonly'] === undefined || isDynamic) {\n              var readonly = this.element.getAttribute(key) === 'readonly' || this.element.getAttribute(key) === '' || this.element.getAttribute(key) === 'true' ? true : false;\n              this.setProperties({\n                readonly: readonly\n              }, !isDynamic);\n            }\n\n            break;\n        }\n      }\n    }\n  };\n\n  MaskedTextBox.prototype.createWrapper = function () {\n    var updatedCssClassValues = this.cssClass;\n\n    if (!isNullOrUndefined(this.cssClass) && this.cssClass !== '') {\n      updatedCssClassValues = this.getValidClassList(this.cssClass);\n    }\n\n    this.inputObj = Input.createInput({\n      element: this.element,\n      floatLabelType: this.floatLabelType,\n      properties: {\n        enableRtl: this.enableRtl,\n        cssClass: updatedCssClassValues,\n        enabled: this.enabled,\n        readonly: this.readonly,\n        placeholder: this.placeholder,\n        showClearButton: this.showClearButton\n      }\n    }, this.createElement);\n    this.inputObj.container.setAttribute('class', ROOT + ' ' + this.inputObj.container.getAttribute('class'));\n  };\n  /**\n   * Calls internally if any of the property value is changed.\n   * @hidden\n   */\n\n\n  MaskedTextBox.prototype.onPropertyChanged = function (newProp, oldProp) {\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'value':\n          setMaskValue.call(this, this.value);\n\n          if (this.placeholder) {\n            this.setMaskPlaceholder(false, false);\n          }\n\n          break;\n\n        case 'placeholder':\n          this.setMaskPlaceholder(true, true);\n          break;\n\n        case 'width':\n          this.setWidth(newProp.width);\n          break;\n\n        case 'cssClass':\n          this.updateCssClass(newProp.cssClass, oldProp.cssClass);\n          break;\n\n        case 'enabled':\n          Input.setEnabled(newProp.enabled, this.element, this.floatLabelType, this.inputObj.container);\n          break;\n\n        case 'readonly':\n          Input.setReadonly(newProp.readonly, this.element);\n          break;\n\n        case 'enableRtl':\n          Input.setEnableRtl(newProp.enableRtl, [this.inputObj.container]);\n          break;\n\n        case 'customCharacters':\n          this.customCharacters = newProp.customCharacters;\n          this.resetMaskedTextBox();\n          break;\n\n        case 'showClearButton':\n          Input.setClearButton(newProp.showClearButton, this.element, this.inputObj, undefined, this.createElement);\n          bindClearEvent.call(this);\n          break;\n\n        case 'floatLabelType':\n          this.floatLabelType = newProp.floatLabelType;\n          Input.removeFloating(this.inputObj);\n          Input.addFloating(this.element, this.floatLabelType, this.placeholder, this.createElement);\n          break;\n\n        case 'htmlAttributes':\n          this.updateHTMLAttrToElement();\n          this.updateHTMLAttrToWrapper();\n          this.checkHtmlAttributes(true);\n          break;\n\n        case 'mask':\n          var strippedValue_1 = this.value;\n          this.mask = newProp.mask;\n          this.updateValue(strippedValue_1);\n          break;\n\n        case 'promptChar':\n          if (newProp.promptChar.length > 1) {\n            newProp.promptChar = newProp.promptChar[0];\n          }\n\n          if (newProp.promptChar) {\n            this.promptChar = newProp.promptChar;\n          } else {\n            this.promptChar = '_';\n          }\n\n          var value = this.element.value.replace(new RegExp('[' + oldProp.promptChar + ']', 'g'), this.promptChar);\n\n          if (this.promptMask === this.element.value) {\n            value = this.promptMask.replace(new RegExp('[' + oldProp.promptChar + ']', 'g'), this.promptChar);\n          }\n\n          this.promptMask = this.promptMask.replace(new RegExp('[' + oldProp.promptChar + ']', 'g'), this.promptChar);\n          this.undoCollec = this.redoCollec = [];\n          setElementValue.call(this, value);\n          break;\n      }\n    }\n  };\n\n  MaskedTextBox.prototype.updateValue = function (strippedVal) {\n    this.resetMaskedTextBox();\n    setMaskValue.call(this, strippedVal);\n  };\n  /**\n   * Gets the value of the MaskedTextBox with the masked format.\n   * By using `value` property, you can get the raw value of maskedtextbox without literals and prompt characters.\n   * @return {string}\n   */\n\n\n  MaskedTextBox.prototype.getMaskedValue = function () {\n    return unstrippedValue.call(this, this.element);\n  };\n  /**\n   * Sets the focus to widget for interaction.\n   * @returns void\n   */\n\n\n  MaskedTextBox.prototype.focusIn = function () {\n    if (document.activeElement !== this.element && this.enabled) {\n      this.element.focus();\n      addClass([this.inputObj.container], [MASKINPUT_FOCUS]);\n    }\n  };\n  /**\n   * Remove the focus from widget, if the widget is in focus state.\n   * @returns void\n   */\n\n\n  MaskedTextBox.prototype.focusOut = function () {\n    if (document.activeElement === this.element && this.enabled) {\n      this.element.blur();\n      removeClass([this.inputObj.container], [MASKINPUT_FOCUS]);\n    }\n  };\n  /**\n   * Removes the component from the DOM and detaches all its related event handlers.\n   * Also it maintains the initial input element from the DOM.\n   * @method destroy\n   * @return {void}\n   */\n\n\n  MaskedTextBox.prototype.destroy = function () {\n    unwireEvents.call(this);\n    var attrArray = ['aria-labelledby', 'role', 'autocomplete', 'aria-readonly', 'autocorrect', 'aria-disabled', 'aria-placeholder', 'autocapitalize', 'spellcheck', 'aria-autocomplete', 'aria-live', 'aria-valuenow', 'aria-invalid'];\n\n    for (var i = 0; i < attrArray.length; i++) {\n      this.element.removeAttribute(attrArray[i]);\n    }\n\n    this.element.classList.remove('e-input');\n    this.inputObj.container.insertAdjacentElement('afterend', this.element);\n    detach(this.inputObj.container);\n\n    _super.prototype.destroy.call(this);\n  };\n\n  __decorate([Property(null)], MaskedTextBox.prototype, \"cssClass\", void 0);\n\n  __decorate([Property(null)], MaskedTextBox.prototype, \"width\", void 0);\n\n  __decorate([Property(null)], MaskedTextBox.prototype, \"placeholder\", void 0);\n\n  __decorate([Property('Never')], MaskedTextBox.prototype, \"floatLabelType\", void 0);\n\n  __decorate([Property({})], MaskedTextBox.prototype, \"htmlAttributes\", void 0);\n\n  __decorate([Property(true)], MaskedTextBox.prototype, \"enabled\", void 0);\n\n  __decorate([Property(false)], MaskedTextBox.prototype, \"readonly\", void 0);\n\n  __decorate([Property(false)], MaskedTextBox.prototype, \"showClearButton\", void 0);\n\n  __decorate([Property(false)], MaskedTextBox.prototype, \"enablePersistence\", void 0);\n\n  __decorate([Property(null)], MaskedTextBox.prototype, \"mask\", void 0);\n\n  __decorate([Property('_')], MaskedTextBox.prototype, \"promptChar\", void 0);\n\n  __decorate([Property(null)], MaskedTextBox.prototype, \"value\", void 0);\n\n  __decorate([Property(null)], MaskedTextBox.prototype, \"customCharacters\", void 0);\n\n  __decorate([Event()], MaskedTextBox.prototype, \"created\", void 0);\n\n  __decorate([Event()], MaskedTextBox.prototype, \"destroyed\", void 0);\n\n  __decorate([Event()], MaskedTextBox.prototype, \"change\", void 0);\n\n  __decorate([Event()], MaskedTextBox.prototype, \"focus\", void 0);\n\n  __decorate([Event()], MaskedTextBox.prototype, \"blur\", void 0);\n\n  MaskedTextBox = __decorate([NotifyPropertyChanges], MaskedTextBox);\n  return MaskedTextBox;\n}(Component);\n\nexport { MaskedTextBox };","map":null,"metadata":{},"sourceType":"module"}