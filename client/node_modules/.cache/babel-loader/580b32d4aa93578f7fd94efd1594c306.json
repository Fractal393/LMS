{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * TextLayouter.ts class for EJ2-PDF\n */\n\n\nimport { ElementLayouter, PdfLayoutResult } from './element-layouter';\nimport { RectangleF, SizeF } from './../../../drawing/pdf-drawing';\nimport { PdfStringLayouter } from './../../fonts/string-layouter';\nimport { PdfLayoutBreakType } from './../../figures/enum';\nimport { PdfColor } from './../../pdf-color';\nimport { PdfTextWebLink } from './../../../annotations/pdf-text-web-link';\n/**\n * Class that `layouts the text`.\n * @private\n */\n\nvar TextLayouter =\n/** @class */\nfunction (_super) {\n  __extends(TextLayouter, _super); // Constructors\n\n  /**\n   * Initializes a new instance of the `TextLayouter` class.\n   * @private\n   */\n\n\n  function TextLayouter(element) {\n    return _super.call(this, element) || this;\n  }\n\n  Object.defineProperty(TextLayouter.prototype, \"element\", {\n    /**\n     * Gets the layout `element`.\n     * @private\n     */\n    get: function () {\n      return _super.prototype.getElement.call(this);\n    },\n    enumerable: true,\n    configurable: true\n  }); // Implementation\n\n  /**\n   * `Layouts` the element.\n   * @private\n   */\n\n  TextLayouter.prototype.layoutInternal = function (param) {\n    /* tslint:disable */\n    this.format = this.element.stringFormat !== null && typeof this.element.stringFormat !== 'undefined' ? this.element.stringFormat : null;\n    var currentPage = param.page;\n    var currentBounds = param.bounds;\n    var text = this.element.value;\n    var result = null;\n    var pageResult = new TextPageLayoutResult();\n    pageResult.page = currentPage;\n    pageResult.remainder = text;\n\n    for (;;) {\n      pageResult = this.layoutOnPage(text, currentPage, currentBounds, param);\n      result = this.getLayoutResult(pageResult);\n      break;\n    }\n    /* tslint:enable */\n\n\n    return result;\n  };\n  /**\n   * Raises `PageLayout` event if needed.\n   * @private\n   */\n\n\n  TextLayouter.prototype.getLayoutResult = function (pageResult) {\n    var result = new PdfTextLayoutResult(pageResult.page, pageResult.bounds, pageResult.remainder, pageResult.lastLineBounds);\n    return result;\n  };\n  /* tslint:disable */\n\n  /**\n   * `Layouts` the text on the page.\n   * @private\n   */\n\n\n  TextLayouter.prototype.layoutOnPage = function (text, currentPage, currentBounds, param) {\n    var result = new TextPageLayoutResult();\n    result.remainder = text;\n    result.page = currentPage;\n    currentBounds = this.checkCorrectBounds(currentPage, currentBounds);\n    var layouter = new PdfStringLayouter();\n    var stringResult = layouter.layout(text, this.element.font, this.format, currentBounds, currentPage.getClientSize().height, false, new SizeF(0, 0));\n    var textFinished = stringResult.remainder == null;\n    var doesntFit = param.format.break === PdfLayoutBreakType.FitElement;\n    var canDraw = !(doesntFit || stringResult.empty); // Draw the text.\n\n    var graphics = currentPage.graphics;\n    var brush = this.element.getBrush();\n\n    if (this.element instanceof PdfTextWebLink) {\n      brush.color = new PdfColor(0, 0, 255);\n    }\n\n    graphics.drawStringLayoutResult(stringResult, this.element.font, this.element.pen, brush, currentBounds, this.format);\n    var lineInfo = stringResult.lines[stringResult.lineCount - 1];\n    result.lastLineBounds = graphics.getLineBounds(stringResult.lineCount - 1, stringResult, this.element.font, currentBounds, this.format);\n    result.bounds = this.getTextPageBounds(currentPage, currentBounds, stringResult);\n    result.remainder = stringResult.remainder;\n    result.end = textFinished;\n    return result;\n  };\n  /* tslint:enable */\n\n  /**\n   * `Corrects current bounds` on the page.\n   * @private\n   */\n\n\n  TextLayouter.prototype.checkCorrectBounds = function (currentPage, currentBounds) {\n    var pageSize = currentPage.graphics.clientSize;\n    currentBounds.height = currentBounds.height > 0 ? currentBounds.height : pageSize.height - currentBounds.y;\n    return currentBounds;\n  };\n  /**\n   * Returns a `rectangle` where the text was printed on the page.\n   * @private\n   */\n\n  /* tslint:disable */\n\n\n  TextLayouter.prototype.getTextPageBounds = function (currentPage, currentBounds, stringResult) {\n    var textSize = stringResult.actualSize;\n    var x = currentBounds.x;\n    var y = currentBounds.y;\n    var width = currentBounds.width > 0 ? currentBounds.width : textSize.width;\n    var height = textSize.height;\n    var shiftedRect = currentPage.graphics.checkCorrectLayoutRectangle(textSize, currentBounds.x, currentBounds.y, this.format); // if (currentBounds.width <= 0) {\n\n    x = shiftedRect.x; // }\n\n    var verticalShift = currentPage.graphics.getTextVerticalAlignShift(textSize.height, currentBounds.height, this.format);\n    y += verticalShift;\n    var bounds = new RectangleF(x, y, width, height);\n    return bounds;\n  };\n\n  return TextLayouter;\n}(ElementLayouter);\n\nexport { TextLayouter };\n\nvar TextPageLayoutResult =\n/** @class */\nfunction () {\n  function TextPageLayoutResult() {}\n\n  return TextPageLayoutResult;\n}();\n\nexport { TextPageLayoutResult };\n\nvar PdfTextLayoutResult =\n/** @class */\nfunction (_super) {\n  __extends(PdfTextLayoutResult, _super); // Constructors\n\n  /**\n   * Initializes the new instance of `PdfTextLayoutResult` class.\n   * @private\n   */\n\n\n  function PdfTextLayoutResult(page, bounds, remainder, lastLineBounds) {\n    var _this = _super.call(this, page, bounds) || this;\n\n    _this.remainderText = remainder;\n    _this.lastLineTextBounds = lastLineBounds;\n    return _this;\n  }\n\n  Object.defineProperty(PdfTextLayoutResult.prototype, \"remainder\", {\n    // Properties\n\n    /**\n     * Gets a value that contains the `text` that was not printed.\n     * @private\n     */\n    get: function () {\n      return this.remainderText;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfTextLayoutResult.prototype, \"lastLineBounds\", {\n    /**\n     * Gets a value that indicates the `bounds` of the last line that was printed on the page.\n     * @private\n     */\n    get: function () {\n      return this.lastLineTextBounds;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PdfTextLayoutResult;\n}(PdfLayoutResult);\n\nexport { PdfTextLayoutResult };","map":null,"metadata":{},"sourceType":"module"}