{"ast":null,"code":"import { CompressedStreamWriter } from './compression-writer';\nimport { Save } from '@syncfusion/ej2-file-utils';\nvar CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\n\nvar ZipArchive =\n/** @class */\nfunction () {\n  /**\n   * constructor for creating ZipArchive instance\n   */\n  function ZipArchive() {\n    if (CRC32TABLE.length === 0) {\n      ZipArchive.initCrc32Table();\n    }\n\n    this.files = [];\n    this.level = 'Normal';\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n\n  Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n    /**\n     * gets compression level\n     */\n    get: function () {\n      return this.level;\n    },\n\n    /**\n     * sets compression level\n     */\n    set: function (level) {\n      this.level = level;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchive.prototype, \"length\", {\n    /**\n     * gets items count\n     */\n    get: function () {\n      if (this.files === undefined) {\n        return 0;\n      }\n\n      return this.files.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * add new item to archive\n   * @param {ZipArchiveItem} item - item to be added\n   * @returns {void}\n   */\n\n  ZipArchive.prototype.addItem = function (item) {\n    if (item === null || item === undefined) {\n      throw new Error('ArgumentException: item cannot be null or undefined');\n    }\n\n    for (var i = 0; i < this.files.length; i++) {\n      var file = this.files[i];\n\n      if (file instanceof ZipArchiveItem) {\n        if (file.name === item.name) {\n          throw new Error('item with same name already exist');\n        }\n      }\n    }\n\n    this.files.push(item);\n  };\n  /**\n   * add new directory to archive\n   * @param directoryName directoryName to be created\n   * @returns {void}\n   */\n\n\n  ZipArchive.prototype.addDirectory = function (directoryName) {\n    if (directoryName === null || directoryName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (directoryName.length === 0) {\n      throw new Error('ArgumentException: string cannot be empty');\n    }\n\n    if (directoryName.slice(-1) !== '/') {\n      directoryName += '/';\n    }\n\n    if (this.files.indexOf(directoryName) !== -1) {\n      throw new Error('item with same name already exist');\n    }\n\n    this.files.push(directoryName);\n  };\n  /**\n   * gets item at specified index\n   * @param {number} index - item index\n   * @returns {ZipArchiveItem}\n   */\n\n\n  ZipArchive.prototype.getItem = function (index) {\n    if (index >= 0 && index < this.files.length) {\n      return this.files[index];\n    }\n\n    return undefined;\n  };\n  /**\n   * determines whether an element is in the collection\n   * @param {string | ZipArchiveItem} item - item to search\n   * @returns {boolean}\n   */\n\n\n  ZipArchive.prototype.contains = function (item) {\n    return this.files.indexOf(item) !== -1 ? true : false;\n  };\n  /**\n   * save archive with specified file name\n   * @param {string} fileName save archive with specified file name\n   * @returns {Promise<ZipArchive>}\n   */\n\n\n  ZipArchive.prototype.save = function (fileName) {\n    if (fileName === null || fileName === undefined || fileName.length === 0) {\n      throw new Error('ArgumentException: fileName cannot be null or undefined');\n    }\n\n    if (this.files.length === 0) {\n      throw new Error('InvalidOperation');\n    }\n\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal(fileName, false).then(function () {\n        resolve(zipArchive);\n      });\n    });\n  };\n  /**\n   * Save archive as blob\n   * @return {Promise<Blob>}\n   */\n\n\n  ZipArchive.prototype.saveAsBlob = function () {\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal('', true).then(function (blob) {\n        resolve(blob);\n      });\n    });\n  };\n\n  ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n    var _this = this;\n\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      var zipData = [];\n      var dirLength = 0;\n\n      for (var i = 0; i < zipArchive.files.length; i++) {\n        var compressedObject = _this.getCompressedData(_this.files[i]);\n\n        compressedObject.then(function (data) {\n          dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n\n          if (zipData.length === zipArchive.files.length) {\n            var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n            resolve(blob);\n          }\n        });\n      }\n    });\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  ZipArchive.prototype.destroy = function () {\n    if (this.files !== undefined && this.files.length > 0) {\n      for (var i = 0; i < this.files.length; i++) {\n        var file = this.files[i];\n\n        if (file instanceof ZipArchiveItem) {\n          file.destroy();\n        }\n\n        file = undefined;\n      }\n\n      this.files = [];\n    }\n\n    this.files = undefined;\n    this.level = undefined;\n  };\n\n  ZipArchive.prototype.getCompressedData = function (item) {\n    var zipArchive = this;\n    var promise = new Promise(function (resolve, reject) {\n      if (item instanceof ZipArchiveItem) {\n        var reader_1 = new FileReader();\n\n        reader_1.onload = function () {\n          var input = new Uint8Array(reader_1.result);\n          var data = {\n            fileName: item.name,\n            crc32Value: 0,\n            compressedData: [],\n            compressedSize: undefined,\n            uncompressedDataSize: input.length,\n            compressionType: undefined,\n            isDirectory: false\n          };\n\n          if (zipArchive.level === 'Normal') {\n            zipArchive.compressData(input, data, CRC32TABLE);\n            var length_1 = 0;\n\n            for (var i = 0; i < data.compressedData.length; i++) {\n              length_1 += data.compressedData[i].length;\n            }\n\n            data.compressedSize = length_1;\n            data.compressionType = '\\x08\\x00'; //Deflated = 8\n          } else {\n            data.compressedSize = input.length;\n            data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n            data.compressionType = '\\x00\\x00'; // Stored = 0\n\n            data.compressedData.push(input);\n          }\n\n          resolve(data);\n        };\n\n        reader_1.readAsArrayBuffer(item.data);\n      } else {\n        var data = {\n          fileName: item,\n          crc32Value: 0,\n          compressedData: '',\n          compressedSize: 0,\n          uncompressedDataSize: 0,\n          compressionType: '\\x00\\x00',\n          isDirectory: true\n        };\n        resolve(data);\n      }\n    });\n    return promise;\n  };\n\n  ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n    var compressor = new CompressedStreamWriter(true);\n    var currentIndex = 0;\n    var nextIndex = 0;\n\n    do {\n      if (currentIndex >= input.length) {\n        compressor.close();\n        break;\n      }\n\n      nextIndex = Math.min(input.length, currentIndex + 16384);\n      var subArray = input.subarray(currentIndex, nextIndex);\n      data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n      compressor.write(subArray, 0, nextIndex - currentIndex);\n      currentIndex = nextIndex;\n    } while (currentIndex <= input.length);\n\n    data.compressedData = compressor.compressedData;\n    compressor.destroy();\n  };\n\n  ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n    var extFileAttr = 0;\n    var date = new Date();\n\n    if (isDirectory) {\n      extFileAttr = extFileAttr | 0x00010; // directory flag\n    }\n\n    extFileAttr = extFileAttr | 0 & 0x3F;\n    var header = this.writeHeader(data, date);\n    var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n    var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n    zipParts.push({\n      localHeader: localHeader,\n      centralDir: centralDir,\n      compressedData: data\n    });\n    return dirLength + localHeader.length + data.compressedSize;\n  };\n\n  ZipArchive.prototype.writeHeader = function (data, date) {\n    var zipHeader = '';\n    zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n\n    zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n\n    zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n\n    zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n\n    zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n\n    zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n\n    zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n\n    zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n\n    zipHeader += this.getBytes(0, 2); // extra field length\n\n    return zipHeader;\n  };\n\n  ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n    var cenDirLen = 0;\n    var buffer = [];\n\n    for (var i = 0; i < zipData.length; i++) {\n      var item = zipData[i];\n      cenDirLen += item.centralDir.length;\n      buffer.push(this.getArrayBuffer(item.localHeader));\n\n      while (item.compressedData.compressedData.length) {\n        buffer.push(item.compressedData.compressedData.shift().buffer);\n      }\n    }\n\n    for (var i = 0; i < zipData.length; i++) {\n      buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n    }\n\n    buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n    var blob = new Blob(buffer, {\n      type: 'application/zip'\n    });\n\n    if (!skipFileSave) {\n      Save.save(fileName, blob);\n    }\n\n    return blob;\n  };\n\n  ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n    var directoryHeader = 'PK\\x01\\x02' + this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n    this.getBytes(0, 2) + // comment length\n    '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n    this.getBytes(externalFileAttribute, 4) + // external file attributes\n    this.getBytes(offset, 4) + // local fileHeader relative offset\n    data.fileName;\n    return directoryHeader;\n  };\n\n  ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n    var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);\n    return dirEnd;\n  };\n\n  ZipArchive.prototype.getArrayBuffer = function (input) {\n    var a = new Uint8Array(input.length);\n\n    for (var j = 0; j < input.length; ++j) {\n      a[j] = input.charCodeAt(j) & 0xFF;\n    }\n\n    return a.buffer;\n  };\n\n  ZipArchive.prototype.getBytes = function (value, offset) {\n    var bytes = '';\n\n    for (var i = 0; i < offset; i++) {\n      bytes += String.fromCharCode(value & 0xff);\n      value = value >>> 8;\n    }\n\n    return bytes;\n  };\n\n  ZipArchive.prototype.getModifiedTime = function (date) {\n    var modTime = date.getHours();\n    modTime = modTime << 6;\n    modTime = modTime | date.getMinutes();\n    modTime = modTime << 5;\n    return modTime = modTime | date.getSeconds() / 2;\n  };\n\n  ZipArchive.prototype.getModifiedDate = function (date) {\n    var modiDate = date.getFullYear() - 1980;\n    modiDate = modiDate << 4;\n    modiDate = modiDate | date.getMonth() + 1;\n    modiDate = modiDate << 5;\n    return modiDate = modiDate | date.getDate();\n  };\n\n  ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n    crc32Value ^= -1;\n\n    for (var i = 0; i < input.length; i++) {\n      crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n    }\n\n    return crc32Value ^ -1;\n  };\n  /**\n   * construct cyclic redundancy code table\n   * @private\n   */\n\n\n  ZipArchive.initCrc32Table = function () {\n    var i;\n\n    for (var j = 0; j < 256; j++) {\n      i = j;\n\n      for (var k = 0; k < 8; k++) {\n        i = i & 1 ? 0xEDB88320 ^ i >>> 1 : i >>> 1;\n      }\n\n      CRC32TABLE[j] = i;\n    }\n  };\n\n  return ZipArchive;\n}();\n\nexport { ZipArchive };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\n\nvar ZipArchiveItem =\n/** @class */\nfunction () {\n  /**\n   * constructor for creating {ZipArchiveItem} instance\n   * @param {Blob|ArrayBuffer} data file data\n   * @param {itemName} itemName absolute file path\n   */\n  function ZipArchiveItem(data, itemName) {\n    if (data === null || data === undefined) {\n      throw new Error('ArgumentException: data cannot be null or undefined');\n    }\n\n    if (itemName === null || itemName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (itemName.length === 0) {\n      throw new Error('string cannot be empty');\n    }\n\n    this.data = data;\n    this.name = itemName;\n  }\n\n  Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n    /**\n     * Get the name of archive item\n     * @returns string\n     */\n    get: function () {\n      return this.fileName;\n    },\n\n    /**\n     * Set the name of archive item\n     * @param  {string} value\n     */\n    set: function (value) {\n      this.fileName = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n  ZipArchiveItem.prototype.destroy = function () {\n    this.fileName = undefined;\n    this.data = undefined;\n  };\n\n  return ZipArchiveItem;\n}();\n\nexport { ZipArchiveItem };","map":null,"metadata":{},"sourceType":"module"}