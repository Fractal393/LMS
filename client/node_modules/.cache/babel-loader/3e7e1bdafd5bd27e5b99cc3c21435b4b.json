{"ast":null,"code":"/**\r\n * DevExtreme (animation/position.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../core/renderer\");\n\nvar commonUtils = require(\"../core/utils/common\");\n\nvar each = require(\"../core/utils/iterator\").each;\n\nvar windowUtils = require(\"../core/utils/window\");\n\nvar window = windowUtils.getWindow();\n\nvar domAdapter = require(\"../core/dom_adapter\");\n\nvar isWindow = require(\"../core/utils/type\").isWindow;\n\nvar extend = require(\"../core/utils/extend\").extend;\n\nvar getBoundingRect = require(\"../core/utils/position\").getBoundingRect;\n\nvar browser = require(\"../core/utils/browser\");\n\nvar translator = require(\"./translator\");\n\nvar support = require(\"../core/utils/support\");\n\nvar horzRe = /left|right/;\nvar vertRe = /top|bottom/;\nvar collisionRe = /fit|flip|none/;\nvar IS_SAFARI = browser.safari;\n\nvar normalizeAlign = function (raw) {\n  var result = {\n    h: \"center\",\n    v: \"center\"\n  };\n  var pair = commonUtils.splitPair(raw);\n\n  if (pair) {\n    each(pair, function () {\n      var w = String(this).toLowerCase();\n\n      if (horzRe.test(w)) {\n        result.h = w;\n      } else {\n        if (vertRe.test(w)) {\n          result.v = w;\n        }\n      }\n    });\n  }\n\n  return result;\n};\n\nvar normalizeOffset = function (raw) {\n  return commonUtils.pairToObject(raw);\n};\n\nvar normalizeCollision = function (raw) {\n  var pair = commonUtils.splitPair(raw);\n  var h = String(pair && pair[0]).toLowerCase();\n  var v = String(pair && pair[1]).toLowerCase();\n\n  if (!collisionRe.test(h)) {\n    h = \"none\";\n  }\n\n  if (!collisionRe.test(v)) {\n    v = h;\n  }\n\n  return {\n    h: h,\n    v: v\n  };\n};\n\nvar getAlignFactor = function (align) {\n  switch (align) {\n    case \"center\":\n      return .5;\n\n    case \"right\":\n    case \"bottom\":\n      return 1;\n\n    default:\n      return 0;\n  }\n};\n\nvar inverseAlign = function (align) {\n  switch (align) {\n    case \"left\":\n      return \"right\";\n\n    case \"right\":\n      return \"left\";\n\n    case \"top\":\n      return \"bottom\";\n\n    case \"bottom\":\n      return \"top\";\n\n    default:\n      return align;\n  }\n};\n\nvar calculateOversize = function (data, bounds) {\n  var oversize = 0;\n\n  if (data.myLocation < bounds.min) {\n    oversize += bounds.min - data.myLocation;\n  }\n\n  if (data.myLocation > bounds.max) {\n    oversize += data.myLocation - bounds.max;\n  }\n\n  return oversize;\n};\n\nvar collisionSide = function (direction, data, bounds) {\n  if (data.myLocation < bounds.min) {\n    return \"h\" === direction ? \"left\" : \"top\";\n  }\n\n  if (data.myLocation > bounds.max) {\n    return \"h\" === direction ? \"right\" : \"bottom\";\n  }\n\n  return \"none\";\n};\n\nvar initMyLocation = function (data) {\n  data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset;\n};\n\nvar collisionResolvers = {\n  fit: function (data, bounds) {\n    var result = false;\n\n    if (data.myLocation > bounds.max) {\n      data.myLocation = bounds.max;\n      result = true;\n    }\n\n    if (data.myLocation < bounds.min) {\n      data.myLocation = bounds.min;\n      result = true;\n    }\n\n    data.fit = result;\n  },\n  flip: function (data, bounds) {\n    data.flip = false;\n\n    if (\"center\" === data.myAlign && \"center\" === data.atAlign) {\n      return;\n    }\n\n    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {\n      var inverseData = extend({}, data, {\n        myAlign: inverseAlign(data.myAlign),\n        atAlign: inverseAlign(data.atAlign),\n        offset: -data.offset\n      });\n      initMyLocation(inverseData);\n      inverseData.oversize = calculateOversize(inverseData, bounds);\n\n      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {\n        data.myLocation = inverseData.myLocation;\n        data.oversize = inverseData.oversize;\n        data.flip = true;\n      }\n    }\n  },\n  flipfit: function (data, bounds) {\n    this.flip(data, bounds);\n    this.fit(data, bounds);\n  },\n  none: function (data) {\n    data.oversize = 0;\n  }\n};\nvar scrollbarWidth;\n\nvar calculateScrollbarWidth = function () {\n  var $scrollDiv = $(\"<div>\").css({\n    width: 100,\n    height: 100,\n    overflow: \"scroll\",\n    position: \"absolute\",\n    top: -9999\n  }).appendTo($(\"body\"));\n  var result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;\n  $scrollDiv.remove();\n  scrollbarWidth = result;\n};\n\nvar defaultPositionResult = {\n  h: {\n    location: 0,\n    flip: false,\n    fit: false,\n    oversize: 0\n  },\n  v: {\n    location: 0,\n    flip: false,\n    fit: false,\n    oversize: 0\n  }\n};\n\nvar calculatePosition = function (what, options) {\n  var $what = $(what);\n  var currentOffset = $what.offset();\n  var result = extend(true, {}, defaultPositionResult, {\n    h: {\n      location: currentOffset.left\n    },\n    v: {\n      location: currentOffset.top\n    }\n  });\n\n  if (!options) {\n    return result;\n  }\n\n  var my = normalizeAlign(options.my);\n  var at = normalizeAlign(options.at);\n  var of = $(options.of).length && options.of || window;\n  var offset = normalizeOffset(options.offset);\n  var collision = normalizeCollision(options.collision);\n  var boundary = options.boundary;\n  var boundaryOffset = normalizeOffset(options.boundaryOffset);\n  var h = {\n    mySize: $what.outerWidth(),\n    myAlign: my.h,\n    atAlign: at.h,\n    offset: offset.h,\n    collision: collision.h,\n    boundaryOffset: boundaryOffset.h\n  };\n  var v = {\n    mySize: $what.outerHeight(),\n    myAlign: my.v,\n    atAlign: at.v,\n    offset: offset.v,\n    collision: collision.v,\n    boundaryOffset: boundaryOffset.v\n  };\n\n  if (of.preventDefault) {\n    h.atLocation = of.pageX;\n    v.atLocation = of.pageY;\n    h.atSize = 0;\n    v.atSize = 0;\n  } else {\n    of = $(of);\n\n    if (isWindow(of[0])) {\n      h.atLocation = of.scrollLeft();\n      v.atLocation = of.scrollTop();\n      h.atSize = of[0].innerWidth >= of[0].outerWidth ? of[0].innerWidth : of.width();\n      v.atSize = of[0].innerHeight >= of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : of.height();\n    } else {\n      if (9 === of[0].nodeType) {\n        h.atLocation = 0;\n        v.atLocation = 0;\n        h.atSize = of.width();\n        v.atSize = of.height();\n      } else {\n        var ofRect = getBoundingRect(of.get(0));\n        var o = of.offset();\n        h.atLocation = o.left;\n        v.atLocation = o.top;\n        h.atSize = ofRect.width;\n        v.atSize = ofRect.height;\n      }\n    }\n  }\n\n  initMyLocation(h);\n  initMyLocation(v);\n\n  var bounds = function () {\n    var win = $(window);\n    var windowWidth = win.width();\n    var windowHeight = win.height();\n    var left = win.scrollLeft();\n    var top = win.scrollTop();\n    var documentElement = domAdapter.getDocumentElement();\n    var hZoomLevel = support.touch ? documentElement.clientWidth / windowWidth : 1;\n    var vZoomLevel = support.touch ? documentElement.clientHeight / windowHeight : 1;\n\n    if (void 0 === scrollbarWidth) {\n      calculateScrollbarWidth();\n    }\n\n    var boundaryWidth = windowWidth;\n    var boundaryHeight = windowHeight;\n\n    if (boundary) {\n      var $boundary = $(boundary);\n      var boundaryPosition = $boundary.offset();\n      left = boundaryPosition.left;\n      top = boundaryPosition.top;\n      boundaryWidth = $boundary.width();\n      boundaryHeight = $boundary.height();\n    }\n\n    return {\n      h: {\n        min: left + h.boundaryOffset,\n        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset\n      },\n      v: {\n        min: top + v.boundaryOffset,\n        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset\n      }\n    };\n  }();\n\n  h.oversize = calculateOversize(h, bounds.h);\n  v.oversize = calculateOversize(v, bounds.v);\n  h.collisionSide = collisionSide(\"h\", h, bounds.h);\n  v.collisionSide = collisionSide(\"v\", v, bounds.v);\n\n  if (collisionResolvers[h.collision]) {\n    collisionResolvers[h.collision](h, bounds.h);\n  }\n\n  if (collisionResolvers[v.collision]) {\n    collisionResolvers[v.collision](v, bounds.v);\n  }\n\n  var preciser = function (number) {\n    return options.precise ? number : Math.round(number);\n  };\n\n  extend(true, result, {\n    h: {\n      location: preciser(h.myLocation),\n      oversize: preciser(h.oversize),\n      fit: h.fit,\n      flip: h.flip,\n      collisionSide: h.collisionSide\n    },\n    v: {\n      location: preciser(v.myLocation),\n      oversize: preciser(v.oversize),\n      fit: v.fit,\n      flip: v.flip,\n      collisionSide: v.collisionSide\n    },\n    precise: options.precise\n  });\n  return result;\n};\n\nvar position = function (what, options) {\n  var $what = $(what);\n\n  if (!options) {\n    return $what.offset();\n  }\n\n  translator.resetPosition($what, true);\n  var offset = $what.offset();\n  var targetPosition = options.h && options.v ? options : calculatePosition($what, options);\n\n  var preciser = function (number) {\n    return options.precise ? number : Math.round(number);\n  };\n\n  translator.move($what, {\n    left: targetPosition.h.location - preciser(offset.left),\n    top: targetPosition.v.location - preciser(offset.top)\n  });\n  return targetPosition;\n};\n\nvar offset = function (element) {\n  element = $(element).get(0);\n\n  if (isWindow(element)) {\n    return null;\n  } else {\n    if (element && \"pageY\" in element && \"pageX\" in element) {\n      return {\n        top: element.pageY,\n        left: element.pageX\n      };\n    }\n  }\n\n  return $(element).offset();\n};\n\nif (!position.inverseAlign) {\n  position.inverseAlign = inverseAlign;\n}\n\nif (!position.normalizeAlign) {\n  position.normalizeAlign = normalizeAlign;\n}\n\nmodule.exports = {\n  calculateScrollbarWidth: calculateScrollbarWidth,\n  calculate: calculatePosition,\n  setup: position,\n  offset: offset\n};","map":null,"metadata":{},"sourceType":"script"}