{"ast":null,"code":"/**\r\n * DevExtreme (ui/grid_core/ui.grid_core.validating.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _events_engine = require(\"../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _uiGrid_core = require(\"./ui.grid_core.modules\");\n\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\n\nvar _uiGrid_core3 = require(\"./ui.grid_core.utils\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _selectors = require(\"../widget/selectors\");\n\nvar _message = require(\"../../localization/message\");\n\nvar _message2 = _interopRequireDefault(_message);\n\nvar _button = require(\"../button\");\n\nvar _button2 = _interopRequireDefault(_button);\n\nvar _pointer = require(\"../../events/pointer\");\n\nvar _pointer2 = _interopRequireDefault(_pointer);\n\nvar _validation_engine = require(\"../validation_engine\");\n\nvar _validation_engine2 = _interopRequireDefault(_validation_engine);\n\nvar _validator = require(\"../validator\");\n\nvar _validator2 = _interopRequireDefault(_validator);\n\nvar _tooltip = require(\"../tooltip\");\n\nvar _tooltip2 = _interopRequireDefault(_tooltip);\n\nvar _overlay = require(\"../overlay\");\n\nvar _overlay2 = _interopRequireDefault(_overlay);\n\nvar _themes = require(\"../themes\");\n\nvar _themes2 = _interopRequireDefault(_themes);\n\nvar _ui = require(\"../widget/ui.errors\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nvar _load_indicator = require(\"../load_indicator\");\n\nvar _load_indicator2 = _interopRequireDefault(_load_indicator);\n\nvar _string = require(\"../../core/utils/string\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) {\n    return;\n  }\n\n  if (\"string\" === typeof o) {\n    return _arrayLikeToArray(o, minLen);\n  }\n\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n\n  if (\"Object\" === n && o.constructor) {\n    n = o.constructor.name;\n  }\n\n  if (\"Map\" === n || \"Set\" === n) {\n    return Array.from(o);\n  }\n\n  if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {\n    return _arrayLikeToArray(o, minLen);\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (\"undefined\" !== typeof Symbol && Symbol.iterator in Object(iter)) {\n    return Array.from(iter);\n  }\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    return _arrayLikeToArray(arr);\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (null == len || len > arr.length) {\n    len = arr.length;\n  }\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar INVALIDATE_CLASS = \"invalid\";\nvar REVERT_TOOLTIP_CLASS = \"revert-tooltip\";\nvar ROWS_VIEW_CLASS = \"rowsview\";\nvar INVALID_MESSAGE_CLASS = \"dx-invalid-message\";\nvar WIDGET_INVALID_MESSAGE_CLASS = \"invalid-message\";\nvar INVALID_MESSAGE_ALWAYS_CLASS = \"dx-invalid-message-always\";\nvar REVERT_BUTTON_CLASS = \"dx-revert-button\";\nvar CELL_HIGHLIGHT_OUTLINE = \"dx-highlight-outline\";\nvar VALIDATOR_CLASS = \"validator\";\nvar PENDING_INDICATOR_CLASS = \"dx-pending-indicator\";\nvar VALIDATION_PENDING_CLASS = \"dx-validation-pending\";\nvar INSERT_INDEX = \"__DX_INSERT_INDEX__\";\nvar PADDING_BETWEEN_TOOLTIPS = 2;\nvar EDIT_MODE_ROW = \"row\";\nvar EDIT_MODE_FORM = \"form\";\nvar EDIT_MODE_BATCH = \"batch\";\nvar EDIT_MODE_CELL = \"cell\";\nvar EDIT_MODE_POPUP = \"popup\";\nvar GROUP_CELL_CLASS = \"dx-group-cell\";\nvar FORM_BASED_MODES = [EDIT_MODE_POPUP, EDIT_MODE_FORM];\nvar COMMAND_TRANSPARENT = \"transparent\";\nvar VALIDATION_STATUS = {\n  valid: \"valid\",\n  invalid: \"invalid\",\n  pending: \"pending\"\n};\nvar EDIT_DATA_INSERT_TYPE = \"insert\";\n\nvar ValidatingController = _uiGrid_core2.default.Controller.inherit(function () {\n  return {\n    init: function () {\n      this._editingController = this.getController(\"editing\");\n      this.createAction(\"onRowValidating\");\n    },\n    _getBrokenRules: function (editData, validationResults) {\n      var brokenRules;\n\n      if (validationResults) {\n        brokenRules = validationResults.brokenRules || validationResults.brokenRule && [validationResults.brokenRule];\n      } else {\n        brokenRules = editData.brokenRules || [];\n      }\n\n      return brokenRules;\n    },\n    _rowValidating: function (editData, validationResults) {\n      var deferred = new _deferred.Deferred();\n\n      var brokenRules = this._getBrokenRules(editData, validationResults);\n\n      var isValid = validationResults ? validationResults.isValid : editData.isValid;\n      var parameters = {\n        brokenRules: brokenRules,\n        isValid: isValid,\n        key: editData.key,\n        newData: editData.data,\n        oldData: editData.oldData,\n        promise: null,\n        errorText: this.getHiddenValidatorsErrorText(brokenRules)\n      };\n      this.executeAction(\"onRowValidating\", parameters);\n      (0, _deferred.when)(parameters.promise).always(function () {\n        editData.isValid = parameters.isValid;\n        editData.errorText = parameters.errorText;\n        deferred.resolve(parameters);\n      });\n      return deferred.promise();\n    },\n    getHiddenValidatorsErrorText: function (brokenRules) {\n      var brokenRulesMessages = [];\n      (0, _iterator.each)(brokenRules, function (_, brokenRule) {\n        var column = brokenRule.column;\n        var isGroupExpandColumn = column && void 0 !== column.groupIndex && !column.showWhenGrouped;\n        var isVisibleColumn = column && column.visible;\n\n        if (!brokenRule.validator.$element().parent().length && (!isVisibleColumn || isGroupExpandColumn)) {\n          brokenRulesMessages.push(brokenRule.message);\n        }\n      });\n      return brokenRulesMessages.join(\", \");\n    },\n    validate: function (isFull) {\n      var _this = this;\n\n      var isValid = true;\n      var editingController = this._editingController;\n      var deferred = new _deferred.Deferred();\n      var completeList = [];\n      var editMode = editingController.getEditMode();\n      isFull = isFull || editMode === EDIT_MODE_ROW;\n\n      if (this._isValidationInProgress) {\n        return deferred.resolve(false).promise();\n      }\n\n      this._isValidationInProgress = true;\n\n      if (isFull) {\n        editingController.addDeferred(deferred);\n        (0, _iterator.each)(editingController._editData, function (index, editData) {\n          if (editData.type && \"remove\" !== editData.type) {\n            var validationResult = _this.validateGroup(editData);\n\n            completeList.push(validationResult);\n            validationResult.done(function (validationResult) {\n              editData.validated = true;\n              isValid = isValid && validationResult.isValid;\n            });\n          }\n        });\n      } else {\n        if (this._currentCellValidator) {\n          var validationResult = this.validateGroup(this._currentCellValidator._findGroup());\n          completeList.push(validationResult);\n          validationResult.done(function (validationResult) {\n            isValid = validationResult.isValid;\n          });\n        }\n      }\n\n      _deferred.when.apply(void 0, completeList).done(function () {\n        _this._isValidationInProgress = false;\n        deferred.resolve(isValid);\n      });\n\n      return deferred.promise();\n    },\n    validateGroup: function validateGroup(editData) {\n      var _this2 = this;\n\n      var result = new _deferred.Deferred();\n\n      var validateGroup = _validation_engine2.default.getGroupConfig(editData);\n\n      var validationResult;\n\n      if (validateGroup && validateGroup.validators.length) {\n        this.resetRowValidationResults(editData);\n        validationResult = _validation_engine2.default.validateGroup(editData);\n      }\n\n      (0, _deferred.when)(validationResult && validationResult.complete || validationResult).done(function (validationResult) {\n        (0, _deferred.when)(_this2._rowValidating(editData, validationResult)).done(result.resolve);\n      });\n      return result.promise();\n    },\n    isRowDataModified: function (editData) {\n      return !(0, _type.isEmptyObject)(editData.data);\n    },\n    updateEditData: function (editData) {\n      var editMode = this._editingController.getEditMode();\n\n      if (FORM_BASED_MODES.indexOf(editMode) === -1) {\n        if (editData.type === EDIT_DATA_INSERT_TYPE && !this.isRowDataModified(editData)) {\n          editData.isValid = true;\n          return;\n        }\n\n        this.setDisableApplyValidationResults(true);\n\n        if (_validation_engine2.default.getGroupConfig(editData)) {\n          var validationResult = _validation_engine2.default.validateGroup(editData);\n\n          (0, _deferred.when)(validationResult.complete || validationResult).done(function (validationResult) {\n            editData.isValid = validationResult.isValid;\n            editData.brokenRules = validationResult.brokenRules;\n          });\n        } else {\n          if (!editData.brokenRules || !editData.brokenRules.length) {\n            editData.isValid = true;\n          }\n        }\n\n        this.setDisableApplyValidationResults(false);\n      } else {\n        editData.isValid = true;\n      }\n    },\n    setValidator: function (validator) {\n      this._currentCellValidator = validator;\n    },\n    renderCellPendingIndicator: function ($container) {\n      var $indicator = $container.find(\".\" + PENDING_INDICATOR_CLASS);\n\n      if (!$indicator.length) {\n        var $indicatorContainer = $container.find(\".\" + CELL_HIGHLIGHT_OUTLINE);\n\n        if (!$indicatorContainer.length) {\n          $indicatorContainer = $container;\n        }\n\n        $indicator = (0, _renderer2.default)(\"<div>\").appendTo($indicatorContainer).addClass(PENDING_INDICATOR_CLASS);\n\n        this._createComponent($indicator, _load_indicator2.default);\n\n        $container.addClass(VALIDATION_PENDING_CLASS);\n      }\n    },\n    disposeCellPendingIndicator: function ($container) {\n      var $indicator = $container.find(\".\" + PENDING_INDICATOR_CLASS);\n\n      if ($indicator.length) {\n        var indicator = _load_indicator2.default.getInstance($indicator);\n\n        if (indicator) {\n          indicator.dispose();\n          indicator.$element().remove();\n        }\n\n        $container.removeClass(VALIDATION_PENDING_CLASS);\n      }\n    },\n    validationStatusChanged: function (result) {\n      var validator = result.validator;\n      var editData = validator.option(\"validationGroup\");\n      var column = validator.option(\"dataGetter\")().column;\n      this.updateCellValidationResult({\n        rowKey: editData.key,\n        columnIndex: column.index,\n        validationResult: result\n      });\n    },\n    validatorInitialized: function (arg) {\n      arg.component.on(\"validating\", this.validationStatusChanged.bind(this));\n      arg.component.on(\"validated\", this.validationStatusChanged.bind(this));\n    },\n    validatorDisposing: function (arg) {\n      var validator = arg.component;\n      var editData = validator.option(\"validationGroup\");\n      var column = validator.option(\"dataGetter\")().column;\n      var result = this.getCellValidationResult({\n        rowKey: editData.key,\n        columnIndex: column.index\n      });\n\n      if (result && result.status === VALIDATION_STATUS.pending) {\n        this.removeCellValidationResult({\n          editData: editData,\n          columnIndex: column.index\n        });\n      }\n    },\n    applyValidationResult: function ($container, result) {\n      var validator = result.validator;\n      var editData = validator.option(\"validationGroup\");\n      var column = validator.option(\"dataGetter\")().column;\n      result.brokenRules && result.brokenRules.forEach(function (rule) {\n        rule.columnIndex = column.index;\n        rule.column = column;\n      });\n\n      if ($container) {\n        var validationResult = this.getCellValidationResult({\n          rowKey: editData.key,\n          columnIndex: column.index\n        });\n        var requestIsDisabled = validationResult && validationResult.disabledPendingId === result.id;\n\n        if (this._disableApplyValidationResults || requestIsDisabled) {\n          return;\n        }\n\n        if (result.status === VALIDATION_STATUS.invalid) {\n          var $focus = $container.find(\":focus\");\n\n          this._editingController.showHighlighting($container, true);\n\n          if (!(0, _selectors.focused)($focus)) {\n            _events_engine2.default.trigger($focus, \"focus\");\n\n            _events_engine2.default.trigger($focus, _pointer2.default.down);\n          }\n        }\n\n        var editor = !column.editCellTemplate && this.getController(\"editorFactory\").getEditorInstance($container);\n\n        if (result.status === VALIDATION_STATUS.pending) {\n          this._editingController.showHighlighting($container, true);\n\n          if (editor) {\n            editor.option(\"validationStatus\", VALIDATION_STATUS.pending);\n          } else {\n            this.renderCellPendingIndicator($container);\n          }\n        } else {\n          if (editor) {\n            editor.option(\"validationStatus\", VALIDATION_STATUS.valid);\n          } else {\n            this.disposeCellPendingIndicator($container);\n          }\n        }\n\n        $container.toggleClass(this.addWidgetPrefix(INVALIDATE_CLASS), result.status === VALIDATION_STATUS.invalid);\n      }\n    },\n    createValidator: function (parameters, $container) {\n      var _this3 = this;\n\n      var editData;\n      var editIndex;\n      var editingController = this._editingController;\n      var column = parameters.column;\n\n      var getValue = function () {\n        var value = column.calculateCellValue(editData.data || {});\n        return void 0 !== value ? value : parameters.value;\n      };\n\n      var showEditorAlways = column.showEditorAlways;\n\n      if ((0, _type.isDefined)(column.command) || !column.validationRules || !Array.isArray(column.validationRules) || !column.validationRules.length) {\n        return;\n      }\n\n      editIndex = editingController.getIndexByKey(parameters.key, editingController._editData);\n\n      if (editIndex < 0) {\n        if (!showEditorAlways) {\n          var columnsController = this.getController(\"columns\");\n          var visibleColumns = columnsController && columnsController.getVisibleColumns() || [];\n          showEditorAlways = visibleColumns.some(function (column) {\n            return column.showEditorAlways;\n          });\n        }\n\n        if (showEditorAlways && editingController.isCellOrBatchEditMode() && editingController.allowUpdating({\n          row: parameters.row\n        })) {\n          editIndex = editingController._addEditData({\n            key: parameters.key,\n            oldData: parameters.data\n          });\n        }\n      }\n\n      if (editIndex >= 0) {\n        if ($container && !$container.length) {\n          _ui2.default.log(\"E1050\");\n\n          return;\n        }\n\n        editData = editingController._editData[editIndex];\n        var useDefaultValidator = $container && $container.hasClass(\"dx-widget\");\n        $container && $container.addClass(this.addWidgetPrefix(VALIDATOR_CLASS));\n        var validator = new _validator2.default($container || (0, _renderer2.default)(\"<div>\"), {\n          name: column.caption,\n          validationRules: (0, _extend.extend)(true, [], column.validationRules),\n          validationGroup: editData,\n          adapter: useDefaultValidator ? null : {\n            getValue: getValue,\n            applyValidationResults: function (result) {\n              _this3.applyValidationResult($container, result);\n            }\n          },\n          dataGetter: function () {\n            return {\n              data: (0, _uiGrid_core3.createObjectWithChanges)(editData.oldData, editData.data),\n              column: column\n            };\n          },\n          onInitialized: this.validatorInitialized.bind(this),\n          onDisposing: this.validatorDisposing.bind(this)\n        });\n\n        if (useDefaultValidator) {\n          var adapter = validator.option(\"adapter\");\n\n          if (adapter) {\n            adapter.getValue = getValue;\n            adapter.validationRequestsCallbacks.empty();\n          }\n        }\n\n        return validator;\n      }\n    },\n    setDisableApplyValidationResults: function (flag) {\n      this._disableApplyValidationResults = flag;\n    },\n    getDisableApplyValidationResults: function () {\n      return this._disableApplyValidationResults;\n    },\n    isCurrentValidatorProcessing: function (_ref) {\n      var rowKey = _ref.rowKey,\n          columnIndex = _ref.columnIndex;\n      return this._currentCellValidator && this._currentCellValidator.option(\"validationGroup\").key === rowKey && this._currentCellValidator.option(\"dataGetter\")().column.index === columnIndex;\n    },\n    validateCell: function (validator) {\n      var cellParams = {\n        rowKey: validator.option(\"validationGroup\").key,\n        columnIndex: validator.option(\"dataGetter\")().column.index\n      };\n      var validationResult = this.getCellValidationResult(cellParams);\n      var stateRestored = !!validationResult;\n\n      if (!validationResult) {\n        validationResult = validator.validate();\n      }\n\n      var deferred = new _deferred.Deferred();\n      var adapter = validator.option(\"adapter\");\n\n      if (stateRestored && validationResult.status === VALIDATION_STATUS.pending) {\n        this.updateCellValidationResult(cellParams);\n        adapter.applyValidationResults(validationResult);\n      }\n\n      (0, _deferred.when)(validationResult.complete || validationResult).done(function (validationResult) {\n        stateRestored && adapter.applyValidationResults(validationResult);\n        deferred.resolve(validationResult);\n      });\n      return deferred.promise();\n    },\n    updateCellValidationResult: function (_ref2) {\n      var rowKey = _ref2.rowKey,\n          columnIndex = _ref2.columnIndex,\n          validationResult = _ref2.validationResult;\n\n      var editData = this._editingController.getEditDataByKey(rowKey);\n\n      if (!editData) {\n        return;\n      }\n\n      if (!editData.validationResults) {\n        editData.validationResults = {};\n      }\n\n      var result;\n\n      if (validationResult) {\n        result = (0, _extend.extend)({}, validationResult);\n        editData.validationResults[columnIndex] = result;\n\n        if (validationResult.status === VALIDATION_STATUS.pending) {\n          if (this._editingController.getEditMode() === EDIT_MODE_CELL) {\n            result.deferred = new _deferred.Deferred();\n            result.complete.always(function () {\n              result.deferred.resolve();\n            });\n\n            this._editingController.addDeferred(result.deferred);\n          }\n\n          if (this._disableApplyValidationResults) {\n            result.disabledPendingId = validationResult.id;\n            return;\n          }\n        }\n      } else {\n        result = editData.validationResults[columnIndex];\n      }\n\n      if (result && result.disabledPendingId) {\n        delete result.disabledPendingId;\n      }\n    },\n    getCellValidationResult: function (_ref3) {\n      var rowKey = _ref3.rowKey,\n          columnIndex = _ref3.columnIndex;\n\n      var editData = this._editingController.getEditDataByKey(rowKey);\n\n      return editData && editData.validationResults && editData.validationResults[columnIndex];\n    },\n    removeCellValidationResult: function (_ref4) {\n      var editData = _ref4.editData,\n          columnIndex = _ref4.columnIndex;\n\n      if (editData && editData.validationResults) {\n        var result = editData.validationResults[columnIndex];\n        result && result.deferred && result.deferred.reject(\"cancel\");\n        delete editData.validationResults[columnIndex];\n      }\n    },\n    resetRowValidationResults: function (editData) {\n      if (editData) {\n        editData.validationResults && delete editData.validationResults;\n        delete editData.validated;\n      }\n    },\n    isInvalidCell: function (_ref5) {\n      var rowKey = _ref5.rowKey,\n          columnIndex = _ref5.columnIndex;\n      var result = this.getCellValidationResult({\n        rowKey: rowKey,\n        columnIndex: columnIndex\n      });\n      return !!result && result.status === VALIDATION_STATUS.invalid;\n    },\n    getCellValidator: function (_ref6) {\n      var rowKey = _ref6.rowKey,\n          columnIndex = _ref6.columnIndex;\n\n      var editData = this._editingController.getEditDataByKey(rowKey);\n\n      var groupConfig = editData && _validation_engine2.default.getGroupConfig(editData);\n\n      var validators = groupConfig && groupConfig.validators;\n      return validators && validators.filter(function (v) {\n        var column = v.option(\"dataGetter\")().column;\n        return column ? column.index === columnIndex : false;\n      })[0];\n    }\n  };\n}());\n\nmodule.exports = {\n  defaultOptions: function () {\n    return {\n      editing: {\n        texts: {\n          validationCancelChanges: _message2.default.format(\"dxDataGrid-validationCancelChanges\")\n        }\n      }\n    };\n  },\n  controllers: {\n    validating: ValidatingController\n  },\n  extenders: {\n    controllers: {\n      editing: {\n        _addEditData: function (options, row) {\n          var that = this;\n          var validatingController = that.getController(\"validating\");\n          var editDataIndex = that.callBase(options, row);\n\n          if (editDataIndex >= 0) {\n            var editData = that._editData[editDataIndex];\n            validatingController.updateEditData(editData);\n          }\n\n          return editDataIndex;\n        },\n        _updateRowAndPageIndices: function () {\n          var that = this;\n          var startInsertIndex = that.getView(\"rowsView\").getTopVisibleItemIndex();\n          var rowIndex = startInsertIndex;\n          (0, _iterator.each)(that._editData, function (_, editData) {\n            if (!editData.isValid && editData.pageIndex !== that._pageIndex) {\n              editData.pageIndex = that._pageIndex;\n\n              if (editData.type === EDIT_DATA_INSERT_TYPE) {\n                editData.rowIndex = startInsertIndex;\n              } else {\n                editData.rowIndex = rowIndex;\n              }\n\n              rowIndex++;\n            }\n          });\n        },\n        _needInsertItem: function (editData) {\n          var result = this.callBase.apply(this, arguments);\n\n          if (result && !editData.isValid) {\n            result = editData.key.pageIndex === this._pageIndex;\n          }\n\n          return result;\n        },\n        processItems: function (items, changeType) {\n          var that = this;\n          var i;\n          var editData = that._editData;\n          var dataController = that.getController(\"data\");\n\n          var getIndexByEditData = function (editData, items) {\n            var index = -1;\n            var isInsert = editData.type === EDIT_DATA_INSERT_TYPE;\n            var key = editData.key;\n            (0, _iterator.each)(items, function (i, item) {\n              if ((0, _common.equalByValue)(key, isInsert ? item : dataController.keyOf(item))) {\n                index = i;\n                return false;\n              }\n            });\n            return index;\n          };\n\n          items = that.callBase(items, changeType);\n          var itemsCount = items.length;\n\n          var addInValidItem = function (editData) {\n            var data = {\n              key: editData.key\n            };\n            var index = getIndexByEditData(editData, items);\n\n            if (index >= 0) {\n              return;\n            }\n\n            editData.rowIndex = editData.rowIndex > itemsCount ? editData.rowIndex % itemsCount : editData.rowIndex;\n            var rowIndex = editData.rowIndex;\n            data[INSERT_INDEX] = 1;\n            items.splice(rowIndex, 0, data);\n          };\n\n          if (that.getEditMode() === EDIT_MODE_BATCH && \"prepend\" !== changeType && \"append\" !== changeType) {\n            for (i = 0; i < editData.length; i++) {\n              if (editData[i].type && editData[i].pageIndex === that._pageIndex && editData[i].key.pageIndex !== that._pageIndex) {\n                addInValidItem(editData[i]);\n              }\n            }\n          }\n\n          return items;\n        },\n        processDataItem: function (item) {\n          var that = this;\n          var isInserted = item.data[INSERT_INDEX];\n          var key = isInserted ? item.data.key : item.key;\n          var editMode = that.getEditMode();\n\n          if (editMode === EDIT_MODE_BATCH && isInserted && key) {\n            var editIndex = (0, _uiGrid_core3.getIndexByKey)(key, that._editData);\n\n            if (editIndex >= 0) {\n              var editData = that._editData[editIndex];\n\n              if (editData.type !== EDIT_DATA_INSERT_TYPE) {\n                item.data = (0, _extend.extend)(true, {}, editData.oldData, editData.data);\n                item.key = key;\n              }\n            }\n          }\n\n          that.callBase.apply(that, arguments);\n        },\n        _getInvisibleColumns: function (editData) {\n          var _this4 = this;\n\n          var columnsController = this.getController(\"columns\");\n          var hasInvisibleRows;\n          var invisibleColumns = columnsController.getInvisibleColumns();\n\n          if (this.isCellOrBatchEditMode()) {\n            hasInvisibleRows = editData.some(function (rowEditData) {\n              var rowIndex = _this4._dataController.getRowIndexByKey(rowEditData.key);\n\n              return rowIndex < 0;\n            });\n          }\n\n          return hasInvisibleRows ? columnsController.getColumns() : invisibleColumns;\n        },\n        _createInvisibleColumnValidators: function (editData) {\n          var validatingController = this.getController(\"validating\");\n          var columnsController = this.getController(\"columns\");\n\n          var invisibleColumns = this._getInvisibleColumns(editData).filter(function (column) {\n            return !column.isBand;\n          });\n\n          var groupColumns = columnsController.getGroupColumns().filter(function (column) {\n            return !column.showWhenGrouped && invisibleColumns.indexOf(column) === -1;\n          });\n          var invisibleColumnValidators = [];\n          invisibleColumns.push.apply(invisibleColumns, _toConsumableArray(groupColumns));\n\n          if (FORM_BASED_MODES.indexOf(this.getEditMode()) === -1) {\n            (0, _iterator.each)(invisibleColumns, function (_, column) {\n              editData.forEach(function (options) {\n                var data;\n\n                if (options.type === EDIT_DATA_INSERT_TYPE) {\n                  data = options.data;\n                } else {\n                  if (\"update\" === options.type) {\n                    data = (0, _uiGrid_core3.createObjectWithChanges)(options.oldData, options.data);\n                  }\n                }\n\n                if (data) {\n                  var validator = validatingController.createValidator({\n                    column: column,\n                    key: options.key,\n                    value: column.calculateCellValue(data)\n                  });\n\n                  if (validator) {\n                    invisibleColumnValidators.push(validator);\n                  }\n                }\n              });\n            });\n          }\n\n          return function () {\n            invisibleColumnValidators.forEach(function (validator) {\n              validator.dispose();\n            });\n          };\n        },\n        _beforeSaveEditData: function (editData, editIndex) {\n          var _this5 = this;\n\n          var result = this.callBase.apply(this, arguments);\n          var validatingController = this.getController(\"validating\");\n\n          if (editData) {\n            var isValid = \"remove\" === editData.type || editData.isValid;\n            result = result || !isValid;\n          } else {\n            var disposeValidators = this._createInvisibleColumnValidators(this._editData);\n\n            result = new _deferred.Deferred();\n            this.executeOperation(result, function () {\n              validatingController.validate(true).done(function (isFullValid) {\n                disposeValidators();\n\n                _this5._updateRowAndPageIndices();\n\n                switch (_this5.getEditMode()) {\n                  case EDIT_MODE_CELL:\n                    if (!isFullValid) {\n                      _this5._focusEditingCell();\n                    }\n\n                    break;\n\n                  case EDIT_MODE_BATCH:\n                    if (!isFullValid) {\n                      _this5._editRowIndex = -1;\n                      _this5._editColumnIndex = -1;\n\n                      _this5.getController(\"data\").updateItems();\n                    }\n\n                }\n\n                result.resolve(!isFullValid);\n              });\n            });\n          }\n\n          return result.promise ? result.promise() : result;\n        },\n        _beforeEditCell: function (rowIndex, columnIndex, item) {\n          var result = this.callBase(rowIndex, columnIndex, item);\n\n          if (this.getEditMode() === EDIT_MODE_CELL) {\n            var $cell = this._rowsView._getCellElement(rowIndex, columnIndex);\n\n            var validator = $cell && $cell.data(\"dxValidator\");\n            var value = validator && validator.option(\"adapter\").getValue();\n\n            if (validator && void 0 !== value) {\n              var validatingController = this.getController(\"validating\");\n              var deferred = new _deferred.Deferred();\n              (0, _deferred.when)(validatingController.validateCell(validator), result).done(function (validationResult, result) {\n                deferred.resolve(validationResult.status === VALIDATION_STATUS.valid && result);\n              });\n              return deferred.promise();\n            } else {\n              if (!validator) {\n                return result;\n              }\n            }\n          }\n        },\n        _afterSaveEditData: function (cancel) {\n          var _this6 = this;\n\n          var $firstErrorRow;\n          (0, _iterator.each)(this._editData, function (_, editData) {\n            var $errorRow = _this6._showErrorRow(editData);\n\n            $firstErrorRow = $firstErrorRow || $errorRow;\n          });\n\n          if ($firstErrorRow) {\n            var scrollable = this._rowsView.getScrollable();\n\n            if (scrollable) {\n              scrollable.update();\n              scrollable.scrollToElement($firstErrorRow);\n            }\n          }\n\n          if (cancel && this.getEditMode() === EDIT_MODE_CELL && this._needUpdateRow()) {\n            var editRowIndex = this.getEditRowIndex();\n\n            this._dataController.updateItems({\n              changeType: \"update\",\n              rowIndices: [editRowIndex]\n            });\n\n            this._focusEditingCell();\n          }\n        },\n        _showErrorRow: function (editData) {\n          var $popupContent;\n          var errorHandling = this.getController(\"errorHandling\");\n          var items = this.getController(\"data\").items();\n          var rowIndex = this.getIndexByKey(editData.key, items);\n\n          if (!editData.isValid && editData.errorText && rowIndex >= 0) {\n            $popupContent = this.getPopupContent();\n            return errorHandling && errorHandling.renderErrorRow(editData.errorText, rowIndex, $popupContent);\n          }\n        },\n        updateFieldValue: function (e) {\n          var _this7 = this;\n\n          var validatingController = this.getController(\"validating\");\n          var deferred = new _deferred.Deferred();\n          validatingController.removeCellValidationResult({\n            editData: this.getEditDataByKey(e.key),\n            columnIndex: e.column.index\n          });\n          this.callBase.apply(this, arguments).done(function () {\n            var currentValidator = validatingController.getCellValidator({\n              rowKey: e.key,\n              columnIndex: e.column.index\n            });\n            (0, _deferred.when)(currentValidator && validatingController.validateCell(currentValidator)).done(function (validationResult) {\n              _this7.getController(\"editorFactory\").refocus();\n\n              deferred.resolve(validationResult);\n            });\n          });\n          return deferred.promise();\n        },\n        showHighlighting: function ($cell, skipValidation) {\n          var _this8 = this;\n\n          var isValid = true;\n          var callBase = this.callBase;\n\n          if (!skipValidation) {\n            var validator = $cell.data(\"dxValidator\");\n\n            if (validator) {\n              (0, _deferred.when)(this.getController(\"validating\").validateCell(validator)).done(function (validationResult) {\n                isValid = validationResult.status === VALIDATION_STATUS.valid;\n\n                if (isValid) {\n                  callBase.call(_this8, $cell);\n                }\n              });\n              return;\n            }\n          }\n\n          if (isValid) {\n            callBase.call(this, $cell);\n          }\n        },\n        highlightDataCell: function ($cell, parameters) {\n          var isEditableCell = !!parameters.setValue;\n          var cellModified = this.isCellModified(parameters);\n\n          if (!cellModified && isEditableCell) {\n            var validationResult = this.getController(\"validating\").getCellValidationResult({\n              rowKey: parameters.key,\n              columnIndex: parameters.column.index\n            });\n            var isValidated = (0, _type.isDefined)(validationResult);\n            var skipValidation = parameters.row.isNewRow || !isValidated;\n            this.showHighlighting($cell, skipValidation);\n            return;\n          }\n\n          this.callBase.apply(this, arguments);\n        },\n        getEditDataByKey: function (key) {\n          return this._editData[(0, _uiGrid_core3.getIndexByKey)(key, this._editData)];\n        },\n        isCellModified: function (parameters) {\n          var cellModified = this.callBase(parameters);\n          var editData = this.getEditDataByKey(parameters.key);\n          var isRowValidated = !!editData && !!editData.validated;\n          var isCellInvalid = !!parameters.row && this.getController(\"validating\").isInvalidCell({\n            rowKey: parameters.key,\n            columnIndex: parameters.column.index\n          });\n          return cellModified || isRowValidated && isCellInvalid;\n        }\n      },\n      editorFactory: function () {\n        var getWidthOfVisibleCells = function (that, element) {\n          var rowIndex = (0, _renderer2.default)(element).closest(\"tr\").index();\n          var $cellElements = (0, _renderer2.default)(that._rowsView.getRowElement(rowIndex)).first().children().filter(\":not(.dx-hidden-cell)\");\n          return that._rowsView._getWidths($cellElements).reduce(function (w1, w2) {\n            return w1 + w2;\n          }, 0);\n        };\n\n        var getBoundaryNonFixedColumnsInfo = function (fixedColumns) {\n          var firstNonFixedColumnIndex;\n          var lastNonFixedColumnIndex;\n          fixedColumns.some(function (column, index) {\n            if (column.command === COMMAND_TRANSPARENT) {\n              firstNonFixedColumnIndex = 0 === index ? -1 : index;\n              lastNonFixedColumnIndex = index === fixedColumns.length - 1 ? -1 : index + column.colspan - 1;\n              return true;\n            }\n          });\n          return {\n            startColumnIndex: firstNonFixedColumnIndex,\n            endColumnIndex: lastNonFixedColumnIndex\n          };\n        };\n\n        return {\n          _showRevertButton: function ($container, $targetElement) {\n            var _this9 = this;\n\n            if (!$targetElement || !$targetElement.length) {\n              return;\n            }\n\n            var $tooltipElement = $container.find(\".\" + this.addWidgetPrefix(REVERT_TOOLTIP_CLASS));\n            $tooltipElement && $tooltipElement.remove();\n            $tooltipElement = (0, _renderer2.default)(\"<div>\").addClass(this.addWidgetPrefix(REVERT_TOOLTIP_CLASS)).appendTo($container);\n            var tooltipOptions = {\n              animation: null,\n              visible: true,\n              target: $targetElement,\n              container: $container,\n              closeOnOutsideClick: false,\n              closeOnTargetScroll: false,\n              contentTemplate: function () {\n                var $buttonElement = (0, _renderer2.default)(\"<div>\").addClass(REVERT_BUTTON_CLASS);\n                var buttonOptions = {\n                  icon: \"revert\",\n                  hint: _this9.option(\"editing.texts.validationCancelChanges\"),\n                  onClick: function () {\n                    _this9._editingController.cancelEditData();\n                  }\n                };\n                return new _button2.default($buttonElement, buttonOptions).$element();\n              },\n              position: {\n                my: \"left top\",\n                at: \"right top\",\n                of: $targetElement,\n                offset: \"1 0\",\n                collision: \"flip\",\n                boundary: this._rowsView.element()\n              },\n              onPositioned: this._positionedHandler.bind(this)\n            };\n            return new _tooltip2.default($tooltipElement, tooltipOptions);\n          },\n          _hideFixedGroupCell: function ($cell, overlayOptions) {\n            var $nextFixedRowElement;\n            var $groupCellElement;\n\n            var isFixedColumns = this._rowsView.isFixedColumns();\n\n            var isFormEditMode = this._editingController.isFormEditMode();\n\n            if (isFixedColumns && !isFormEditMode) {\n              var nextRowOptions = $cell.closest(\".dx-row\").next().data(\"options\");\n\n              if (nextRowOptions && \"group\" === nextRowOptions.rowType) {\n                $nextFixedRowElement = (0, _renderer2.default)(this._rowsView.getRowElement(nextRowOptions.rowIndex)).last();\n                $groupCellElement = $nextFixedRowElement.find(\".\" + GROUP_CELL_CLASS);\n\n                if ($groupCellElement.length && \"hidden\" !== $groupCellElement.get(0).style.visibility) {\n                  $groupCellElement.css(\"visibility\", \"hidden\");\n\n                  overlayOptions.onDisposing = function () {\n                    $groupCellElement.css(\"visibility\", \"\");\n                  };\n                }\n              }\n            }\n          },\n          _positionedHandler: function (e, isOverlayVisible) {\n            if (!e.component.__skipPositionProcessing) {\n              var isRevertButton = (0, _renderer2.default)(e.element).hasClass(this.addWidgetPrefix(REVERT_TOOLTIP_CLASS));\n\n              var needRepaint = !isRevertButton && this._rowsView.updateFreeSpaceRowHeight();\n\n              var normalizedPosition = this._normalizeValidationMessagePositionAndMaxWidth(e, isRevertButton, isOverlayVisible);\n\n              e.component.__skipPositionProcessing = !!(needRepaint || normalizedPosition);\n\n              if (normalizedPosition) {\n                e.component.option(normalizedPosition);\n              } else {\n                if (needRepaint) {\n                  e.component.repaint();\n                }\n              }\n            }\n          },\n          _showValidationMessage: function ($cell, messages, alignment, revertTooltip) {\n            var _this10 = this;\n\n            var $highlightContainer = $cell.find(\".\" + CELL_HIGHLIGHT_OUTLINE);\n\n            var isMaterial = _themes2.default.isMaterial();\n\n            var overlayTarget = $highlightContainer.length && !isMaterial ? $highlightContainer : $cell;\n            var editorPopup = $cell.find(\".dx-dropdowneditor-overlay\").data(\"dxPopup\");\n            var isOverlayVisible = editorPopup && editorPopup.option(\"visible\");\n            var myPosition = isOverlayVisible ? \"top right\" : \"top \" + alignment;\n            var atPosition = isOverlayVisible ? \"top left\" : \"bottom \" + alignment;\n            var errorMessageText = \"\";\n            messages && messages.forEach(function (message) {\n              errorMessageText += (errorMessageText.length ? \"<br/>\" : \"\") + (0, _string.encodeHtml)(message);\n            });\n            var $overlayElement = (0, _renderer2.default)(\"<div>\").addClass(INVALID_MESSAGE_CLASS).addClass(INVALID_MESSAGE_ALWAYS_CLASS).addClass(this.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS)).html(errorMessageText).appendTo($cell);\n            var overlayOptions = {\n              target: overlayTarget,\n              container: $cell,\n              shading: false,\n              width: \"auto\",\n              height: \"auto\",\n              visible: true,\n              animation: false,\n              propagateOutsideClick: true,\n              closeOnOutsideClick: false,\n              closeOnTargetScroll: false,\n              position: {\n                collision: \"flip\",\n                boundary: this._rowsView.element(),\n                boundaryOffset: \"0 0\",\n                my: myPosition,\n                at: atPosition\n              },\n              onPositioned: function (e) {\n                _this10._positionedHandler(e, isOverlayVisible);\n\n                _this10._shiftValidationMessageIfNeed(e.component.$content(), revertTooltip && revertTooltip.$content(), $cell);\n              }\n            };\n\n            this._hideFixedGroupCell($cell, overlayOptions);\n\n            new _overlay2.default($overlayElement, overlayOptions);\n          },\n          _normalizeValidationMessagePositionAndMaxWidth: function (options, isRevertButton, isOverlayVisible) {\n            var fixedColumns = this._columnsController.getFixedColumns();\n\n            if (!fixedColumns || !fixedColumns.length) {\n              return;\n            }\n\n            var position;\n            var visibleTableWidth = !isRevertButton && getWidthOfVisibleCells(this, options.element);\n            var $overlayContentElement = isRevertButton ? options.component.overlayContent() : options.component.$content();\n            var validationMessageWidth = $overlayContentElement.outerWidth(true);\n            var needMaxWidth = !isRevertButton && validationMessageWidth > visibleTableWidth;\n\n            var columnIndex = this._rowsView.getCellIndex((0, _renderer2.default)(options.element).closest(\"td\"));\n\n            var boundaryNonFixedColumnsInfo = getBoundaryNonFixedColumnsInfo(fixedColumns);\n\n            if (!isRevertButton && (columnIndex === boundaryNonFixedColumnsInfo.startColumnIndex || needMaxWidth)) {\n              position = {\n                collision: \"none flip\",\n                my: \"top left\",\n                at: isOverlayVisible ? \"top right\" : \"bottom left\"\n              };\n            } else {\n              if (columnIndex === boundaryNonFixedColumnsInfo.endColumnIndex) {\n                position = {\n                  collision: \"none flip\",\n                  my: \"top right\",\n                  at: isRevertButton || isOverlayVisible ? \"top left\" : \"bottom right\"\n                };\n\n                if (isRevertButton) {\n                  position.offset = \"-1 0\";\n                }\n              }\n            }\n\n            return position && {\n              position: position,\n              maxWidth: needMaxWidth ? visibleTableWidth - 2 : void 0\n            };\n          },\n          _shiftValidationMessageIfNeed: function ($content, $revertContent, $cell) {\n            if (!$revertContent) {\n              return;\n            }\n\n            var contentOffset = $content.offset();\n            var revertContentOffset = $revertContent.offset();\n\n            if (contentOffset.top === revertContentOffset.top && contentOffset.left + $content.width() > revertContentOffset.left) {\n              var left = $revertContent.width() + PADDING_BETWEEN_TOOLTIPS;\n              $content.css(\"left\", revertContentOffset.left < $cell.offset().left ? -left : left);\n            }\n          },\n          _getTooltipsSelector: function () {\n            var invalidMessageClass = this.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS);\n            var revertTooltipClass = this.addWidgetPrefix(REVERT_TOOLTIP_CLASS);\n            return \".dx-editor-cell .\" + revertTooltipClass + \", .dx-editor-cell .\" + invalidMessageClass + \", .dx-cell-modified .\" + invalidMessageClass;\n          },\n          init: function () {\n            this.callBase();\n            this._editingController = this.getController(\"editing\");\n            this._columnsController = this.getController(\"columns\");\n            this._rowsView = this.getView(\"rowsView\");\n          },\n          loseFocus: function (skipValidator) {\n            if (!skipValidator) {\n              this.getController(\"validating\").setValidator(null);\n            }\n\n            this.callBase();\n          },\n          updateCellState: function ($element, validationResult, hideBorder) {\n            var $focus = $element && $element.closest(this._getFocusCellSelector());\n            var $cell = $focus && $focus.is(\"td\") ? $focus : null;\n            var rowOptions = $focus && $focus.closest(\".dx-row\").data(\"options\");\n            var editData = rowOptions ? this.getController(\"editing\").getEditDataByKey(rowOptions.key) : null;\n            var column = $cell && this.getController(\"columns\").getVisibleColumns()[$cell.index()];\n            var revertTooltip;\n\n            if (validationResult && validationResult.status === VALIDATION_STATUS.invalid || editData && \"update\" === editData.type && !this._editingController.isSaving()) {\n              if (this._editingController.getEditMode() === EDIT_MODE_CELL) {\n                revertTooltip = this._showRevertButton($focus, $cell ? $focus.find(\".\" + CELL_HIGHLIGHT_OUTLINE).first() : $focus);\n              }\n            }\n\n            var showValidationMessage = validationResult && validationResult.status === VALIDATION_STATUS.invalid;\n\n            if (showValidationMessage && $cell && column && validationResult && validationResult.brokenRules) {\n              var errorMessages = [];\n              validationResult.brokenRules.forEach(function (rule) {\n                errorMessages.push(rule.message);\n              });\n\n              this._showValidationMessage($focus, errorMessages, column.alignment || \"left\", revertTooltip);\n            }\n\n            !hideBorder && this._rowsView.element() && this._rowsView.updateFreeSpaceRowHeight();\n          },\n          focus: function ($element, hideBorder) {\n            var _this11 = this;\n\n            var $focus = $element && $element.closest(this._getFocusCellSelector());\n            var callBase = this.callBase;\n            var validator = $focus && ($focus.data(\"dxValidator\") || $element.find(\".\" + this.addWidgetPrefix(VALIDATOR_CLASS)).eq(0).data(\"dxValidator\"));\n            var rowOptions = $focus && $focus.closest(\".dx-row\").data(\"options\");\n            var editingController = this.getController(\"editing\");\n            var editData = rowOptions ? editingController.getEditDataByKey(rowOptions.key) : null;\n            var validationResult;\n            var $tooltips = $focus && $focus.closest(\".\" + this.addWidgetPrefix(ROWS_VIEW_CLASS)).find(this._getTooltipsSelector());\n            var $cell = $focus && $focus.is(\"td\") ? $focus : null;\n            var column = $cell && this.getController(\"columns\").getVisibleColumns()[$cell.index()];\n            var validatingController = this.getController(\"validating\");\n\n            if (!arguments.length) {\n              return this.callBase();\n            }\n\n            $tooltips && $tooltips.remove();\n\n            if (validator) {\n              validatingController.setValidator(validator);\n\n              if (void 0 !== validator.option(\"adapter\").getValue() || editData && editData.validated) {\n                editingController.waitForDeferredOperations().done(function () {\n                  (0, _deferred.when)(validatingController.validateCell(validator)).done(function (result) {\n                    validationResult = result;\n\n                    if (editData && column && !validatingController.isCurrentValidatorProcessing({\n                      rowKey: editData.key,\n                      columnIndex: column.index\n                    })) {\n                      return;\n                    }\n\n                    if (validationResult.status === VALIDATION_STATUS.invalid) {\n                      hideBorder = true;\n                    }\n\n                    _this11.updateCellState($element, validationResult, hideBorder);\n\n                    callBase.call(_this11, $element, hideBorder);\n                  });\n                });\n                return this.callBase($element, hideBorder);\n              }\n            }\n\n            this.updateCellState($element, validationResult, hideBorder);\n            return this.callBase($element, hideBorder);\n          },\n          getEditorInstance: function ($container) {\n            var $editor = $container.find(\".dx-texteditor\").eq(0);\n            return (0, _uiGrid_core3.getWidgetInstance)($editor);\n          }\n        };\n      }()\n    },\n    views: {\n      rowsView: {\n        updateFreeSpaceRowHeight: function ($table) {\n          var that = this;\n          var $rowElements;\n          var $freeSpaceRowElement;\n          var $freeSpaceRowElements;\n          var $element = that.element();\n          var $tooltipContent = $element && $element.find(\".\" + that.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS) + \" .dx-overlay-content\");\n          that.callBase($table);\n\n          if ($tooltipContent && $tooltipContent.length) {\n            $rowElements = that._getRowElements();\n            $freeSpaceRowElements = that._getFreeSpaceRowElements($table);\n            $freeSpaceRowElement = $freeSpaceRowElements.first();\n\n            if ($freeSpaceRowElement && 1 === $rowElements.length && (!$freeSpaceRowElement.is(\":visible\") || $tooltipContent.outerHeight() > $freeSpaceRowElement.outerHeight())) {\n              $freeSpaceRowElements.show();\n              $freeSpaceRowElements.height($tooltipContent.outerHeight());\n              return true;\n            }\n          }\n        },\n        _formItemPrepared: function (cellOptions, $container) {\n          var _this12 = this;\n\n          this.callBase.apply(this, arguments);\n          (0, _common.deferUpdate)(function () {\n            var $editor = $container.find(\".dx-widget\").first();\n            var isEditorDisposed = $editor.length && !$editor.children().length;\n\n            if (!isEditorDisposed) {\n              _this12.getController(\"validating\").createValidator(cellOptions, $editor);\n            }\n          });\n        },\n        _cellPrepared: function ($cell, parameters) {\n          if (!this.getController(\"editing\").isFormEditMode()) {\n            this.getController(\"validating\").createValidator(parameters, $cell);\n          }\n\n          this.callBase.apply(this, arguments);\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}