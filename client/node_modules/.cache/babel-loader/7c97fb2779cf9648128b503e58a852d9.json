{"ast":null,"code":"import { isNullOrUndefined, remove, extend } from '@syncfusion/ej2-base';\nimport { RowModelGenerator } from '../services/row-model-generator';\nimport { FreezeRowModelGenerator } from '../services/freeze-row-model-generator';\nimport { RowRenderer } from '../renderer/row-renderer';\nimport * as events from '../base/constant';\nimport { getScrollBarWidth, ensureLastRow, ensureFirstRow, getEditedDataIndex } from '../base/util';\n/**\n * Infinite Scrolling class\n */\n\nvar InfiniteScroll =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the Grid infinite scrolling.\n   * @hidden\n   */\n  function InfiniteScroll(parent, serviceLocator) {\n    this.infiniteCache = {};\n    this.infiniteFrozenCache = {};\n    this.isDownScroll = false;\n    this.isUpScroll = false;\n    this.isScroll = true;\n    this.enableContinuousScroll = false;\n    this.initialRender = true;\n    this.isRemove = false;\n    this.isInitialCollapse = false;\n    this.prevScrollTop = 0;\n    this.actions = ['filtering', 'searching', 'grouping', 'ungrouping', 'reorder', 'sorting'];\n    this.keys = ['downArrow', 'upArrow', 'PageUp', 'PageDown'];\n    this.rowTop = 0;\n    this.isInitialMovableRender = true;\n    this.virtualInfiniteData = {};\n    this.isCancel = false;\n    this.emptyRowData = {};\n    this.isNormaledit = false;\n    this.isInfiniteScroll = false;\n    this.isLastPage = false;\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.isNormaledit = this.parent.editSettings.mode === 'Normal';\n    this.addEventListener();\n    this.rowModelGenerator = this.parent.getFrozenColumns() ? new FreezeRowModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  }\n\n  InfiniteScroll.prototype.getModuleName = function () {\n    return 'infiniteScroll';\n  };\n  /**\n   * @hidden\n   */\n\n\n  InfiniteScroll.prototype.addEventListener = function () {\n    this.parent.on(events.dataReady, this.onDataReady, this);\n    this.parent.on(events.dataSourceModified, this.dataSourceModified, this);\n    this.parent.on(events.infinitePageQuery, this.infinitePageQuery, this);\n    this.parent.on(events.infiniteScrollHandler, this.infiniteScrollHandler, this);\n    this.parent.on(events.beforeCellFocused, this.infiniteCellFocus, this);\n    this.parent.on(events.appendInfiniteContent, this.appendInfiniteRows, this);\n    this.parent.on(events.removeInfiniteRows, this.removeInfiniteCacheRows, this);\n    this.parent.on(events.resetInfiniteBlocks, this.resetInfiniteBlocks, this);\n    this.parent.on(events.setInfiniteCache, this.setCache, this);\n    this.parent.on(events.initialCollapse, this.ensureIntialCollapse, this);\n    this.parent.on(events.keyPressed, this.infiniteCellFocus, this);\n    this.parent.on(events.infiniteShowHide, this.setDisplayNone, this);\n    this.parent.on(events.virtualScrollEditActionBegin, this.editActionBegin, this);\n    this.parent.on(events.getVirtualData, this.getVirtualInfiniteData, this);\n    this.parent.on(events.editReset, this.resetInfiniteEdit, this);\n    this.parent.on(events.virtualScrollEditSuccess, this.infiniteEditSuccess, this);\n    this.parent.on(events.refreshVirtualCache, this.refreshInfiniteCache, this);\n    this.parent.on(events.infiniteEditHandler, this.infiniteEditHandler, this);\n    this.parent.on(events.virtualScrollAddActionBegin, this.infiniteAddActionBegin, this);\n    this.parent.on(events.modelChanged, this.modelChanged, this);\n    this.parent.addEventListener(events.actionBegin, this.actionBegin.bind(this));\n    this.parent.addEventListener(events.actionComplete, this.actionComplete.bind(this));\n  };\n  /**\n   * @hidden\n   */\n\n\n  InfiniteScroll.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(events.dataReady, this.onDataReady);\n    this.parent.off(events.dataSourceModified, this.dataSourceModified);\n    this.parent.off(events.infinitePageQuery, this.infinitePageQuery);\n    this.parent.off(events.infiniteScrollHandler, this.infiniteScrollHandler);\n    this.parent.off(events.beforeCellFocused, this.infiniteCellFocus);\n    this.parent.off(events.appendInfiniteContent, this.appendInfiniteRows);\n    this.parent.off(events.removeInfiniteRows, this.removeInfiniteCacheRows);\n    this.parent.off(events.resetInfiniteBlocks, this.resetInfiniteBlocks);\n    this.parent.off(events.setInfiniteCache, this.setCache);\n    this.parent.off(events.initialCollapse, this.ensureIntialCollapse);\n    this.parent.off(events.keyPressed, this.infiniteCellFocus);\n    this.parent.off(events.infiniteShowHide, this.setDisplayNone);\n    this.parent.off(events.virtualScrollEditActionBegin, this.editActionBegin);\n    this.parent.off(events.getVirtualData, this.getVirtualInfiniteData);\n    this.parent.off(events.editReset, this.resetInfiniteEdit);\n    this.parent.off(events.virtualScrollEditSuccess, this.infiniteEditSuccess);\n    this.parent.off(events.refreshVirtualCache, this.refreshInfiniteCache);\n    this.parent.off(events.infiniteEditHandler, this.infiniteEditHandler);\n    this.parent.off(events.virtualScrollAddActionBegin, this.infiniteAddActionBegin);\n    this.parent.off(events.modelChanged, this.modelChanged);\n    this.parent.removeEventListener(events.actionBegin, this.actionBegin.bind(this));\n    this.parent.removeEventListener(events.actionComplete, this.actionComplete.bind(this));\n  };\n\n  InfiniteScroll.prototype.modelChanged = function (args) {\n    if (args.requestType !== 'infiniteScroll' && (args.requestType === 'delete' || this.requestType === 'add')) {\n      var rows = this.parent.getRows();\n      this.firstIndex = parseInt(rows[0].getAttribute('aria-rowindex'), 10);\n      this.firstBlock = Math.ceil((this.firstIndex + 1) / this.parent.pageSettings.pageSize);\n      this.lastIndex = parseInt(rows[rows.length - 1].getAttribute('aria-rowindex'), 10);\n\n      if (args.requestType === 'delete') {\n        var rowObj = this.parent.getRowsObject();\n        args.startIndex = this.parent.infiniteScrollSettings.enableCache ? (this.firstBlock - 1) * this.parent.pageSettings.pageSize : rowObj[rowObj.length - 1].index;\n      } else {\n        args.startIndex = this.firstIndex;\n      }\n\n      if (!this.parent.infiniteScrollSettings.enableCache && this.parent.pageSettings.currentPage === this.maxPage && args.requestType === 'delete') {\n        this.isLastPage = true;\n        this.lastIndex = this.lastIndex - 1;\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.infiniteAddActionBegin = function (args) {\n    if (this.isNormaledit) {\n      this.isAdd = true;\n\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        if (!Object.keys(this.emptyRowData).length) {\n          this.createEmptyRowdata();\n        }\n\n        if (this.parent.pageSettings.currentPage > 1) {\n          args.startEdit = false;\n          this.resetInfiniteBlocks({}, true);\n          this.makeRequest({\n            currentPage: 1\n          });\n        }\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.infiniteEditHandler = function (args) {\n    if (!this.parent.infiniteScrollSettings.enableCache && (args.e.requestType === 'delete' || args.e.requestType === 'save' && this.requestType === 'add')) {\n      var frozenCols = this.parent.getFrozenColumns();\n      var rowElms = this.parent.getRows();\n      var rows = this.parent.getRowsObject();\n\n      if (this.ensureRowAvailability(rows, args.result[0])) {\n        this.resetRowIndex(rows, args.e, rowElms, this.requestType === 'add');\n\n        if (frozenCols) {\n          var rows_1 = this.parent.getMovableRowsObject();\n          this.resetRowIndex(rows_1, args.e, this.parent.getMovableDataRows(), this.requestType === 'add');\n        }\n\n        if (!this.isLastPage) {\n          this.createRow(rows, args);\n        } else {\n          this.isLastPage = false;\n          this.parent.pageSettings.currentPage = this.maxPage;\n\n          if (this.parent.selectionModule.index < this.parent.frozenRows) {\n            remove(rowElms[this.parent.frozenRows - 1]);\n            this.createRow([rows[this.parent.frozenRows - 1]], args, false, true);\n\n            if (frozenCols) {\n              var movableRows = this.parent.getMovableDataRows();\n              remove(movableRows[this.parent.frozenRows]);\n              this.createRow([this.parent.getMovableRowsObject()[this.parent.frozenRows - 1]], args, true, true);\n            }\n\n            this.setRowElements();\n          }\n        }\n      }\n\n      this.parent.hideSpinner();\n      this.requestType === 'delete' ? this.parent.notify(events.deleteComplete, args.e) : this.parent.notify(events.saveComplete, args.e);\n    }\n  };\n\n  InfiniteScroll.prototype.createRow = function (rows, args, isMovable, isFrozenRows) {\n    var row = !isFrozenRows ? this.generateRows(args.result, args.e) : rows;\n    var rowRenderer = new RowRenderer(this.serviceLocator, null, this.parent);\n    var tbody = !this.parent.getFrozenColumns() ? this.parent.getContent().querySelector('tbody') : isMovable ? this.parent.getMovableVirtualContent().querySelector('tbody') : this.parent.getFrozenVirtualContent().querySelector('tbody');\n\n    if (this.parent.frozenRows) {\n      tbody = isFrozenRows && this.requestType !== 'add' || !isFrozenRows && this.requestType === 'add' ? !this.parent.getFrozenColumns() ? this.parent.getHeaderContent().querySelector('tbody') : isMovable ? this.parent.getMovableVirtualHeader().querySelector('tbody') : this.parent.getFrozenVirtualHeader().querySelector('tbody') : tbody;\n    }\n\n    for (var i = row.length - 1; i >= 0; i--) {\n      if (this.requestType === 'delete') {\n        tbody.appendChild(rowRenderer.render(row[i], this.parent.getColumns()));\n      } else {\n        tbody.insertBefore(rowRenderer.render(row[i], this.parent.getColumns()), tbody.firstElementChild);\n      }\n    }\n\n    if (!isFrozenRows && this.parent.frozenRows && (this.parent.selectionModule.index < this.parent.frozenRows || this.requestType === 'add')) {\n      var rowElems = isMovable ? this.parent.getMovableDataRows() : this.parent.getRows();\n      var index = isMovable && this.requestType === 'add' ? this.parent.frozenRows : this.parent.frozenRows - 1;\n      remove(rowElems[index]);\n      this.createRow([rows[this.parent.frozenRows - 1]], args, isMovable, true);\n    }\n\n    if (!this.parent.infiniteScrollSettings.enableCache && !isFrozenRows) {\n      if (!this.parent.getFrozenColumns() || isMovable) {\n        this.setRowElements();\n        this.parent.contentModule.visibleRows = this.requestType === 'add' ? row.concat(rows) : rows.concat(row);\n      } else {\n        this.parent.contentModule.visibleFrozenRows = this.requestType === 'add' ? row.concat(rows) : rows.concat(row);\n        this.createRow(this.parent.getMovableRowsObject(), args, true);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.ensureRowAvailability = function (rows, data) {\n    var resume = true;\n\n    if (this.parent.frozenRows && !this.parent.infiniteScrollSettings.enableCache && this.parent.sortSettings.columns && this.requestType === 'add') {\n      var key = this.parent.getPrimaryKeyFieldNames()[0];\n\n      for (var i = 0; i < rows.length; i++) {\n        if (rows[i].data[key] === data[key]) {\n          resume = false;\n          break;\n        }\n      }\n    }\n\n    return resume;\n  };\n\n  InfiniteScroll.prototype.generateRows = function (data, args) {\n    return this.rowModelGenerator.generateRows(data, args);\n  };\n\n  InfiniteScroll.prototype.resetRowIndex = function (rows, args, rowElms, isAdd) {\n    var keyField = this.parent.getPrimaryKeyFieldNames()[0];\n    var isRemove = !(rowElms.length % this.parent.pageSettings.pageSize);\n\n    if (isAdd) {\n      if (isRemove) {\n        remove(rowElms[rows.length - 1]);\n        rowElms.splice(rows.length - 1, 1);\n        rows.splice(rows.length - 1, 1);\n      }\n    } else {\n      rows.filter(function (e, index) {\n        if (e.data[keyField] === args.data[0][keyField]) {\n          rows.splice(index, 1);\n          remove(rowElms[index]);\n          rowElms.splice(index, 1);\n        }\n      });\n    }\n\n    var startIndex = isAdd ? 1 : 0;\n\n    for (var i = 0; i < rows.length; i++) {\n      rows[i].index = startIndex;\n      rowElms[i].setAttribute('aria-rowindex', startIndex.toString());\n      this.resetCellIndex(rowElms[i].cells, startIndex);\n      startIndex++;\n    }\n\n    if (!rows.length) {\n      this.renderEmptyRow();\n    }\n  };\n\n  InfiniteScroll.prototype.renderEmptyRow = function () {\n    this.parent.renderModule.emptyRow(true);\n  };\n\n  InfiniteScroll.prototype.resetCellIndex = function (cells, index) {\n    for (var i = 0; i < cells.length; i++) {\n      cells[i].setAttribute('index', index.toString());\n    }\n  };\n\n  InfiniteScroll.prototype.setDisplayNone = function (args) {\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      var frozenCols = this.parent.getFrozenColumns();\n      var keys = frozenCols ? Object.keys(this.infiniteFrozenCache) : Object.keys(this.infiniteCache);\n\n      for (var i = 1; i <= keys.length; i++) {\n        var cache = frozenCols ? args.isFreeze ? this.infiniteFrozenCache[i][0] : this.infiniteFrozenCache[i][1] : this.infiniteCache[i];\n        cache.filter(function (e) {\n          e.cells[args.index].visible = args.visible === '';\n        });\n      }\n\n      this.resetContentModuleCache(frozenCols ? this.infiniteFrozenCache : this.infiniteCache);\n    }\n  };\n\n  InfiniteScroll.prototype.refreshInfiniteCache = function (data) {\n    this.getEditedRowObject().data = data;\n  };\n\n  InfiniteScroll.prototype.getEditedRowObject = function () {\n    var rowObjects = this.parent.getRowsObject();\n    var editedrow;\n\n    for (var i = 0; i < rowObjects.length; i++) {\n      if (rowObjects[i].index === this.editRowIndex) {\n        editedrow = rowObjects[i];\n      }\n    }\n\n    return editedrow;\n  };\n\n  InfiniteScroll.prototype.infiniteEditSuccess = function (args) {\n    if (this.isNormaledit) {\n      if (!this.isAdd && args.data) {\n        this.updateCurrentViewRecords(args.data);\n      }\n\n      this.isAdd = false;\n    }\n  };\n\n  InfiniteScroll.prototype.updateCurrentViewRecords = function (data) {\n    var index = getEditedDataIndex(this.parent, data);\n\n    if (!isNullOrUndefined(index)) {\n      this.parent.getCurrentViewRecords()[index] = data;\n    }\n  };\n\n  InfiniteScroll.prototype.actionBegin = function (args) {\n    if (args.requestType === 'add' || args.requestType === 'delete') {\n      this.requestType = args.requestType;\n    }\n  };\n\n  InfiniteScroll.prototype.actionComplete = function (args) {\n    if (args.requestType === 'delete' || args.requestType === 'save' || args.requestType === 'cancel') {\n      this.requestType = this.empty;\n      this.isCancel = args.requestType === 'cancel' || args.requestType === 'save';\n      this.isAdd = this.isEdit = false;\n\n      if (this.isNormaledit) {\n        this.editRowIndex = this.empty;\n        this.virtualInfiniteData = {};\n        this.parent.editModule.previousVirtualData = {};\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.resetInfiniteEdit = function () {\n    if (this.parent.enableInfiniteScrolling && this.isNormaledit) {\n      if (this.parent.editSettings.allowEditing && this.isEdit || this.parent.editSettings.allowAdding && this.isAdd) {\n        this.parent.isEdit = true;\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.getVirtualInfiniteData = function (data) {\n    data.virtualData = this.virtualInfiniteData;\n    data.isAdd = this.isAdd;\n    data.isCancel = this.isCancel;\n  };\n\n  InfiniteScroll.prototype.editActionBegin = function (e) {\n    this.isEdit = true;\n    this.editRowIndex = e.index;\n    var rowObject = extend({}, this.getEditedRowObject().data);\n    e.data = Object.keys(this.virtualInfiniteData).length ? this.virtualInfiniteData : rowObject;\n  };\n\n  InfiniteScroll.prototype.dataSourceModified = function () {\n    this.resetInfiniteBlocks({\n      requestType: this.empty\n    }, true);\n  };\n\n  InfiniteScroll.prototype.onDataReady = function (e) {\n    if (!isNullOrUndefined(e.count)) {\n      this.maxPage = Math.ceil(e.count / this.parent.pageSettings.pageSize);\n    }\n  };\n\n  InfiniteScroll.prototype.ensureIntialCollapse = function (isExpand) {\n    this.isInitialCollapse = !isExpand;\n  };\n\n  InfiniteScroll.prototype.infiniteScrollHandler = function (e) {\n    var _this = this;\n\n    this.restoreInfiniteEdit();\n    this.restoreInfiniteAdd();\n    var targetEle = e.target;\n    var isInfinite = targetEle.classList.contains('e-content') || targetEle.classList.contains('e-movablecontent');\n\n    if (isInfinite && this.parent.enableInfiniteScrolling) {\n      var scrollEle = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.parent.getContent().firstElementChild;\n      this.prevScrollTop = scrollEle.scrollTop;\n      var rows = this.parent.getRows();\n      var index = parseInt(rows[rows.length - 1].getAttribute('aria-rowindex'), 10) + 1;\n      var prevPage = this.parent.pageSettings.currentPage;\n      var args = void 0;\n      var offset = targetEle.scrollHeight - targetEle.scrollTop;\n      var round = Math.round(targetEle.scrollHeight - targetEle.scrollTop);\n      var floor = offset < targetEle.clientHeight ? Math.ceil(offset) : Math.floor(offset);\n      var isBottom = floor === targetEle.clientHeight || round === targetEle.clientHeight;\n\n      if (this.isScroll && isBottom && (this.parent.pageSettings.currentPage <= this.maxPage - 1 || this.enableContinuousScroll)) {\n        if (this.parent.infiniteScrollSettings.enableCache) {\n          this.isUpScroll = false;\n          this.isDownScroll = true;\n          setTimeout(function () {\n            _this.isScroll = true;\n          }, 600);\n        }\n\n        var rows_2 = [].slice.call(scrollEle.querySelectorAll('.e-row:not(.e-addedrow)'));\n        var row = rows_2[rows_2.length - 1];\n        var rowIndex = parseInt(row.getAttribute('aria-rowindex'), 10);\n        this.parent.pageSettings.currentPage = Math.ceil(rowIndex / this.parent.pageSettings.pageSize) + 1;\n        args = {\n          requestType: 'infiniteScroll',\n          currentPage: this.parent.pageSettings.currentPage,\n          prevPage: prevPage,\n          startIndex: index,\n          direction: 'down'\n        };\n        this.makeRequest(args);\n      }\n\n      if (this.isScroll && this.parent.infiniteScrollSettings.enableCache && targetEle.scrollTop === 0 && this.parent.pageSettings.currentPage !== 1) {\n        if (this.parent.infiniteScrollSettings.enableCache) {\n          this.isDownScroll = false;\n          this.isUpScroll = true;\n          setTimeout(function () {\n            _this.isScroll = true;\n          }, 600);\n        }\n\n        var row = [].slice.call(scrollEle.querySelectorAll('.e-row'));\n        var rowIndex = parseInt(row[this.parent.pageSettings.pageSize - 1].getAttribute('aria-rowindex'), 10);\n        var startIndex = parseInt(row[0].getAttribute('aria-rowindex'), 10) - this.parent.pageSettings.pageSize;\n        this.parent.pageSettings.currentPage = Math.ceil(rowIndex / this.parent.pageSettings.pageSize) - 1;\n\n        if (this.parent.pageSettings.currentPage) {\n          args = {\n            requestType: 'infiniteScroll',\n            currentPage: this.parent.pageSettings.currentPage,\n            prevPage: prevPage,\n            startIndex: startIndex,\n            direction: 'up'\n          };\n          this.makeRequest(args);\n        }\n      }\n\n      if (this.parent.infiniteScrollSettings.enableCache && !this.isScroll && isNullOrUndefined(args)) {\n        if (this.isDownScroll || this.isUpScroll) {\n          scrollEle.scrollTop = this.top;\n        }\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.makeRequest = function (args) {\n    var _this = this;\n\n    if (this.parent.pageSettings.currentPage !== args.prevPage) {\n      if (this.parent.pageSettings.currentPage <= this.maxPage) {\n        this.isInfiniteScroll = true;\n\n        if (isNullOrUndefined(this.infiniteCache[args.currentPage])) {\n          setTimeout(function () {\n            _this.getVirtualInfiniteEditedData();\n\n            _this.parent.notify('model-changed', args);\n          }, 100);\n        } else {\n          setTimeout(function () {\n            _this.getVirtualInfiniteEditedData();\n\n            _this.parent.notify(events.refreshInfiniteModeBlocks, args);\n          }, 100);\n        }\n      } else {\n        this.parent.pageSettings.currentPage = this.maxPage;\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.infinitePageQuery = function (query) {\n    if (this.initialRender) {\n      this.initialRender = false;\n      this.intialPageQuery(query);\n    } else {\n      if (!this.isInfiniteScroll && (this.requestType === 'delete' || this.requestType === 'add')) {\n        this.editPageQuery(query);\n      } else {\n        query.page(this.parent.pageSettings.currentPage, this.parent.pageSettings.pageSize);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.editPageQuery = function (query) {\n    var initialBlocks = this.parent.infiniteScrollSettings.initialBlocks;\n    var isCache = this.parent.infiniteScrollSettings.enableCache;\n\n    if (isCache) {\n      this.infiniteCache = {};\n      this.infiniteFrozenCache = {};\n      query.skip(this.firstIndex);\n      query.take(initialBlocks * this.parent.pageSettings.pageSize);\n    } else {\n      if (this.parent.editSettings.mode === 'Dialog') {\n        this.parent.clearSelection();\n      }\n\n      var index = this.requestType === 'delete' ? this.lastIndex : this.firstIndex;\n      query.skip(index);\n      query.take(1);\n    }\n  };\n\n  InfiniteScroll.prototype.intialPageQuery = function (query) {\n    if (this.parent.infiniteScrollSettings.enableCache && this.parent.infiniteScrollSettings.initialBlocks > this.parent.infiniteScrollSettings.maxBlocks) {\n      this.parent.infiniteScrollSettings.initialBlocks = this.parent.infiniteScrollSettings.maxBlocks;\n    }\n\n    var pageSize = this.parent.pageSettings.pageSize * this.parent.infiniteScrollSettings.initialBlocks;\n    query.page(1, pageSize);\n  };\n\n  InfiniteScroll.prototype.infiniteCellFocus = function (e) {\n    if (e.byKey && (e.keyArgs.action === 'upArrow' || e.keyArgs.action === 'downArrow')) {\n      this.pressedKey = e.keyArgs.action;\n      var ele = document.activeElement;\n      var rowIndex = parseInt(ele.parentElement.getAttribute('aria-rowindex'), 10);\n      var scrollEle = this.parent.getContent().firstElementChild;\n      this.rowIndex = e.keyArgs.action === 'downArrow' ? rowIndex + 1 : rowIndex - 1;\n      this.cellIndex = parseInt(ele.getAttribute('aria-colindex'), 10);\n      var row = this.parent.getRowByIndex(rowIndex);\n      var visibleRowCount = Math.floor(scrollEle.offsetHeight / this.parent.getRowHeight());\n\n      if (!row || ensureLastRow(row, this.parent) || ensureFirstRow(row, this.rowTop)) {\n        var height = row ? row.getBoundingClientRect().height : this.parent.getRowHeight();\n\n        if (!this.parent.infiniteScrollSettings.enableCache) {\n          if (e.keyArgs.action === 'downArrow' && (ensureLastRow(row, this.parent) || !row)) {\n            var nTop = (this.rowIndex - visibleRowCount) * height;\n            var oTop = scrollEle.scrollTop + this.parent.getRowHeight();\n            scrollEle.scrollTop = nTop < oTop ? oTop : nTop;\n          }\n\n          if (e.keyArgs.action === 'upArrow' && ensureFirstRow(row, this.rowTop)) {\n            scrollEle.scrollTop = this.rowIndex * height;\n          }\n        }\n      } else {\n        this.pressedKey = this.empty;\n      }\n    } else if (e.key === 'PageDown' || e.key === 'PageUp') {\n      this.pressedKey = e.key;\n    }\n  };\n\n  InfiniteScroll.prototype.createEmptyRowdata = function () {\n    var _this = this;\n\n    this.parent.getColumns().filter(function (e) {\n      _this.emptyRowData[e.field] = _this.empty;\n    });\n  };\n\n  InfiniteScroll.prototype.getVirtualInfiniteEditedData = function () {\n    var editForm = this.parent.element.querySelector('.e-editedrow');\n    var addForm = this.parent.element.querySelector('.e-addedrow');\n    var gridForm = this.parent.element.querySelector('.e-gridform');\n\n    if (this.parent.infiniteScrollSettings.enableCache && (editForm || addForm)) {\n      var rowData = editForm ? extend({}, this.getEditedRowObject().data) : extend({}, this.emptyRowData);\n      this.virtualInfiniteData = this.parent.editModule.getCurrentEditedData(gridForm, rowData);\n\n      if (this.parent.getFrozenColumns()) {\n        this.virtualInfiniteData = this.parent.editModule.getCurrentEditedData(this.parent.getMovableVirtualContent().querySelector('.e-gridform'), rowData);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.restoreInfiniteEdit = function () {\n    var content = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.parent.getContent().firstElementChild;\n    var frozenEdit = this.parent.frozenRows ? this.editRowIndex >= this.parent.frozenRows : true;\n\n    if (this.isNormaledit && this.parent.infiniteScrollSettings.enableCache && frozenEdit) {\n      if (this.parent.editSettings.allowEditing && !isNullOrUndefined(this.editRowIndex)) {\n        var row = this.parent.getRowByIndex(this.editRowIndex);\n\n        if (Object.keys(this.virtualInfiniteData).length && row && !this.parent.getContent().querySelector('.e-editedrow')) {\n          var top_1 = row.getBoundingClientRect().top;\n\n          if (top_1 < content.offsetHeight && top_1 > this.parent.getRowHeight()) {\n            this.parent.isEdit = false;\n            this.parent.editModule.startEdit(row);\n          }\n        }\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.restoreInfiniteAdd = function () {\n    var content = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.parent.getContent().firstElementChild;\n\n    if (this.parent.getRowByIndex(0) && this.isNormaledit && this.parent.infiniteScrollSettings.enableCache && this.isAdd && !content.querySelector('.e-addedrow')) {\n      var isTop = content.scrollTop < this.parent.getRowHeight();\n\n      if (isTop) {\n        this.parent.isEdit = false;\n        this.parent.addRecord();\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.appendInfiniteRows = function (e) {\n    var target = document.activeElement;\n    var frozenCols = this.parent.getFrozenColumns();\n    var scrollEle = frozenCols ? this.parent.getMovableVirtualContent() : this.parent.getContent().firstElementChild;\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && e.args.requestType === 'infiniteScroll';\n\n    if (isInfiniteScroll && !e.args.isFrozen || !isInfiniteScroll) {\n      if (isInfiniteScroll && e.args.direction === 'up') {\n        e.tbody.insertBefore(e.frag, e.tbody.firstElementChild);\n      } else {\n        e.tbody.appendChild(e.frag);\n      }\n    }\n\n    if (!frozenCols) {\n      this.parent.contentModule.getTable().appendChild(e.tbody);\n    } else {\n      if (isInfiniteScroll) {\n        if (e.args.isFrozen) {\n          this.frozenFrag = e.frag;\n        } else {\n          var tbody = this.parent.getFrozenVirtualContent().querySelector('tbody');\n          e.args.direction === 'up' ? tbody.insertBefore(this.frozenFrag, tbody.firstElementChild) : tbody.appendChild(this.frozenFrag);\n          this.parent.getMovableVirtualContent().querySelector('.e-table').appendChild(e.tbody);\n        }\n      } else {\n        var table = e.args.isFrozen ? this.parent.getFrozenVirtualContent().querySelector('.e-table') : this.parent.getMovableVirtualContent().querySelector('.e-table');\n        table.appendChild(e.tbody);\n      }\n    }\n\n    if (!e.args.isFrozen) {\n      this.rowTop = !this.rowTop ? this.parent.getRows()[0].getBoundingClientRect().top : this.rowTop;\n\n      if (isInfiniteScroll) {\n        if (this.parent.infiniteScrollSettings.enableCache && this.isRemove) {\n          scrollEle.scrollTop = this.top;\n\n          if (frozenCols) {\n            this.parent.getFrozenVirtualContent().scrollTop = this.top;\n          }\n        }\n\n        this.setRowElements();\n        this.selectNewRow(e.tbody, e.args.startIndex);\n        this.pressedKey = undefined;\n      }\n\n      this.restoreInfiniteAdd();\n    }\n\n    this.isInfiniteScroll = false;\n  };\n\n  InfiniteScroll.prototype.setRowElements = function () {\n    if (this.parent.getFrozenColumns()) {\n      this.parent.contentModule.rowElements = [].slice.call(this.parent.element.querySelectorAll('.e-movableheader .e-row, .e-movablecontent .e-row'));\n      this.parent.contentModule.freezeRowElements = [].slice.call(this.parent.element.querySelectorAll('.e-frozenheader .e-row, .e-frozencontent .e-row'));\n    } else {\n      this.parent.contentModule.rowElements = [].slice.call(this.parent.element.querySelectorAll('.e-row:not(.e-addedrow)'));\n    }\n  };\n\n  InfiniteScroll.prototype.selectNewRow = function (tbody, startIndex) {\n    var _this = this;\n\n    var row = this.parent.getRowByIndex(this.rowIndex);\n\n    if (this.keys.some(function (value) {\n      return value === _this.pressedKey;\n    })) {\n      if (this.pressedKey === 'downArrow' || this.parent.infiniteScrollSettings.enableCache && this.pressedKey === 'upArrow') {\n        setTimeout(function () {\n          // tslint:disable-next-line:no-any\n          var target = row.cells[0];\n          target.focus({\n            preventScroll: true\n          });\n\n          _this.parent.selectRow(_this.rowIndex);\n\n          _this.parent.getContent().firstElementChild.scrollTop += _this.parent.getRowHeight();\n        }, 0);\n      }\n\n      if (this.pressedKey === 'PageDown') {\n        var row_1 = this.parent.getRowByIndex(startIndex);\n\n        if (row_1) {\n          row_1.cells[0].focus();\n        }\n      }\n\n      if (this.pressedKey === 'PageUp') {\n        tbody.querySelector('.e-row').cells[0].focus();\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.removeInfiniteCacheRows = function (e) {\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && e.args.requestType === 'infiniteScroll';\n\n    if (!e.args.isFrozen && isInfiniteScroll && this.parent.infiniteScrollSettings.enableCache && this.isRemove) {\n      var rows = [].slice.call(this.parent.getContentTable().querySelectorAll('.e-row'));\n\n      if (e.args.direction === 'down') {\n        if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n          var captionRows = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));\n          this.removeCaptionRows(captionRows, e.args);\n        }\n\n        var addRowCount = this.parent.element.querySelector('.e-addedrow') ? 0 : 1;\n        this.removeTopRows(rows, this.parent.pageSettings.pageSize - addRowCount);\n      }\n\n      if (e.args.direction === 'up') {\n        if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n          var captionRows = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));\n          this.removeCaptionRows(captionRows, e.args);\n        } else {\n          this.removeBottomRows(rows, rows.length - 1, e.args);\n        }\n      }\n\n      this.isScroll = false;\n      this.top = this.calculateScrollTop(e.args);\n    }\n  };\n\n  InfiniteScroll.prototype.calculateScrollTop = function (args) {\n    var top = 0;\n    var scrollCnt = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.parent.getContent().firstElementChild;\n\n    if (args.direction === 'down') {\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && !this.isInitialCollapse) {\n        top = this.captionRowHeight();\n      }\n\n      var captionRows = [].slice.call(this.parent.getContent().firstElementChild.querySelectorAll('tr:not(.e-row)'));\n      var captionCount = 0;\n\n      if (this.isInitialCollapse && !isNullOrUndefined(captionRows)) {\n        captionCount = Math.round((captionRows.length - 1) / this.parent.groupSettings.columns.length);\n      }\n\n      var value = captionCount ? captionCount : this.parent.pageSettings.pageSize * (this.parent.infiniteScrollSettings.maxBlocks - 1);\n      var currentViewRowCount = 0;\n      var i = 0;\n\n      while (currentViewRowCount < scrollCnt.clientHeight) {\n        i++;\n        currentViewRowCount = i * this.parent.getRowHeight();\n      }\n\n      i = i - 1;\n      top += (value - i) * this.parent.getRowHeight();\n    }\n\n    if (args.direction === 'up') {\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length && !this.isInitialCollapse) {\n        top = this.infiniteCache[this.parent.pageSettings.currentPage].length * this.parent.getRowHeight();\n      } else if (this.isInitialCollapse) {\n        var groupedData = this.infiniteCache[this.parent.pageSettings.currentPage];\n        var count = 0;\n\n        for (var i = 0; i < groupedData.length; i++) {\n          if (groupedData[i].isCaptionRow) {\n            count++;\n          }\n        }\n\n        top += Math.round(count / this.parent.groupSettings.columns.length) * this.parent.getRowHeight();\n      } else {\n        top += this.parent.pageSettings.pageSize * this.parent.getRowHeight() + getScrollBarWidth();\n      }\n    }\n\n    return top;\n  };\n\n  InfiniteScroll.prototype.captionRowHeight = function () {\n    var rows = [].slice.call(this.parent.getContent().querySelectorAll('tr:not(.e-row)'));\n    return rows.length * this.parent.getRowHeight();\n  };\n\n  InfiniteScroll.prototype.removeTopRows = function (rows, maxIndx) {\n    var frozeCols = this.parent.getFrozenColumns();\n    var movableRows = frozeCols ? [].slice.call(this.parent.getMovableVirtualContent().querySelectorAll('.e-row')) : null;\n\n    for (var i = 0; i <= maxIndx; i++) {\n      if (this.parent.frozenRows && this.parent.pageSettings.currentPage === this.parent.infiniteScrollSettings.maxBlocks + 1 && i > maxIndx - this.parent.frozenRows) {\n        continue;\n      }\n\n      remove(rows[i]);\n\n      if (movableRows) {\n        remove(movableRows[i]);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.removeBottomRows = function (rows, maxIndx, args) {\n    var cnt = 0;\n    var frozeCols = this.parent.getFrozenColumns();\n    var movableRows = frozeCols ? [].slice.call(this.parent.getMovableVirtualContent().querySelectorAll('.e-row')) : null;\n    var pageSize = this.parent.pageSettings.pageSize;\n\n    if (!frozeCols && this.infiniteCache[args.prevPage].length < pageSize) {\n      cnt = this.parent.pageSettings.pageSize - this.infiniteCache[args.prevPage].length;\n    }\n\n    if (frozeCols && this.infiniteFrozenCache[args.prevPage][1].length < pageSize) {\n      cnt = this.parent.pageSettings.pageSize - this.infiniteFrozenCache[args.prevPage][1].length;\n    }\n\n    for (var i = maxIndx; cnt < pageSize; i--) {\n      cnt++;\n      remove(rows[i]);\n\n      if (movableRows) {\n        remove(movableRows[i]);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.removeCaptionRows = function (rows, args) {\n    if (args.direction === 'down') {\n      var lastRow = this.parent.getRows()[this.parent.pageSettings.pageSize];\n      var lastRowIndex = parseInt(lastRow.getAttribute('aria-rowindex'), 10) - 1;\n      var k = 0;\n\n      for (var i = 0; k < lastRowIndex; i++) {\n        if (!rows[i].classList.contains('e-row')) {\n          remove(rows[i]);\n        } else {\n          k = parseInt(rows[i].getAttribute('aria-rowindex'), 10);\n        }\n      }\n    }\n\n    if (args.direction === 'up') {\n      var rowElements = [].slice.call(this.parent.getContent().querySelectorAll('.e-row'));\n      var lastIndex = parseInt(rowElements[rowElements.length - 1].getAttribute('aria-rowindex'), 10);\n      var page = Math.ceil(lastIndex / this.parent.pageSettings.pageSize);\n      var startIndex = 0;\n\n      for (var i = this.parent.pageSettings.currentPage + 1; i < page; i++) {\n        startIndex += this.infiniteCache[i].length;\n      }\n\n      for (var i = startIndex; i < rows.length; i++) {\n        remove(rows[i]);\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.resetInfiniteBlocks = function (args, isDataModified) {\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && args.requestType !== 'infiniteScroll';\n\n    if (!this.initialRender && !isNullOrUndefined(this.parent.infiniteScrollModule) && isInfiniteScroll) {\n      if (this.actions.some(function (value) {\n        return value === args.requestType;\n      }) || isDataModified) {\n        var scrollEle = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.parent.getContent().firstElementChild;\n        this.initialRender = true;\n        scrollEle.scrollTop = 0;\n        this.parent.pageSettings.currentPage = 1;\n        this.infiniteCache = this.infiniteFrozenCache = {};\n        this.resetContentModuleCache({});\n        this.isRemove = false;\n        this.top = 0;\n        this.isInitialMovableRender = true;\n        this.isInitialCollapse = false;\n        this.parent.contentModule.isRemove = this.isRemove;\n        this.parent.contentModule.isAddRows = this.isRemove;\n        this.parent.contentModule.visibleRows = [];\n        this.parent.contentModule.visibleFrozenRows = [];\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.setCache = function (e) {\n    if (this.parent.enableInfiniteScrolling && this.parent.infiniteScrollSettings.enableCache) {\n      var frozeCols = this.parent.getFrozenColumns();\n      var idx = e.args.isFrozen ? 1 : 0;\n      var isEdit = e.args.requestType !== 'infiniteScroll' && (this.requestType === 'delete' || this.requestType === 'add');\n      var currentPage = this.parent.pageSettings.currentPage;\n\n      if (frozeCols && this.isInitialMovableRender || !frozeCols && !Object.keys(this.infiniteCache).length || isEdit) {\n        this.isInitialMovableRender = !e.args.isFrozen;\n        this.setInitialCache(e.modelData, e.args, isEdit);\n      }\n\n      if (!frozeCols && isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage])) {\n        this.infiniteCache[this.parent.pageSettings.currentPage] = e.modelData;\n        this.resetContentModuleCache(this.infiniteCache);\n      }\n\n      if (frozeCols) {\n        if (idx === 0 && isNullOrUndefined(this.infiniteFrozenCache[currentPage]) || !this.infiniteFrozenCache[currentPage][idx].length) {\n          this.createFrozenCache(currentPage);\n          this.infiniteFrozenCache[currentPage][idx] = e.modelData;\n\n          if (idx === 1) {\n            this.resetContentModuleCache(this.infiniteFrozenCache);\n          }\n        }\n      }\n\n      if (e.isInfiniteScroll && !this.isRemove) {\n        this.isRemove = (currentPage - 1) % this.parent.infiniteScrollSettings.maxBlocks === 0;\n        this.parent.contentModule.isRemove = this.isRemove;\n      }\n    }\n  };\n\n  InfiniteScroll.prototype.setInitialCache = function (data, args, isEdit) {\n    var frozenCols = this.parent.getFrozenColumns();\n    var idx = args.isFrozen ? 1 : 0;\n    var k = !isEdit ? 1 : this.firstBlock;\n\n    for (var i = 1; i <= this.parent.infiniteScrollSettings.initialBlocks; i++) {\n      var startIndex = (i - 1) * this.parent.pageSettings.pageSize;\n      var endIndex = i * this.parent.pageSettings.pageSize;\n\n      if (this.parent.allowGrouping && this.parent.groupSettings.columns.length) {\n        this.setInitialGroupCache(data, k, startIndex, endIndex);\n      } else {\n        if (frozenCols) {\n          this.createFrozenCache(k);\n          this.infiniteFrozenCache[k][idx] = data.slice(startIndex, endIndex);\n          this.resetContentModuleCache(this.infiniteFrozenCache);\n        } else {\n          this.infiniteCache[k] = data.slice(startIndex, endIndex);\n          this.resetContentModuleCache(this.infiniteCache);\n        }\n      }\n\n      k++;\n    }\n  };\n\n  InfiniteScroll.prototype.createFrozenCache = function (index) {\n    if (!this.infiniteFrozenCache[index]) {\n      this.infiniteFrozenCache[index] = [[], []];\n    }\n  };\n\n  InfiniteScroll.prototype.setInitialGroupCache = function (data, index, sIndex, eIndex) {\n    var pageData = [];\n    var startIndex = 0;\n\n    for (var i = 1; i <= Object.keys(this.infiniteCache).length; i++) {\n      startIndex += this.infiniteCache[i].length;\n    }\n\n    var k = sIndex;\n\n    for (var i = startIndex; i < data.length && k < eIndex; i++) {\n      if (data[i].index < eIndex || data[i].isCaptionRow) {\n        k = data[i].isCaptionRow ? k : data[i].index;\n        pageData.push(data[i]);\n      }\n\n      if (data[i].index >= eIndex || data[i].index === eIndex - 1) {\n        break;\n      }\n    }\n\n    this.infiniteCache[index] = pageData;\n    this.resetContentModuleCache(this.infiniteCache);\n  };\n\n  InfiniteScroll.prototype.resetContentModuleCache = function (data) {\n    this.parent.contentModule.infiniteCache = data;\n  };\n  /**\n   * @hidden\n   */\n\n\n  InfiniteScroll.prototype.destroy = function () {\n    this.removeEventListener();\n  };\n\n  return InfiniteScroll;\n}();\n\nexport { InfiniteScroll };","map":null,"metadata":{},"sourceType":"module"}