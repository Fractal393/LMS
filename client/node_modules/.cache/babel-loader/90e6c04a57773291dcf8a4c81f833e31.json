{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { remove, createElement, closest, formatUnit, Browser, extend } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined, removeClass } from '@syncfusion/ej2-base';\nimport { DataManager } from '@syncfusion/ej2-data';\nimport { dataReady, modelChanged, refreshVirtualBlock, contentReady } from '../base/constant';\nimport * as events from '../base/constant';\nimport { RenderType } from '../base/enum';\nimport { ContentRender } from './content-renderer';\nimport { HeaderRender } from './header-renderer';\nimport { InterSectionObserver } from '../services/intersection-observer';\nimport { VirtualRowModelGenerator } from '../services/virtual-row-model-generator';\nimport { isGroupAdaptive, getTransformValues, ensureLastRow, ensureFirstRow, getEditedDataIndex, getScrollBarWidth } from '../base/util';\nimport { isBlazor, setStyleAttribute } from '@syncfusion/ej2-base';\n/**\n * VirtualContentRenderer\n * @hidden\n */\n\nvar VirtualContentRenderer =\n/** @class */\nfunction (_super) {\n  __extends(VirtualContentRenderer, _super);\n\n  function VirtualContentRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.prevHeight = 0;\n    /** @hidden */\n\n    _this.startIndex = 0;\n    _this.preStartIndex = 0;\n    _this.preventEvent = false;\n    _this.actions = ['filtering', 'searching', 'grouping', 'ungrouping'];\n    _this.offsets = {};\n    _this.tmpOffsets = {};\n    /** @hidden */\n\n    _this.virtualEle = new VirtualElementHandler();\n    _this.offsetKeys = [];\n    _this.isFocused = false;\n    _this.isSelection = false;\n    _this.isBottom = false;\n    _this.rndrCount = 0;\n    _this.empty = undefined;\n    _this.isCancel = false;\n    _this.requestTypes = ['beginEdit', 'cancel', 'delete', 'add', 'save'];\n    _this.isNormaledit = _this.parent.editSettings.mode === 'Normal';\n    _this.virtualData = {};\n    _this.emptyRowData = {};\n    _this.vfColIndex = [];\n    _this.locator = locator;\n\n    _this.eventListener('on');\n\n    _this.parent.on(events.columnVisibilityChanged, _this.setVisible, _this);\n\n    _this.vgenerator = _this.generator;\n    return _this;\n  }\n\n  VirtualContentRenderer.prototype.renderTable = function () {\n    this.header = this.locator.getService('rendererFactory').getRenderer(RenderType.Header);\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualEle.table = this.getTable();\n    this.virtualEle.content = this.content = this.getPanel().querySelector('.e-content');\n    var minHeight = this.parent.height;\n\n    if (this.parent.getFrozenColumns() && this.parent.height.toString().indexOf('%') < 0) {\n      minHeight = parseInt(this.parent.height, 10) - getScrollBarWidth();\n    }\n\n    this.virtualEle.renderWrapper(minHeight);\n    this.virtualEle.renderPlaceHolder();\n\n    if (!this.parent.getFrozenColumns()) {\n      this.virtualEle.wrapper.style.position = 'absolute';\n    }\n\n    var debounceEvent = this.parent.dataSource instanceof DataManager && !this.parent.dataSource.dataSource.offline;\n    var content = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.content;\n    var opt = {\n      container: content,\n      pageHeight: this.getBlockHeight() * 2,\n      debounceEvent: debounceEvent,\n      axes: this.parent.enableColumnVirtualization ? ['X', 'Y'] : ['Y']\n    };\n    this.observer = new InterSectionObserver(this.virtualEle.wrapper, opt);\n  };\n\n  VirtualContentRenderer.prototype.renderEmpty = function (tbody) {\n    this.getTable().appendChild(tbody);\n    this.virtualEle.adjustTable(0, 0);\n  };\n\n  VirtualContentRenderer.prototype.refreshMvTbalTransform = function () {\n    var mCont = this.parent.getMovableVirtualContent();\n    var fCont = this.parent.getFrozenVirtualContent();\n    var mContTV = getTransformValues(mCont.firstElementChild);\n    var fContTV = getTransformValues(fCont.firstElementChild);\n    var top = mCont.scrollTop;\n\n    if (top > 0 && mContTV.height !== fContTV.height) {\n      mCont.firstElementChild.style.transform = \"translate(\" + mContTV.width + \"px, \" + fContTV.height + \"px)\";\n    }\n  };\n\n  VirtualContentRenderer.prototype.scrollListener = function (scrollArgs) {\n    this.scrollAfterEdit();\n\n    if (this.parent.enablePersistence) {\n      this.parent.scrollPosition = scrollArgs.offset;\n    }\n\n    if (this.preventEvent || this.parent.isDestroyed) {\n      this.preventEvent = false;\n      return;\n    }\n\n    if (isNullOrUndefined(document.activeElement)) {\n      this.isFocused = false;\n    } else {\n      this.isFocused = this.content === closest(document.activeElement, '.e-content') || this.content === document.activeElement;\n    }\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && scrollArgs.sentinel.axis === 'X') {\n      this.refreshMvTbalTransform();\n    }\n\n    var info = scrollArgs.sentinel;\n    var pStartIndex = this.preStartIndex;\n    var previousColIndexes = this.parent.getColumnIndexesInView();\n    var viewInfo = this.currentInfo = this.getInfoFromView(scrollArgs.direction, info, scrollArgs.offset);\n\n    if (isBlazor() && this.parent.isServerRendered && this.parent.enableColumnVirtualization && JSON.stringify(previousColIndexes) !== JSON.stringify(viewInfo.columnIndexes)) {\n      this.parent.refreshHeader();\n      var translateX = this.getColumnOffset(this.startColIndex - 1);\n      var width = this.getColumnOffset(this.endColIndex - 1) - translateX + '';\n      this.parent.notify('refresh-virtual-indices', {\n        requestType: 'virtualscroll',\n        startColumnIndex: viewInfo.columnIndexes[0],\n        endColumnIndex: viewInfo.columnIndexes[viewInfo.columnIndexes.length - 1],\n        axis: 'X',\n        VTablewidth: width,\n        translateX: this.getColumnOffset(viewInfo.columnIndexes[0] - 1)\n      });\n      this.parent.notify('setcolumnstyles', {});\n    }\n\n    if (isGroupAdaptive(this.parent) && !isBlazor()) {\n      if (info.axis === 'Y' && viewInfo.blockIndexes && this.prevInfo.blockIndexes.toString() === viewInfo.blockIndexes.toString() && scrollArgs.direction === 'up' && viewInfo.blockIndexes[viewInfo.blockIndexes.length - 1] !== 2) {\n        return;\n      } else {\n        viewInfo.event = 'refresh-virtual-block';\n\n        if (!isNullOrUndefined(viewInfo.offsets)) {\n          viewInfo.offsets.top = this.content.scrollTop;\n        }\n\n        this.parent.notify(viewInfo.event, {\n          requestType: 'virtualscroll',\n          virtualInfo: viewInfo,\n          focusElement: scrollArgs.focusElement\n        });\n        return;\n      }\n    }\n\n    if (!isBlazor() || isBlazor() && !this.parent.isServerRendered) {\n      if (this.prevInfo && (info.axis === 'Y' && this.prevInfo.blockIndexes.toString() === viewInfo.blockIndexes.toString() || info.axis === 'X' && this.prevInfo.columnIndexes.toString() === viewInfo.columnIndexes.toString())) {\n        if (Browser.isIE) {\n          this.parent.hideSpinner();\n        }\n\n        this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n        this.restoreEdit();\n        return;\n      }\n    }\n\n    this.parent.setColumnIndexesInView(this.parent.enableColumnVirtualization ? viewInfo.columnIndexes : []);\n\n    if (!isBlazor() || isBlazor() && !this.parent.isServerRendered) {\n      this.parent.pageSettings.currentPage = viewInfo.loadNext && !viewInfo.loadSelf ? viewInfo.nextInfo.page : viewInfo.page;\n    } else if (isBlazor() && this.parent.isServerRendered && this.preStartIndex !== pStartIndex && this.parent.pageSettings.currentPage === viewInfo.currentPage) {\n      this.parent.notify('refresh-virtual-indices', {\n        requestType: 'virtualscroll',\n        virtualStartIndex: viewInfo.startIndex,\n        virtualEndIndex: viewInfo.endIndex,\n        axis: 'Y',\n        RHeight: this.parent.getRowHeight()\n      });\n    }\n\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization) {\n      var lastPage = Math.ceil(this.getTotalBlocks() / 2);\n\n      if (this.parent.pageSettings.currentPage === lastPage && scrollArgs.sentinel.axis === 'Y') {\n        this.rndrCount++;\n      }\n\n      if (scrollArgs.sentinel.axis === 'Y') {\n        if (this.parent.pageSettings.currentPage === lastPage && this.rndrCount > 1) {\n          this.rndrCount = 0;\n          return;\n        } else if (this.parent.pageSettings.currentPage !== lastPage && this.parent.pageSettings.currentPage !== lastPage - 1) {\n          this.rndrCount = 0;\n        }\n      }\n    }\n\n    if (!isBlazor() || isBlazor() && !this.parent.isServerRendered) {\n      this.requestType = 'virtualscroll';\n      this.parent.notify(viewInfo.event, {\n        requestType: 'virtualscroll',\n        virtualInfo: viewInfo,\n        focusElement: scrollArgs.focusElement\n      });\n    } else if (this.preStartIndex !== pStartIndex && this.parent.pageSettings.currentPage !== viewInfo.currentPage) {\n      this.parent.pageSettings.currentPage = viewInfo.currentPage;\n      this.parent.notify(viewInfo.event, {\n        requestType: 'virtualscroll',\n        virtualStartIndex: viewInfo.startIndex,\n        virtualEndIndex: viewInfo.endIndex,\n        axis: 'Y',\n        RHeight: this.parent.getRowHeight()\n      });\n    }\n  };\n\n  VirtualContentRenderer.prototype.block = function (blk) {\n    return this.vgenerator.isBlockAvailable(blk);\n  };\n\n  VirtualContentRenderer.prototype.getInfoFromView = function (direction, info, e) {\n    var isBlockAdded = false;\n    var tempBlocks = [];\n    var infoType = {\n      direction: direction,\n      sentinelInfo: info,\n      offsets: e,\n      startIndex: this.preStartIndex,\n      endIndex: this.preEndIndex\n    };\n    var vHeight = this.parent.height.toString().indexOf('%') < 0 ? this.content.getBoundingClientRect().height : this.parent.element.getBoundingClientRect().height;\n    infoType.page = this.getPageFromTop(e.top, infoType);\n    infoType.blockIndexes = tempBlocks = this.vgenerator.getBlockIndexes(infoType.page);\n    infoType.loadSelf = !this.vgenerator.isBlockAvailable(tempBlocks[infoType.block]);\n    var blocks = this.ensureBlocks(infoType);\n\n    if (this.activeKey === 'upArrow' && infoType.blockIndexes.toString() !== blocks.toString()) {\n      // To avoid dupilcate row index problem in key focus support\n      var newBlock = blocks[blocks.length - 1];\n\n      if (infoType.blockIndexes.indexOf(newBlock) === -1) {\n        isBlockAdded = true;\n      }\n    }\n\n    infoType.blockIndexes = blocks;\n    infoType.loadNext = !blocks.filter(function (val) {\n      return tempBlocks.indexOf(val) === -1;\n    }).every(this.block.bind(this));\n    infoType.event = infoType.loadNext || infoType.loadSelf ? modelChanged : refreshVirtualBlock;\n    infoType.nextInfo = infoType.loadNext ? {\n      page: Math.max(1, infoType.page + (direction === 'down' ? 1 : -1))\n    } : {};\n\n    if (isBlockAdded) {\n      infoType.blockIndexes = [infoType.blockIndexes[0] - 1, infoType.blockIndexes[0], infoType.blockIndexes[0] + 1];\n    }\n\n    if (this.activeKey === 'downArrow') {\n      var firstBlock = Math.ceil(this.rowIndex / this.getBlockSize());\n\n      if (firstBlock !== 1 && (infoType.blockIndexes[1] !== firstBlock || infoType.blockIndexes.length < 3)) {\n        infoType.blockIndexes = [firstBlock - 1, firstBlock, firstBlock + 1];\n      }\n    }\n\n    infoType.columnIndexes = info.axis === 'X' ? this.vgenerator.getColumnIndexes() : this.parent.getColumnIndexesInView();\n\n    if (this.parent.enableColumnVirtualization && info.axis === 'X') {\n      infoType.event = refreshVirtualBlock;\n    }\n\n    if (isBlazor() && this.parent.isServerRendered) {\n      var rowHeight = this.parent.getRowHeight();\n      var exactTopIndex = e.top / rowHeight;\n      var noOfInViewIndexes = vHeight / rowHeight;\n      var exactEndIndex = exactTopIndex + noOfInViewIndexes;\n      var pageSizeBy4 = this.parent.pageSettings.pageSize / 4;\n\n      if (infoType.direction === 'down') {\n        var sIndex = Math.round(exactEndIndex) - Math.round(pageSizeBy4);\n\n        if (isNullOrUndefined(infoType.startIndex) || exactEndIndex > infoType.startIndex + Math.round(this.parent.pageSettings.pageSize / 2 + pageSizeBy4) && infoType.endIndex !== this.count) {\n          infoType.startIndex = sIndex >= 0 ? Math.round(sIndex) : 0;\n          infoType.startIndex = infoType.startIndex > exactTopIndex ? Math.floor(exactTopIndex) : infoType.startIndex;\n          var eIndex = infoType.startIndex + this.parent.pageSettings.pageSize;\n          infoType.startIndex = eIndex < exactEndIndex ? Math.ceil(exactEndIndex) - this.parent.pageSettings.pageSize : infoType.startIndex;\n          infoType.endIndex = eIndex < this.count ? eIndex : this.count;\n          infoType.startIndex = eIndex >= this.count ? infoType.endIndex - this.parent.pageSettings.pageSize : infoType.startIndex;\n          infoType.currentPage = Math.ceil(infoType.endIndex / this.parent.pageSettings.pageSize);\n          this.setKeyboardNavIndex();\n        }\n      } else if (infoType.direction === 'up') {\n        if (infoType.startIndex && infoType.endIndex) {\n          var loadAtIndex = Math.round((infoType.startIndex * rowHeight + pageSizeBy4 * rowHeight) / rowHeight);\n\n          if (exactTopIndex < loadAtIndex) {\n            var idxAddedToExactTop = pageSizeBy4 > noOfInViewIndexes ? pageSizeBy4 : noOfInViewIndexes + noOfInViewIndexes / 4;\n            var eIndex = Math.round(exactTopIndex + idxAddedToExactTop);\n            infoType.endIndex = eIndex < this.count ? eIndex : this.count;\n            var sIndex = infoType.endIndex - this.parent.pageSettings.pageSize;\n            infoType.startIndex = sIndex > 0 ? sIndex : 0;\n            infoType.endIndex = sIndex < 0 ? this.parent.pageSettings.pageSize : infoType.endIndex;\n            infoType.currentPage = Math.ceil(infoType.startIndex / this.parent.pageSettings.pageSize);\n            this.setKeyboardNavIndex();\n          }\n        }\n      }\n\n      this.preStartIndex = this.startIndex = infoType.startIndex;\n      this.preEndIndex = infoType.endIndex;\n      infoType.event = infoType.currentPage !== this.parent.pageSettings.currentPage ? modelChanged : refreshVirtualBlock;\n    }\n\n    return infoType;\n  };\n\n  VirtualContentRenderer.prototype.setKeyboardNavIndex = function () {\n    this.blazorDataLoad = true;\n\n    if (this.activeKey === 'downArrow' || this.activeKey === 'upArrow') {\n      this.blzRowIndex = this.activeKey === 'downArrow' ? this.rowIndex + 1 : this.rowIndex - 1;\n      document.activeElement.blur();\n    }\n  };\n\n  VirtualContentRenderer.prototype.ensureBlocks = function (info) {\n    var _this = this;\n\n    var index = info.blockIndexes[info.block];\n    var mIdx;\n    var old = index;\n    var max = Math.max;\n    var indexes = info.direction === 'down' ? [max(index, 1), ++index, ++index] : [max(index - 1, 1), index, index + 1];\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns()) {\n      if (info.sentinelInfo.axis === 'X' || info.sentinelInfo.axis === 'Y' && info.page === this.prevInfo.page) {\n        indexes = this.prevInfo.blockIndexes;\n      }\n    }\n\n    indexes = indexes.filter(function (val, ind) {\n      return indexes.indexOf(val) === ind;\n    });\n\n    if (this.prevInfo.blockIndexes.toString() === indexes.toString()) {\n      return indexes;\n    }\n\n    if (info.loadSelf || info.direction === 'down' && this.isEndBlock(old)) {\n      indexes = this.vgenerator.getBlockIndexes(info.page);\n    }\n\n    indexes.some(function (val, ind) {\n      var result = val === (isGroupAdaptive(_this.parent) ? _this.getGroupedTotalBlocks() : _this.getTotalBlocks());\n\n      if (result) {\n        mIdx = ind;\n      }\n\n      return result;\n    });\n\n    if (mIdx !== undefined) {\n      indexes = indexes.slice(0, mIdx + 1);\n\n      if (info.block === 0 && indexes.length === 1 && this.vgenerator.isBlockAvailable(indexes[0] - 1)) {\n        indexes = [indexes[0] - 1, indexes[0]];\n      }\n    }\n\n    return indexes;\n  };\n  /**\n   * @hidden\n   */\n\n\n  VirtualContentRenderer.prototype.vfTblTransform = function (info, left, top, e, cOffset, translate) {\n    var lastPage = Math.ceil(this.getTotalBlocks() / 2);\n    var isLastPage = lastPage === this.parent.pageSettings.currentPage && this.parent.enableColumnVirtualization;\n    var wrappers = [].slice.call(this.parent.getContent().querySelectorAll('.e-virtualtable'));\n\n    for (var i = 0; i < wrappers.length; i++) {\n      if (i === 0 && e.requestType === 'virtualscroll' && info.sentinelInfo.axis === 'X') {\n        continue;\n      }\n\n      if (lastPage !== this.parent.pageSettings.currentPage && this.parent.enableColumnVirtualization && (left > 0 || top > 0 && left === 0)) {\n        continue;\n      }\n\n      var cOff = isLastPage && i === 0 ? 0 : cOffset;\n      this.virtualEle.wrapper = wrappers[i];\n      this.virtualEle.adjustTable(cOff, translate);\n    }\n  }; // tslint:disable-next-line:max-func-body-length\n\n\n  VirtualContentRenderer.prototype.appendContent = function (target, newChild, e) {\n    var _this = this; // currentInfo value will be used if there are multiple dom updates happened due to mousewheel\n\n\n    var colVFtable = this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() !== 0;\n    this.checkFirstBlockColIndexes(e);\n    var info = e.virtualInfo.sentinelInfo && e.virtualInfo.sentinelInfo.axis === 'Y' && this.currentInfo.page && this.currentInfo.page !== e.virtualInfo.page ? this.currentInfo : e.virtualInfo;\n    this.prevInfo = this.prevInfo || e.virtualInfo;\n    var cBlock = info.columnIndexes[0] - 1;\n\n    if (colVFtable && info.columnIndexes[0] === this.parent.getFrozenColumns()) {\n      cBlock = info.columnIndexes[0] - this.parent.getFrozenColumns() - 1;\n    }\n\n    var cOffset = this.getColumnOffset(cBlock);\n    var width;\n    var blocks = info.blockIndexes;\n\n    if (this.parent.groupSettings.columns.length) {\n      this.refreshOffsets();\n    }\n\n    if (this.parent.height === '100%') {\n      this.parent.element.style.height = '100%';\n    }\n\n    var vHeight = this.parent.height.toString().indexOf('%') < 0 ? this.content.getBoundingClientRect().height : this.parent.element.getBoundingClientRect().height;\n    var translate = 0;\n\n    if (this.parent.getFrozenColumns()) {\n      var mCont = this.parent.getMovableVirtualContent();\n      var left = mCont.scrollLeft;\n      var top_1 = mCont.scrollTop;\n      translate = this.getTranslateY(mCont.scrollTop, vHeight, info);\n      this.vfTblTransform(info, left, top_1, e, cOffset, translate);\n    } else {\n      if (!this.requestTypes.some(function (value) {\n        return value === _this.requestType;\n      })) {\n        translate = this.getTranslateY(this.content.scrollTop, vHeight, info);\n        this.virtualEle.adjustTable(cOffset, translate);\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization && !this.parent.getFrozenColumns()) {\n      this.header.virtualEle.adjustTable(cOffset, 0);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      var cIndex = info.columnIndexes;\n      width = this.getColumnOffset(cIndex[cIndex.length - 1]) - this.getColumnOffset(cIndex[0] - 1) + '';\n      this.header.virtualEle.setWrapperWidth(width);\n    }\n\n    this.virtualEle.setWrapperWidth(width, Browser.isIE || Browser.info.name === 'edge');\n\n    if (!isNullOrUndefined(target.parentNode)) {\n      remove(target);\n    }\n\n    var tbody;\n\n    if (this.parent.getFrozenColumns() && !e.renderMovableContent) {\n      tbody = this.parent.getFrozenVirtualContent().querySelector('tbody');\n    } else if (this.parent.getFrozenColumns() && e.renderMovableContent) {\n      tbody = this.parent.getMovableVirtualContent().querySelector('tbody');\n    } else {\n      tbody = this.parent.element.querySelector('.e-content').querySelector('tbody');\n    }\n\n    if (tbody) {\n      remove(tbody);\n      target = null;\n    }\n\n    target = this.parent.createElement('tbody');\n    target.appendChild(newChild);\n\n    if (this.parent.frozenRows && e.requestType === 'virtualscroll' && this.parent.pageSettings.currentPage === 1) {\n      for (var i = 0; i < this.parent.frozenRows; i++) {\n        target.children[0].remove();\n      }\n    }\n\n    if (this.parent.getFrozenColumns()) {\n      if (!e.renderMovableContent) {\n        this.parent.getFrozenVirtualContent().querySelector('.e-table').appendChild(target);\n      } else {\n        this.parent.getMovableVirtualContent().querySelector('.e-table').appendChild(target);\n        this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n      }\n\n      if (this.vfColIndex.length) {\n        e.virtualInfo.columnIndexes = info.columnIndexes = extend([], this.vfColIndex);\n        this.vfColIndex = e.renderMovableContent ? [] : this.vfColIndex;\n      }\n    } else {\n      this.getTable().appendChild(target);\n      this.requestType = this.requestType === 'virtualscroll' ? this.empty : this.requestType;\n    }\n\n    if (this.parent.groupSettings.columns.length) {\n      if (!isGroupAdaptive(this.parent) && info.direction === 'up') {\n        var blk = this.offsets[this.getTotalBlocks()] - this.prevHeight;\n        this.preventEvent = true;\n        var sTop = this.content.scrollTop;\n        this.content.scrollTop = sTop + blk;\n      }\n\n      this.setVirtualHeight();\n      this.observer.setPageHeight(this.getOffset(blocks[blocks.length - 1]) - this.getOffset(blocks[0] - 1));\n    }\n\n    this.prevInfo = info;\n\n    if (this.isFocused && this.activeKey !== 'downArrow' && this.activeKey !== 'upArrow') {\n      this.content.focus();\n    }\n\n    var lastPage = Math.ceil(this.getTotalBlocks() / 2);\n\n    if (this.isBottom) {\n      this.isBottom = false;\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 1];\n    }\n\n    if (this.parent.pageSettings.currentPage === lastPage && blocks.length === 1) {\n      this.isBottom = true;\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 2];\n    }\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && e.requestType === 'virtualscroll' && e.virtualInfo.sentinelInfo.axis === 'X') {\n      this.refreshMvTbalTransform();\n    }\n\n    if (e.requestType === 'virtualscroll' && e.virtualInfo.sentinelInfo.axis === 'X') {\n      this.parent.notify(events.autoCol, {});\n    }\n\n    this.focusCell(e);\n    this.restoreEdit();\n    this.restoreAdd();\n  };\n\n  VirtualContentRenderer.prototype.checkFirstBlockColIndexes = function (e) {\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && e.virtualInfo.columnIndexes[0] === 0) {\n      var indexes = [];\n\n      if (!e.renderMovableContent && e.virtualInfo.columnIndexes.length > this.parent.getFrozenColumns()) {\n        this.vfColIndex = e.virtualInfo.columnIndexes;\n\n        for (var i = 0; i < this.parent.getFrozenColumns(); i++) {\n          indexes.push(i);\n        }\n\n        e.virtualInfo.columnIndexes = indexes;\n      } else if (e.renderMovableContent) {\n        if (!this.vfColIndex.length) {\n          this.vfColIndex = extend([], e.virtualInfo.columnIndexes);\n        }\n\n        e.virtualInfo.columnIndexes = extend([], this.vfColIndex);\n        e.virtualInfo.columnIndexes.splice(0, this.parent.getFrozenColumns());\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.focusCell = function (e) {\n    if (this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow') {\n      return;\n    }\n\n    var row = this.parent.getRowByIndex(this.rowIndex); // tslint:disable-next-line:no-any\n\n    var cell = row.cells[this.cellIndex];\n    cell.focus({\n      preventScroll: true\n    });\n    this.parent.selectRow(parseInt(row.getAttribute('aria-rowindex'), 10));\n    this.activeKey = this.empty;\n  };\n\n  VirtualContentRenderer.prototype.restoreEdit = function () {\n    if (this.isNormaledit) {\n      if (this.parent.editSettings.allowEditing && this.parent.editModule && !isNullOrUndefined(this.editedRowIndex)) {\n        var row = this.getRowByIndex(this.editedRowIndex);\n\n        if (Object.keys(this.virtualData).length && row && !this.content.querySelector('.e-editedrow')) {\n          var top_2 = row.getBoundingClientRect().top;\n\n          if (top_2 < this.content.offsetHeight && top_2 > this.parent.getRowHeight()) {\n            this.parent.isEdit = false;\n            this.parent.editModule.startEdit(row);\n          }\n        }\n\n        if (row && this.content.querySelector('.e-editedrow') && !Object.keys(this.virtualData).length) {\n          var rowData = extend({}, this.getRowObjectByIndex(this.editedRowIndex));\n          this.virtualData = this.getVirtualEditedData(rowData);\n        }\n      }\n\n      this.restoreAdd();\n    }\n  };\n\n  VirtualContentRenderer.prototype.getVirtualEditedData = function (rowData) {\n    var editForm = this.content.querySelector('.e-gridform');\n    return this.parent.editModule.getCurrentEditedData(editForm, rowData);\n  };\n\n  VirtualContentRenderer.prototype.restoreAdd = function () {\n    if (this.isNormaledit && this.isAdd && !this.content.querySelector('.e-addedrow')) {\n      var isTop = this.parent.editSettings.newRowPosition === 'Top' && this.content.scrollTop < this.parent.getRowHeight();\n      var isBottom = this.parent.editSettings.newRowPosition === 'Bottom' && this.parent.pageSettings.currentPage === this.maxPage;\n\n      if (isTop || isBottom) {\n        this.parent.isEdit = false;\n        this.parent.addRecord();\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.onDataReady = function (e) {\n    if (!isNullOrUndefined(e.count)) {\n      this.count = e.count;\n      this.maxPage = Math.ceil(e.count / this.parent.pageSettings.pageSize);\n    }\n\n    this.vgenerator.checkAndResetCache(e.requestType);\n\n    if (['refresh', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', undefined].some(function (value) {\n      return e.requestType === value;\n    })) {\n      this.refreshOffsets();\n    }\n\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization) {\n      var hdrTbls = [].slice.call(this.parent.getHeaderContent().querySelectorAll('.e-table'));\n      this.header.virtualEle.table = hdrTbls[1];\n    }\n\n    this.setVirtualHeight();\n    this.resetScrollPosition(e.requestType);\n  };\n  /** @hidden */\n\n\n  VirtualContentRenderer.prototype.setVirtualHeight = function (height) {\n    var width = this.parent.enableColumnVirtualization ? this.getColumnOffset(this.parent.columns.length + this.parent.groupSettings.columns.length - 1) + 'px' : '100%';\n\n    if (this.parent.getFrozenColumns()) {\n      var virtualHeightTemp = this.parent.pageSettings.currentPage === 1 && Object.keys(this.offsets).length <= 2 ? this.offsets[1] : this.offsets[this.getTotalBlocks() - 2];\n      var scrollableElementHeight = this.parent.getMovableVirtualContent().clientHeight;\n      virtualHeightTemp = virtualHeightTemp > scrollableElementHeight ? virtualHeightTemp : 0;\n      var fTblWidth = this.parent.enableColumnVirtualization ? 'auto' : width;\n      this.virtualEle.placeholder = this.parent.getFrozenVirtualContent().querySelector('.e-virtualtrack'); // To overcome the white space issue in last page (instead of position absolute)\n\n      this.virtualEle.setVirtualHeight(virtualHeightTemp, fTblWidth);\n      this.virtualEle.placeholder = this.parent.getMovableVirtualContent().querySelector('.e-virtualtrack'); // To overcome the white space issue in last page (instead of position absolute)\n\n      this.virtualEle.setVirtualHeight(virtualHeightTemp, width);\n    } else {\n      var virtualHeight = isBlazor() && this.parent.isServerRendered && this.parent.groupSettings.columns.length && height ? height : this.offsets[isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks()];\n      this.virtualEle.setVirtualHeight(virtualHeight, width);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      this.header.virtualEle.setVirtualHeight(1, width);\n    }\n  };\n\n  VirtualContentRenderer.prototype.getPageFromTop = function (sTop, info) {\n    var _this = this;\n\n    var total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    var page = 0;\n    var extra = this.offsets[total] - this.prevHeight;\n    this.offsetKeys.some(function (offset) {\n      var iOffset = Number(offset);\n      var border = sTop <= _this.offsets[offset] || iOffset === total && sTop > _this.offsets[offset];\n\n      if (border) {\n        if (_this.offsetKeys.length % 2 !== 0 && iOffset.toString() === _this.offsetKeys[_this.offsetKeys.length - 2] && sTop <= _this.offsets[_this.offsetKeys.length - 1]) {\n          iOffset = iOffset + 1;\n        }\n\n        info.block = iOffset % 2 === 0 ? 1 : 0;\n        page = Math.max(1, Math.min(_this.vgenerator.getPage(iOffset), _this.maxPage));\n      }\n\n      return border;\n    });\n    return page;\n  };\n\n  VirtualContentRenderer.prototype.getTranslateY = function (sTop, cHeight, info, isOnenter) {\n    if (info === undefined) {\n      info = {\n        page: this.getPageFromTop(sTop, {})\n      };\n      info.blockIndexes = this.vgenerator.getBlockIndexes(info.page);\n    }\n\n    var block = (info.blockIndexes[0] || 1) - 1;\n    var translate = this.getOffset(block);\n    var endTranslate = this.getOffset(info.blockIndexes[info.blockIndexes.length - 1]);\n\n    if (isOnenter) {\n      info = this.prevInfo;\n    }\n\n    var result = translate > sTop ? this.getOffset(block - 1) : endTranslate < sTop + cHeight ? this.getOffset(block + 1) : translate;\n    var blockHeight = this.offsets[info.blockIndexes[info.blockIndexes.length - 1]] - this.tmpOffsets[info.blockIndexes[0]];\n\n    if (result + blockHeight > this.offsets[isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks()]) {\n      result -= result + blockHeight - this.offsets[this.getTotalBlocks()];\n    }\n\n    return result;\n  };\n\n  VirtualContentRenderer.prototype.getOffset = function (block) {\n    return Math.min(this.offsets[block] | 0, this.offsets[this.maxBlock] | 0);\n  };\n\n  VirtualContentRenderer.prototype.onEntered = function () {\n    var _this = this;\n\n    return function (element, current, direction, e, isWheel, check) {\n      if (Browser.isIE && !isWheel && check && !_this.preventEvent) {\n        _this.parent.showSpinner();\n      }\n\n      var xAxis = current.axis === 'X';\n      var top = _this.prevInfo.offsets ? _this.prevInfo.offsets.top : null;\n\n      var height = _this.content.getBoundingClientRect().height;\n\n      var x = _this.getColumnOffset(xAxis ? _this.vgenerator.getColumnIndexes()[0] - 1 : _this.prevInfo.columnIndexes[0] - 1);\n\n      var y = _this.getTranslateY(e.top, height, xAxis && top === e.top ? _this.prevInfo : undefined, true);\n\n      if (isBlazor() && _this.parent.isServerRendered && _this.currentInfo && _this.currentInfo.startIndex && xAxis) {\n        y = _this.currentInfo.startIndex * _this.parent.getRowHeight();\n      }\n\n      _this.virtualEle.adjustTable(x, Math.min(y, _this.offsets[_this.maxBlock]));\n\n      if (isBlazor() && _this.parent.isServerRendered && xAxis) {\n        _this.parent.notify('setcolumnstyles', {\n          refresh: true\n        });\n      }\n\n      if (_this.parent.getFrozenColumns() && !xAxis) {\n        var left = _this.parent.getMovableVirtualContent().scrollLeft;\n\n        if (_this.parent.enableColumnVirtualization && left > 0) {\n          var fvTable = _this.parent.getFrozenVirtualContent().querySelector('.e-virtualtable');\n\n          fvTable.style.transform = \"translate(\" + 0 + \"px, \" + Math.min(y, _this.offsets[_this.maxBlock]) + \"px)\";\n        } else {\n          var fvTable = _this.parent.getFrozenVirtualContent().querySelector('.e-virtualtable');\n\n          fvTable.style.transform = \"translate(\" + x + \"px, \" + Math.min(y, _this.offsets[_this.maxBlock]) + \"px)\";\n        }\n      }\n\n      if (_this.parent.enableColumnVirtualization && (!isBlazor() || isBlazor() && !_this.parent.isServerRendered)) {\n        _this.header.virtualEle.adjustTable(x, 0);\n      }\n    };\n  };\n\n  VirtualContentRenderer.prototype.dataBound = function () {\n    if (this.isSelection && this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow') {\n      this.parent.selectRow(this.selectedRowIndex);\n    } else if (!isBlazor()) {\n      this.activeKey = this.empty;\n    }\n  };\n\n  VirtualContentRenderer.prototype.rowSelected = function () {\n    this.isSelection = false;\n  };\n\n  VirtualContentRenderer.prototype.eventListener = function (action) {\n    var _this = this;\n\n    this.parent[action](dataReady, this.onDataReady, this);\n    this.parent.addEventListener(events.dataBound, this.dataBound.bind(this));\n    this.parent.addEventListener(events.actionBegin, this.actionBegin.bind(this));\n    this.parent.addEventListener(events.actionComplete, this.actionComplete.bind(this));\n    this.parent.addEventListener(events.rowSelected, this.rowSelected.bind(this));\n    this.parent[action](refreshVirtualBlock, this.refreshContentRows, this);\n    this.parent[action](events.selectVirtualRow, this.selectVirtualRow, this);\n    this.parent[action](events.virtaulCellFocus, this.virtualCellFocus, this);\n    this.parent[action](events.virtualScrollEditActionBegin, this.editActionBegin, this);\n    this.parent[action](events.virtualScrollAddActionBegin, this.addActionBegin, this);\n    this.parent[action](events.virtualScrollEdit, this.restoreEdit, this);\n    this.parent[action](events.virtualScrollEditSuccess, this.editSuccess, this);\n    this.parent[action](events.refreshVirtualCache, this.refreshCache, this);\n    this.parent[action](events.editReset, this.resetIsedit, this);\n    this.parent[action](events.getVirtualData, this.getVirtualData, this);\n    this.parent[action](events.virtualScrollEditCancel, this.editCancel, this);\n    var event = this.actions;\n\n    for (var i = 0; i < event.length; i++) {\n      this.parent[action](event[i] + \"-begin\", this.onActionBegin, this);\n    }\n\n    var fn = function () {\n      _this.observer.observe(function (scrollArgs) {\n        return _this.scrollListener(scrollArgs);\n      }, _this.onEntered());\n\n      var gObj = _this.parent;\n\n      if (gObj.enablePersistence && gObj.scrollPosition) {\n        _this.content.scrollTop = gObj.scrollPosition.top;\n        var scrollValues = {\n          direction: 'down',\n          sentinel: _this.observer.sentinelInfo.down,\n          offset: gObj.scrollPosition,\n          focusElement: gObj.element\n        };\n\n        _this.scrollListener(scrollValues);\n\n        if (gObj.enableColumnVirtualization) {\n          _this.content.scrollLeft = gObj.scrollPosition.left;\n        }\n      }\n\n      _this.parent.off(contentReady, fn);\n    };\n\n    this.parent.on(contentReady, fn, this);\n  };\n\n  VirtualContentRenderer.prototype.getVirtualData = function (data) {\n    data.virtualData = this.virtualData;\n    data.isAdd = this.isAdd;\n    data.isCancel = this.isCancel;\n  };\n\n  VirtualContentRenderer.prototype.editCancel = function (args) {\n    var dataIndex = getEditedDataIndex(this.parent, args.data);\n\n    if (!isNullOrUndefined(dataIndex)) {\n      args.data = this.parent.getCurrentViewRecords()[dataIndex];\n    }\n  };\n\n  VirtualContentRenderer.prototype.editSuccess = function (args) {\n    if (this.isNormaledit) {\n      if (!this.isAdd && args.data) {\n        this.updateCurrentViewData(args.data);\n      }\n\n      this.isAdd = false;\n    }\n  };\n\n  VirtualContentRenderer.prototype.updateCurrentViewData = function (data) {\n    var dataIndex = getEditedDataIndex(this.parent, data);\n\n    if (!isNullOrUndefined(dataIndex)) {\n      this.parent.getCurrentViewRecords()[dataIndex] = data;\n    }\n  };\n\n  VirtualContentRenderer.prototype.actionBegin = function (args) {\n    if (args.requestType !== 'virtualscroll') {\n      this.requestType = args.requestType;\n    }\n  };\n\n  VirtualContentRenderer.prototype.virtualCellFocus = function (e) {\n    // To decide the action (select or scroll), when using arrow keys for cell focus\n    var ele = document.activeElement;\n\n    if (ele.classList.contains('e-rowcell') && e && (e.action === 'upArrow' || e.action === 'downArrow')) {\n      var rowIndex = parseInt(ele.parentElement.getAttribute('aria-rowindex'), 10);\n\n      if (e && (e.action === 'downArrow' || e.action === 'upArrow')) {\n        var scrollEle = this.parent.getContent().firstElementChild;\n        e.action === 'downArrow' ? rowIndex += 1 : rowIndex -= 1;\n        this.rowIndex = rowIndex;\n        this.cellIndex = parseInt(ele.getAttribute('aria-colindex'), 10);\n        var row = this.parent.getRowByIndex(rowIndex);\n        var page = this.parent.pageSettings.currentPage;\n        var visibleRowCount = Math.floor(scrollEle.offsetHeight / this.parent.getRowHeight()) - 1;\n        var emptyRow = false;\n\n        if (isNullOrUndefined(row)) {\n          emptyRow = true;\n\n          if (e.action === 'downArrow' && page === this.maxPage - 1 || e.action === 'upArrow' && page === 1) {\n            emptyRow = false;\n          }\n        }\n\n        if (emptyRow || ensureLastRow(row, this.parent) && e.action === 'downArrow' || ensureFirstRow(row, this.parent.getRowHeight() * 2) && e.action === 'upArrow') {\n          this.activeKey = e.action;\n          scrollEle.scrollTop = e.action === 'downArrow' ? (rowIndex - visibleRowCount) * this.parent.getRowHeight() : rowIndex * this.parent.getRowHeight();\n        } else {\n          this.activeKey = this.empty;\n        }\n\n        if (!isBlazor() || isBlazor() && !this.blazorDataLoad) {\n          this.parent.selectRow(rowIndex);\n        }\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.editActionBegin = function (e) {\n    this.editedRowIndex = e.index;\n    var rowData = extend({}, this.getRowObjectByIndex(e.index));\n    e.data = Object.keys(this.virtualData).length ? this.virtualData : rowData;\n  };\n\n  VirtualContentRenderer.prototype.refreshCache = function (data) {\n    var block = Math.ceil((this.editedRowIndex + 1) / this.getBlockSize());\n    var index = this.editedRowIndex - (block - 1) * this.getBlockSize();\n    this.vgenerator.cache[block][index].data = data;\n  };\n\n  VirtualContentRenderer.prototype.actionComplete = function (args) {\n    if (args.requestType === 'delete' || args.requestType === 'save' || args.requestType === 'cancel') {\n      this.refreshOffsets();\n      this.refreshVirtualElement();\n\n      if (this.isNormaledit) {\n        if (args.requestType === 'cancel') {\n          this.isCancel = true;\n        }\n\n        this.isAdd = false;\n        this.editedRowIndex = this.empty;\n        this.virtualData = {};\n        this.parent.editModule.previousVirtualData = {};\n      }\n    }\n\n    if (this.parent.enableColumnVirtualization && args.requestType === 'filterafteropen' && this.currentInfo.columnIndexes && this.currentInfo.columnIndexes[0] > 0) {\n      this.parent.resetFilterDlgPosition(args.columnName);\n    }\n  };\n\n  VirtualContentRenderer.prototype.resetIsedit = function () {\n    if (this.parent.enableVirtualization && this.isNormaledit) {\n      if (this.parent.editSettings.allowEditing && Object.keys(this.virtualData).length || this.parent.editSettings.allowAdding && this.isAdd) {\n        this.parent.isEdit = true;\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.scrollAfterEdit = function () {\n    if (this.parent.editModule && this.parent.editSettings.allowEditing && this.isNormaledit) {\n      if (this.content.querySelector('.e-gridform')) {\n        var editForm = this.content.querySelector('.e-editedrow');\n        var addForm = this.content.querySelector('.e-addedrow');\n\n        if (editForm || addForm) {\n          var rowData = editForm ? extend({}, this.getRowObjectByIndex(this.editedRowIndex)) : extend({}, this.emptyRowData);\n          this.virtualData = this.getVirtualEditedData(rowData);\n        }\n      }\n    }\n  };\n\n  VirtualContentRenderer.prototype.createEmptyRowdata = function () {\n    var _this = this;\n\n    this.parent.getColumns().filter(function (e) {\n      _this.emptyRowData[e.field] = _this.empty;\n    });\n  };\n\n  VirtualContentRenderer.prototype.addActionBegin = function (args) {\n    if (this.isNormaledit) {\n      if (!Object.keys(this.emptyRowData).length) {\n        this.createEmptyRowdata();\n      }\n\n      this.isAdd = true;\n      var page = this.parent.pageSettings.currentPage;\n\n      if (page > 1 && this.parent.editSettings.newRowPosition === 'Top') {\n        this.isAdd = true;\n        this.onActionBegin();\n        args.startEdit = false;\n        this.content.scrollTop = 0;\n      }\n\n      if (page < this.maxPage - 1 && this.parent.editSettings.newRowPosition === 'Bottom') {\n        this.isAdd = true;\n        this.parent.setProperties({\n          pageSettings: {\n            currentPage: this.maxPage - 1\n          }\n        }, true);\n        args.startEdit = false;\n        this.content.scrollTop = this.offsets[this.offsetKeys.length];\n      }\n    }\n  };\n  /** @hidden */\n\n\n  VirtualContentRenderer.prototype.getRowObjectByIndex = function (index) {\n    var data = this.getRowCollection(index, false, true);\n    return data;\n  };\n\n  VirtualContentRenderer.prototype.getBlockSize = function () {\n    return this.parent.pageSettings.pageSize >> 1;\n  };\n\n  VirtualContentRenderer.prototype.getBlockHeight = function () {\n    return this.getBlockSize() * this.parent.getRowHeight();\n  };\n\n  VirtualContentRenderer.prototype.isEndBlock = function (index) {\n    var totalBlocks = this.getTotalBlocks();\n    return index >= totalBlocks || index === totalBlocks - 1;\n  };\n\n  VirtualContentRenderer.prototype.getGroupedTotalBlocks = function () {\n    var rows = this.parent.vcRows;\n    return Math.floor(rows.length / this.getBlockSize() < 1 ? 1 : rows.length / this.getBlockSize());\n  };\n\n  VirtualContentRenderer.prototype.getTotalBlocks = function () {\n    return Math.ceil(this.count / this.getBlockSize());\n  };\n\n  VirtualContentRenderer.prototype.getColumnOffset = function (block) {\n    return this.vgenerator.cOffsets[block] | 0;\n  };\n\n  VirtualContentRenderer.prototype.getModelGenerator = function () {\n    return new VirtualRowModelGenerator(this.parent);\n  };\n\n  VirtualContentRenderer.prototype.resetScrollPosition = function (action) {\n    if (this.actions.some(function (value) {\n      return value === action;\n    })) {\n      var content = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.content;\n      this.preventEvent = content.scrollTop !== 0;\n      content.scrollTop = 0;\n    }\n\n    if (action !== 'virtualscroll') {\n      this.isAdd = false;\n    }\n  };\n\n  VirtualContentRenderer.prototype.onActionBegin = function (e) {\n    //Update property silently..\n    this.parent.setProperties({\n      pageSettings: {\n        currentPage: 1\n      }\n    }, true);\n  };\n\n  VirtualContentRenderer.prototype.getRows = function () {\n    return this.vgenerator.getRows();\n  };\n\n  VirtualContentRenderer.prototype.getRowByIndex = function (index) {\n    if (isGroupAdaptive(this.parent)) {\n      return this.parent.getDataRows()[index];\n    }\n\n    return this.getRowCollection(index, false);\n  };\n\n  VirtualContentRenderer.prototype.getMovableVirtualRowByIndex = function (index) {\n    return this.getRowCollection(index, true);\n  };\n\n  VirtualContentRenderer.prototype.getRowCollection = function (index, isMovable, isRowObject) {\n    var prev = this.prevInfo.blockIndexes;\n    var startIdx = !isBlazor() || isBlazor() && !this.parent.isServerRendered ? (prev[0] - 1) * this.getBlockSize() : this.startIndex;\n    var rowCollection = isMovable ? this.parent.getMovableDataRows() : this.parent.getDataRows();\n    var collection = isRowObject ? this.parent.getCurrentViewRecords() : rowCollection;\n    var selectedRow = collection[index - startIdx];\n\n    if (!isRowObject && this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n      selectedRow = index <= this.parent.frozenRows ? rowCollection[index] : rowCollection[index - startIdx + this.parent.frozenRows];\n    }\n\n    return selectedRow;\n  };\n\n  VirtualContentRenderer.prototype.getVirtualRowIndex = function (index) {\n    var prev = this.prevInfo.blockIndexes;\n    var startIdx = (prev[0] - 1) * this.getBlockSize();\n    return startIdx + index;\n  };\n  /** @hidden */\n\n\n  VirtualContentRenderer.prototype.refreshOffsets = function () {\n    var gObj = this.parent;\n    var row = 0;\n    var bSize = this.getBlockSize();\n    var total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    this.prevHeight = this.offsets[total];\n    this.maxBlock = total % 2 === 0 ? total - 2 : total - 1;\n    this.offsets = {}; //Row offset update\n\n    var blocks = Array.apply(null, Array(total)).map(function () {\n      return ++row;\n    });\n\n    for (var i = 0; i < blocks.length; i++) {\n      var tmp = (this.vgenerator.cache[blocks[i]] || []).length;\n      var rem = !isGroupAdaptive(this.parent) ? this.count % bSize : gObj.vcRows.length % bSize;\n      var size = !isGroupAdaptive(this.parent) && blocks[i] in this.vgenerator.cache ? tmp * this.parent.getRowHeight() : rem && blocks[i] === total ? rem * this.parent.getRowHeight() : this.getBlockHeight(); // let size: number = this.parent.groupSettings.columns.length && block in this.vgenerator.cache ?\n      // tmp * getRowHeight() : this.getBlockHeight();\n\n      this.offsets[blocks[i]] = (this.offsets[blocks[i] - 1] | 0) + size;\n      this.tmpOffsets[blocks[i]] = this.offsets[blocks[i] - 1] | 0;\n    }\n\n    this.offsetKeys = Object.keys(this.offsets);\n\n    if (isGroupAdaptive(this.parent)) {\n      this.parent.vGroupOffsets = this.offsets;\n    } //Column offset update\n\n\n    if (this.parent.enableColumnVirtualization) {\n      this.vgenerator.refreshColOffsets();\n    }\n  };\n\n  VirtualContentRenderer.prototype.refreshVirtualElement = function () {\n    this.vgenerator.refreshColOffsets();\n    this.setVirtualHeight();\n  };\n\n  VirtualContentRenderer.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var frozenCols = this.parent.getFrozenColumns();\n    var fcntColGrp;\n    var mcntColGrp;\n\n    if (frozenCols) {\n      fcntColGrp = [].slice.call(this.parent.getFrozenVirtualContent().querySelectorAll('col'));\n      mcntColGrp = [].slice.call(this.parent.getMovableVirtualContent().querySelectorAll('col'));\n    }\n\n    if (isBlazor() && gObj.isServerRendered) {\n      this.parent.notify('setvisibility', columns);\n    }\n\n    var rows = [];\n    rows = this.getRows();\n    var testRow;\n    rows.some(function (r) {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    var needFullRefresh = true;\n\n    if (!gObj.groupSettings.columns.length && testRow) {\n      needFullRefresh = false;\n    }\n\n    var tr = gObj.getDataRows();\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      var idx = gObj.getNormalizedColumnIndex(column.uid);\n      var displayVal = column.visible === true ? '' : 'none';\n      var colGrp = void 0;\n\n      if (fcntColGrp && mcntColGrp) {\n        if (idx >= frozenCols) {\n          colGrp = mcntColGrp;\n          tr = this.parent.getMovableRows();\n          idx = idx - frozenCols;\n        } else {\n          colGrp = fcntColGrp;\n        }\n      } else {\n        colGrp = this.getColGroup().children;\n      }\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        setStyleAttribute(colGrp[idx], {\n          'display': displayVal\n        });\n      }\n\n      if (!needFullRefresh) {\n        var width = void 0;\n\n        if (column.visible) {\n          width = this.virtualEle.wrapper.offsetWidth + parseInt(column.width.toString(), 10);\n        } else {\n          width = this.virtualEle.wrapper.offsetWidth - parseInt(column.width.toString(), 10);\n        }\n\n        if (width > gObj.width) {\n          this.setDisplayNone(tr, idx, displayVal, rows);\n\n          if (this.parent.enableColumnVirtualization) {\n            this.virtualEle.setWrapperWidth(width + '');\n          }\n\n          this.refreshVirtualElement();\n        } else {\n          needFullRefresh = true;\n        }\n      }\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n\n    if (isBlazor() && this.parent.isServerRendered && needFullRefresh) {\n      var inViewIdx = this.parent.inViewIndexes;\n      var translateX = this.getColumnOffset(inViewIdx[0] - 1);\n      var width = this.getColumnOffset(inViewIdx[inViewIdx.length - 1]) - translateX + '';\n      this.parent.notify('refresh-virtual-indices', {\n        requestType: 'virtualScrollRefresh',\n        startColumnIndex: inViewIdx[0],\n        endColumnIndex: inViewIdx[inViewIdx.length - 1],\n        axis: 'X',\n        VTablewidth: width,\n        translateX: translateX\n      });\n      this.parent.notify('setcolumnstyles', {});\n    }\n\n    if (needFullRefresh || frozenCols) {\n      this.refreshContentRows({\n        requestType: 'refresh'\n      });\n    } else {\n      this.parent.notify(events.partialRefresh, {\n        rows: rows,\n        args: {\n          isFrozen: false,\n          rows: rows\n        }\n      });\n    }\n  };\n\n  VirtualContentRenderer.prototype.selectVirtualRow = function (args) {\n    var _this = this;\n\n    if (this.activeKey !== 'upArrow' && this.activeKey !== 'downArrow' && !this.requestTypes.some(function (value) {\n      return value === _this.requestType;\n    }) && !this.parent.selectionModule.isInteracted) {\n      var ele = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.parent.getContent().firstElementChild;\n      var selectedRow = this.parent.getRowByIndex(args.selectedIndex);\n      var rowHeight = this.parent.getRowHeight();\n      var eleOffsHeight = ele.offsetHeight;\n\n      if (!selectedRow || this.isRowInView(args.selectedIndex, selectedRow, ele, eleOffsHeight, rowHeight)) {\n        this.isSelection = true;\n        this.selectedRowIndex = args.selectedIndex;\n        var scrollTop = (args.selectedIndex + 1) * rowHeight;\n\n        if (!isNullOrUndefined(scrollTop)) {\n          ele.scrollTop = scrollTop;\n        }\n      }\n    }\n\n    this.requestType = this.empty;\n  };\n\n  VirtualContentRenderer.prototype.isRowInView = function (index, selectedRow, ele, eleOffsHeight, rowHeight) {\n    if (isBlazor()) {\n      var exactTopIndex = ele.scrollTop / rowHeight;\n      var exactEndIndex = exactTopIndex + eleOffsHeight / rowHeight;\n      return index < exactTopIndex || index > exactEndIndex;\n    } else {\n      if (this.parent.frozenRows && index < this.parent.frozenRows) {\n        return false;\n      }\n\n      var rectTop = selectedRow ? selectedRow.getBoundingClientRect().top : 0;\n      return rectTop < rowHeight || rectTop > eleOffsHeight;\n    }\n  };\n\n  return VirtualContentRenderer;\n}(ContentRender);\n\nexport { VirtualContentRenderer };\n/**\n * @hidden\n */\n\nvar VirtualHeaderRenderer =\n/** @class */\nfunction (_super) {\n  __extends(VirtualHeaderRenderer, _super);\n\n  function VirtualHeaderRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.virtualEle = new VirtualElementHandler();\n    _this.gen = new VirtualRowModelGenerator(_this.parent);\n\n    _this.parent.on(events.columnVisibilityChanged, _this.setVisible, _this);\n\n    _this.parent.on(refreshVirtualBlock, function (e) {\n      return e.virtualInfo.sentinelInfo.axis === 'X' ? _this.refreshUI() : null;\n    }, _this);\n\n    return _this;\n  }\n\n  VirtualHeaderRenderer.prototype.renderTable = function () {\n    this.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.gen.getColumnIndexes(this.getPanel().querySelector('.e-headercontent')));\n\n    if (isBlazor() && this.parent.isServerRendered) {\n      this.parent.notify('refresh-virtual-indices', {\n        startColumnIndex: this.parent.contentModule.startColIndex,\n        endColumnIndex: this.parent.contentModule.endColIndex,\n        axis: 'X'\n      });\n    }\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualEle.table = this.getTable();\n    this.virtualEle.content = this.getPanel().querySelector('.e-headercontent');\n\n    if (!this.parent.getFrozenColumns()) {\n      this.virtualEle.content.style.position = 'relative';\n    }\n\n    this.virtualEle.renderWrapper();\n    this.virtualEle.renderPlaceHolder('absolute');\n  };\n\n  VirtualHeaderRenderer.prototype.appendContent = function (table) {\n    this.virtualEle.wrapper.appendChild(table);\n  };\n\n  VirtualHeaderRenderer.prototype.refreshUI = function () {\n    this.setFrozenTable(this.parent.getMovableVirtualContent());\n    this.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.gen.getColumnIndexes(this.getPanel().querySelector('.e-headercontent')));\n\n    _super.prototype.refreshUI.call(this);\n\n    this.setFrozenTable(this.parent.getFrozenVirtualContent());\n  };\n\n  VirtualHeaderRenderer.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var displayVal;\n    var idx;\n    var needFullRefresh;\n    var frozenCols = this.parent.getFrozenColumns();\n    var fhdrColGrp;\n    var mhdrColGrp;\n\n    if (frozenCols) {\n      fhdrColGrp = [].slice.call(this.parent.getFrozenVirtualHeader().querySelectorAll('col'));\n      mhdrColGrp = [].slice.call(this.parent.getMovableVirtualHeader().querySelectorAll('col'));\n    }\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      idx = gObj.getNormalizedColumnIndex(column.uid);\n      displayVal = column.visible ? '' : 'none';\n      var colGrp = void 0;\n\n      if (fhdrColGrp && mhdrColGrp) {\n        if (idx >= frozenCols) {\n          colGrp = mhdrColGrp;\n          idx = idx - frozenCols;\n        } else {\n          colGrp = fhdrColGrp;\n        }\n      } else {\n        colGrp = this.getColGroup().children;\n      }\n\n      setStyleAttribute(colGrp[idx], {\n        'display': displayVal\n      });\n\n      if (gObj.enableColumnVirtualization && !gObj.groupSettings.columns.length) {\n        var tablewidth = void 0;\n\n        if (column.visible) {\n          tablewidth = this.virtualEle.wrapper.offsetWidth + parseInt(column.width.toString(), 10);\n        } else {\n          tablewidth = this.virtualEle.wrapper.offsetWidth - parseInt(column.width.toString(), 10);\n        }\n\n        if (tablewidth > gObj.width) {\n          this.setDisplayNone(column, displayVal);\n          this.virtualEle.setWrapperWidth(tablewidth + '');\n          this.gen.refreshColOffsets();\n        } else {\n          needFullRefresh = true;\n        }\n      } else {\n        needFullRefresh = true;\n      }\n\n      if (needFullRefresh && !frozenCols) {\n        this.refreshUI();\n      }\n    }\n\n    if (frozenCols) {\n      this.parent.notify(events.columnPositionChanged, {});\n    }\n  };\n\n  VirtualHeaderRenderer.prototype.setFrozenTable = function (content) {\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization && this.parent.contentModule.isXaxis()) {\n      this.parent.contentModule.setTable(content.querySelector('.e-table'));\n    }\n  };\n\n  VirtualHeaderRenderer.prototype.setDisplayNone = function (col, displayVal) {\n    var frozenCols = this.parent.getFrozenColumns();\n    var table = this.getTable();\n\n    if (frozenCols && col.index >= frozenCols) {\n      table = this.parent.getMovableVirtualHeader().querySelector('.e-table');\n    }\n\n    for (var _i = 0, _a = [].slice.apply(table.querySelectorAll('th.e-headercell')); _i < _a.length; _i++) {\n      var ele = _a[_i];\n\n      if (ele.querySelector('[e-mappinguid]') && ele.querySelector('[e-mappinguid]').getAttribute('e-mappinguid') === col.uid) {\n        setStyleAttribute(ele, {\n          'display': displayVal\n        });\n\n        if (displayVal === '') {\n          removeClass([ele], 'e-hide');\n        }\n\n        break;\n      }\n    }\n  };\n\n  return VirtualHeaderRenderer;\n}(HeaderRender);\n\nexport { VirtualHeaderRenderer };\n/**\n * @hidden\n */\n\nvar VirtualElementHandler =\n/** @class */\nfunction () {\n  function VirtualElementHandler() {}\n\n  VirtualElementHandler.prototype.renderWrapper = function (height) {\n    if (isBlazor()) {\n      this.wrapper = this.content.querySelector('.e-virtualtable') ? this.content.querySelector('.e-virtualtable') : createElement('div', {\n        className: 'e-virtualtable'\n      });\n      this.wrapper.setAttribute('styles', \"min-height:\" + formatUnit(height));\n    } else {\n      this.wrapper = createElement('div', {\n        className: 'e-virtualtable',\n        styles: \"min-height:\" + formatUnit(height)\n      });\n    }\n\n    this.wrapper.appendChild(this.table);\n    this.content.appendChild(this.wrapper);\n  };\n\n  VirtualElementHandler.prototype.renderPlaceHolder = function (position) {\n    if (position === void 0) {\n      position = 'relative';\n    }\n\n    if (isBlazor()) {\n      this.placeholder = this.content.querySelector('.e-virtualtrack') ? this.content.querySelector('.e-virtualtrack') : createElement('div', {\n        className: 'e-virtualtrack'\n      });\n      this.placeholder.setAttribute('styles', \"position:\" + position);\n    } else {\n      this.placeholder = createElement('div', {\n        className: 'e-virtualtrack',\n        styles: \"position:\" + position\n      });\n    }\n\n    this.content.appendChild(this.placeholder);\n  };\n\n  VirtualElementHandler.prototype.adjustTable = function (xValue, yValue) {\n    this.wrapper.style.transform = \"translate(\" + xValue + \"px, \" + yValue + \"px)\";\n  };\n\n  VirtualElementHandler.prototype.setWrapperWidth = function (width, full) {\n    this.wrapper.style.width = width ? width + \"px\" : full ? '100%' : '';\n  };\n\n  VirtualElementHandler.prototype.setVirtualHeight = function (height, width) {\n    this.placeholder.style.height = height + \"px\";\n    this.placeholder.style.width = width;\n  };\n\n  VirtualElementHandler.prototype.setFreezeWrapperWidth = function (wrapper, width, full) {\n    wrapper.style.width = width ? width + \"px\" : full ? '100%' : '';\n  };\n\n  return VirtualElementHandler;\n}();\n\nexport { VirtualElementHandler };","map":null,"metadata":{},"sourceType":"module"}