{"ast":null,"code":"import { isNullOrUndefined, extend, isBlazor, updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { doesImplementInterface, setStyleAndAttributes, appendChildren, extendObjWithFn } from '../base/util';\nimport { createCheckBox } from '@syncfusion/ej2-buttons';\nimport { foreignKeyData } from '../base/constant';\n/**\n * CellRenderer class which responsible for building cell content.\n * @hidden\n */\n\nvar CellRenderer =\n/** @class */\nfunction () {\n  function CellRenderer(parent, locator) {\n    this.localizer = locator.getService('localization');\n    this.formatter = locator.getService('valueFormatter');\n    this.parent = parent;\n    this.element = this.parent.createElement('TD', {\n      className: 'e-rowcell',\n      attrs: {\n        role: 'gridcell',\n        tabindex: '-1'\n      }\n    });\n    this.rowChkBox = this.parent.createElement('input', {\n      className: 'e-checkselect',\n      attrs: {\n        'type': 'checkbox'\n      }\n    });\n  }\n  /**\n   * Function to return the wrapper for the TD content\n   * @returns string\n   */\n\n\n  CellRenderer.prototype.getGui = function () {\n    return '';\n  };\n  /**\n   * Function to format the cell value.\n   * @param  {Column} column\n   * @param  {Object} value\n   * @param  {Object} data\n   */\n\n\n  CellRenderer.prototype.format = function (column, value, data) {\n    if (!isNullOrUndefined(column.format)) {\n      if (column.type === 'number' && isNaN(parseInt(value, 10))) {\n        value = null;\n      }\n\n      value = this.formatter.toView(value, column.getFormatter());\n    }\n\n    return isNullOrUndefined(value) ? '' : value.toString();\n  };\n\n  CellRenderer.prototype.evaluate = function (node, cell, data, attributes, fData, isEdit) {\n    var _a;\n\n    var result;\n\n    if (cell.column.template) {\n      var literals = ['index'];\n      var dummyData = extendObjWithFn({}, data, (_a = {}, _a[foreignKeyData] = fData, _a.column = cell.column, _a));\n      var templateID = this.parent.element.id + cell.column.uid;\n      var str = 'isStringTemplate';\n      var index = 'index';\n\n      if (isBlazor() && isEdit) {\n        var rNumber = this.parent.editSettings.mode !== 'Batch' ? parseInt(attributes[index], 10) : null;\n        result = cell.column.getColumnTemplate()(extend({\n          'index': attributes[literals[0]]\n        }, dummyData), this.parent, 'template', templateID, this.parent[str], rNumber);\n        window[templateID] = null;\n\n        if (this.parent.editSettings.mode !== 'Batch') {\n          updateBlazorTemplate(templateID, 'Template', cell.column, false);\n        }\n      } else {\n        result = cell.column.getColumnTemplate()(extend({\n          'index': attributes[literals[0]]\n        }, dummyData), this.parent, 'template', templateID, this.parent[str]);\n      }\n\n      appendChildren(node, result);\n      this.parent.notify('template-result', {\n        template: result\n      });\n      result = null;\n      node.setAttribute('aria-label', node.innerText + ' is template cell' + ' column header ' + cell.column.headerText);\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Function to invoke the custom formatter available in the column object.\n   * @param  {Column} column\n   * @param  {Object} value\n   * @param  {Object} data\n   */\n\n\n  CellRenderer.prototype.invokeFormatter = function (column, value, data) {\n    if (!isNullOrUndefined(column.formatter)) {\n      if (doesImplementInterface(column.formatter, 'getValue')) {\n        var formatter = column.formatter;\n        value = new formatter().getValue(column, data);\n      } else if (typeof column.formatter === 'function') {\n        value = column.formatter(column, data);\n      } else {\n        value = column.formatter.getValue(column, data);\n      }\n    }\n\n    return value;\n  };\n  /**\n   * Function to render the cell content based on Column object.\n   * @param  {Column} column\n   * @param  {Object} data\n   * @param  {{[x:string]:Object}} attributes?\n   * @param  {Element}\n   */\n\n\n  CellRenderer.prototype.render = function (cell, data, attributes, isExpand, isEdit) {\n    return this.refreshCell(cell, data, attributes, isEdit);\n  };\n  /**\n   * Function to refresh the cell content based on Column object.\n   * @param  {Column} column\n   * @param  {Object} data\n   * @param  {{[x:string]:Object}} attributes?\n   * @param  {Element}\n   */\n\n\n  CellRenderer.prototype.refreshTD = function (td, cell, data, attributes) {\n    var isEdit = this.parent.editSettings.mode === 'Batch' && td.classList.contains('e-editedbatchcell');\n    var node = this.refreshCell(cell, data, attributes, isEdit);\n    td.innerHTML = '';\n    td.setAttribute('aria-label', node.getAttribute('aria-label'));\n    var elements = [].slice.call(node.childNodes);\n\n    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n      var elem = elements_1[_i];\n      td.appendChild(elem);\n    }\n  };\n\n  CellRenderer.prototype.refreshCell = function (cell, data, attributes, isEdit) {\n    var _a;\n\n    var node = this.element.cloneNode();\n    var column = cell.column;\n    var fData;\n\n    if (cell.isForeignKey) {\n      fData = cell.foreignKeyData[0] || (_a = {}, _a[column.foreignKeyValue] = column.format ? null : '', _a);\n    } //Prepare innerHtml\n\n\n    var innerHtml = this.getGui();\n    var value = cell.isForeignKey ? this.getValue(column.foreignKeyValue, fData, column) : this.getValue(column.field, data, column);\n\n    if ((column.type === 'date' || column.type === 'datetime') && !isNullOrUndefined(value)) {\n      value = new Date(value);\n    }\n\n    value = this.format(column, value, data);\n    innerHtml = value.toString();\n\n    if (column.type === 'boolean' && !column.displayAsCheckBox) {\n      var localeStr = value !== 'true' && value !== 'false' ? null : value === 'true' ? 'True' : 'False';\n      innerHtml = localeStr ? this.localizer.getConstant(localeStr) : innerHtml;\n    }\n\n    var fromFormatter = this.invokeFormatter(column, value, data);\n    innerHtml = !isNullOrUndefined(column.formatter) ? isNullOrUndefined(fromFormatter) ? '' : fromFormatter.toString() : innerHtml;\n    node.setAttribute('aria-label', innerHtml + ' column header ' + cell.column.headerText);\n\n    if (this.evaluate(node, cell, data, attributes, fData, isEdit) && column.type !== 'checkbox') {\n      this.appendHtml(node, innerHtml, column.getDomSetter ? column.getDomSetter() : 'innerHTML');\n    } else if (column.type === 'checkbox') {\n      node.classList.add('e-gridchkbox');\n      node.setAttribute('aria-label', 'checkbox');\n\n      if (this.parent.selectionSettings.persistSelection) {\n        value = value === 'true';\n      } else {\n        value = false;\n      }\n\n      var checkWrap = createCheckBox(this.parent.createElement, false, {\n        checked: value,\n        label: ' '\n      });\n      checkWrap.insertBefore(this.rowChkBox.cloneNode(), checkWrap.firstChild);\n      node.appendChild(checkWrap);\n    }\n\n    if (this.parent.checkAllRows === 'Check' && this.parent.enableVirtualization) {\n      cell.isSelected = true;\n    }\n\n    this.setAttributes(node, cell, attributes);\n\n    if (column.type === 'boolean' && column.displayAsCheckBox) {\n      var checked = isNaN(parseInt(value.toString(), 10)) ? value === 'true' : parseInt(value.toString(), 10) > 0;\n      var checkWrap = createCheckBox(this.parent.createElement, false, {\n        checked: checked,\n        label: ' '\n      });\n      node.innerHTML = '';\n      checkWrap.classList.add('e-checkbox-disabled');\n      node.appendChild(checkWrap);\n      node.setAttribute('aria-label', checked + ' column header ' + cell.column.headerText);\n    }\n\n    return node;\n  };\n  /**\n   * Function to specifies how the result content to be placed in the cell.\n   * @param  {Element} node\n   * @param  {string|Element} innerHtml\n   * @returns Element\n   */\n\n\n  CellRenderer.prototype.appendHtml = function (node, innerHtml, property) {\n    if (property === void 0) {\n      property = 'innerHTML';\n    }\n\n    node[property] = innerHtml;\n    return node;\n  };\n  /**\n   * @hidden\n   */\n\n\n  CellRenderer.prototype.setAttributes = function (node, cell, attributes) {\n    var column = cell.column;\n    this.buildAttributeFromCell(node, cell, column.type === 'checkbox');\n    setStyleAndAttributes(node, attributes);\n    setStyleAndAttributes(node, cell.attributes);\n\n    if (column.customAttributes) {\n      setStyleAndAttributes(node, column.customAttributes);\n    }\n\n    if (column.textAlign) {\n      node.style.textAlign = column.textAlign;\n    }\n\n    if (column.clipMode === 'Clip' || !column.clipMode && this.parent.clipMode === 'Clip') {\n      node.classList.add('e-gridclip');\n    } else if (column.clipMode === 'EllipsisWithTooltip' || !column.clipMode && this.parent.clipMode === 'EllipsisWithTooltip') {\n      if (column.type !== 'checkbox') {\n        node.classList.add('e-ellipsistooltip');\n      }\n    }\n  };\n\n  CellRenderer.prototype.buildAttributeFromCell = function (node, cell, isCheckBoxType) {\n    var attr = {};\n    var prop = {\n      'colindex': 'aria-colindex'\n    };\n    var classes = [];\n\n    if (cell.colSpan) {\n      attr.colSpan = cell.colSpan;\n    }\n\n    if (cell.rowSpan) {\n      attr.rowSpan = cell.rowSpan;\n    }\n\n    if (cell.isTemplate) {\n      classes.push('e-templatecell');\n    }\n\n    if (cell.isSelected) {\n      classes.push.apply(classes, ['e-selectionbackground', 'e-active']);\n\n      if (isCheckBoxType) {\n        node.querySelector('.e-frame').classList.add('e-check');\n      }\n    }\n\n    if (!isNullOrUndefined(cell.index)) {\n      attr[prop.colindex] = cell.index;\n    }\n\n    if (!cell.visible) {\n      classes.push('e-hide');\n    }\n\n    attr.class = classes;\n    setStyleAndAttributes(node, attr);\n  };\n\n  CellRenderer.prototype.getValue = function (field, data, column) {\n    return column.valueAccessor(field, data, column);\n  };\n\n  return CellRenderer;\n}();\n\nexport { CellRenderer };","map":null,"metadata":{},"sourceType":"module"}