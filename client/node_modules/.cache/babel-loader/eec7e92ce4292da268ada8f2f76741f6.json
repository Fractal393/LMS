{"ast":null,"code":"import { DataUtil } from './util';\n/**\n * Query class is used to build query which is used by the DataManager to communicate with datasource.\n */\n\nvar Query =\n/** @class */\nfunction () {\n  /**\n   * Constructor for Query class.\n   * @param  {string|string[]} from?\n   * @hidden\n   */\n  function Query(from) {\n    /** @hidden */\n    this.subQuery = null;\n    /** @hidden */\n\n    this.isChild = false;\n    /** @hidden */\n\n    this.distincts = [];\n    this.queries = [];\n    this.key = '';\n    this.fKey = '';\n\n    if (typeof from === 'string') {\n      this.fromTable = from;\n    } else if (from && from instanceof Array) {\n      this.lookups = from;\n    }\n\n    this.expands = [];\n    this.sortedColumns = [];\n    this.groupedColumns = [];\n    this.subQuery = null;\n    this.isChild = false;\n    this.params = [];\n    return this;\n  }\n  /**\n   * Sets the primary key.\n   * @param  {string} field - Defines the column field.\n   */\n\n\n  Query.prototype.setKey = function (field) {\n    this.key = field;\n    return this;\n  };\n  /**\n   * Sets default DataManager to execute query.\n   * @param  {DataManager} dataManager - Defines the DataManager.\n   */\n\n\n  Query.prototype.using = function (dataManager) {\n    this.dataManager = dataManager;\n    return this;\n  };\n  /**\n   * Executes query with the given DataManager.\n   * @param  {DataManager} dataManager - Defines the DataManager.\n   * @param  {Function} done - Defines the success callback.\n   * @param  {Function} fail - Defines the failure callback.\n   * @param  {Function} always - Defines the callback which will be invoked on either success or failure.\n   *\n   * <pre>\n   * let dataManager: DataManager = new DataManager([{ ID: '10' }, { ID: '2' }, { ID: '1' }, { ID: '20' }]);\n   * let query: Query = new Query();\n   * query.sortBy('ID', (x: string, y: string): number => { return parseInt(x, 10) - parseInt(y, 10) });\n   * let promise: Promise< Object > = query.execute(dataManager);\n   * promise.then((e: { result: Object }) => { });\n   * </pre>\n   */\n\n\n  Query.prototype.execute = function (dataManager, done, fail, always) {\n    dataManager = dataManager || this.dataManager;\n\n    if (dataManager) {\n      return dataManager.executeQuery(this, done, fail, always);\n    }\n\n    return DataUtil.throwError('Query - execute() : dataManager needs to be is set using \"using\" function or should be passed as argument');\n  };\n  /**\n   * Executes query with the local datasource.\n   * @param  {DataManager} dataManager - Defines the DataManager.\n   */\n\n\n  Query.prototype.executeLocal = function (dataManager) {\n    dataManager = dataManager || this.dataManager;\n\n    if (dataManager) {\n      return dataManager.executeLocal(this);\n    }\n\n    return DataUtil.throwError('Query - executeLocal() : dataManager needs to be is set using \"using\" function or should be passed as argument');\n  };\n  /**\n   * Creates deep copy of the Query object.\n   */\n\n\n  Query.prototype.clone = function () {\n    var cloned = new Query();\n    cloned.queries = this.queries.slice(0);\n    cloned.key = this.key;\n    cloned.isChild = this.isChild;\n    cloned.dataManager = this.dataManager;\n    cloned.fromTable = this.fromTable;\n    cloned.params = this.params.slice(0);\n    cloned.expands = this.expands.slice(0);\n    cloned.sortedColumns = this.sortedColumns.slice(0);\n    cloned.groupedColumns = this.groupedColumns.slice(0);\n    cloned.subQuerySelector = this.subQuerySelector;\n    cloned.subQuery = this.subQuery;\n    cloned.fKey = this.fKey;\n    cloned.isCountRequired = this.isCountRequired;\n    cloned.distincts = this.distincts.slice(0);\n    return cloned;\n  };\n  /**\n   * Specifies the name of table to retrieve data in query execution.\n   * @param  {string} tableName - Defines the table name.\n   */\n\n\n  Query.prototype.from = function (tableName) {\n    this.fromTable = tableName;\n    return this;\n  };\n  /**\n   * Adds additional parameter which will be sent along with the request which will be generated while DataManager execute.\n   * @param  {string} key - Defines the key of additional parameter.\n   * @param  {Function|string} value - Defines the value for the key.\n   */\n\n\n  Query.prototype.addParams = function (key, value) {\n    if (typeof value === 'function') {\n      this.params.push({\n        key: key,\n        fn: value\n      });\n    } else {\n      this.params.push({\n        key: key,\n        value: value\n      });\n    }\n\n    return this;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Query.prototype.distinct = function (fields) {\n    if (typeof fields === 'string') {\n      this.distincts = [].slice.call([fields], 0);\n    } else {\n      this.distincts = fields.slice(0);\n    }\n\n    return this;\n  };\n  /**\n   * Expands the related table.\n   * @param  {string|Object[]} tables\n   */\n\n\n  Query.prototype.expand = function (tables) {\n    if (typeof tables === 'string') {\n      this.expands = [].slice.call([tables], 0);\n    } else {\n      this.expands = tables.slice(0);\n    }\n\n    return this;\n  };\n  /**\n   * Filter data with given filter criteria.\n   * @param  {string|Predicate} fieldName - Defines the column field or Predicate.\n   * @param  {string} operator - Defines the operator how to filter data.\n   * @param  {string|number|boolean} value - Defines the values to match with data.\n   * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else\n   * filter data with case insensitive.\n   */\n\n\n  Query.prototype.where = function (fieldName, operator, value, ignoreCase, ignoreAccent) {\n    operator = operator ? operator.toLowerCase() : null;\n    var predicate = null;\n\n    if (typeof fieldName === 'string') {\n      predicate = new Predicate(fieldName, operator, value, ignoreCase, ignoreAccent);\n    } else if (fieldName instanceof Predicate) {\n      predicate = fieldName;\n    }\n\n    this.queries.push({\n      fn: 'onWhere',\n      e: predicate\n    });\n    return this;\n  };\n  /**\n   * Search data with given search criteria.\n   * @param  {string|number|boolean} searchKey - Defines the search key.\n   * @param  {string|string[]} fieldNames - Defines the collection of column fields.\n   * @param  {string} operator - Defines the operator how to search data.\n   * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else\n   * filter data with case insensitive.\n   */\n\n\n  Query.prototype.search = function (searchKey, fieldNames, operator, ignoreCase, ignoreAccent) {\n    if (typeof fieldNames === 'string') {\n      fieldNames = [fieldNames];\n    }\n\n    if (!operator || operator === 'none') {\n      operator = 'contains';\n    }\n\n    var comparer = DataUtil.fnOperators[operator];\n    this.queries.push({\n      fn: 'onSearch',\n      e: {\n        fieldNames: fieldNames,\n        operator: operator,\n        searchKey: searchKey,\n        ignoreCase: ignoreCase,\n        ignoreAccent: ignoreAccent,\n        comparer: comparer\n      }\n    });\n    return this;\n  };\n  /**\n   * Sort the data with given sort criteria.\n   * By default, sort direction is ascending.\n   * @param  {string|string[]} fieldName - Defines the single or collection of column fields.\n   * @param  {string|Function} comparer - Defines the sort direction or custom sort comparer function.\n   */\n\n\n  Query.prototype.sortBy = function (fieldName, comparer, isFromGroup) {\n    var order = 'ascending';\n    var sorts;\n    var temp;\n\n    if (typeof fieldName === 'string' && DataUtil.endsWith(fieldName.toLowerCase(), ' desc')) {\n      fieldName = fieldName.replace(/ desc$/i, '');\n      comparer = 'descending';\n    }\n\n    if (!comparer || typeof comparer === 'string') {\n      order = comparer ? comparer.toLowerCase() : 'ascending';\n      comparer = DataUtil.fnSort(comparer);\n    }\n\n    if (isFromGroup) {\n      sorts = Query.filterQueries(this.queries, 'onSortBy');\n\n      for (var i = 0; i < sorts.length; i++) {\n        temp = sorts[i].e.fieldName;\n\n        if (typeof temp === 'string') {\n          if (temp === fieldName) {\n            return this;\n          }\n        } else if (temp instanceof Array) {\n          for (var j = 0; j < temp.length; j++) {\n            if (temp[j] === fieldName || fieldName.toLowerCase() === temp[j] + ' desc') {\n              return this;\n            }\n          }\n        }\n      }\n    }\n\n    this.queries.push({\n      fn: 'onSortBy',\n      e: {\n        fieldName: fieldName,\n        comparer: comparer,\n        direction: order\n      }\n    });\n    return this;\n  };\n  /**\n   * Sorts data in descending order.\n   * @param  {string} fieldName - Defines the column field.\n   */\n\n\n  Query.prototype.sortByDesc = function (fieldName) {\n    return this.sortBy(fieldName, 'descending');\n  };\n  /**\n   * Groups data with the given field name.\n   * @param  {string} fieldName - Defines the column field.\n   */\n\n\n  Query.prototype.group = function (fieldName, fn, format) {\n    this.sortBy(fieldName, null, true);\n    this.queries.push({\n      fn: 'onGroup',\n      e: {\n        fieldName: fieldName,\n        comparer: fn ? fn : null,\n        format: format ? format : null\n      }\n    });\n    return this;\n  };\n  /**\n   * Gets data based on the given page index and size.\n   * @param  {number} pageIndex - Defines the current page index.\n   * @param  {number} pageSize - Defines the no of records per page.\n   */\n\n\n  Query.prototype.page = function (pageIndex, pageSize) {\n    this.queries.push({\n      fn: 'onPage',\n      e: {\n        pageIndex: pageIndex,\n        pageSize: pageSize\n      }\n    });\n    return this;\n  };\n  /**\n   * Gets data based on the given start and end index.\n   * @param  {number} start - Defines the start index of the datasource.\n   * @param  {number} end - Defines the end index of the datasource.\n   */\n\n\n  Query.prototype.range = function (start, end) {\n    this.queries.push({\n      fn: 'onRange',\n      e: {\n        start: start,\n        end: end\n      }\n    });\n    return this;\n  };\n  /**\n   * Gets data from the top of the data source based on given number of records count.\n   * @param  {number} nos - Defines the no of records to retrieve from datasource.\n   */\n\n\n  Query.prototype.take = function (nos) {\n    this.queries.push({\n      fn: 'onTake',\n      e: {\n        nos: nos\n      }\n    });\n    return this;\n  };\n  /**\n   * Skips data with given number of records count from the top of the data source.\n   * @param  {number} nos - Defines the no of records skip in the datasource.\n   */\n\n\n  Query.prototype.skip = function (nos) {\n    this.queries.push({\n      fn: 'onSkip',\n      e: {\n        nos: nos\n      }\n    });\n    return this;\n  };\n  /**\n   * Selects specified columns from the data source.\n   * @param  {string|string[]} fieldNames - Defines the collection of column fields.\n   */\n\n\n  Query.prototype.select = function (fieldNames) {\n    if (typeof fieldNames === 'string') {\n      fieldNames = [].slice.call([fieldNames], 0);\n    }\n\n    this.queries.push({\n      fn: 'onSelect',\n      e: {\n        fieldNames: fieldNames\n      }\n    });\n    return this;\n  };\n  /**\n   * Gets the records in hierarchical relationship from two tables. It requires the foreign key to relate two tables.\n   * @param  {Query} query - Defines the query to relate two tables.\n   * @param  {Function} selectorFn - Defines the custom function to select records.\n   */\n\n\n  Query.prototype.hierarchy = function (query, selectorFn) {\n    this.subQuerySelector = selectorFn;\n    this.subQuery = query;\n    return this;\n  };\n  /**\n   * Sets the foreign key which is used to get data from the related table.\n   * @param  {string} key - Defines the foreign key.\n   */\n\n\n  Query.prototype.foreignKey = function (key) {\n    this.fKey = key;\n    return this;\n  };\n  /**\n   * It is used to get total number of records in the DataManager execution result.\n   */\n\n\n  Query.prototype.requiresCount = function () {\n    this.isCountRequired = true;\n    return this;\n  }; //type - sum, avg, min, max\n\n  /**\n   * Aggregate the data with given type and field name.\n   * @param  {string} type - Defines the aggregate type.\n   * @param  {string} field - Defines the column field to aggregate.\n   */\n\n\n  Query.prototype.aggregate = function (type, field) {\n    this.queries.push({\n      fn: 'onAggregates',\n      e: {\n        field: field,\n        type: type\n      }\n    });\n    return this;\n  };\n  /**\n   * Pass array of filterColumn query for performing filter operation.\n   * @param  {QueryOptions[]} queries\n   * @param  {string} name\n   * @hidden\n   */\n\n\n  Query.filterQueries = function (queries, name) {\n    return queries.filter(function (q) {\n      return q.fn === name;\n    });\n  };\n  /**\n   * To get the list of queries which is already filtered in current data source.\n   * @param  {Object[]} queries\n   * @param  {string[]} singles\n   * @hidden\n   */\n\n\n  Query.filterQueryLists = function (queries, singles) {\n    var filtered = queries.filter(function (q) {\n      return singles.indexOf(q.fn) !== -1;\n    });\n    var res = {};\n\n    for (var i = 0; i < filtered.length; i++) {\n      if (!res[filtered[i].fn]) {\n        res[filtered[i].fn] = filtered[i].e;\n      }\n    }\n\n    return res;\n  };\n\n  return Query;\n}();\n\nexport { Query };\n/**\n * Predicate class is used to generate complex filter criteria.\n * This will be used by DataManager to perform multiple filtering operation.\n */\n\nvar Predicate =\n/** @class */\nfunction () {\n  /**\n   * Constructor for Predicate class.\n   * @param  {string|Predicate} field\n   * @param  {string} operator\n   * @param  {string|number|boolean|Predicate|Predicate[]} value\n   * @param  {boolean=false} ignoreCase\n   * @hidden\n   */\n  function Predicate(field, operator, value, ignoreCase, ignoreAccent) {\n    if (ignoreCase === void 0) {\n      ignoreCase = false;\n    }\n    /** @hidden */\n\n\n    this.ignoreAccent = false;\n    /** @hidden */\n\n    this.isComplex = false;\n\n    if (typeof field === 'string') {\n      this.field = field;\n      this.operator = operator.toLowerCase();\n      this.value = value;\n      this.ignoreCase = ignoreCase;\n      this.ignoreAccent = ignoreAccent;\n      this.isComplex = false;\n      this.comparer = DataUtil.fnOperators.processOperator(this.operator);\n    } else if (field instanceof Predicate && value instanceof Predicate || value instanceof Array) {\n      this.isComplex = true;\n      this.condition = operator.toLowerCase();\n      this.predicates = [field];\n\n      if (value instanceof Array) {\n        [].push.apply(this.predicates, value);\n      } else {\n        this.predicates.push(value);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Adds n-number of new predicates on existing predicate with “and” condition.\n   * @param  {Object[]} args - Defines the collection of predicates.\n   */\n\n\n  Predicate.and = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return Predicate.combinePredicates([].slice.call(args, 0), 'and');\n  };\n  /**\n   * Adds new predicate on existing predicate with “and” condition.\n   * @param  {string} field - Defines the column field.\n   * @param  {string} operator - Defines the operator how to filter data.\n   * @param  {string} value - Defines the values to match with data.\n   * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else\n   * filter data with case insensitive.\n   */\n\n\n  Predicate.prototype.and = function (field, operator, value, ignoreCase, ignoreAccent) {\n    return Predicate.combine(this, field, operator, value, 'and', ignoreCase, ignoreAccent);\n  };\n  /**\n   * Adds n-number of new predicates on existing predicate with “or” condition.\n   * @param  {Object[]} args - Defines the collection of predicates.\n   */\n\n\n  Predicate.or = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return Predicate.combinePredicates([].slice.call(args, 0), 'or');\n  };\n  /**\n   * Adds new predicate on existing predicate with “or” condition.\n   * @param  {string} field - Defines the column field.\n   * @param  {string} operator - Defines the operator how to filter data.\n   * @param  {string} value - Defines the values to match with data.\n   * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else\n   * filter data with case insensitive.\n   */\n\n\n  Predicate.prototype.or = function (field, operator, value, ignoreCase, ignoreAccent) {\n    return Predicate.combine(this, field, operator, value, 'or', ignoreCase, ignoreAccent);\n  };\n  /**\n   * Converts plain JavaScript object to Predicate object.\n   * @param  {Predicate[]|Predicate} json - Defines single or collection of Predicate.\n   */\n\n\n  Predicate.fromJson = function (json) {\n    if (json instanceof Array) {\n      var res = [];\n\n      for (var i = 0, len = json.length; i < len; i++) {\n        res.push(this.fromJSONData(json[i]));\n      }\n\n      return res;\n    }\n\n    var pred = json;\n    return this.fromJSONData(pred);\n  };\n  /**\n   * Validate the record based on the predicates.\n   * @param  {Object} record - Defines the datasource record.\n   */\n\n\n  Predicate.prototype.validate = function (record) {\n    var predicate = this.predicates ? this.predicates : [];\n    var isAnd;\n    var ret;\n\n    if (!this.isComplex && this.comparer) {\n      return this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);\n    }\n\n    isAnd = this.condition === 'and';\n\n    for (var i = 0; i < predicate.length; i++) {\n      ret = predicate[i].validate(record);\n\n      if (isAnd) {\n        if (!ret) {\n          return false;\n        }\n      } else {\n        if (ret) {\n          return true;\n        }\n      }\n    }\n\n    return isAnd;\n  };\n  /**\n   * Converts predicates to plain JavaScript.\n   * This method is uses Json stringify when serializing Predicate object.\n   */\n\n\n  Predicate.prototype.toJson = function () {\n    var predicates;\n    var p;\n\n    if (this.isComplex) {\n      predicates = [];\n      p = this.predicates;\n\n      for (var i = 0; i < p.length; i++) {\n        predicates.push(p[i].toJson());\n      }\n    }\n\n    return {\n      isComplex: this.isComplex,\n      field: this.field,\n      operator: this.operator,\n      value: this.value,\n      ignoreCase: this.ignoreCase,\n      ignoreAccent: this.ignoreAccent,\n      condition: this.condition,\n      predicates: predicates\n    };\n  };\n\n  Predicate.combinePredicates = function (predicates, operator) {\n    if (predicates.length === 1) {\n      if (!(predicates[0] instanceof Array)) {\n        return predicates[0];\n      }\n\n      predicates = predicates[0];\n    }\n\n    return new Predicate(predicates[0], operator, predicates.slice(1));\n  };\n\n  Predicate.combine = function (pred, field, operator, value, condition, ignoreCase, ignoreAccent) {\n    if (field instanceof Predicate) {\n      return Predicate[condition](pred, field);\n    }\n\n    if (typeof field === 'string') {\n      return Predicate[condition](pred, new Predicate(field, operator, value, ignoreCase, ignoreAccent));\n    }\n\n    return DataUtil.throwError('Predicate - ' + condition + ' : invalid arguments');\n  };\n\n  Predicate.fromJSONData = function (json) {\n    var preds = json.predicates || [];\n    var len = preds.length;\n    var predicates = [];\n    var result;\n\n    for (var i = 0; i < len; i++) {\n      predicates.push(this.fromJSONData(preds[i]));\n    }\n\n    if (!json.isComplex) {\n      result = new Predicate(json.field, json.operator, json.value, json.ignoreCase, json.ignoreAccent);\n    } else {\n      result = new Predicate(predicates[0], json.condition, predicates.slice(1));\n    }\n\n    return result;\n  };\n\n  return Predicate;\n}();\n\nexport { Predicate };","map":null,"metadata":{},"sourceType":"module"}