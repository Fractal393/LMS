{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * React Component Base\n */\n\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { extend, isNullOrUndefined, setValue, getValue } from '@syncfusion/ej2-base'; // tslint:disable\n\nvar ComponentBaseHybrid =\n/** @class */\nfunction (_super) {\n  __extends(ComponentBaseHybrid, _super);\n\n  function ComponentBaseHybrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.attrKeys = [];\n    _this.cachedTimeOut = 0;\n    _this.isAppendCalled = false;\n    _this.isReact = true;\n    return _this;\n  } // Lifecycle methods are changed by React team and so we can deprecate this method and use\n  // Reference link:https://reactjs.org/docs/react-component.html#unsafe_componentWillMount\n  // tslint:disable-next-line:no-any\n\n  /**\n   * @private\n   */\n\n\n  ComponentBaseHybrid.prototype.UNSAFE_componentWillMount = function () {\n    this.isReact = true;\n  };\n  /* tslint:disable:no-any */\n\n\n  ComponentBaseHybrid.prototype.generateReactElements = function (ele) {\n    var childrens = ele.children;\n\n    if (childrens && childrens.length) {\n      var childObject = [];\n\n      for (var i = 0, length_1 = childrens.length; i < length_1; i++) {\n        var child = childrens[i];\n\n        if (typeof child === 'string') {\n          childObject.push(child);\n        } else {\n          if (!child.tagName) {\n            if (child.template) {\n              childObject.push(React.createElement(child.template, child.data || {}));\n            }\n          } else {\n            childObject.push(this.generateReactElements(child));\n          }\n        }\n      }\n\n      return React.createElement(ele.tagName, ele.attributes, childObject);\n    } else {\n      return React.createElement(ele.tagName, ele.attributes);\n    }\n  };\n\n  ComponentBaseHybrid.prototype.componentDidMount = function () {\n    if (this.mount) {\n      this.mount();\n    }\n  };\n\n  ComponentBaseHybrid.prototype.componentDidUpdate = function () {\n    this.currentContext(this.currentContext.calls, this.currentContext.args);\n  }; // Lifecycle methods are changed by React team and so we can deprecate this method and use\n  // Reference link:https://reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops\n  // tslint:disable-next-line:no-any\n\n  /**\n   * @private\n   */\n\n\n  ComponentBaseHybrid.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var _this = this;\n\n    if (!this.isAppendCalled) {\n      clearTimeout(this.cachedTimeOut);\n      this.isAppendCalled = true;\n      this.appendTo(ReactDOM.findDOMNode(this));\n    }\n\n    var dProps = extend({}, nextProps);\n    var keys = Object.keys(nextProps);\n\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var propkey = keys_1[_i];\n      var isClassName = propkey === 'className';\n\n      if (!isClassName && !isNullOrUndefined(this.htmlattributes[propkey]) && this.htmlattributes[propkey] !== dProps[propkey]) {\n        this.htmlattributes[propkey] = dProps[propkey];\n      }\n\n      if (this.props[propkey] === nextProps[propkey]) {\n        delete dProps[propkey];\n      } else if (this.attrKeys.indexOf(propkey) !== -1) {\n        if (isClassName) {\n          this.element.classList.remove(this.props[propkey]);\n          this.element.classList.add(dProps[propkey]);\n        } else if (propkey !== 'disabled') {\n          delete dProps[propkey];\n        }\n      }\n    }\n\n    if (dProps['children']) {\n      delete dProps['children'];\n    } // tslint:disable-next-line:no-any\n\n\n    if (this.canDelayUpdate || this.props.delayUpdate) {\n      setTimeout(function () {\n        _this.refreshProperties(dProps, nextProps);\n      });\n    } else {\n      this.refreshProperties(dProps, nextProps);\n    }\n  };\n\n  ComponentBaseHybrid.prototype.refreshProperties = function (dProps, nextProps) {\n    if (Object.keys(dProps).length) {\n      // tslint:disable-next-line:no-any\n      this.processComplexTemplate(dProps, this);\n      this.setProperties(dProps);\n    }\n\n    this.refreshChild(false, nextProps);\n  };\n\n  ComponentBaseHybrid.prototype.processComplexTemplate = function (curObject, context) {\n    var compTemplate = context.complexTemplate;\n\n    if (compTemplate) {\n      for (var prop in compTemplate) {\n        var PropVal = compTemplate[prop];\n\n        if (curObject[prop]) {\n          setValue(PropVal, getValue(prop, curObject), curObject);\n        }\n      }\n    }\n  };\n  /* tslint:disable:no-any */\n\n\n  ComponentBaseHybrid.prototype.trigger = function (eventName, eventProp, successHandler) {\n    if (this.isDestroyed !== true) {\n      if (eventName === 'change' || eventName === 'input') {\n        if (this.props.onChange && eventProp.event) {\n          this.props.onChange.call(undefined, {\n            syntheticEvent: eventProp.event,\n            nativeEvent: {\n              text: eventProp.value\n            },\n            value: eventProp.value,\n            target: this\n          });\n        }\n      }\n\n      var prevDetection = this.isProtectedOnChange;\n      this.isProtectedOnChange = false;\n      this.modelObserver.notify(eventName, eventProp, successHandler);\n      this.isProtectedOnChange = prevDetection;\n    }\n  };\n\n  ComponentBaseHybrid.prototype.compareObjects = function (oldProps, newProps) {\n    return JSON.stringify(oldProps) === JSON.stringify(newProps);\n  };\n\n  ComponentBaseHybrid.prototype.refreshChild = function (silent, props) {\n    if (this.checkInjectedModules) {\n      var prevModule = this.getInjectedModules() || [];\n      var curModule = this.getInjectedServices() || [];\n\n      for (var _i = 0, curModule_1 = curModule; _i < curModule_1.length; _i++) {\n        var mod = curModule_1[_i];\n\n        if (prevModule.indexOf(mod) === -1) {\n          prevModule.push(mod);\n        }\n      }\n\n      this.injectedModules = prevModule;\n    }\n\n    if (this.directivekeys) {\n      var directiveValue = this.validateChildren({}, this.directivekeys, props || this.props);\n\n      if (directiveValue) {\n        if (!silent && this.skipRefresh) {\n          for (var _a = 0, _b = this.skipRefresh; _a < _b.length; _a++) {\n            var fields = _b[_a];\n            delete directiveValue[fields];\n          }\n        }\n\n        if (this.prevProperties) {\n          var dKeys = Object.keys(this.prevProperties);\n\n          for (var i = 0; i < dKeys.length; i++) {\n            var key = dKeys[i];\n\n            if (this.compareObjects(this.prevProperties[key], directiveValue[key])) {\n              delete directiveValue[key];\n            } else {\n              var obj = {};\n              obj[key] = directiveValue[key];\n              this.prevProperties = extend(this.prevProperties, obj);\n            }\n          }\n        } else {\n          this.prevProperties = extend({}, directiveValue, {}, true);\n        }\n\n        this.setProperties(directiveValue, silent);\n      }\n    }\n  };\n\n  ComponentBaseHybrid.prototype.componentWillUnmount = function () {\n    clearTimeout(this.cachedTimeOut);\n    this.destroy();\n  };\n  /* tslint:disable:no-any */\n\n\n  ComponentBaseHybrid.prototype.validateChildren = function (childCache, mapper, props) {\n    var flag = false;\n    var childs = React.Children.toArray(props.children);\n\n    for (var _i = 0, childs_1 = childs; _i < childs_1.length; _i++) {\n      var child = childs_1[_i];\n      var ifield = this.getChildType(child);\n      var key = mapper[ifield];\n\n      if (ifield && mapper) {\n        // tslint:disable\n        var childProps = this.getChildProps(React.Children.toArray(child.props.children), key);\n\n        if (childProps.length) {\n          flag = true; // tslint:disable\n\n          childCache[child.type.propertyName || ifield] = childProps;\n        }\n      }\n    }\n\n    if (flag) {\n      return childCache;\n    }\n\n    return null;\n  }; // tslint:disable:no-any\n\n\n  ComponentBaseHybrid.prototype.getChildType = function (child) {\n    if (child.type && child.type.isDirective) {\n      return child.type.moduleName || '';\n    }\n\n    return '';\n  };\n\n  ComponentBaseHybrid.prototype.getChildProps = function (subChild, matcher) {\n    var ret = [];\n\n    for (var _i = 0, subChild_1 = subChild; _i < subChild_1.length; _i++) {\n      var child = subChild_1[_i];\n      var accessProp = false;\n      var key = void 0;\n\n      if (typeof matcher === 'string') {\n        accessProp = true;\n        key = matcher;\n      } else {\n        key = Object.keys(matcher)[0];\n      }\n\n      var prop = child.props; // tslint:disable-next-line:no-any\n\n      var field = this.getChildType(child);\n\n      if (field === key) {\n        if (accessProp || !prop.children) {\n          // tslint:disable\n          var cacheVal = extend({}, prop, {}, true); // tslint:disable\n\n          this.processComplexTemplate(cacheVal, child.type);\n          ret.push(cacheVal);\n        } else {\n          var cachedValue = this.validateChildren(extend({}, prop), matcher[key], prop) || prop;\n\n          if (cachedValue['children']) {\n            delete cachedValue['children'];\n          } // tslint:disable\n\n\n          this.processComplexTemplate(cachedValue, child.type);\n          ret.push(cachedValue);\n        }\n      }\n    }\n\n    return ret;\n  }; // tslint:disable:no-any\n\n\n  ComponentBaseHybrid.prototype.getInjectedServices = function () {\n    var childs = React.Children.toArray(this.props.children);\n\n    for (var _i = 0, childs_2 = childs; _i < childs_2.length; _i++) {\n      var child = childs_2[_i];\n      /* tslint:disable:no-any */\n\n      if (child.type.isService) {\n        return child.props.services;\n      }\n    }\n\n    return [];\n  };\n\n  return ComponentBaseHybrid;\n}(React.PureComponent);\n\nexport { ComponentBaseHybrid };\n/* tslint:enable:no-any */","map":null,"metadata":{},"sourceType":"module"}