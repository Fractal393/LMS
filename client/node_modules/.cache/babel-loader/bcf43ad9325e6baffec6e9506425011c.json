{"ast":null,"code":"import { closest, addClass } from '@syncfusion/ej2-base';\nimport { extend, getValue, resetBlazorTemplate, updateBlazorTemplate, isBlazor } from '@syncfusion/ej2-base';\nimport { remove } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport * as events from '../base/constant';\nimport { EditRender } from '../renderer/edit-renderer';\nimport { BooleanEditCell } from '../renderer/boolean-edit-cell';\nimport { DropDownEditCell } from '../renderer/dropdown-edit-cell';\nimport { NumericEditCell } from '../renderer/numeric-edit-cell';\nimport { DefaultEditCell } from '../renderer/default-edit-cell';\nimport { InlineEdit } from './inline-edit';\nimport { BatchEdit } from './batch-edit';\nimport { DialogEdit } from './dialog-edit';\nimport { Dialog } from '@syncfusion/ej2-popups';\nimport { parentsUntil, getComplexFieldID, setComplexFieldID, getScrollBarWidth } from '../base/util';\nimport { FormValidator } from '@syncfusion/ej2-inputs';\nimport { DatePickerEditCell } from '../renderer/datepicker-edit-cell';\nimport { calculateRelativeBasedPosition } from '@syncfusion/ej2-popups';\nimport { TemplateEditCell } from '../renderer/template-edit-cell';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * The `Edit` module is used to handle editing actions.\n */\n\nvar Edit =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the Grid editing module\n   * @hidden\n   */\n  function Edit(parent, serviceLocator) {\n    this.editType = {\n      'Inline': InlineEdit,\n      'Normal': InlineEdit,\n      'Batch': BatchEdit,\n      'Dialog': DialogEdit\n    };\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.l10n = this.serviceLocator.getService('localization');\n    this.addEventListener();\n    this.updateEditObj();\n    this.createAlertDlg();\n    this.createConfirmDlg();\n  }\n\n  Edit.prototype.updateColTypeObj = function () {\n    var cols = this.parent.columnModel;\n\n    for (var i = 0; i < cols.length; i++) {\n      if (this.parent.editSettings.template || cols[i].editTemplate) {\n        var templteCell = 'templateedit';\n        cols[i].edit = extend(new Edit.editCellType[templteCell](this.parent), cols[i].edit || {});\n      } else {\n        cols[i].edit = extend(new Edit.editCellType[cols[i].editType && Edit.editCellType[cols[i].editType] ? cols[i].editType : 'defaultedit'](this.parent, this.serviceLocator), cols[i].edit || {});\n      }\n    }\n\n    this.parent.log('primary_column_missing');\n  };\n  /**\n   * For internal use only - Get the module name.\n   * @private\n   */\n\n\n  Edit.prototype.getModuleName = function () {\n    return 'edit';\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.onPropertyChanged = function (e) {\n    if (e.module !== this.getModuleName()) {\n      return;\n    }\n\n    var gObj = this.parent;\n    var newProp = e.properties;\n\n    for (var _i = 0, _a = Object.keys(e.properties); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'allowAdding':\n        case 'allowDeleting':\n        case 'allowEditing':\n          if (gObj.editSettings.allowAdding || gObj.editSettings.allowEditing || gObj.editSettings.allowDeleting) {\n            this.initialEnd();\n          }\n\n          break;\n\n        case 'mode':\n          this.updateEditObj();\n          gObj.isEdit = false;\n          gObj.refresh();\n          break;\n      }\n    }\n  };\n\n  Edit.prototype.updateEditObj = function () {\n    if (this.editModule) {\n      this.editModule.destroy();\n    }\n\n    this.renderer = new EditRender(this.parent, this.serviceLocator);\n    this.editModule = new this.editType[this.parent.editSettings.mode](this.parent, this.serviceLocator, this.renderer);\n  };\n\n  Edit.prototype.initialEnd = function () {\n    this.updateColTypeObj();\n  };\n  /**\n   * Edits any bound record in the Grid by TR element.\n   * @param {HTMLTableRowElement} tr - Defines the table row to be edited.\n   */\n\n\n  Edit.prototype.startEdit = function (tr) {\n    var gObj = this.parent;\n\n    if (!gObj.editSettings.allowEditing || gObj.isEdit || gObj.editSettings.mode === 'Batch') {\n      return;\n    }\n\n    this.parent.element.classList.add('e-editing');\n\n    if (!gObj.getSelectedRows().length) {\n      if (!tr) {\n        this.showDialog('EditOperationAlert', this.alertDObj);\n        return;\n      }\n    } else if (!tr) {\n      tr = gObj.getSelectedRows()[0];\n    }\n\n    this.isLastRow = tr.rowIndex === this.parent.getContent().querySelector('tr:last-child').rowIndex;\n\n    if (tr.style.display === 'none') {\n      return;\n    }\n\n    this.editModule.startEdit(tr);\n\n    if (!isBlazor()) {\n      this.refreshToolbar();\n      gObj.element.querySelector('.e-gridpopup').style.display = 'none';\n      this.parent.notify('start-edit', {});\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.checkLastRow = function (tr, args) {\n    var checkLastRow = this.isLastRow;\n\n    if (this.parent.height !== 'auto' && this.parent.editSettings.newRowPosition === 'Bottom' && args && args.requestType === 'add' && this.parent.height > this.parent.getContentTable().scrollHeight) {\n      addClass(tr.querySelectorAll('.e-rowcell'), 'e-lastrowadded');\n    } else if (checkLastRow && tr && tr.classList) {\n      addClass(tr.querySelectorAll('.e-rowcell'), 'e-lastrowcell');\n    }\n  };\n  /**\n   * Cancels edited state.\n   */\n\n\n  Edit.prototype.closeEdit = function () {\n    if (this.parent.editSettings.mode === 'Batch' && this.parent.editSettings.showConfirmDialog && this.parent.element.querySelectorAll('.e-updatedtd').length) {\n      this.showDialog('CancelEdit', this.dialogObj);\n      return;\n    }\n\n    this.parent.element.classList.remove('e-editing');\n    this.editModule.closeEdit();\n\n    if (!isBlazor()) {\n      this.refreshToolbar();\n      this.parent.notify('close-edit', {});\n    }\n  };\n\n  Edit.prototype.refreshToolbar = function () {\n    this.parent.notify(events.toolbarRefresh, {});\n  };\n  /**\n   * To adds a new row at the top with the given data. When data is not passed, it will add empty rows.\n   * > `editSettings.allowEditing` should be true.\n   * @param {Object} data - Defines the new add record data.\n   * @param {number} index - Defines the row index to be added\n   */\n\n\n  Edit.prototype.addRecord = function (data, index) {\n    if (!this.parent.editSettings.allowAdding) {\n      return;\n    }\n\n    var args = {\n      startEdit: true\n    };\n\n    if (!data) {\n      this.parent.notify(events.virtualScrollAddActionBegin, args);\n    }\n\n    if (args.startEdit) {\n      this.parent.element.classList.add('e-editing');\n      this.editModule.addRecord(data, index);\n\n      if (!isBlazor()) {\n        this.refreshToolbar();\n        this.parent.notify('start-add', {});\n      }\n    }\n  };\n  /**\n   * Deletes a record with the given options. If fieldname and data are not given, the Grid will delete the selected record.\n   * > `editSettings.allowDeleting` should be true.\n   * @param {string} fieldname - Defines the primary key field name of the column.\n   * @param {Object} data - Defines the JSON data record to be deleted.\n   */\n\n\n  Edit.prototype.deleteRecord = function (fieldname, data) {\n    var gObj = this.parent;\n\n    if (!gObj.editSettings.allowDeleting) {\n      return;\n    }\n\n    if (!data) {\n      if (!gObj.getSelectedRecords().length && isNullOrUndefined(gObj.commandDelIndex)) {\n        this.showDialog('DeleteOperationAlert', this.alertDObj);\n        return;\n      }\n    }\n\n    if (gObj.editSettings.showDeleteConfirmDialog) {\n      this.showDialog('ConfirmDelete', this.dialogObj);\n      return;\n    }\n\n    this.editModule.deleteRecord(fieldname, data);\n  };\n  /**\n   * Deletes a visible row by TR element.\n   * @param {HTMLTableRowElement} tr - Defines the table row element.\n   */\n\n\n  Edit.prototype.deleteRow = function (tr) {\n    this.deleteRowUid = tr.getAttribute('data-uid');\n    var rowObj = this.parent.getRowObjectFromUID(this.deleteRowUid);\n\n    if (!isNullOrUndefined(rowObj)) {\n      this.deleteRecord(null, rowObj.data);\n    }\n  };\n  /**\n   * If Grid is in editable state, you can save a record by invoking endEdit.\n   */\n\n\n  Edit.prototype.endEdit = function () {\n    if (this.parent.editSettings.mode === 'Batch' && this.parent.editSettings.showConfirmDialog && (isNullOrUndefined(this.formObj) || this.formObj.validate())) {\n      this.parent.editModule.saveCell();\n      this.parent.notify(events.editNextValCell, {});\n\n      if (isNullOrUndefined(this.formObj) || this.formObj.validate()) {\n        this.showDialog('BatchSaveConfirm', this.dialogObj);\n        return;\n      }\n    }\n\n    this.endEditing();\n  };\n  /**\n   * To update the specified cell by given value without changing into edited state.\n   * @param {number} rowIndex Defines the row index.\n   * @param {string} field Defines the column field.\n   * @param {string | number | boolean | Date} value - Defines the value to be changed.\n   */\n\n\n  Edit.prototype.updateCell = function (rowIndex, field, value) {\n    this.editModule.updateCell(rowIndex, field, value);\n  };\n  /**\n   * To update the specified row by given values without changing into edited state.\n   * @param {number} index Defines the row index.\n   * @param {Object} data Defines the data object to be updated.\n   */\n\n\n  Edit.prototype.updateRow = function (index, data) {\n    this.editModule.updateRow(index, data);\n  };\n  /**\n   * Resets added, edited, and deleted records in the batch mode.\n   */\n\n\n  Edit.prototype.batchCancel = function () {\n    this.closeEdit();\n  };\n  /**\n   * Bulk saves added, edited, and deleted records in the batch mode.\n   */\n\n\n  Edit.prototype.batchSave = function () {\n    this.endEdit();\n  };\n  /**\n   * Changes a particular cell into edited state based on the row index and field name provided in the `batch` mode.\n   * @param {number} index - Defines row index to edit a particular cell.\n   * @param {string} field - Defines the field name of the column to perform batch edit.\n   */\n\n\n  Edit.prototype.editCell = function (index, field) {\n    this.editModule.editCell(index, field);\n  };\n  /**\n   * Checks the status of validation at the time of editing. If validation is passed, it returns true.\n   * @return {boolean}\n   */\n\n\n  Edit.prototype.editFormValidate = function () {\n    if (this.formObj) {\n      return this.formObj.validate();\n    }\n\n    return false;\n  };\n  /**\n   * Gets the added, edited,and deleted data before bulk save to the DataSource in batch mode.\n   * @return {Object}\n   */\n\n\n  Edit.prototype.getBatchChanges = function () {\n    return this.editModule.getBatchChanges ? this.editModule.getBatchChanges() : {};\n  };\n  /**\n   * Gets the current value of the edited component.\n   */\n\n\n  Edit.prototype.getCurrentEditCellData = function () {\n    var obj = this.getCurrentEditedData(this.formObj.element, {});\n    return obj[Object.keys(obj)[0]];\n  };\n  /**\n   * Saves the cell that is currently edited. It does not save the value to the DataSource.\n   */\n\n\n  Edit.prototype.saveCell = function () {\n    this.editModule.saveCell();\n  };\n\n  Edit.prototype.endEditing = function () {\n    this.parent.element.classList.remove('e-editing');\n    this.editModule.endEdit();\n    this.refreshToolbar();\n  };\n\n  Edit.prototype.showDialog = function (content, obj) {\n    obj.content = '<div>' + this.l10n.getConstant(content) + '</div>';\n    obj.dataBind();\n    obj.show();\n  };\n\n  Edit.prototype.getValueFromType = function (col, value) {\n    var val = value;\n\n    switch (col.type) {\n      case 'number':\n        val = !isNaN(parseFloat(value)) ? parseFloat(value) : null;\n        break;\n\n      case 'boolean':\n        if (col.editType !== 'booleanedit') {\n          val = value === this.l10n.getConstant('True') || value === true ? true : false;\n        }\n\n        break;\n\n      case 'date':\n      case 'datetime':\n        if (col.editType !== 'datepickeredit' && col.editType !== 'datetimepickeredit' && value && value.length) {\n          val = new Date(value);\n        } else if (value === '') {\n          val = null;\n        }\n\n        break;\n    }\n\n    return val;\n  };\n\n  Edit.prototype.destroyToolTip = function () {\n    var elements = [].slice.call(this.parent.element.querySelectorAll('.e-griderror'));\n\n    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n      var elem = elements_1[_i];\n      remove(elem);\n    }\n\n    this.parent.getContent().firstElementChild.style.position = 'relative';\n  };\n\n  Edit.prototype.createConfirmDlg = function () {\n    this.dialogObj = this.dlgWidget([{\n      click: this.dlgOk.bind(this),\n      buttonModel: {\n        content: this.l10n.getConstant('OKButton'),\n        cssClass: 'e-primary',\n        isPrimary: true\n      }\n    }, {\n      click: this.dlgCancel.bind(this),\n      buttonModel: {\n        cssClass: 'e-flat',\n        content: this.l10n.getConstant('CancelButton')\n      }\n    }], 'EditConfirm');\n  };\n\n  Edit.prototype.createAlertDlg = function () {\n    this.alertDObj = this.dlgWidget([{\n      click: this.alertClick.bind(this),\n      buttonModel: {\n        content: this.l10n.getConstant('OKButton'),\n        cssClass: 'e-flat',\n        isPrimary: true\n      }\n    }], 'EditAlert');\n  };\n\n  Edit.prototype.alertClick = function () {\n    this.alertDObj.hide();\n  };\n\n  Edit.prototype.dlgWidget = function (btnOptions, name) {\n    var div = this.parent.createElement('div', {\n      id: this.parent.element.id + name\n    });\n    this.parent.element.appendChild(div);\n    var options = {\n      showCloseIcon: false,\n      isModal: true,\n      visible: false,\n      closeOnEscape: true,\n      target: this.parent.element,\n      width: '320px',\n      animationSettings: {\n        effect: 'None'\n      }\n    };\n    options.buttons = btnOptions;\n    var obj = new Dialog(options);\n    var isStringTemplate = 'isStringTemplate';\n    obj[isStringTemplate] = true;\n    obj.appendTo(div);\n    return obj;\n  };\n\n  Edit.prototype.dlgCancel = function () {\n    this.parent.focusModule.clearIndicator();\n    this.parent.focusModule.restoreFocus();\n    this.dialogObj.hide();\n  };\n\n  Edit.prototype.dlgOk = function (e) {\n    switch (this.dialogObj.element.querySelector('.e-dlg-content').firstElementChild.innerText) {\n      case this.l10n.getConstant('ConfirmDelete'):\n        this.editModule.deleteRecord();\n        break;\n\n      case this.l10n.getConstant('CancelEdit'):\n        this.editModule.closeEdit();\n        break;\n\n      case this.l10n.getConstant('BatchSaveConfirm'):\n        this.endEditing();\n        break;\n\n      case this.l10n.getConstant('BatchSaveLostChanges'):\n        if (this.parent.editSettings.mode === 'Batch') {\n          this.editModule.addCancelWhilePaging();\n\n          if (isBlazor() && this.parent.isServerRendered) {\n            this.editModule.closeEdit();\n          }\n        }\n\n        this.executeAction();\n        break;\n    }\n\n    this.dlgCancel();\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.addEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(events.inBoundModelChanged, this.onPropertyChanged, this);\n    this.parent.on(events.initialEnd, this.initialEnd, this);\n    this.parent.on(events.keyPressed, this.keyPressHandler, this);\n    this.parent.on(events.autoCol, this.updateColTypeObj, this);\n    this.parent.on(events.tooltipDestroy, this.destroyToolTip, this);\n    this.parent.on(events.preventBatch, this.preventBatch, this);\n    this.parent.on(events.destroyForm, this.destroyForm, this);\n    this.actionBeginFunction = this.onActionBegin.bind(this);\n    this.actionCompleteFunction = this.actionComplete.bind(this);\n    this.parent.addEventListener(events.actionBegin, this.actionBeginFunction);\n    this.parent.addEventListener(events.actionComplete, this.actionCompleteFunction);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.removeEventListener = function () {\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.off(events.inBoundModelChanged, this.onPropertyChanged);\n    this.parent.off(events.initialEnd, this.initialEnd);\n    this.parent.off(events.keyPressed, this.keyPressHandler);\n    this.parent.off(events.autoCol, this.updateColTypeObj);\n    this.parent.off(events.tooltipDestroy, this.destroyToolTip);\n    this.parent.off(events.preventBatch, this.preventBatch);\n    this.parent.off(events.destroyForm, this.destroyForm);\n    this.parent.removeEventListener(events.actionComplete, this.actionCompleteFunction);\n    this.parent.removeEventListener(events.actionBegin, this.actionBeginFunction);\n  };\n\n  Edit.prototype.actionComplete = function (e) {\n    var actions = ['add', 'beginEdit', 'save', 'delete', 'cancel'];\n\n    if (actions.indexOf(e.requestType) < 0) {\n      this.parent.isEdit = false;\n    }\n\n    if (e.requestType === 'batchsave') {\n      this.parent.focusModule.restoreFocus();\n    }\n\n    this.refreshToolbar();\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.getCurrentEditedData = function (form, editedData) {\n    var gObj = this.parent;\n\n    if (gObj.editSettings.template) {\n      var elements = [].slice.call(form.elements);\n\n      for (var k = 0; k < elements.length; k++) {\n        if (elements[k].hasAttribute('name') && elements[k].className !== 'e-multi-hidden' || elements[k].classList.contains('e-multiselect')) {\n          var field = elements[k].hasAttribute('name') ? setComplexFieldID(elements[k].getAttribute('name')) : setComplexFieldID(elements[k].getAttribute('id'));\n          var column = gObj.getColumnByField(field) || {\n            field: field,\n            type: elements[k].getAttribute('type')\n          };\n          var value = void 0;\n\n          if (column.type === 'checkbox' || column.type === 'boolean') {\n            value = elements[k].checked;\n          } else if (elements[k].value) {\n            value = elements[k].value;\n\n            if (elements[k].ej2_instances && elements[k].ej2_instances.length && !isNullOrUndefined(elements[k].ej2_instances[0].value)) {\n              elements[k].blur();\n              value = elements[k].ej2_instances[0].value;\n\n              if ((column.type === 'date' || column.type === 'dateTime' || column.type === 'datetime') && elements[k].ej2_instances[0].isServerRendered) {\n                value = elements[k].value;\n              }\n            }\n          } else if (elements[k].ej2_instances) {\n            value = elements[k].ej2_instances[0].value;\n          }\n\n          if (column.edit && typeof column.edit.read === 'string') {\n            value = getValue(column.edit.read, window)(elements[k], value);\n          } else if (column.edit && column.edit.read) {\n            value = column.edit.read(elements[k], value);\n          }\n\n          value = gObj.editModule.getValueFromType(column, value);\n          DataUtil.setValue(column.field, value, editedData);\n        }\n      }\n\n      return editedData;\n    }\n\n    var col = gObj.columnModel.filter(function (col) {\n      return col.editTemplate;\n    });\n\n    for (var j = 0; j < col.length; j++) {\n      if (form[getComplexFieldID(col[j].field)]) {\n        var inputElements = [].slice.call(form[getComplexFieldID(col[j].field)]);\n        inputElements = inputElements.length ? inputElements : [form[getComplexFieldID(col[j].field)]];\n        var temp = inputElements.filter(function (e) {\n          return !isNullOrUndefined(e.ej2_instances);\n        });\n\n        if (temp.length === 0) {\n          temp = inputElements.filter(function (e) {\n            return e.hasAttribute('name');\n          });\n        }\n\n        for (var k = 0; k < temp.length; k++) {\n          var value = this.getValue(col[j], temp[k], editedData);\n          DataUtil.setValue(col[j].field, value, editedData);\n        }\n      }\n    }\n\n    var inputs = [].slice.call(form.querySelectorAll('.e-field'));\n\n    for (var i = 0, len = inputs.length; i < len; i++) {\n      var col_1 = gObj.getColumnByUid(inputs[i].getAttribute('e-mappinguid'));\n\n      if (col_1 && col_1.field) {\n        var value = this.getValue(col_1, inputs[i], editedData);\n        DataUtil.setValue(col_1.field, value, editedData);\n      }\n    }\n\n    return editedData;\n  };\n\n  Edit.prototype.getValue = function (col, input, editedData) {\n    var value = input.ej2_instances && !(isBlazor() && input.ej2_instances[0].isServerRendered && (col.type === 'date' || col.type === 'datetime')) ? input.ej2_instances[0].value : input.value;\n    var gObj = this.parent;\n    var temp = col.edit.read;\n\n    if (col.type === 'checkbox' || col.type === 'boolean') {\n      value = input.checked;\n    }\n\n    if (typeof temp === 'string') {\n      temp = getValue(temp, window);\n      value = gObj.editModule.getValueFromType(col, temp(input, value));\n    } else {\n      value = gObj.editModule.getValueFromType(col, col.edit.read(input, value));\n    }\n\n    if (isNullOrUndefined(editedData[col.field]) && value === '') {\n      value = editedData[col.field];\n    }\n\n    return value;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.onActionBegin = function (e) {\n    if (e.requestType === 'columnstate' && this.parent.isEdit && this.parent.editSettings.mode !== 'Batch') {\n      this.closeEdit();\n    } else {\n      var restrictedRequestTypes = ['filterafteropen', 'filterbeforeopen', 'filterchoicerequest', 'save', 'infiniteScroll'];\n\n      if (this.parent.editSettings.mode !== 'Batch' && this.formObj && !this.formObj.isDestroyed && restrictedRequestTypes.indexOf(e.requestType) === -1 && !e.cancel) {\n        this.destroyWidgets();\n        this.destroyForm();\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.destroyWidgets = function (cols) {\n    var gObj = this.parent;\n\n    if (gObj.editSettings.template) {\n      this.parent.destroyTemplate(['editSettingsTemplate']);\n    }\n\n    cols = cols ? cols : this.parent.getVisibleColumns();\n\n    if (cols.some(function (column) {\n      return !isNullOrUndefined(column.editTemplate);\n    })) {\n      this.parent.destroyTemplate(['editTemplate']);\n    }\n\n    for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n      var col = cols_1[_i];\n      var temp = col.edit.destroy;\n\n      if (isBlazor() && col.editTemplate) {\n        resetBlazorTemplate(this.parent.element.id + col.uid + 'editTemplate', 'EditTemplate');\n        updateBlazorTemplate(this.parent.element.id + col.uid + 'editTemplate', 'EditTemplate', col, false);\n      }\n\n      if (col.edit.destroy) {\n        if (typeof temp === 'string') {\n          temp = getValue(temp, window);\n          temp();\n        } else {\n          col.edit.destroy();\n        }\n      }\n    }\n\n    var elements = [].slice.call(this.formObj.element.elements);\n\n    for (var i = 0; i < elements.length; i++) {\n      if (elements[i].hasAttribute('name')) {\n        if (elements[i].ej2_instances && elements[i].ej2_instances.length && !elements[i].ej2_instances[0].isDestroyed) {\n          elements[i].ej2_instances[0].destroy();\n        }\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.destroyForm = function () {\n    this.destroyToolTip();\n\n    if (this.formObj && !this.formObj.isDestroyed) {\n      this.formObj.destroy();\n    }\n\n    this.destroyToolTip();\n  };\n  /**\n   * To destroy the editing.\n   * @return {void}\n   * @hidden\n   */\n\n\n  Edit.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (!gridElement) {\n      return;\n    }\n\n    var hasGridChild = gridElement.querySelector('.e-gridheader') && gridElement.querySelector('.e-gridcontent') ? true : false;\n\n    if (hasGridChild) {\n      this.destroyForm();\n    }\n\n    this.removeEventListener();\n    var elem = this.dialogObj.element;\n\n    if (elem.childElementCount > 0) {\n      this.dialogObj.destroy();\n      remove(elem);\n    }\n\n    elem = this.alertDObj.element;\n\n    if (elem.childElementCount > 0) {\n      this.alertDObj.destroy();\n      remove(elem);\n    }\n\n    if (!hasGridChild) {\n      return;\n    }\n\n    if (this.editModule) {\n      this.editModule.destroy();\n    }\n  };\n\n  Edit.prototype.keyPressHandler = function (e) {\n    switch (e.action) {\n      case 'insert':\n        this.addRecord();\n        break;\n\n      case 'delete':\n        if ((e.target.tagName !== 'INPUT' || e.target.classList.contains('e-checkselect')) && !document.querySelector('.e-popup-open')) {\n          this.deleteRecord();\n        }\n\n        break;\n\n      case 'f2':\n        this.startEdit();\n        break;\n\n      case 'enter':\n        if (!parentsUntil(e.target, 'e-unboundcelldiv') && this.parent.editSettings.mode !== 'Batch' && (parentsUntil(e.target, 'e-gridcontent') || this.parent.frozenRows && parentsUntil(e.target, 'e-headercontent')) && !document.querySelectorAll('.e-popup-open').length) {\n          e.preventDefault();\n          this.endEdit();\n        }\n\n        break;\n\n      case 'escape':\n        if (this.parent.isEdit) {\n          if (this.parent.editSettings.mode === 'Batch') {\n            this.editModule.escapeCellEdit();\n          } else {\n            this.closeEdit();\n          }\n        }\n\n        break;\n    }\n  };\n\n  Edit.prototype.preventBatch = function (args) {\n    this.preventObj = args;\n    this.showDialog('BatchSaveLostChanges', this.dialogObj);\n  };\n\n  Edit.prototype.executeAction = function () {\n    this.preventObj.handler.call(this.preventObj.instance, this.preventObj.arg1, this.preventObj.arg2, this.preventObj.arg3, this.preventObj.arg4, this.preventObj.arg5, this.preventObj.arg6, this.preventObj.arg7, this.preventObj.arg8);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.applyFormValidation = function (cols) {\n    var gObj = this.parent;\n    var frzCols = gObj.getFrozenColumns();\n    var form = this.parent.editSettings.mode !== 'Dialog' ? gObj.element.querySelector('.e-gridform') : document.querySelector('#' + gObj.element.id + '_dialogEdit_wrapper').querySelector('.e-gridform');\n    var mForm = gObj.element.querySelectorAll('.e-gridform')[1];\n    var rules = {};\n    var mRules = {};\n    cols = cols ? cols : gObj.getColumns();\n\n    for (var i = 0; i < cols.length; i++) {\n      if (!cols[i].visible) {\n        continue;\n      }\n\n      if (isBlazor() && cols[i].editTemplate) {\n        continue;\n      }\n\n      if (i < frzCols && cols[i].validationRules) {\n        rules[getComplexFieldID(cols[i].field)] = cols[i].validationRules;\n      } else if (i >= frzCols && cols[i].validationRules) {\n        mRules[getComplexFieldID(cols[i].field)] = cols[i].validationRules;\n      }\n    }\n\n    if (frzCols && this.parent.editSettings.mode !== 'Dialog') {\n      this.parent.editModule.mFormObj = this.createFormObj(mForm, mRules);\n    } else {\n      rules = extend(rules, mRules);\n    }\n\n    if (isBlazor() && this.parent.editSettings.template) {\n      this.parent.editModule.formObj = this.createFormObj(form, {});\n    } else {\n      this.parent.editModule.formObj = this.createFormObj(form, rules);\n    }\n  };\n\n  Edit.prototype.createFormObj = function (form, rules) {\n    var _this = this;\n\n    return new FormValidator(form, {\n      rules: rules,\n      locale: this.parent.locale,\n      validationComplete: function (args) {\n        _this.validationComplete(args);\n      },\n      customPlacement: function (inputElement, error) {\n        var uid = inputElement.getAttribute('e-mappinguid');\n        var args = {\n          column: _this.parent.getColumnByUid(uid),\n          error: error,\n          inputElement: inputElement,\n          value: inputElement.value\n        };\n\n        _this.valErrorPlacement(inputElement, error);\n\n        _this.parent.notify(events.valCustomPlacement, args);\n      }\n    });\n  };\n\n  Edit.prototype.valErrorPlacement = function (inputElement, error) {\n    if (this.parent.isEdit) {\n      var id = error.getAttribute('for');\n      var elem = this.getElemTable(inputElement).querySelector('#' + id + '_Error');\n\n      if (!elem) {\n        this.createTooltip(inputElement, error, id, '');\n      } else {\n        elem.querySelector('.e-tip-content').innerHTML = error.outerHTML;\n      }\n    }\n  };\n\n  Edit.prototype.getElemTable = function (inputElement) {\n    var isFHdr;\n\n    if (this.parent.editSettings.mode !== 'Dialog') {\n      isFHdr = this.parent.frozenRows && this.parent.frozenRows > (parseInt(closest(inputElement, '.e-row').getAttribute('aria-rowindex'), 10) || 0);\n    }\n\n    return this.parent.editSettings.mode !== 'Dialog' ? isFHdr ? this.parent.getHeaderTable() : this.parent.getContentTable() : document.querySelector('#' + this.parent.element.id + '_dialogEdit_wrapper');\n  };\n\n  Edit.prototype.validationComplete = function (args) {\n    if (this.parent.isEdit) {\n      var elem = this.getElemTable(args.element).querySelector('#' + args.inputName + '_Error');\n\n      if (elem) {\n        if (args.status === 'failure') {\n          elem.style.display = '';\n        } else {\n          elem.style.display = 'none';\n        }\n      }\n    }\n  }; // tslint:disable-next-line:max-func-body-length\n\n\n  Edit.prototype.createTooltip = function (element, error, name, display) {\n    var gcontent = this.parent.getContent().firstElementChild;\n\n    if (this.parent.getFrozenColumns()) {\n      gcontent = this.parent.getMovableVirtualContent();\n    }\n\n    var isScroll = gcontent.scrollHeight > gcontent.clientHeight || gcontent.scrollWidth > gcontent.clientWidth;\n    var isInline = this.parent.editSettings.mode !== 'Dialog';\n    var td = closest(element, '.e-rowcell');\n    var row = closest(element, '.e-row');\n    var fCont = this.parent.getContent().querySelector('.e-frozencontent');\n    var isFHdr;\n    var isFHdrLastRow = false;\n    var validationForBottomRowPos;\n    var isBatchModeLastRow = false;\n    var viewPortRowCount = Math.round(this.parent.getContent().clientHeight / this.parent.getRowHeight()) - 1;\n    var rows = !fCont ? [].slice.call(this.parent.getContent().querySelectorAll('.e-row')) : [].slice.call(this.parent.getFrozenVirtualContent().querySelectorAll('.e-row'));\n\n    if (this.parent.editSettings.mode === 'Batch') {\n      if (viewPortRowCount > 1 && rows.length >= viewPortRowCount && rows[rows.length - 1].getAttribute('aria-rowindex') === row.getAttribute('aria-rowindex')) {\n        isBatchModeLastRow = true;\n      }\n    }\n\n    if (isInline) {\n      if (this.parent.frozenRows) {\n        var fHeraderRows = this.parent.getFrozenColumns() ? this.parent.getFrozenVirtualHeader().querySelector('tbody').children : this.parent.getHeaderTable().querySelector('tbody').children;\n        isFHdr = fHeraderRows.length > (parseInt(row.getAttribute('aria-rowindex'), 10) || 0);\n        isFHdrLastRow = isFHdr && parseInt(row.getAttribute('aria-rowindex'), 10) === fHeraderRows.length - 1;\n      }\n\n      if (isFHdrLastRow || viewPortRowCount > 1 && rows.length >= viewPortRowCount && (this.parent.editSettings.newRowPosition === 'Bottom' && this.editModule.args && this.editModule.args.requestType === 'add' || td.classList.contains('e-lastrowcell') && !row.classList.contains('e-addedrow')) || isBatchModeLastRow) {\n        validationForBottomRowPos = true;\n      }\n    }\n\n    var table = isInline ? isFHdr ? this.parent.getHeaderTable() : this.parent.getContentTable() : document.querySelector('#' + this.parent.element.id + '_dialogEdit_wrapper').querySelector('.e-dlg-content');\n    var client = table.getBoundingClientRect();\n    var left = isInline ? this.parent.element.getBoundingClientRect().left : client.left;\n    var input = closest(element, 'td');\n    var inputClient = input ? input.getBoundingClientRect() : element.parentElement.getBoundingClientRect();\n    var div = this.parent.createElement('div', {\n      className: 'e-tooltip-wrap e-lib e-control e-popup e-griderror',\n      id: name + '_Error',\n      styles: 'display:' + display + ';top:' + ((isFHdr ? inputClient.top + inputClient.height : inputClient.bottom - client.top - (this.parent.getFrozenColumns() ? fCont.scrollTop : 0)) + table.scrollTop + 9) + 'px;left:' + (inputClient.left - left + table.scrollLeft + inputClient.width / 2) + 'px;' + 'max-width:' + inputClient.width + 'px;text-align:center;'\n    });\n\n    if (isInline && client.left < left) {\n      div.style.left = parseInt(div.style.left, 10) - client.left + left + 'px';\n    }\n\n    var content = this.parent.createElement('div', {\n      className: 'e-tip-content'\n    });\n    content.appendChild(error);\n    var arrow;\n\n    if (validationForBottomRowPos) {\n      arrow = this.parent.createElement('div', {\n        className: 'e-arrow-tip e-tip-bottom'\n      });\n      arrow.appendChild(this.parent.createElement('div', {\n        className: 'e-arrow-tip-outer e-tip-bottom'\n      }));\n      arrow.appendChild(this.parent.createElement('div', {\n        className: 'e-arrow-tip-inner e-tip-bottom'\n      }));\n    } else {\n      arrow = this.parent.createElement('div', {\n        className: 'e-arrow-tip e-tip-top'\n      });\n      arrow.appendChild(this.parent.createElement('div', {\n        className: 'e-arrow-tip-outer e-tip-top'\n      }));\n      arrow.appendChild(this.parent.createElement('div', {\n        className: 'e-arrow-tip-inner e-tip-top'\n      }));\n    }\n\n    div.appendChild(content);\n    div.appendChild(arrow);\n\n    if ((this.parent.getFrozenColumns() || this.parent.frozenRows) && this.parent.editSettings.mode !== 'Dialog') {\n      var getEditCell = this.parent.editSettings.mode === 'Normal' ? closest(element, '.e-editcell') : closest(element, '.e-table');\n      getEditCell.style.position = 'relative';\n      div.style.position = 'absolute';\n\n      if (this.parent.editSettings.mode === 'Batch' || closest(element, '.e-frozencontent') || closest(element, '.e-frozenheader') || this.parent.frozenRows && !this.parent.getFrozenColumns()) {\n        this.formObj.element.appendChild(div);\n      } else {\n        this.mFormObj.element.appendChild(div);\n      }\n    } else {\n      this.formObj.element.appendChild(div);\n    }\n\n    if (!validationForBottomRowPos && isInline && gcontent.getBoundingClientRect().bottom < inputClient.bottom + inputClient.height) {\n      gcontent.scrollTop = gcontent.scrollTop + div.offsetHeight + arrow.scrollHeight;\n    }\n\n    var lineHeight = parseInt(document.defaultView.getComputedStyle(div, null).getPropertyValue('font-size'), 10);\n\n    if (div.getBoundingClientRect().width < inputClient.width && div.querySelector('label').getBoundingClientRect().height / (lineHeight * 1.2) >= 2) {\n      div.style.width = div.style.maxWidth;\n    }\n\n    if ((this.parent.getFrozenColumns() || this.parent.frozenRows) && (this.parent.editSettings.mode === 'Normal' || this.parent.editSettings.mode === 'Batch')) {\n      div.style.left = input.offsetLeft + (input.offsetWidth / 2 - div.offsetWidth / 2) + 'px';\n    } else {\n      div.style.left = parseInt(div.style.left, 10) - div.offsetWidth / 2 + 'px';\n    }\n\n    if (isInline && !isScroll && !this.parent.allowPaging || this.parent.getFrozenColumns() || this.parent.frozenRows) {\n      gcontent.style.position = 'static';\n      var pos = calculateRelativeBasedPosition(input, div);\n      div.style.top = pos.top + inputClient.height + 9 + 'px';\n    }\n\n    if (validationForBottomRowPos) {\n      if (isScroll && !this.parent.getFrozenColumns() && this.parent.height !== 'auto' && !this.parent.frozenRows && !this.parent.enableVirtualization) {\n        var scrollWidth = gcontent.scrollWidth > gcontent.offsetWidth ? getScrollBarWidth() : 0;\n        div.style.bottom = this.parent.height - gcontent.querySelector('table').offsetHeight - scrollWidth + inputClient.height + 9 + 'px';\n      } else {\n        div.style.bottom = inputClient.height + 9 + 'px';\n      }\n\n      if (rows.length < viewPortRowCount && this.parent.editSettings.newRowPosition === 'Bottom' && this.editModule.args && this.editModule.args.requestType === 'add') {\n        var rowsCount = this.parent.frozenRows ? this.parent.frozenRows + (rows.length - 1) : rows.length - 1;\n        var rowsHeight = rowsCount * this.parent.getRowHeight();\n        var position = this.parent.getContent().clientHeight - rowsHeight;\n        div.style.bottom = position + 9 + 'px';\n      }\n\n      div.style.top = null;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.prototype.checkColumnIsGrouped = function (col) {\n    return !col.visible && !(this.parent.groupSettings.columns.indexOf(col.field) > -1);\n  };\n  /**\n   * @hidden\n   */\n\n\n  Edit.AddEditors = function (editors) {\n    Edit.editCellType = extend(Edit.editCellType, editors);\n  };\n\n  Edit.editCellType = {\n    'dropdownedit': DropDownEditCell,\n    'numericedit': NumericEditCell,\n    'datepickeredit': DatePickerEditCell,\n    'datetimepickeredit': DatePickerEditCell,\n    'booleanedit': BooleanEditCell,\n    'defaultedit': DefaultEditCell,\n    'templateedit': TemplateEditCell\n  };\n  return Edit;\n}();\n\nexport { Edit };","map":null,"metadata":{},"sourceType":"module"}