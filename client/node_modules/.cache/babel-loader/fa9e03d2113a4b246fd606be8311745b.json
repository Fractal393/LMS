{"ast":null,"code":"import { Save } from './save';\n/**\n * XmlWriter class provide method to create XML data\n */\n\nvar XmlWriter =\n/** @class */\nfunction () {\n  /**\n   * Initialize new instance of {XmlWriter}\n   */\n  function XmlWriter() {\n    this.contentPos = 0;\n    this.bufferText = '';\n    this.bufferBlob = new Blob([''], {\n      type: 'text/plain'\n    });\n    this.currentState = 'Initial';\n    this.namespaceStack = [];\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[2].set('', '', 'Implied');\n    this.elementStack = [];\n    this.elementStack.push(new XmlElement());\n    this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n    this.attributeStack = [];\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n\n  Object.defineProperty(XmlWriter.prototype, \"buffer\", {\n    /**\n     * Gets the content written to the {XmlWriter} as Blob.\n     * @returns {Blob}\n     */\n    get: function () {\n      this.flush();\n      return this.bufferBlob;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Writes processing instruction with a space between the name and text\n   * @param {string} name - name of the processing instruction\n   * @param {string} text - text to write in the processing instruction\n   * @throws ArgumentException\n   * @throws InvalidArgumentException\n   * @throws InvalidOperationException\n   */\n\n  XmlWriter.prototype.writeProcessingInstruction = function (name, text) {\n    if (name === undefined || name === null || name.length === 0) {\n      throw new Error('ArgumentException: name should not be undefined, null or empty');\n    }\n\n    this.checkName(name);\n\n    if (text === undefined || text === null) {\n      text = '';\n    }\n\n    if (name.length === 3 && name === 'xml') {\n      if (this.currentState !== 'Initial') {\n        // tslint:disable-next-line:max-line-length\n        throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n      }\n    }\n\n    if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    } else {\n      this.writeStartDocument();\n      this.writeProcessingInstructionInternal(name, text);\n    }\n  };\n  /**\n   * Writes Xml declaration with version and standalone attribute\n   * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n   * @throws InvalidOperation\n   */\n\n\n  XmlWriter.prototype.writeStartDocument = function (standalone) {\n    if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n\n    this.currentState = 'StartDocument';\n    this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n\n    if (standalone !== null && standalone !== undefined) {\n      this.rawText('\" standalone=\"');\n      this.rawText(standalone ? 'yes' : 'no');\n    }\n\n    this.rawText('\"?>');\n  };\n  /**\n   * Closes any open tag or attribute and write the state back to start\n   */\n\n\n  XmlWriter.prototype.writeEndDocument = function () {\n    while (this.elementStack.length - 1 > 0) {\n      this.writeEndElement();\n    }\n\n    this.currentState = 'EndDocument';\n    this.flush();\n  };\n  /**\n   * Writes the specified start tag and associates it with the given namespace and prefix.\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName -localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @throws ArgumentException\n   * @throws InvalidOperationException\n   */\n\n\n  XmlWriter.prototype.writeStartElement = function (prefix, localName, namespace) {\n    if (this.bufferBlob === undefined) {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n\n    if (localName === undefined || localName === null || localName.length === 0) {\n      throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n    }\n\n    this.checkName(localName);\n\n    if (this.currentState === 'Initial') {\n      this.writeStartDocument();\n    }\n\n    if (this.currentState === 'StartElement') {\n      this.startElementContent();\n    }\n\n    this.currentState = 'StartElement';\n\n    if (prefix === undefined || prefix === null) {\n      if (namespace !== undefined && namespace !== null) {\n        prefix = this.lookupPrefix(namespace);\n      }\n\n      if (prefix === undefined || prefix === null) {\n        prefix = '';\n      }\n    } else if (prefix.length > 0) {\n      if (namespace === undefined || namespace === null) {\n        namespace = this.lookupNamespace(prefix);\n      }\n\n      if (namespace === undefined || namespace === null || namespace !== undefined && namespace.length === 0) {\n        throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n      }\n    }\n\n    if (namespace === undefined || namespace === null) {\n      namespace = this.lookupNamespace(prefix);\n    }\n\n    this.writeStartElementInternal(prefix, localName, namespace);\n  };\n  /**\n   * Closes one element and pop corresponding namespace scope\n   */\n\n\n  XmlWriter.prototype.writeEndElement = function () {\n    if (this.currentState === 'StartElement') {\n      this.startElementContent();\n      this.currentState = 'ElementContent';\n    } else if (this.currentState === 'ElementContent') {\n      this.currentState = 'ElementContent';\n    }\n\n    this.currentState = 'EndElement';\n    var top = this.elementStack.length - 1;\n    this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n    this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n    this.elementStack.splice(top);\n\n    if (this.bufferText.length > 10240) {\n      this.flush();\n    }\n  };\n  /**\n   * Writes an element with the specified prefix, local name, namespace URI, and value.\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName - localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @param {string} value - value of element\n   */\n\n\n  XmlWriter.prototype.writeElementString = function (prefix, localName, namespace, value) {\n    this.writeStartElement(prefix, localName, namespace);\n\n    if (value !== undefined && value !== null && value.length !== 0) {\n      this.writeString(value);\n    }\n\n    this.writeEndElement();\n  };\n  /**\n   * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n   * @param {string} prefix - namespace prefix of element\n   * @param {string} localName - localName of element\n   * @param {string} namespace - namespace URI associate with element\n   * @param {string} value - value of element\n   */\n\n\n  XmlWriter.prototype.writeAttributeString = function (prefix, localName, namespace, value) {\n    this.writeStartAttribute(prefix, localName, namespace, value);\n    this.writeStringInternal(value, true);\n    this.writeEndAttribute();\n  };\n  /**\n   * Writes the given text content\n   * @param {string} text - text to write\n   * @throws InvalidOperationException\n   */\n\n\n  XmlWriter.prototype.writeString = function (text) {\n    this.writeInternal(text, false);\n  };\n  /**\n   * Write given text as raw data\n   * @param {string} text - text to write\n   * @throws InvalidOperationException\n   */\n\n\n  XmlWriter.prototype.writeRaw = function (text) {\n    this.writeInternal(text, true);\n  };\n\n  XmlWriter.prototype.writeInternal = function (text, isRawString) {\n    if (text === undefined || text === null) {\n      return;\n    } else {\n      if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n        throw new Error('InvalidOperationException: Wrong Token');\n      }\n\n      if (this.currentState === 'StartElement') {\n        this.startElementContent();\n      }\n\n      this.currentState = 'ElementContent';\n\n      if (isRawString) {\n        this.rawText(text);\n      } else {\n        this.writeStringInternal(text, false);\n      }\n    }\n  };\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param {string} fileName - file name\n   */\n\n\n  XmlWriter.prototype.save = function (fileName) {\n    while (this.elementStack.length - 1 > 0) {\n      this.writeEndElement();\n    }\n\n    if (this.bufferText !== '') {\n      this.flush();\n    }\n\n    Save.save(fileName, this.buffer);\n  };\n  /**\n   * Releases the resources used by XmlWriter.\n   */\n\n\n  XmlWriter.prototype.destroy = function () {\n    this.bufferBlob = undefined;\n\n    for (var i = 0; i < this.namespaceStack.length; i++) {\n      this.namespaceStack[i].destroy();\n    }\n\n    this.namespaceStack = [];\n\n    for (var i = 0; i < this.elementStack.length; i++) {\n      this.elementStack[i].destroy();\n    }\n\n    this.elementStack = [];\n    this.bufferText = '';\n    this.contentPos = 0;\n  };\n\n  XmlWriter.prototype.flush = function () {\n    if (this.bufferBlob === undefined) {\n      return;\n    }\n\n    this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], {\n      type: 'text/plain'\n    });\n    this.bufferText = '';\n  };\n\n  XmlWriter.prototype.writeProcessingInstructionInternal = function (name, text) {\n    this.bufferText += '<?';\n    this.rawText(name);\n\n    if (text.length > 0) {\n      this.bufferText += ' ';\n      text = text.replace(/\\?\\>/g, '? >');\n      this.bufferText += text;\n    }\n\n    this.bufferText += '?';\n    this.bufferText += '>';\n  };\n\n  XmlWriter.prototype.writeStartAttribute = function (prefix, localName, namespace, value) {\n    if (localName === undefined || localName === null || localName.length === 0) {\n      if (prefix === 'xmlns') {\n        localName = 'xmlns';\n        prefix = '';\n      } else {\n        throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n      }\n    }\n\n    if (this.currentState !== 'StartElement') {\n      throw new Error('InvalidOperationException: Wrong Token');\n    }\n\n    this.checkName(localName);\n    this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n  };\n\n  XmlWriter.prototype.writeStartAttributePrefixAndNameSpace = function (prefix, localName, namespace, value) {\n    if (prefix === undefined || prefix === null) {\n      if (namespace !== undefined && namespace !== null) {\n        if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n          prefix = this.lookupPrefix(namespace);\n        }\n      }\n\n      if (prefix === undefined || prefix === null) {\n        prefix = '';\n      }\n    }\n\n    if (namespace === undefined || namespace === null) {\n      if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n        namespace = this.lookupNamespace(prefix);\n      }\n\n      if (namespace === undefined || namespace === null) {\n        namespace = '';\n      }\n    }\n\n    this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n  };\n\n  XmlWriter.prototype.writeStartAttributeSpecialAttribute = function (prefix, localName, namespace, value) {\n    if (prefix.length === 0) {\n      if (localName[0] === 'x' && localName === 'xmlns') {\n        this.skipPushAndWrite(prefix, localName, namespace);\n        this.pushNamespaceExplicit('', value);\n        return;\n      } else if (namespace.length > 0) {\n        prefix = this.lookupPrefix(namespace);\n      }\n    } else {\n      if (prefix[0] === 'x') {\n        if (prefix === 'xmlns') {\n          this.skipPushAndWrite(prefix, localName, namespace);\n          this.pushNamespaceExplicit(localName, value);\n          return;\n        } else if (prefix === 'xml') {\n          if (localName === 'space' || localName === 'lang') {\n            this.skipPushAndWrite(prefix, localName, namespace);\n            return;\n          }\n        }\n      }\n\n      if (namespace.length === 0) {\n        prefix = '';\n      }\n    }\n\n    if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n      this.pushNamespaceImplicit(prefix, namespace);\n    }\n\n    this.skipPushAndWrite(prefix, localName, namespace);\n  };\n\n  XmlWriter.prototype.writeEndAttribute = function () {\n    this.currentState = 'StartElement';\n    this.bufferText += '\"';\n  };\n\n  XmlWriter.prototype.writeStartElementInternal = function (prefix, localName, namespace) {\n    this.bufferText += '<';\n\n    if (prefix.length > 0) {\n      this.rawText(prefix);\n      this.bufferText += ':';\n    }\n\n    this.rawText(localName);\n    var top = this.elementStack.length;\n    this.elementStack.push(new XmlElement());\n    this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n    this.pushNamespaceImplicit(prefix, namespace);\n\n    for (var i = 0; i < this.attributeStack.length; i++) {\n      this.attributeStack[i].destroy();\n    }\n\n    this.attributeStack = [];\n  };\n\n  XmlWriter.prototype.writeEndElementInternal = function (prefix, localName) {\n    if (this.contentPos !== this.bufferText.length + 1) {\n      this.bufferText += '</';\n\n      if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n        this.rawText(prefix);\n        this.bufferText += ':';\n      }\n\n      this.rawText(localName);\n      this.bufferText += '>';\n    } else {\n      this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n      this.bufferText += ' />';\n    }\n  };\n\n  XmlWriter.prototype.writeStartAttributeInternal = function (prefix, localName, namespaceName) {\n    this.bufferText += ' ';\n\n    if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n      this.rawText(prefix);\n      this.bufferText += ':';\n    }\n\n    this.rawText(localName);\n    this.bufferText += '=';\n    this.bufferText += '\"';\n  };\n\n  XmlWriter.prototype.writeNamespaceDeclaration = function (prefix, namespaceUri) {\n    this.writeStartNamespaceDeclaration(prefix);\n    this.writeStringInternal(namespaceUri, true);\n    this.bufferText += '\"';\n  };\n\n  XmlWriter.prototype.writeStartNamespaceDeclaration = function (prefix) {\n    if (prefix === undefined || prefix === null || prefix.length === 0) {\n      this.rawText(' xmlns=\\\"');\n    } else {\n      this.rawText(' xmlns:');\n      this.rawText(prefix);\n      this.bufferText += '=';\n      this.bufferText += '\"';\n    }\n  };\n\n  XmlWriter.prototype.writeStringInternal = function (text, inAttributeValue) {\n    if (text === null || text === undefined) {\n      text = '';\n    }\n\n    var tempText = '';\n    text = text.replace(/\\&/g, '&amp;');\n    text = text.replace(/\\</g, '&lt;');\n    text = text.replace(/\\>/g, '&gt;');\n\n    if (inAttributeValue) {\n      text = text.replace(/\\\"/g, '&quot;');\n    }\n\n    this.bufferText += text;\n\n    if (!inAttributeValue) {\n      this.contentPos = 0;\n    }\n  };\n\n  XmlWriter.prototype.startElementContent = function () {\n    var start = this.elementStack[this.elementStack.length - 1].previousTop;\n\n    for (var i = this.namespaceStack.length - 1; i > start; i--) {\n      if (this.namespaceStack[i].kind === 'NeedToWrite') {\n        this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n      }\n    }\n\n    this.bufferText += '>';\n    this.contentPos = this.bufferText.length + 1;\n  };\n\n  XmlWriter.prototype.rawText = function (text) {\n    this.bufferText += text;\n  };\n\n  XmlWriter.prototype.addNamespace = function (prefix, ns, kind) {\n    var top = this.namespaceStack.length;\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[top].set(prefix, ns, kind);\n  };\n\n  XmlWriter.prototype.lookupPrefix = function (namespace) {\n    for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].namespaceUri === namespace) {\n        return this.namespaceStack[i].prefix;\n      }\n    }\n\n    return undefined;\n  };\n\n  XmlWriter.prototype.lookupNamespace = function (prefix) {\n    for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].prefix === prefix) {\n        return this.namespaceStack[i].namespaceUri;\n      }\n    }\n\n    return undefined;\n  };\n\n  XmlWriter.prototype.lookupNamespaceIndex = function (prefix) {\n    for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n      if (this.namespaceStack[i].prefix === prefix) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  XmlWriter.prototype.pushNamespaceImplicit = function (prefix, ns) {\n    var kind;\n    var existingNsIndex = this.lookupNamespaceIndex(prefix);\n\n    if (existingNsIndex !== -1) {\n      if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n        if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n          throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n        }\n\n        return;\n      } else {\n        if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n          if (prefix === 'xml') {\n            if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n              throw new Error('InvalidArgumentException: Xml String');\n            } else {\n              kind = 'Implied';\n            }\n          } else {\n            throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n          }\n        } else {\n          kind = this.namespaceStack[existingNsIndex].namespaceUri === ns ? 'Implied' : 'NeedToWrite';\n        }\n      }\n    } else {\n      if (ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml' || ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns') {\n        throw new Error('InvalidArgumentException');\n      }\n\n      kind = 'NeedToWrite';\n    }\n\n    this.addNamespace(prefix, ns, kind);\n  };\n\n  XmlWriter.prototype.pushNamespaceExplicit = function (prefix, ns) {\n    var existingNsIndex = this.lookupNamespaceIndex(prefix);\n\n    if (existingNsIndex !== -1) {\n      if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n        this.namespaceStack[existingNsIndex].kind = 'Written';\n        return;\n      }\n    }\n\n    this.addNamespace(prefix, ns, 'Written');\n    return;\n  };\n\n  XmlWriter.prototype.addAttribute = function (prefix, localName, namespaceName) {\n    var top = this.attributeStack.length;\n    this.attributeStack.push(new XmlAttribute());\n    this.attributeStack[top].set(prefix, localName, namespaceName);\n\n    for (var i = 0; i < top; i++) {\n      if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n        throw new Error('XmlException: duplicate attribute name');\n      }\n    }\n  };\n\n  XmlWriter.prototype.skipPushAndWrite = function (prefix, localName, namespace) {\n    this.addAttribute(prefix, localName, namespace);\n    this.writeStartAttributeInternal(prefix, localName, namespace);\n  };\n\n  XmlWriter.prototype.checkName = function (text) {\n    var format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n\n    if (format.test(text)) {\n      throw new Error('InvalidArgumentException: invalid name character');\n    }\n  };\n\n  return XmlWriter;\n}();\n\nexport { XmlWriter };\n/**\n * class for managing namespace collection\n */\n\nvar Namespace =\n/** @class */\nfunction () {\n  function Namespace() {}\n  /**\n   * set value for current namespace instance\n   * @param {string} prefix namespace's prefix\n   * @param {string} namespaceUri namespace URI\n   * @param {string} kind namespace kind\n   */\n\n\n  Namespace.prototype.set = function (prefix, namespaceUri, kind) {\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.kind = kind;\n  };\n  /**\n   * Releases the resources used by Namespace\n   */\n\n\n  Namespace.prototype.destroy = function () {\n    this.prefix = undefined;\n    this.namespaceUri = undefined;\n    this.kind = undefined;\n  };\n\n  return Namespace;\n}();\n\nexport { Namespace };\n/**\n * class for managing element collection\n */\n\nvar XmlElement =\n/** @class */\nfunction () {\n  function XmlElement() {}\n  /**\n   * set value of current element\n   * @param {string} prefix - element prefix\n   * @param {string} localName - element local name\n   * @param {string} namespaceUri -namespace URI\n   * @param {string} previousTop - previous namespace top\n   */\n\n\n  XmlElement.prototype.set = function (prefix, localName, namespaceUri, previousTop) {\n    this.previousTop = previousTop;\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.localName = localName;\n  };\n  /**\n   * Releases the resources used by XmlElement\n   */\n\n\n  XmlElement.prototype.destroy = function () {\n    this.previousTop = undefined;\n    this.prefix = undefined;\n    this.localName = undefined;\n    this.namespaceUri = undefined;\n  };\n\n  return XmlElement;\n}();\n\nexport { XmlElement };\n/**\n * class for managing attribute collection\n */\n\nvar XmlAttribute =\n/** @class */\nfunction () {\n  function XmlAttribute() {}\n  /**\n   * set value of current attribute\n   * @param {string} prefix - namespace's prefix\n   * @param {string} namespaceUri - namespace URI\n   * @param {string} localName - attribute localName\n   */\n\n\n  XmlAttribute.prototype.set = function (prefix, localName, namespaceUri) {\n    this.prefix = prefix;\n    this.namespaceUri = namespaceUri;\n    this.localName = localName;\n  };\n  /**\n   * get whether the attribute is duplicate or not\n   * @param {string} prefix - namespace's prefix\n   * @param {string} namespaceUri - namespace URI\n   * @param {string} localName - attribute localName\n   */\n\n\n  XmlAttribute.prototype.isDuplicate = function (prefix, localName, namespaceUri) {\n    return this.localName === localName && (this.prefix === prefix || this.namespaceUri === namespaceUri);\n  };\n  /**\n   * Releases the resources used by XmlAttribute\n   */\n\n\n  XmlAttribute.prototype.destroy = function () {\n    this.prefix = undefined;\n    this.namespaceUri = undefined;\n    this.localName = undefined;\n  };\n\n  return XmlAttribute;\n}();\n\nexport { XmlAttribute };","map":null,"metadata":{},"sourceType":"module"}