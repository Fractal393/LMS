{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useSpecialFileActionHandlerMap = exports.useSpecialActionDispatcher = void 0;\n\nvar react_1 = require(\"react\");\n\nvar recoil_1 = require(\"recoil\");\n\nvar file_actions_recoil_1 = require(\"../recoil/file-actions.recoil\");\n\nvar files_recoil_1 = require(\"../recoil/files.recoil\");\n\nvar search_recoil_1 = require(\"../recoil/search.recoil\");\n\nvar selection_recoil_1 = require(\"../recoil/selection.recoil\");\n\nvar special_actions_recoil_1 = require(\"../recoil/special-actions.recoil\");\n\nvar special_actions_types_1 = require(\"../types/special-actions.types\");\n\nvar file_actions_definitions_1 = require(\"./file-actions-definitions\");\n\nvar file_helper_1 = require(\"./file-helper\");\n\nvar hooks_helpers_1 = require(\"./hooks-helpers\");\n\nvar logger_1 = require(\"./logger\");\n/**\n * Returns a dispatch method meant to be used by child components. This dispatch\n * method is meant for \"special\" internal actions. It takes a special action, and\n * transforms it into a \"file action\" that can be handled by the user.\n */\n\n\nexports.useSpecialActionDispatcher = function (files, selection, selectionUtil, selectionModifiers) {\n  // Create the special action handler map\n  var specialActionHandlerMap = exports.useSpecialFileActionHandlerMap(selectionUtil, selectionModifiers); // Process special actions using the handlers from the map\n\n  var dispatchSpecialAction = react_1.useCallback(function (actionData) {\n    logger_1.Logger.debug(\"SPECIAL ACTION REQUEST:\", actionData);\n    var actionId = actionData.actionId;\n    var handler = specialActionHandlerMap[actionId];\n\n    if (handler) {\n      try {\n        handler(actionData);\n      } catch (error) {\n        logger_1.Logger.error(\"Handler for special action \\\"\" + actionId + \"\\\" threw an error.\", error);\n      }\n    } else {\n      logger_1.Logger.error(\"Internal components dispatched a \\\"\" + actionId + \"\\\" special action, \" + \"but no internal handler is available to process it.\");\n    }\n  }, [specialActionHandlerMap]);\n  var setRecoilDispatchSpecialAction = recoil_1.useSetRecoilState(special_actions_recoil_1.dispatchSpecialActionState);\n  react_1.useEffect(function () {\n    setRecoilDispatchSpecialAction(function () {\n      return dispatchSpecialAction;\n    });\n  }, [dispatchSpecialAction, setRecoilDispatchSpecialAction]);\n};\n\nexports.useSpecialFileActionHandlerMap = function (selectionUtil, selectionModifiers) {\n  // Instance variables based on Recoil state\n  var _recoilFiles = recoil_1.useRecoilValue(files_recoil_1.filesState);\n\n  var filesRef = hooks_helpers_1.useInstanceVariable(_recoilFiles);\n  var parentFolderRef = hooks_helpers_1.useInstanceVariable(recoil_1.useRecoilValue(files_recoil_1.parentFolderState));\n  var selectedFilesRef = hooks_helpers_1.useInstanceVariable(recoil_1.useRecoilValue(selection_recoil_1.selectedFilesState));\n  var dispatchFileActionRef = hooks_helpers_1.useInstanceVariable(recoil_1.useRecoilValue(file_actions_recoil_1.dispatchFileActionState));\n  var setSearchBarVisible = recoil_1.useSetRecoilState(search_recoil_1.searchBarVisibleState); // Internal instance variables used by special actions\n\n  var lastClickDisplayIndexRef = react_1.useRef(null);\n  react_1.useEffect(function () {\n    // We zero out the last click whenever files update\n    lastClickDisplayIndexRef.current = null;\n  }, [_recoilFiles]); // Define handlers in a map\n\n  var specialActionHandlerMap = react_1.useMemo(function () {\n    var _a;\n\n    return _a = {}, _a[special_actions_types_1.SpecialAction.MouseClickFile] = function (data) {\n      var _a;\n\n      if (data.clickType === 'double') {\n        if (file_helper_1.FileHelper.isOpenable(data.file)) {\n          dispatchFileActionRef.current({\n            actionId: file_actions_definitions_1.ChonkyActions.OpenFiles.id,\n            target: data.file,\n            // To simulate Windows Explorer and Nautilus behaviour,\n            // a double click on a file only opens that file even if\n            // there is a selection.\n            files: [data.file]\n          });\n        }\n      } else {\n        // We're dealing with a single click\n        if (file_helper_1.FileHelper.isSelectable(data.file)) {\n          if (data.ctrlKey) {\n            // Multiple selection\n            selectionModifiers.toggleSelection(data.file.id, false);\n            lastClickDisplayIndexRef.current = data.fileDisplayIndex;\n          } else if (data.shiftKey) {\n            // Range selection\n            if (typeof lastClickDisplayIndexRef.current === 'number') {\n              // We have the index of the previous click\n              var rangeStart = lastClickDisplayIndexRef.current;\n              var rangeEnd = data.fileDisplayIndex;\n\n              if (rangeStart > rangeEnd) {\n                _a = [rangeEnd, rangeStart], rangeStart = _a[0], rangeEnd = _a[1];\n              }\n\n              var fileIds = filesRef.current.slice(rangeStart, rangeEnd + 1).filter(function (file) {\n                return file_helper_1.FileHelper.isSelectable(file);\n              }).map(function (file) {\n                return file.id;\n              });\n              selectionModifiers.selectFiles(fileIds, true);\n            } else {\n              // Since we can't do a range selection, do a\n              // multiple selection\n              selectionModifiers.toggleSelection(data.file.id, false);\n              lastClickDisplayIndexRef.current = data.fileDisplayIndex;\n            }\n          } else {\n            // Exclusive selection\n            selectionModifiers.toggleSelection(data.file.id, true);\n            lastClickDisplayIndexRef.current = data.fileDisplayIndex;\n          }\n        } else {\n          if (!data.ctrlKey) selectionModifiers.clearSelection();\n          lastClickDisplayIndexRef.current = data.fileDisplayIndex;\n        }\n      }\n    }, _a[special_actions_types_1.SpecialAction.KeyboardClickFile] = function (data) {\n      lastClickDisplayIndexRef.current = data.fileDisplayIndex;\n\n      if (data.enterKey) {\n        // We only dispatch the Open Files action here when the selection is\n        // empty. Otherwise, `Enter` key presses are handled by the\n        // hotkey manager for the Open Files action.\n        if (selectedFilesRef.current.length === 0) {\n          dispatchFileActionRef.current({\n            actionId: file_actions_definitions_1.ChonkyActions.OpenFiles.id,\n            target: data.file,\n            files: [data.file]\n          });\n        }\n      } else if (data.spaceKey && file_helper_1.FileHelper.isSelectable(data.file)) {\n        selectionModifiers.toggleSelection(data.file.id, data.ctrlKey);\n      }\n    }, _a[special_actions_types_1.SpecialAction.OpenParentFolder] = function () {\n      if (file_helper_1.FileHelper.isOpenable(parentFolderRef.current)) {\n        dispatchFileActionRef.current({\n          actionId: file_actions_definitions_1.ChonkyActions.OpenFiles.id,\n          target: parentFolderRef.current,\n          files: [parentFolderRef.current]\n        });\n      } else {\n        logger_1.Logger.warn(\"Special action \\\"\" + special_actions_types_1.SpecialAction.OpenParentFolder + \"\\\" was \" + \"dispatched even though the parent folder is not \" + \"openable. This indicates a bug in presentation components.\");\n      }\n    }, _a[special_actions_types_1.SpecialAction.OpenFolderChainFolder] = function (data) {\n      dispatchFileActionRef.current({\n        actionId: file_actions_definitions_1.ChonkyActions.OpenFiles.id,\n        target: data.file,\n        files: [data.file]\n      });\n    }, _a[special_actions_types_1.SpecialAction.ToggleSearchBar] = function () {\n      setSearchBarVisible(function (visible) {\n        return !visible;\n      });\n    }, _a[special_actions_types_1.SpecialAction.SelectAllFiles] = function () {\n      var fileIds = filesRef.current.filter(function (file) {\n        return file_helper_1.FileHelper.isSelectable(file);\n      }).map(function (file) {\n        return file.id;\n      });\n      selectionModifiers.selectFiles(fileIds, true);\n    }, _a[special_actions_types_1.SpecialAction.ClearSelection] = function () {\n      selectionModifiers.clearSelection();\n    }, _a[special_actions_types_1.SpecialAction.DragNDropStart] = function (data) {\n      var file = data.dragSource;\n\n      if (!selectionUtil.isSelected(file)) {\n        selectionModifiers.clearSelection();\n\n        if (file_helper_1.FileHelper.isSelectable(file)) {\n          selectionModifiers.selectFiles([file.id]);\n        }\n      }\n    }, _a[special_actions_types_1.SpecialAction.DragNDropEnd] = function (data) {\n      if (selectionUtil.isSelected(data.dropTarget)) {\n        // Can't drop a selection into itself\n        return;\n      }\n\n      var selectedFiles = selectionUtil.getSelectedFiles(file_helper_1.FileHelper.isDraggable);\n      var droppedFiles = selectedFiles.length > 0 ? selectedFiles : [data.dragSource];\n      dispatchFileActionRef.current({\n        actionId: data.dropEffect === 'copy' ? file_actions_definitions_1.ChonkyActions.DuplicateFilesTo.id : file_actions_definitions_1.ChonkyActions.MoveFilesTo.id,\n        target: data.dropTarget,\n        files: droppedFiles\n      });\n    }, _a;\n  }, [selectionUtil, selectionModifiers, filesRef, parentFolderRef, selectedFilesRef, dispatchFileActionRef, setSearchBarVisible]);\n  return specialActionHandlerMap;\n};","map":null,"metadata":{},"sourceType":"script"}