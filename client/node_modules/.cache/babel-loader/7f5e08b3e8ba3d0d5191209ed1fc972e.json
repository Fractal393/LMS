{"ast":null,"code":"/**\r\n * DevExtreme (ui/toolbar/ui.toolbar.base.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _themes = require(\"../themes\");\n\nvar _themes2 = _interopRequireDefault(_themes);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _component_registrator = require(\"../../core/component_registrator\");\n\nvar _component_registrator2 = _interopRequireDefault(_component_registrator);\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _position = require(\"../../core/utils/position\");\n\nvar _uiCollection_widget = require(\"../collection/ui.collection_widget.async\");\n\nvar _uiCollection_widget2 = _interopRequireDefault(_uiCollection_widget);\n\nvar _promise = require(\"../../core/polyfills/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _bindable_template = require(\"../../core/templates/bindable_template\");\n\nvar _errors = require(\"../../core/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _fx = require(\"../../animation/fx\");\n\nvar _fx2 = _interopRequireDefault(_fx);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar TOOLBAR_CLASS = \"dx-toolbar\";\nvar TOOLBAR_BEFORE_CLASS = \"dx-toolbar-before\";\nvar TOOLBAR_CENTER_CLASS = \"dx-toolbar-center\";\nvar TOOLBAR_AFTER_CLASS = \"dx-toolbar-after\";\nvar TOOLBAR_BOTTOM_CLASS = \"dx-toolbar-bottom\";\nvar TOOLBAR_MINI_CLASS = \"dx-toolbar-mini\";\nvar TOOLBAR_ITEM_CLASS = \"dx-toolbar-item\";\nvar TOOLBAR_LABEL_CLASS = \"dx-toolbar-label\";\nvar TOOLBAR_BUTTON_CLASS = \"dx-toolbar-button\";\nvar TOOLBAR_ITEMS_CONTAINER_CLASS = \"dx-toolbar-items-container\";\nvar TOOLBAR_GROUP_CLASS = \"dx-toolbar-group\";\nvar TOOLBAR_COMPACT_CLASS = \"dx-toolbar-compact\";\nvar TOOLBAR_LABEL_SELECTOR = \".\" + TOOLBAR_LABEL_CLASS;\nvar TOOLBAR_MULTILINE_CLASS = \"dx-toolbar-multiline\";\nvar TEXT_BUTTON_MODE = \"text\";\nvar DEFAULT_BUTTON_TYPE = \"default\";\nvar TOOLBAR_ITEM_DATA_KEY = \"dxToolbarItemDataKey\";\n\nvar ToolbarBase = _uiCollection_widget2.default.inherit({\n  compactMode: false,\n  ctor: function (element, options) {\n    this._userOptions = options || {};\n    this.callBase(element, options);\n\n    if (\"height\" in this._userOptions) {\n      _errors2.default.log(\"W0001\", this.NAME, \"height\", \"20.1\", \"Functionality associated with this option is not intended for the Toolbar widget.\");\n    }\n  },\n  _getSynchronizableOptionsForCreateComponent: function () {\n    return this.callBase().filter(function (item) {\n      return \"disabled\" !== item;\n    });\n  },\n  _initTemplates: function () {\n    this.callBase();\n    var template = new _bindable_template.BindableTemplate(function ($container, data, rawModel) {\n      if ((0, _type.isPlainObject)(data)) {\n        if (data.text) {\n          $container.text(data.text).wrapInner(\"<div>\");\n        }\n\n        if (data.html) {\n          $container.html(data.html);\n        }\n\n        if (\"dxButton\" === data.widget) {\n          if (this.option(\"useFlatButtons\")) {\n            data.options = data.options || {};\n            data.options.stylingMode = data.options.stylingMode || TEXT_BUTTON_MODE;\n          }\n\n          if (this.option(\"useDefaultButtons\")) {\n            data.options = data.options || {};\n            data.options.type = data.options.type || DEFAULT_BUTTON_TYPE;\n          }\n        }\n      } else {\n        $container.text(String(data));\n      }\n\n      this._getTemplate(\"dx-polymorph-widget\").render({\n        container: $container,\n        model: rawModel,\n        parent: this\n      });\n    }.bind(this), [\"text\", \"html\", \"widget\", \"options\"], this.option(\"integrationOptions.watchMethod\"));\n\n    this._templateManager.addDefaultTemplates({\n      item: template,\n      menuItem: template\n    });\n  },\n  _getDefaultOptions: function () {\n    return (0, _extend.extend)(this.callBase(), {\n      renderAs: \"topToolbar\",\n      grouped: false,\n      useFlatButtons: false,\n      useDefaultButtons: false,\n      multiline: false\n    });\n  },\n  _defaultOptionsRules: function () {\n    return this.callBase().concat([{\n      device: function () {\n        return _themes2.default.isMaterial();\n      },\n      options: {\n        useFlatButtons: true\n      }\n    }]);\n  },\n  _itemContainer: function () {\n    return this._$toolbarItemsContainer.find([\".\" + TOOLBAR_BEFORE_CLASS, \".\" + TOOLBAR_CENTER_CLASS, \".\" + TOOLBAR_AFTER_CLASS].join(\",\"));\n  },\n  _itemClass: function () {\n    return TOOLBAR_ITEM_CLASS;\n  },\n  _itemDataKey: function () {\n    return TOOLBAR_ITEM_DATA_KEY;\n  },\n  _buttonClass: function () {\n    return TOOLBAR_BUTTON_CLASS;\n  },\n  _dimensionChanged: function () {\n    this._arrangeItems();\n\n    this._applyCompactMode();\n  },\n  _initMarkup: function () {\n    this._renderToolbar();\n\n    this._renderSections();\n\n    this.callBase();\n    this.setAria(\"role\", \"toolbar\");\n  },\n  _waitParentAnimationFinished: function () {\n    var _this = this;\n\n    var $element = this.$element();\n    var timeout = 15;\n    return new _promise2.default(function (resolve) {\n      var check = function () {\n        var readyToResolve = true;\n        $element.parents().each(function (_, parent) {\n          if (_fx2.default.isAnimating((0, _renderer2.default)(parent))) {\n            readyToResolve = false;\n            return false;\n          }\n        });\n\n        if (readyToResolve) {\n          resolve();\n        }\n\n        return readyToResolve;\n      };\n\n      var runCheck = function runCheck() {\n        clearTimeout(_this._waitParentAnimationTimeout);\n        _this._waitParentAnimationTimeout = setTimeout(function () {\n          return check() || runCheck();\n        }, timeout);\n      };\n\n      runCheck();\n    });\n  },\n  _render: function () {\n    this.callBase();\n\n    this._renderItemsAsync();\n\n    if (_themes2.default.isMaterial()) {\n      _promise2.default.all([this._waitParentAnimationFinished(), this._checkWebFontForLabelsLoaded()]).then(this._dimensionChanged.bind(this));\n    }\n  },\n  _postProcessRenderItems: function () {\n    this._arrangeItems();\n  },\n  _renderToolbar: function () {\n    this.$element().addClass(TOOLBAR_CLASS).toggleClass(TOOLBAR_BOTTOM_CLASS, \"bottomToolbar\" === this.option(\"renderAs\")).toggleClass(TOOLBAR_MULTILINE_CLASS, this.option(\"multiline\"));\n    this._$toolbarItemsContainer = (0, _renderer2.default)(\"<div>\").addClass(TOOLBAR_ITEMS_CONTAINER_CLASS).appendTo(this.$element());\n  },\n  _renderSections: function () {\n    var $container = this._$toolbarItemsContainer;\n    var that = this;\n    (0, _iterator.each)([\"before\", \"center\", \"after\"], function () {\n      var sectionClass = \"dx-toolbar-\" + this;\n      var $section = $container.find(\".\" + sectionClass);\n\n      if (!$section.length) {\n        that[\"_$\" + this + \"Section\"] = $section = (0, _renderer2.default)(\"<div>\").addClass(sectionClass).appendTo($container);\n      }\n    });\n  },\n  _checkWebFontForLabelsLoaded: function () {\n    var $labels = this.$element().find(TOOLBAR_LABEL_SELECTOR);\n    var promises = [];\n    $labels.each(function (_, label) {\n      var text = (0, _renderer2.default)(label).text();\n      var fontWeight = (0, _renderer2.default)(label).css(\"fontWeight\");\n      promises.push(_themes2.default.waitWebFont(text, fontWeight));\n    });\n    return _promise2.default.all(promises);\n  },\n  _arrangeItems: function (elementWidth) {\n    elementWidth = elementWidth || this.$element().width();\n\n    this._$centerSection.css({\n      margin: \"0 auto\",\n      \"float\": \"none\"\n    });\n\n    var beforeRect = (0, _position.getBoundingRect)(this._$beforeSection.get(0));\n    var afterRect = (0, _position.getBoundingRect)(this._$afterSection.get(0));\n\n    this._alignCenterSection(beforeRect, afterRect, elementWidth);\n\n    var $label = this._$toolbarItemsContainer.find(TOOLBAR_LABEL_SELECTOR).eq(0);\n\n    var $section = $label.parent();\n\n    if (!$label.length) {\n      return;\n    }\n\n    var labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;\n    var widthBeforeSection = $section.hasClass(TOOLBAR_BEFORE_CLASS) ? 0 : labelOffset;\n    var widthAfterSection = $section.hasClass(TOOLBAR_AFTER_CLASS) ? 0 : afterRect.width;\n    var elemsAtSectionWidth = 0;\n    $section.children().not(TOOLBAR_LABEL_SELECTOR).each(function () {\n      elemsAtSectionWidth += (0, _renderer2.default)(this).outerWidth();\n    });\n    var freeSpace = elementWidth - elemsAtSectionWidth;\n    var sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);\n\n    if ($section.hasClass(TOOLBAR_BEFORE_CLASS)) {\n      this._alignSection(this._$beforeSection, sectionMaxWidth);\n    } else {\n      var labelPaddings = $label.outerWidth() - $label.width();\n      $label.css(\"maxWidth\", sectionMaxWidth - labelPaddings);\n    }\n  },\n  _alignCenterSection: function (beforeRect, afterRect, elementWidth) {\n    this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);\n\n    var isRTL = this.option(\"rtlEnabled\");\n    var leftRect = isRTL ? afterRect : beforeRect;\n    var rightRect = isRTL ? beforeRect : afterRect;\n    var centerRect = (0, _position.getBoundingRect)(this._$centerSection.get(0));\n\n    if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {\n      this._$centerSection.css({\n        marginLeft: leftRect.width,\n        marginRight: rightRect.width,\n        \"float\": leftRect.width > rightRect.width ? \"none\" : \"right\"\n      });\n    }\n  },\n  _alignSection: function ($section, maxWidth) {\n    var $labels = $section.find(TOOLBAR_LABEL_SELECTOR);\n    var labels = $labels.toArray();\n    maxWidth -= this._getCurrentLabelsPaddings(labels);\n\n    var currentWidth = this._getCurrentLabelsWidth(labels);\n\n    var difference = Math.abs(currentWidth - maxWidth);\n\n    if (maxWidth < currentWidth) {\n      labels = labels.reverse();\n\n      this._alignSectionLabels(labels, difference, false);\n    } else {\n      this._alignSectionLabels(labels, difference, true);\n    }\n  },\n  _alignSectionLabels: function (labels, difference, expanding) {\n    var getRealLabelWidth = function (label) {\n      return (0, _position.getBoundingRect)(label).width;\n    };\n\n    for (var i = 0; i < labels.length; i++) {\n      var $label = (0, _renderer2.default)(labels[i]);\n      var currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));\n      var labelMaxWidth = void 0;\n\n      if (expanding) {\n        $label.css(\"maxWidth\", \"inherit\");\n      }\n\n      var possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);\n\n      if (possibleLabelWidth < difference) {\n        labelMaxWidth = expanding ? possibleLabelWidth : 0;\n        difference -= possibleLabelWidth;\n      } else {\n        labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;\n        $label.css(\"maxWidth\", labelMaxWidth);\n        break;\n      }\n\n      $label.css(\"maxWidth\", labelMaxWidth);\n    }\n  },\n  _applyCompactMode: function () {\n    var $element = this.$element();\n    $element.removeClass(TOOLBAR_COMPACT_CLASS);\n\n    if (this.option(\"compactMode\") && this._getSummaryItemsWidth(this.itemElements(), true) > $element.width()) {\n      $element.addClass(TOOLBAR_COMPACT_CLASS);\n    }\n  },\n  _getCurrentLabelsWidth: function (labels) {\n    var width = 0;\n    labels.forEach(function (label, index) {\n      width += (0, _renderer2.default)(label).outerWidth();\n    });\n    return width;\n  },\n  _getCurrentLabelsPaddings: function (labels) {\n    var padding = 0;\n    labels.forEach(function (label, index) {\n      padding += (0, _renderer2.default)(label).outerWidth() - (0, _renderer2.default)(label).width();\n    });\n    return padding;\n  },\n  _renderItem: function (index, item, itemContainer, $after) {\n    var location = item.location || \"center\";\n    var container = itemContainer || this[\"_$\" + location + \"Section\"];\n    var itemHasText = !!(item.text || item.html);\n    var itemElement = this.callBase(index, item, container, $after);\n    itemElement.toggleClass(this._buttonClass(), !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText).addClass(item.cssClass);\n    return itemElement;\n  },\n  _renderGroupedItems: function () {\n    var that = this;\n    (0, _iterator.each)(this.option(\"items\"), function (groupIndex, group) {\n      var groupItems = group.items;\n      var $container = (0, _renderer2.default)(\"<div>\").addClass(TOOLBAR_GROUP_CLASS);\n      var location = group.location || \"center\";\n\n      if (!groupItems || !groupItems.length) {\n        return;\n      }\n\n      (0, _iterator.each)(groupItems, function (itemIndex, item) {\n        that._renderItem(itemIndex, item, $container, null);\n      });\n\n      that._$toolbarItemsContainer.find(\".dx-toolbar-\" + location).append($container);\n    });\n  },\n  _renderItems: function (items) {\n    var grouped = this.option(\"grouped\") && items.length && items[0].items;\n    grouped ? this._renderGroupedItems() : this.callBase(items);\n  },\n  _getToolbarItems: function () {\n    return this.option(\"items\") || [];\n  },\n  _renderContentImpl: function () {\n    var items = this._getToolbarItems();\n\n    this.$element().toggleClass(TOOLBAR_MINI_CLASS, 0 === items.length);\n\n    if (this._renderedItemsCount) {\n      this._renderItems(items.slice(this._renderedItemsCount));\n    } else {\n      this._renderItems(items);\n    }\n\n    this._applyCompactMode();\n  },\n  _renderEmptyMessage: _common2.default.noop,\n  _clean: function () {\n    this._$toolbarItemsContainer.children().empty();\n\n    this.$element().empty();\n  },\n  _visibilityChanged: function (visible) {\n    if (visible) {\n      this._arrangeItems();\n    }\n  },\n  _isVisible: function () {\n    return this.$element().width() > 0 && this.$element().height() > 0;\n  },\n  _getIndexByItem: function (item) {\n    return (0, _array.inArray)(item, this._getToolbarItems());\n  },\n  _itemOptionChanged: function (item, property, value) {\n    this.callBase.apply(this, [item, property, value]);\n\n    this._arrangeItems();\n  },\n  _optionChanged: function (args) {\n    var name = args.name;\n\n    switch (name) {\n      case \"width\":\n        this.callBase.apply(this, arguments);\n\n        this._dimensionChanged();\n\n        break;\n\n      case \"multiline\":\n        this.$element().toggleClass(TOOLBAR_MULTILINE_CLASS, args.value);\n        break;\n\n      case \"renderAs\":\n      case \"useFlatButtons\":\n      case \"useDefaultButtons\":\n        this._invalidate();\n\n        break;\n\n      case \"compactMode\":\n        this._applyCompactMode();\n\n        break;\n\n      case \"grouped\":\n        break;\n\n      default:\n        this.callBase.apply(this, arguments);\n    }\n  },\n  _dispose: function () {\n    this.callBase();\n    clearTimeout(this._waitParentAnimationTimeout);\n  }\n});\n\n(0, _component_registrator2.default)(\"dxToolbarBase\", ToolbarBase);\nmodule.exports = ToolbarBase;","map":null,"metadata":{},"sourceType":"script"}