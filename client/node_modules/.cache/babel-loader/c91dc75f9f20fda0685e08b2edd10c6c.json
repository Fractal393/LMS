{"ast":null,"code":"/**\n * TrueTypeFont.ts class for EJ2-PDF\n */\nimport { ByteArray } from './../../graphics/images/index';\nimport { TtfReader } from './ttf-reader';\nimport { PdfDictionary, SaveDescendantFontEventHandler, SaveFontDictionaryEventHandler } from './../../primitives/pdf-dictionary';\nimport { SaveFontProgramEventHandler, SaveCmapEventHandler } from './../../primitives/pdf-stream';\nimport { PdfStream } from './../../primitives/pdf-stream';\nimport { PdfArray } from './../../primitives/pdf-array';\nimport { PdfName } from './../../primitives/pdf-name';\nimport { PdfNumber } from './../../primitives/pdf-number';\nimport { PdfString } from './../../primitives/pdf-string';\nimport { PdfReferenceHolder } from './../../primitives/pdf-reference';\nimport { PdfFontMetrics } from './pdf-font-metrics';\nimport { StandardWidthTable } from './pdf-font-metrics';\nimport { DictionaryProperties } from './../../input-output/pdf-dictionary-properties';\nimport { Dictionary } from './../../collections/dictionary';\nimport { FontDescriptorFlags } from './enum';\nimport { RectangleF } from './../../drawing/pdf-drawing';\nimport { Operators } from './../../input-output/pdf-operators';\n\nvar UnicodeTrueTypeFont =\n/** @class */\nfunction () {\n  /* tslint:enable */\n  //Constructors\n\n  /**\n   * Initializes a new instance of the `PdfTrueTypeFont` class.\n   * @private\n   */\n  function UnicodeTrueTypeFont(base64String, size) {\n    // Fields\n    this.nameString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    /**\n     * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.\n     * @private\n     */\n\n    this.dictionaryProperties = new DictionaryProperties();\n    /**\n     * Indicates whether the font program is compressed or not.\n     * @private\n     */\n\n    this.isCompress = false;\n    /**\n     * Indicates whether the font is embedded or not.\n     */\n\n    this.isEmbedFont = false;\n    /**\n     * Cmap table's start prefix.\n     */\n\n    /* tslint:disable */\n\n    this.cmapPrefix = '/CIDInit /ProcSet findresource begin\\n12 dict begin\\nbegincmap' + Operators.newLine + '/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\\n/CMapName ' + '/Adobe-Identity-UCS def\\n/CMapType 2 def\\n1 begincodespacerange' + Operators.newLine;\n    /* tslint:enable */\n\n    /**\n     * Cmap table's start suffix.\n     */\n\n    this.cmapEndCodespaceRange = 'endcodespacerange' + Operators.newLine;\n    /**\n     * Cmap's begin range marker.\n     */\n\n    this.cmapBeginRange = 'beginbfrange' + Operators.newLine;\n    /**\n     * Cmap's end range marker.\n     */\n\n    this.cmapEndRange = 'endbfrange' + Operators.newLine;\n    /**\n     * Cmap table's end\n     */\n\n    /* tslint:disable */\n\n    this.cmapSuffix = 'endbfrange\\nendcmap\\nCMapName currentdict ' + '/CMap defineresource pop\\nend end' + Operators.newLine;\n\n    if (base64String === null || base64String === undefined) {\n      throw new Error('ArgumentNullException:base64String');\n    }\n\n    this.fontSize = size;\n    this.fontString = base64String;\n    this.Initialize();\n  } //Implementation\n\n  /**\n   * Returns width of the char symbol.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.getCharWidth = function (charCode) {\n    var codeWidth = this.ttfReader.getCharWidth(charCode);\n    return codeWidth;\n  };\n  /**\n   * Returns width of the text line.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.getLineWidth = function (line) {\n    // if (line == null) {\n    //     throw new Error('ArgumentNullException : line');\n    // }\n    var width = 0;\n\n    for (var i = 0, len = line.length; i < len; i++) {\n      var ch = line[i];\n      var charWidth = this.getCharWidth(ch);\n      width += charWidth;\n    }\n\n    return width;\n  };\n  /**\n   * Initializes a new instance of the `PdfTrueTypeFont` class.\n   * @private\n   */\n\n\n  UnicodeTrueTypeFont.prototype.Initialize = function () {\n    var byteArray = new ByteArray(this.fontString.length);\n    byteArray.writeFromBase64String(this.fontString);\n    this.fontData = byteArray.internalBuffer;\n    this.ttfReader = new TtfReader(this.fontData);\n    this.ttfMetrics = this.ttfReader.metrics;\n  };\n\n  UnicodeTrueTypeFont.prototype.createInternals = function () {\n    this.fontDictionary = new PdfDictionary();\n    this.fontProgram = new PdfStream();\n    this.cmap = new PdfStream();\n    this.descendantFont = new PdfDictionary();\n    this.metrics = new PdfFontMetrics();\n    this.ttfReader.createInternals();\n    this.ttfMetrics = this.ttfReader.metrics;\n    this.initializeMetrics(); // Create all the dictionaries of the font.\n\n    this.subsetName = this.getFontName();\n    this.createDescendantFont();\n    this.createCmap();\n    this.createFontDictionary();\n    this.createFontProgram();\n  };\n\n  UnicodeTrueTypeFont.prototype.getInternals = function () {\n    return this.fontDictionary;\n  };\n  /**\n   * Initializes metrics.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.initializeMetrics = function () {\n    var ttfMetrics = this.ttfReader.metrics;\n    this.metrics.ascent = ttfMetrics.macAscent;\n    this.metrics.descent = ttfMetrics.macDescent;\n    this.metrics.height = ttfMetrics.macAscent - ttfMetrics.macDescent + ttfMetrics.lineGap;\n    this.metrics.name = ttfMetrics.fontFamily;\n    this.metrics.postScriptName = ttfMetrics.postScriptName;\n    this.metrics.size = this.fontSize;\n    this.metrics.widthTable = new StandardWidthTable(ttfMetrics.widthTable);\n    this.metrics.lineGap = ttfMetrics.lineGap;\n    this.metrics.subScriptSizeFactor = ttfMetrics.subScriptSizeFactor;\n    this.metrics.superscriptSizeFactor = ttfMetrics.superscriptSizeFactor;\n    this.metrics.isBold = ttfMetrics.isBold;\n  };\n  /**\n   * Gets random string.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.getFontName = function () {\n    var builder = '';\n    var name; // if (this.isEmbed === false) {\n\n    for (var i = 0; i < 6; i++) {\n      var index = Math.floor(Math.random() * (25 - 0 + 1)) + 0;\n      builder += this.nameString[index];\n    }\n\n    builder += '+'; // }\n\n    builder += this.ttfReader.metrics.postScriptName;\n    name = builder.toString(); // if (name === '') {\n    //     name = this.ttfReader.metrics.fontFamily;\n    // }\n\n    name = this.formatName(name);\n    return name;\n  };\n  /**\n   * Generates name of the font.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.formatName = function (fontName) {\n    // if (fontName === null) {\n    //     throw new Error('ArgumentNullException : fontName');\n    // }\n    // if (fontName === '') {\n    //     throw new Error('ArgumentOutOfRangeException : fontName, Parameter can not be empty');\n    // }\n    var ret = fontName.replace('(', '#28');\n    ret = ret.replace(')', '#29');\n    ret = ret.replace('[', '#5B');\n    ret = ret.replace(']', '#5D');\n    ret = ret.replace('<', '#3C');\n    ret = ret.replace('>', '#3E');\n    ret = ret.replace('{', '#7B');\n    ret = ret.replace('}', '#7D');\n    ret = ret.replace('/', '#2F');\n    ret = ret.replace('%', '#25');\n    return ret.replace(' ', '#20');\n  };\n  /**\n   * Creates descendant font.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.createDescendantFont = function () {\n    // Set property used to clone Font every time\n    this.descendantFont.isFont = true;\n    this.descendantFont.descendantFontBeginSave = new SaveDescendantFontEventHandler(this);\n    this.descendantFont.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));\n    this.descendantFont.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.cIDFontType2));\n    this.descendantFont.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));\n    this.descendantFont.items.setValue(this.dictionaryProperties.cIDToGIDMap, new PdfName(this.dictionaryProperties.identity));\n    this.descendantFont.items.setValue(this.dictionaryProperties.dw, new PdfNumber(1000));\n    this.fontDescriptor = this.createFontDescriptor();\n    this.descendantFont.items.setValue(this.dictionaryProperties.fontDescriptor, new PdfReferenceHolder(this.fontDescriptor));\n    var systemInfo = this.createSystemInfo();\n    this.descendantFont.items.setValue(this.dictionaryProperties.cIDSystemInfo, systemInfo);\n  };\n  /**\n   * Creates font descriptor.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.createFontDescriptor = function () {\n    var descriptor = new PdfDictionary();\n    var metrics = this.ttfReader.metrics; // Set property used to clone Font every time\n\n    descriptor.isFont = true;\n    descriptor.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.fontDescriptor));\n    descriptor.items.setValue(this.dictionaryProperties.fontName, new PdfName(this.subsetName));\n    descriptor.items.setValue(this.dictionaryProperties.flags, new PdfNumber(this.getDescriptorFlags()));\n    descriptor.items.setValue(this.dictionaryProperties.fontBBox, PdfArray.fromRectangle(this.getBoundBox()));\n    descriptor.items.setValue(this.dictionaryProperties.missingWidth, new PdfNumber(metrics.widthTable[32]));\n    descriptor.items.setValue(this.dictionaryProperties.stemV, new PdfNumber(metrics.stemV));\n    descriptor.items.setValue(this.dictionaryProperties.italicAngle, new PdfNumber(metrics.italicAngle));\n    descriptor.items.setValue(this.dictionaryProperties.capHeight, new PdfNumber(metrics.capHeight));\n    descriptor.items.setValue(this.dictionaryProperties.ascent, new PdfNumber(metrics.winAscent));\n    descriptor.items.setValue(this.dictionaryProperties.descent, new PdfNumber(metrics.winDescent));\n    descriptor.items.setValue(this.dictionaryProperties.leading, new PdfNumber(metrics.leading));\n    descriptor.items.setValue(this.dictionaryProperties.avgWidth, new PdfNumber(metrics.widthTable[32]));\n    descriptor.items.setValue(this.dictionaryProperties.fontFile2, new PdfReferenceHolder(this.fontProgram));\n    descriptor.items.setValue(this.dictionaryProperties.maxWidth, new PdfNumber(metrics.widthTable[32]));\n    descriptor.items.setValue(this.dictionaryProperties.xHeight, new PdfNumber(0));\n    descriptor.items.setValue(this.dictionaryProperties.stemH, new PdfNumber(0));\n    return descriptor;\n  };\n  /**\n   * Generates cmap.\n   * @private\n   */\n\n\n  UnicodeTrueTypeFont.prototype.createCmap = function () {\n    this.cmap.cmapBeginSave = new SaveCmapEventHandler(this);\n  };\n  /**\n   * Generates font dictionary.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.createFontDictionary = function () {\n    // Set property used to clone Font every time\n    this.fontDictionary.isFont = true;\n    this.fontDictionary.fontDictionaryBeginSave = new SaveFontDictionaryEventHandler(this);\n    this.fontDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));\n    this.fontDictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));\n    this.fontDictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type0));\n    this.fontDictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(this.dictionaryProperties.identityH));\n    var descFonts = new PdfArray();\n    var reference = new PdfReferenceHolder(this.descendantFont); // Set property used to clone Font every time\n\n    descFonts.isFont = true;\n    descFonts.add(reference);\n    this.fontDictionary.items.setValue(this.dictionaryProperties.descendantFonts, descFonts);\n  };\n  /**\n   * Creates font program.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.createFontProgram = function () {\n    this.fontProgram.fontProgramBeginSave = new SaveFontProgramEventHandler(this);\n  };\n  /**\n   * Creates system info dictionary for CID font.\n   * @private\n   */\n\n\n  UnicodeTrueTypeFont.prototype.createSystemInfo = function () {\n    var systemInfo = new PdfDictionary();\n    systemInfo.items.setValue(this.dictionaryProperties.registry, new PdfString('Adobe'));\n    systemInfo.items.setValue(this.dictionaryProperties.ordering, new PdfString(this.dictionaryProperties.identity));\n    systemInfo.items.setValue(this.dictionaryProperties.supplement, new PdfNumber(0));\n    return systemInfo;\n  };\n  /**\n   * Runs before font Dictionary will be saved.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.descendantFontBeginSave = function () {\n    if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {\n      var width = this.getDescendantWidth();\n\n      if (width !== null) {\n        this.descendantFont.items.setValue(this.dictionaryProperties.w, width);\n      }\n    }\n  };\n  /**\n   * Runs before font Dictionary will be saved.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.cmapBeginSave = function () {\n    this.generateCmap();\n  };\n  /**\n   * Runs before font Dictionary will be saved.\n   */\n\n  /* tslint:disable */\n\n\n  UnicodeTrueTypeFont.prototype.fontDictionaryBeginSave = function () {\n    if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0 && !this.fontDictionary.containsKey(this.dictionaryProperties.toUnicode)) {\n      this.fontDictionary.items.setValue(this.dictionaryProperties.toUnicode, new PdfReferenceHolder(this.cmap));\n    }\n  };\n  /* tslint:enable */\n\n  /**\n   * Runs before font program stream save.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.fontProgramBeginSave = function () {\n    this.isCompress = true;\n    this.generateFontProgram();\n  };\n  /**\n   * Gets width description pad array for c i d font.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.getDescendantWidth = function () {\n    var array = new PdfArray();\n\n    if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {\n      var glyphInfo = []; // if (!this.isEmbedFont) {\n\n      var keys = this.usedChars.keys();\n\n      for (var i = 0; i < keys.length; i++) {\n        var chLen = keys[i];\n        var glyph = this.ttfReader.getGlyph(chLen);\n\n        if (glyph.empty) {\n          continue;\n        }\n\n        glyphInfo.push(glyph);\n      } // } else {\n      //     glyphInfo = this.ttfReader.getAllGlyphs();\n      // }\n\n\n      glyphInfo.sort(function (a, b) {\n        return a.index - b.index;\n      });\n      var firstGlyphIndex = 0;\n      var lastGlyphIndex = 0;\n      var firstGlyphIndexWasSet = false;\n      var widthDetails = new PdfArray(); // if (!this.isEmbedFont) {\n\n      for (var i = 0; i < glyphInfo.length; i++) {\n        var glyph = glyphInfo[i];\n\n        if (!firstGlyphIndexWasSet) {\n          firstGlyphIndexWasSet = true;\n          firstGlyphIndex = glyph.index;\n          lastGlyphIndex = glyph.index - 1;\n        }\n\n        if ((lastGlyphIndex + 1 !== glyph.index || i + 1 === glyphInfo.length) && glyphInfo.length > 1) {\n          // Add glyph index / width.\n          array.add(new PdfNumber(firstGlyphIndex));\n\n          if (i !== 0) {\n            array.add(widthDetails);\n          }\n\n          firstGlyphIndex = glyph.index;\n          widthDetails = new PdfArray();\n        }\n\n        widthDetails.add(new PdfNumber(glyph.width));\n\n        if (i + 1 === glyphInfo.length) {\n          array.add(new PdfNumber(firstGlyphIndex));\n          array.add(widthDetails);\n        }\n\n        lastGlyphIndex = glyph.index;\n      } // } else {\n      //     for (let i : number = 0; i < glyphInfo.length; i++) {\n      //         let glyph : TtfGlyphInfo = glyphInfo[i];\n      //         if (!firstGlyphIndexWasSet) {\n      //             firstGlyphIndexWasSet = true;\n      //             lastGlyphIndex = glyph.index - 1;\n      //         }\n      //         firstGlyphIndex = glyph.index;\n      //         if ((lastGlyphIndex + 1 === glyph.index || (i + 1 === glyphInfo.length)) && glyphInfo.length > 1) {\n      //             // Add glyph index / width.\n      //             widthDetails.add(new PdfNumber(glyph.width));\n      //             array.add(new PdfNumber(firstGlyphIndex));\n      //             array.add(widthDetails);\n      //             widthDetails = new PdfArray();\n      //         }\n      //         lastGlyphIndex = glyph.index;\n      //     }\n      // }\n\n    }\n\n    return array;\n  };\n  /**\n   * Creates cmap.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.generateCmap = function () {\n    if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {\n      var glyphChars = this.ttfReader.getGlyphChars(this.usedChars);\n\n      if (glyphChars.size() > 0) {\n        var keys = glyphChars.keys().sort(); // add first and last glyph indexes\n\n        var first = keys[0];\n        var last = keys[keys.length - 1];\n        var middlePart = this.toHexString(first, false) + this.toHexString(last, false) + Operators.newLine;\n        var builder = '';\n        builder += this.cmapPrefix;\n        builder += middlePart;\n        builder += this.cmapEndCodespaceRange;\n        var nextRange = 0;\n\n        for (var i = 0; i < keys.length; i++) {\n          if (nextRange === 0) {\n            if (i !== 0) {\n              builder += this.cmapEndRange;\n            }\n\n            nextRange = Math.min(100, keys.length - i);\n            builder += nextRange;\n            builder += Operators.whiteSpace;\n            builder += this.cmapBeginRange;\n          }\n\n          nextRange -= 1;\n          var key = keys[i];\n          /* tslint:disable */\n\n          builder += this.toHexString(key, true) + this.toHexString(key, true) + this.toHexString(glyphChars.getValue(key), true) + '\\n';\n          /* tslint:enable */\n        }\n\n        builder += this.cmapSuffix;\n        this.cmap.clearStream();\n        this.cmap.isFont = true;\n        this.cmap.write(builder);\n      }\n    }\n  };\n  /**\n   * Generates font program.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.generateFontProgram = function () {\n    var fontProgram = null;\n    this.usedChars = this.usedChars === null || this.usedChars === undefined ? new Dictionary() : this.usedChars;\n    this.ttfReader.setOffset(0);\n    fontProgram = this.ttfReader.readFontProgram(this.usedChars);\n    this.fontProgram.clearStream();\n    this.fontProgram.isFont = true;\n    this.fontProgram.writeBytes(fontProgram);\n  };\n  /**\n   * Calculates flags for the font descriptor.\n   * @private\n   */\n\n\n  UnicodeTrueTypeFont.prototype.getDescriptorFlags = function () {\n    var flags = 0;\n    var metrics = this.ttfReader.metrics;\n\n    if (metrics.isFixedPitch) {\n      flags |= FontDescriptorFlags.FixedPitch;\n    }\n\n    if (metrics.isSymbol) {\n      flags |= FontDescriptorFlags.Symbolic;\n    } else {\n      flags |= FontDescriptorFlags.Nonsymbolic;\n    }\n\n    if (metrics.isItalic) {\n      flags |= FontDescriptorFlags.Italic;\n    }\n\n    if (metrics.isBold) {\n      flags |= FontDescriptorFlags.ForceBold;\n    }\n\n    return flags;\n  };\n  /**\n   * Calculates BoundBox of the descriptor.\n   * @private\n   */\n\n\n  UnicodeTrueTypeFont.prototype.getBoundBox = function () {\n    var rect = this.ttfReader.metrics.fontBox;\n    var width = Math.abs(rect.right - rect.left);\n    var height = Math.abs(rect.top - rect.bottom);\n    var rectangle = new RectangleF(rect.left, rect.bottom, width, height);\n    return rectangle;\n  };\n  /**\n   * Converts integer of decimal system to hex integer.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.toHexString = function (n, isCaseChange) {\n    var s = n.toString(16);\n\n    if (isCaseChange) {\n      s = s.toUpperCase();\n    }\n\n    return '<0000'.substring(0, 5 - s.length) + s + '>';\n  };\n  /**\n   * Stores used symbols.\n   */\n\n\n  UnicodeTrueTypeFont.prototype.setSymbols = function (text) {\n    if (text === null) {\n      throw new Error('Argument Null Exception : text');\n    }\n\n    if (this.usedChars === null || this.usedChars === undefined) {\n      this.usedChars = new Dictionary();\n    }\n\n    for (var i = 0; i < text.length; i++) {\n      var ch = text[i];\n      this.usedChars.setValue(ch, String.fromCharCode(0));\n    } // else {\n    //     if (text === null) {\n    //         throw new Error('Argument Null Exception : glyphs');\n    //     }\n    //     if (this.usedChars === null || this.usedChars === undefined) {\n    //             this.usedChars = new Dictionary<string, string>();\n    //     }\n    //     for (let i : number = 0; i < text.length; i++) {\n    //         let glyphIndex : number = text[i];\n    //         let glyph : TtfGlyphInfo =  this.ttfReader.getGlyph(glyphIndex);\n    //         if (!glyph == null) {\n    //             let c : string = glyph.charCode.toLocaleString();\n    //             this.usedChars.setValue(c, String.fromCharCode(0));\n    //         }\n    //     }\n    // }\n\n\n    if (this.isEmbedFont === false) {\n      this.getDescendantWidth();\n    }\n  };\n\n  return UnicodeTrueTypeFont;\n}();\n\nexport { UnicodeTrueTypeFont };","map":null,"metadata":{},"sourceType":"module"}