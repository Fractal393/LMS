{"ast":null,"code":"import { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\n\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\n\nvar CompressedStreamWriter =\n/** @class */\nfunction () {\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  function CompressedStreamWriter(noWrap) {\n    this.pendingBuffer = new Uint8Array(1 << 16);\n    this.pendingBufLength = 0;\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.currentHash = 0;\n    this.matchStart = 0;\n    this.matchLength = 0;\n    this.matchPrevAvail = false;\n    this.blockStart = 0;\n    this.stringStart = 0;\n    this.lookAhead = 0;\n    this.totalBytesIn = 0;\n    this.inputOffset = 0;\n    this.inputEnd = 0;\n    this.windowSize = 1 << 15;\n    this.windowMask = this.windowSize - 1;\n    this.hashSize = 1 << 15;\n    this.hashMask = this.hashSize - 1;\n    this.hashShift = Math.floor((15 + 3 - 1) / 3);\n    this.maxDist = this.windowSize - 262;\n    this.checkSum = 1;\n    this.noWrap = false;\n\n    if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n      CompressedStreamWriter.initHuffmanTree();\n      CompressedStreamWriter.isHuffmanTreeInitiated = true;\n    }\n\n    this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n    this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n    this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n    this.arrDistances = new Uint16Array(1 << 14);\n    this.arrLiterals = new Uint8Array(1 << 14);\n    this.stream = [];\n    this.dataWindow = new Uint8Array(2 * this.windowSize);\n    this.hashHead = new Int16Array(this.hashSize);\n    this.hashPrevious = new Int16Array(this.windowSize);\n    this.blockStart = this.stringStart = 1;\n    this.noWrap = noWrap;\n\n    if (!noWrap) {\n      this.writeZLibHeader();\n    }\n  }\n\n  Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n    /**\n     * get compressed data\n     */\n    get: function () {\n      return this.stream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n    get: function () {\n      var compressedString = '';\n\n      if (this.stream !== undefined) {\n        for (var i = 0; i < this.stream.length; i++) {\n          compressedString += String.fromCharCode.apply(null, this.stream[i]);\n        }\n      }\n\n      return compressedString;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Compresses data and writes it to the stream.\n   * @param {Uint8Array} data - data to compress\n   * @param {number} offset - offset in data\n   * @param {number} length - length of the data\n   * @returns {void}\n   */\n\n  CompressedStreamWriter.prototype.write = function (data, offset, length) {\n    if (data === undefined || data === null) {\n      throw new Error('ArgumentException: data cannot null or undefined');\n    }\n\n    var end = offset + length;\n\n    if (0 > offset || offset > end || end > data.length) {\n      throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n    }\n\n    if (typeof data === 'string') {\n      var encode = new Encoding(false);\n      encode.type = 'Utf8';\n      data = new Uint8Array(encode.getBytes(data, 0, data.length));\n      end = offset + data.length;\n    }\n\n    this.inputBuffer = data;\n    this.inputOffset = offset;\n    this.inputEnd = end;\n\n    if (!this.noWrap) {\n      this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n    }\n\n    while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n      this.pendingBufferFlush();\n      this.compressData(false);\n    }\n  };\n  /**\n   * write ZLib header to the compressed data\n   * @return {void}\n   */\n\n\n  CompressedStreamWriter.prototype.writeZLibHeader = function () {\n    /* Initialize header.*/\n    var headerDate = 8 + (7 << 4) << 8;\n    /* Save compression level.*/\n\n    headerDate |= (5 >> 2 & 3) << 6;\n    /* Align header.*/\n\n    headerDate += 31 - headerDate % 31;\n    /* Write header to stream.*/\n\n    this.pendingBufferWriteShortBytes(headerDate);\n  };\n  /**\n   *  Write Most Significant Bytes in to stream\n   * @param {number} s - check sum value\n   */\n\n\n  CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n    this.pendingBuffer[this.pendingBufLength++] = s;\n  };\n\n  CompressedStreamWriter.prototype.compressData = function (finish) {\n    var success;\n\n    do {\n      this.fillWindow();\n      var canFlush = finish && this.inputEnd === this.inputOffset;\n      success = this.compressSlow(canFlush, finish);\n    } while (this.pendingBufLength === 0 && success);\n\n    return success;\n  };\n\n  CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n    if (this.lookAhead < 262 && !flush) {\n      return false;\n    }\n\n    while (this.lookAhead >= 262 || flush) {\n      if (this.lookAhead === 0) {\n        return this.lookAheadCompleted(finish);\n      }\n\n      if (this.stringStart >= 2 * this.windowSize - 262) {\n        this.slideWindow();\n      }\n\n      var prevMatch = this.matchStart;\n      var prevLen = this.matchLength;\n\n      if (this.lookAhead >= 3) {\n        this.discardMatch();\n      }\n\n      if (prevLen >= 3 && this.matchLength <= prevLen) {\n        prevLen = this.matchPreviousBest(prevMatch, prevLen);\n      } else {\n        this.matchPreviousAvailable();\n      }\n\n      if (this.bufferPosition >= 1 << 14) {\n        return this.huffmanIsFull(finish);\n      }\n    }\n\n    return true;\n  };\n\n  CompressedStreamWriter.prototype.discardMatch = function () {\n    var hashHead = this.insertString();\n\n    if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n      if (this.matchLength <= 5 && this.matchLength === 3 && this.stringStart - this.matchStart > 4096) {\n        this.matchLength = 3 - 1;\n      }\n    }\n  };\n\n  CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = true;\n    this.stringStart++;\n    this.lookAhead--;\n  };\n\n  CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n    this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n    prevLen -= 2;\n\n    do {\n      this.stringStart++;\n      this.lookAhead--;\n\n      if (this.lookAhead >= 3) {\n        this.insertString();\n      }\n    } while (--prevLen > 0);\n\n    this.stringStart++;\n    this.lookAhead--;\n    this.matchPrevAvail = false;\n    this.matchLength = 3 - 1;\n    return prevLen;\n  };\n\n  CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = false;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n    this.blockStart = this.stringStart;\n    return false;\n  };\n\n  CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n    var len = this.stringStart - this.blockStart;\n\n    if (this.matchPrevAvail) {\n      len--;\n    }\n\n    var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n    this.blockStart += len;\n    return !lastBlock;\n  };\n\n  CompressedStreamWriter.prototype.fillWindow = function () {\n    if (this.stringStart >= this.windowSize + this.maxDist) {\n      this.slideWindow();\n    }\n\n    while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n      var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n\n      if (more > this.inputEnd - this.inputOffset) {\n        more = this.inputEnd - this.inputOffset;\n      }\n\n      this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n      this.inputOffset += more;\n      this.totalBytesIn += more;\n      this.lookAhead += more;\n    }\n\n    if (this.lookAhead >= 3) {\n      this.updateHash();\n    }\n  };\n\n  CompressedStreamWriter.prototype.slideWindow = function () {\n    this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n    this.matchStart -= this.windowSize;\n    this.stringStart -= this.windowSize;\n    this.blockStart -= this.windowSize;\n\n    for (var i = 0; i < this.hashSize; ++i) {\n      var m = this.hashHead[i] & 0xffff;\n      this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n\n    for (var i = 0; i < this.windowSize; i++) {\n      var m = this.hashPrevious[i] & 0xffff;\n      this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n  };\n\n  CompressedStreamWriter.prototype.insertString = function () {\n    var match;\n    var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n    this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n    this.hashHead[hash] = this.stringStart;\n    this.currentHash = hash;\n    return match & 0xffff;\n  };\n\n  CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n    var chainLen = 4096;\n    var niceLen = 258;\n    var scan = this.stringStart;\n    var match;\n    var bestEnd = this.stringStart + this.matchLength;\n    var bestLength = Math.max(this.matchLength, 3 - 1);\n    var limit = Math.max(this.stringStart - this.maxDist, 0);\n    var stringEnd = this.stringStart + 258 - 1;\n    var scanEnd1 = this.dataWindow[bestEnd - 1];\n    var scanEnd = this.dataWindow[bestEnd];\n    var data = this.dataWindow;\n\n    if (bestLength >= 32) {\n      chainLen >>= 2;\n    }\n\n    if (niceLen > this.lookAhead) {\n      niceLen = this.lookAhead;\n    }\n\n    do {\n      if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {\n        continue;\n      }\n\n      match = curMatch + 2;\n      scan += 2;\n      /* tslint:disable */\n\n      while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n        /* tslint:disable */\n      }\n\n      if (scan > bestEnd) {\n        this.matchStart = curMatch;\n        bestEnd = scan;\n        bestLength = scan - this.stringStart;\n\n        if (bestLength >= niceLen) {\n          break;\n        }\n\n        scanEnd1 = data[bestEnd - 1];\n        scanEnd = data[bestEnd];\n      }\n\n      scan = this.stringStart;\n    } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 0xffff) > limit && --chainLen !== 0);\n\n    this.matchLength = Math.min(bestLength, this.lookAhead);\n    return this.matchLength >= 3;\n  };\n\n  CompressedStreamWriter.prototype.updateHash = function () {\n    this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];\n  };\n\n  CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n    this.arrDistances[this.bufferPosition] = 0;\n    this.arrLiterals[this.bufferPosition++] = literal;\n    this.treeLiteral.codeFrequencies[literal]++;\n    return this.bufferPosition >= 1 << 14;\n  };\n\n  CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n    this.arrDistances[this.bufferPosition] = dist;\n    this.arrLiterals[this.bufferPosition++] = len - 3;\n    var lc = this.huffmanLengthCode(len - 3);\n    this.treeLiteral.codeFrequencies[lc]++;\n\n    if (lc >= 265 && lc < 285) {\n      this.extraBits += Math.floor((lc - 261) / 4);\n    }\n\n    var dc = this.huffmanDistanceCode(dist - 1);\n    this.treeDistances.codeFrequencies[dc]++;\n\n    if (dc >= 4) {\n      this.extraBits += Math.floor(dc / 2 - 1);\n    }\n\n    return this.bufferPosition >= 1 << 14;\n  };\n\n  CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.treeLiteral.codeFrequencies[256]++;\n    this.treeLiteral.buildTree();\n    this.treeDistances.buildTree();\n    this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n    this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n    this.treeCodeLengths.buildTree();\n    var blTreeCodes = 4;\n\n    for (var i = 18; i > blTreeCodes; i--) {\n      if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n        blTreeCodes = i + 1;\n      }\n    }\n\n    var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n    var static_len = this.extraBits;\n\n    for (var i = 0; i < 286; i++) {\n      static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n    }\n\n    for (var i = 0; i < 30; i++) {\n      static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n    }\n\n    if (opt_len >= static_len) {\n      // Force static trees.\n      opt_len = static_len;\n    }\n\n    if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n      this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n    } else if (opt_len == static_len) {\n      // Encode with static tree.\n      this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n      this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n      this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    } else {\n      this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n      this.huffmanSendAllTrees(blTreeCodes);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    }\n  };\n\n  CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n    this.pendingBufferAlignToByte();\n    this.pendingBufferWriteShort(storedLength);\n    this.pendingBufferWriteShort(~storedLength);\n    this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n    this.huffmanReset();\n  };\n\n  CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n    if (len === 255) {\n      return 285;\n    }\n\n    var code = 257;\n\n    while (len >= 8) {\n      code += 4;\n      len >>= 1;\n    }\n\n    return code + len;\n  };\n\n  CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n    var code = 0;\n\n    while (distance >= 4) {\n      code += 2;\n      distance >>= 1;\n    }\n\n    return code + distance;\n  };\n\n  CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n    this.treeCodeLengths.buildCodes();\n    this.treeLiteral.buildCodes();\n    this.treeDistances.buildCodes();\n    this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n    this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n    this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n\n    for (var rank = 0; rank < blTreeCodes; rank++) {\n      this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n    }\n\n    this.treeLiteral.writeTree(this.treeCodeLengths);\n    this.treeDistances.writeTree(this.treeCodeLengths);\n  };\n\n  CompressedStreamWriter.prototype.huffmanReset = function () {\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.treeLiteral.reset();\n    this.treeDistances.reset();\n    this.treeCodeLengths.reset();\n  };\n\n  CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n    for (var i = 0; i < this.bufferPosition; i++) {\n      var literalLen = this.arrLiterals[i] & 255;\n      var dist = this.arrDistances[i];\n\n      if (dist-- !== 0) {\n        var lc = this.huffmanLengthCode(literalLen);\n        this.treeLiteral.writeCodeToStream(lc);\n        var bits = Math.floor((lc - 261) / 4);\n\n        if (bits > 0 && bits <= 5) {\n          this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);\n        }\n\n        var dc = this.huffmanDistanceCode(dist);\n        this.treeDistances.writeCodeToStream(dc);\n        bits = Math.floor(dc / 2 - 1);\n\n        if (bits > 0) {\n          this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);\n        }\n      } else {\n        this.treeLiteral.writeCodeToStream(literalLen);\n      }\n    }\n\n    this.treeLiteral.writeCodeToStream(256);\n  };\n  /**\n   * write bits in to internal buffer\n   * @param {number} b - source of bits\n   * @param {number} count - count of bits to write\n   */\n\n\n  CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n    var uint = new Uint32Array(1);\n    uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;\n    this.pendingBufCache = uint[0];\n    this.pendingBufBitsInCache += count;\n    this.pendingBufferFlushBits();\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n    this.pendingBufferFlushBits();\n\n    if (this.pendingBufLength > 0) {\n      var array = new Uint8Array(this.pendingBufLength);\n      array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n      this.stream.push(array);\n    }\n\n    this.pendingBufLength = 0;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n    var result = 0;\n\n    while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n      this.pendingBufCache >>= 8;\n      this.pendingBufBitsInCache -= 8;\n      result++;\n    }\n\n    return result;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n    var array = data.subarray(offset, offset + length);\n    this.pendingBuffer.set(array, this.pendingBufLength);\n    this.pendingBufLength += length;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s;\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n    if (this.pendingBufBitsInCache > 0) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n    }\n\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n  };\n  /**\n   * Huffman Tree literal calculation\n   * @private\n   */\n\n\n  CompressedStreamWriter.initHuffmanTree = function () {\n    var i = 0;\n\n    while (i < 144) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x030 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    while (i < 256) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x190 - 144 + i << 7);\n      ARR_LITERAL_LENGTHS[i++] = 9;\n    }\n\n    while (i < 280) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x000 - 256 + i << 9);\n      ARR_LITERAL_LENGTHS[i++] = 7;\n    }\n\n    while (i < 286) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x0c0 - 280 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    for (i = 0; i < 30; i++) {\n      ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n      ARR_DISTANCE_LENGTHS[i] = 5;\n    }\n  };\n  /**\n   * close the stream and write all pending buffer in to stream\n   * @returns {void}\n   */\n\n\n  CompressedStreamWriter.prototype.close = function () {\n    do {\n      this.pendingBufferFlush(true);\n\n      if (!this.compressData(true)) {\n        this.pendingBufferFlush(true);\n        this.pendingBufferAlignToByte();\n\n        if (!this.noWrap) {\n          this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n          this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n        }\n\n        this.pendingBufferFlush(true);\n      }\n    } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  CompressedStreamWriter.prototype.destroy = function () {\n    this.stream = [];\n    this.stream = undefined;\n    this.pendingBuffer = undefined;\n    this.treeLiteral = undefined;\n    this.treeDistances = undefined;\n    this.treeCodeLengths = undefined;\n    this.arrLiterals = undefined;\n    this.arrDistances = undefined;\n    this.hashHead = undefined;\n    this.hashPrevious = undefined;\n    this.dataWindow = undefined;\n    this.inputBuffer = undefined;\n    this.pendingBufLength = undefined;\n    this.pendingBufCache = undefined;\n    this.pendingBufBitsInCache = undefined;\n    this.bufferPosition = undefined;\n    this.extraBits = undefined;\n    this.currentHash = undefined;\n    this.matchStart = undefined;\n    this.matchLength = undefined;\n    this.matchPrevAvail = undefined;\n    this.blockStart = undefined;\n    this.stringStart = undefined;\n    this.lookAhead = undefined;\n    this.totalBytesIn = undefined;\n    this.inputOffset = undefined;\n    this.inputEnd = undefined;\n    this.windowSize = undefined;\n    this.windowMask = undefined;\n    this.hashSize = undefined;\n    this.hashMask = undefined;\n    this.hashShift = undefined;\n    this.maxDist = undefined;\n    this.checkSum = undefined;\n    this.noWrap = undefined;\n  };\n\n  CompressedStreamWriter.isHuffmanTreeInitiated = false;\n  return CompressedStreamWriter;\n}();\n\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\n\nvar CompressorHuffmanTree =\n/** @class */\nfunction () {\n  /**\n   * Create new Huffman Tree\n   * @param {CompressedStreamWriter} writer instance\n   * @param {number} elementCount - element count\n   * @param {number} minCodes - minimum count\n   * @param {number} maxLength - maximum count\n   */\n  function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n    this.writer = writer;\n    this.codeMinCount = minCodes;\n    this.maxLength = maxLength;\n    this.codeFrequency = new Uint16Array(elementCount);\n    this.lengthCount = new Int32Array(maxLength);\n  }\n\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n    get: function () {\n      return this.codeCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n    get: function () {\n      return this.codeLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n    get: function () {\n      return this.codeFrequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n    var temp = new Int16Array(codes.length);\n    temp.set(codes, 0);\n    this.codes = temp;\n    var lengthTemp = new Uint8Array(lengths.length);\n    lengthTemp.set(lengths, 0);\n    this.codeLength = lengthTemp;\n  };\n  /**\n   * reset all code data in tree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.reset = function () {\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      this.codeFrequency[i] = 0;\n    }\n\n    this.codes = undefined;\n    this.codeLength = undefined;\n  };\n  /**\n   * write code to the compressor output stream\n   * @param {number} code - code to be written\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n    this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n  };\n  /**\n   * calculate code from their frequencies\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.buildCodes = function () {\n    var nextCode = new Int32Array(this.maxLength);\n    this.codes = new Int16Array(this.codeCount);\n    var code = 0;\n\n    for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n      nextCode[bitsCount] = code;\n      code += this.lengthCount[bitsCount] << 15 - bitsCount;\n    }\n\n    for (var i = 0; i < this.codeCount; i++) {\n      var bits = this.codeLength[i];\n\n      if (bits > 0) {\n        this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n        nextCode[bits - 1] += 1 << 16 - bits;\n      }\n    }\n  };\n\n  CompressorHuffmanTree.bitReverse = function (value) {\n    return CompressorHuffmanTree.reverseBits[value & 15] << 12 | CompressorHuffmanTree.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree.reverseBits[value >> 12];\n  };\n  /**\n   * calculate length of compressed data\n   * @returns {number}\n   */\n\n\n  CompressorHuffmanTree.prototype.getEncodedLength = function () {\n    var len = 0;\n\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      len += this.codeFrequency[i] * this.codeLength[i];\n    }\n\n    return len;\n  };\n  /**\n   * calculate code frequencies\n   * @param {CompressorHuffmanTree} blTree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n    var maxCount;\n    var minCount;\n    var count;\n    var curLen = -1;\n    var i = 0;\n\n    while (i < this.codeCount) {\n      count = 1;\n      var nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxCount = 138;\n        minCount = 3;\n      } else {\n        maxCount = 6;\n        minCount = 3;\n\n        if (curLen !== nextLen) {\n          blTree.codeFrequency[nextLen]++;\n          count = 0;\n        }\n      }\n\n      curLen = nextLen;\n      i++;\n\n      while (i < this.codeCount && curLen === this.codeLength[i]) {\n        i++;\n\n        if (++count >= maxCount) {\n          break;\n        }\n      }\n\n      if (count < minCount) {\n        blTree.codeFrequency[curLen] += count;\n      } else if (curLen !== 0) {\n        blTree.codeFrequency[16]++;\n      } else if (count <= 10) {\n        blTree.codeFrequency[17]++;\n      } else {\n        blTree.codeFrequency[18]++;\n      }\n    }\n  };\n  /**\n   * @param {CompressorHuffmanTree} blTree - write tree to output stream\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n    var maxRepeatCount;\n    var minRepeatCount;\n    var currentRepeatCount;\n    var currentCodeLength = -1;\n    var i = 0;\n\n    while (i < this.codeCount) {\n      currentRepeatCount = 1;\n      var nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxRepeatCount = 138;\n        minRepeatCount = 3;\n      } else {\n        maxRepeatCount = 6;\n        minRepeatCount = 3;\n\n        if (currentCodeLength !== nextLen) {\n          blTree.writeCodeToStream(nextLen);\n          currentRepeatCount = 0;\n        }\n      }\n\n      currentCodeLength = nextLen;\n      i++;\n\n      while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n        i++;\n\n        if (++currentRepeatCount >= maxRepeatCount) {\n          break;\n        }\n      }\n\n      if (currentRepeatCount < minRepeatCount) {\n        while (currentRepeatCount-- > 0) {\n          blTree.writeCodeToStream(currentCodeLength);\n        }\n      } else if (currentCodeLength !== 0) {\n        blTree.writeCodeToStream(16);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n      } else if (currentRepeatCount <= 10) {\n        blTree.writeCodeToStream(17);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n      } else {\n        blTree.writeCodeToStream(18);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n      }\n    }\n  };\n  /**\n   * Build huffman tree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.buildTree = function () {\n    var codesCount = this.codeFrequency.length;\n    var arrTree = new Int32Array(codesCount);\n    var treeLength = 0;\n    var maxCount = 0;\n\n    for (var n = 0; n < codesCount; n++) {\n      var freq = this.codeFrequency[n];\n\n      if (freq !== 0) {\n        var pos = treeLength++;\n        var pPos = 0;\n\n        while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n          arrTree[pos] = arrTree[pPos];\n          pos = pPos;\n        }\n\n        arrTree[pos] = n;\n        maxCount = n;\n      }\n    }\n\n    while (treeLength < 2) {\n      arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;\n    }\n\n    this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n    var leafsCount = treeLength;\n    var nodesCount = leafsCount;\n    var child = new Int32Array(4 * treeLength - 2);\n    var values = new Int32Array(2 * treeLength - 1);\n\n    for (var i = 0; i < treeLength; i++) {\n      var node = arrTree[i];\n      var iIndex = 2 * i;\n      child[iIndex] = node;\n      child[iIndex + 1] = -1;\n      values[i] = this.codeFrequency[node] << 8;\n      arrTree[i] = i;\n    }\n\n    this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n    this.buildLength(child);\n  };\n\n  CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n    do {\n      var first = arrTree[0];\n      var last = arrTree[--treeLength];\n      var lastVal = values[last];\n      var pPos = 0;\n      var path = 1;\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n      var second = arrTree[0];\n      last = nodesCount++;\n      child[2 * last] = first;\n      child[2 * last + 1] = second;\n      var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n      values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n      pPos = 0;\n      path = 1;\n      /* tslint:disable */\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n      /* tslint:disable */\n\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n    } while (treeLength > 1);\n  };\n\n  CompressorHuffmanTree.prototype.buildLength = function (child) {\n    this.codeLength = new Uint8Array(this.codeFrequency.length);\n    var numNodes = Math.floor(child.length / 2);\n    var numLeafs = Math.floor((numNodes + 1) / 2);\n    var overflow = 0;\n\n    for (var i = 0; i < this.maxLength; i++) {\n      this.lengthCount[i] = 0;\n    }\n\n    overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n\n    if (overflow === 0) {\n      return;\n    }\n\n    var iIncreasableLength = this.maxLength - 1;\n\n    do {\n      while (this.lengthCount[--iIncreasableLength] === 0) {\n        /* tslint:disable */\n      }\n\n      do {\n        this.lengthCount[iIncreasableLength]--;\n        this.lengthCount[++iIncreasableLength]++;\n        overflow -= 1 << this.maxLength - 1 - iIncreasableLength;\n      } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n    } while (overflow > 0);\n\n    this.recreateTree(child, overflow, numLeafs);\n  };\n\n  CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n    this.lengthCount[this.maxLength - 1] += overflow;\n    this.lengthCount[this.maxLength - 2] -= overflow;\n    var nodePtr = 2 * numLeafs;\n\n    for (var bits = this.maxLength; bits !== 0; bits--) {\n      var n = this.lengthCount[bits - 1];\n\n      while (n > 0) {\n        var childPtr = 2 * child[nodePtr++];\n\n        if (child[childPtr + 1] === -1) {\n          this.codeLength[child[childPtr]] = bits;\n          n--;\n        }\n      }\n    }\n  };\n\n  CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n    var lengths = new Int32Array(numNodes);\n    lengths[numNodes - 1] = 0;\n\n    for (var i = numNodes - 1; i >= 0; i--) {\n      var childIndex = 2 * i + 1;\n\n      if (child[childIndex] !== -1) {\n        var bitLength = lengths[i] + 1;\n\n        if (bitLength > this.maxLength) {\n          bitLength = this.maxLength;\n          overflow++;\n        }\n\n        lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n      } else {\n        var bitLength = lengths[i];\n        this.lengthCount[bitLength - 1]++;\n        this.codeLength[child[childIndex - 1]] = lengths[i];\n      }\n    }\n\n    return overflow;\n  };\n\n  CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n  CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  return CompressorHuffmanTree;\n}();\n\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\n\nvar ChecksumCalculator =\n/** @class */\nfunction () {\n  function ChecksumCalculator() {}\n  /**\n   * Updates checksum by calculating checksum of the\n   * given buffer and adding it to current value.\n   * @param {number} checksum - current checksum.\n   * @param {Uint8Array} buffer - data byte array.\n   * @param {number} offset - offset in the buffer.\n   * @param {number} length - length of data to be used from the stream.\n   * @returns {number}\n   */\n\n\n  ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n    var uint = new Uint32Array(1);\n    uint[0] = checksum;\n    var checksum_uint = uint[0];\n    var s1 = uint[0] = checksum_uint & 65535;\n    var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n\n    while (length > 0) {\n      var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n      length -= steps;\n\n      while (--steps >= 0) {\n        s1 = s1 + (uint[0] = buffer[offset++] & 255);\n        s2 = s2 + s1;\n      }\n\n      s1 %= ChecksumCalculator.checksumBase;\n      s2 %= ChecksumCalculator.checksumBase;\n    }\n\n    checksum_uint = s2 << ChecksumCalculator.checkSumBitOffset | s1;\n    return checksum_uint;\n  };\n\n  ChecksumCalculator.checkSumBitOffset = 16;\n  ChecksumCalculator.checksumBase = 65521;\n  ChecksumCalculator.checksumIterationCount = 3800;\n  return ChecksumCalculator;\n}();\n\nexport { ChecksumCalculator };","map":null,"metadata":{},"sourceType":"module"}