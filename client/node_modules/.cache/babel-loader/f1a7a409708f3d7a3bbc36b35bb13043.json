{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SelectionUtil = exports.SelectionHelper = exports.useSelection = void 0;\n\nvar react_1 = require(\"react\");\n\nvar recoil_1 = require(\"recoil\");\n\nvar file_actions_recoil_1 = require(\"../recoil/file-actions.recoil\");\n\nvar file_actions_definitions_1 = require(\"./file-actions-definitions\");\n\nvar file_helper_1 = require(\"./file-helper\");\n\nexports.useSelection = function (files, disableSelection) {\n  var dispatchFileAction = recoil_1.useRecoilValue(file_actions_recoil_1.dispatchFileActionState); // Create React-managed state for components that need to re-render on state change.\n\n  var _a = react_1.useState(new Set()),\n      selection = _a[0],\n      setSelection = _a[1]; // Dispatch an action every time selection changes.\n\n\n  var lastSelectionSizeForAction = react_1.useRef(0);\n  react_1.useEffect(function () {\n    var selectedFiles = SelectionHelper.getSelectedFiles(files, selection); // We want to solve two problems here - first, we don't want to dispatch a\n    // selection action when Chonky is first initialized. We also don't want to\n    // dispatch an action if the current selection and the previous selection\n    // are empty (this can happen because Recoil can sometimes trigger updates\n    // even if object reference did not change).\n\n    if (lastSelectionSizeForAction.current === selectedFiles.length && selectedFiles.length === 0) {\n      return;\n    }\n\n    lastSelectionSizeForAction.current = selectedFiles.length;\n    dispatchFileAction({\n      actionId: file_actions_definitions_1.ChonkyActions.ChangeSelection.id,\n      files: selectedFiles\n    });\n  }, [files, dispatchFileAction, selection]); // Pre-compute selection size for components that are only interested in the\n  // number of selected files but not the actual files\n\n  var selectionSize = react_1.useMemo(function () {\n    return SelectionHelper.getSelectionSize(files, selection);\n  }, [files, selection]); // Create callbacks for updating selection. These will update the React\n  // state `selection`, causing re-renders. This is intentional.\n\n  var selectionModifiers = useSelectionModifiers(disableSelection, setSelection); // Create selection ref for functions that need selection but shouldn't re-render\n\n  var selectionUtilRef = react_1.useRef(new UpdateableSelectionUtil(files, selection));\n  react_1.useEffect(function () {\n    selectionUtilRef.current.update(files, selection);\n  }, [files, selection]);\n  return {\n    selection: selection,\n    selectionSize: selectionSize,\n    selectionUtilRef: selectionUtilRef,\n    selectionModifiers: selectionModifiers\n  };\n};\n\nvar useSelectionModifiers = function (disableSelection, setSelection) {\n  var selectFiles = react_1.useCallback(function (fileIds, reset) {\n    if (reset === void 0) {\n      reset = true;\n    }\n\n    if (disableSelection) return;\n    setSelection(function (selection) {\n      var newSelection = reset ? new Set() : new Set(selection);\n\n      for (var _i = 0, fileIds_1 = fileIds; _i < fileIds_1.length; _i++) {\n        var fileId = fileIds_1[_i];\n        newSelection.add(fileId);\n      }\n\n      return newSelection;\n    });\n  }, [disableSelection, setSelection]);\n  var toggleSelection = react_1.useCallback(function (fileId, exclusive) {\n    if (exclusive === void 0) {\n      exclusive = false;\n    }\n\n    if (disableSelection) return;\n    setSelection(function (selection) {\n      var newSelection = exclusive ? new Set() : new Set(selection);\n\n      if (selection.has(fileId)) {\n        newSelection.delete(fileId);\n      } else {\n        newSelection.add(fileId);\n      }\n\n      return newSelection;\n    });\n  }, [disableSelection, setSelection]);\n  var clearSelection = react_1.useCallback(function () {\n    if (disableSelection) return;\n    setSelection(function (oldSelection) {\n      if (oldSelection.size === 0) return oldSelection;\n      return new Set();\n    });\n  }, [disableSelection, setSelection]);\n  var selectionModifiers = react_1.useMemo(function () {\n    return {\n      selectFiles: selectFiles,\n      toggleSelection: toggleSelection,\n      clearSelection: clearSelection\n    };\n  }, [selectFiles, toggleSelection, clearSelection]);\n  return selectionModifiers;\n};\n/**\n * This helper relies on the `files` and `selection` objects to be passed from the\n * outside. It is safe to use in React components because it doesn't have any\n * internal state, and all methods are static.\n */\n\n\nvar SelectionHelper =\n/** @class */\nfunction () {\n  function SelectionHelper() {}\n\n  SelectionHelper.getSelectedFiles = function (files, selection) {\n    var filters = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      filters[_i - 2] = arguments[_i];\n    }\n\n    var selectedFiles = files.filter(function (file) {\n      return file_helper_1.FileHelper.isSelectable(file) && selection.has(file.id);\n    });\n    return filters.reduce(function (prevFiles, filter) {\n      return filter ? prevFiles.filter(filter) : prevFiles;\n    }, selectedFiles);\n  };\n\n  SelectionHelper.getSelectionSize = function (files, selection) {\n    var filters = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      filters[_i - 2] = arguments[_i];\n    }\n\n    return SelectionHelper.getSelectedFiles.apply(SelectionHelper, __spreadArrays([files, selection], filters)).length;\n  };\n\n  SelectionHelper.isSelected = function (selection, file) {\n    return file_helper_1.FileHelper.isSelectable(file) && selection.has(file.id);\n  };\n\n  return SelectionHelper;\n}();\n\nexports.SelectionHelper = SelectionHelper;\n/**\n * This `SelectionUtil` contains an internal reference to `files` and `selection`\n * objects. It is exposed via a React context, and is meant to be used in functions\n * that need to access selection WITHOUT triggering re-renders.\n */\n\nvar SelectionUtil =\n/** @class */\nfunction () {\n  function SelectionUtil(files, selection) {\n    if (files === void 0) {\n      files = [];\n    }\n\n    if (selection === void 0) {\n      selection = new Set();\n    }\n\n    this.protectedUpdate(files, selection);\n  }\n\n  SelectionUtil.prototype.protectedUpdate = function (files, selection) {\n    this.files = files;\n    this.selection = selection;\n  };\n\n  SelectionUtil.prototype.getSelection = function () {\n    return this.selection;\n  };\n\n  SelectionUtil.prototype.getSelectedFiles = function () {\n    var filters = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      filters[_i] = arguments[_i];\n    }\n\n    return SelectionHelper.getSelectedFiles.apply(SelectionHelper, __spreadArrays([this.files, this.selection], filters));\n  };\n\n  SelectionUtil.prototype.getSelectionSize = function () {\n    var filters = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      filters[_i] = arguments[_i];\n    }\n\n    return SelectionHelper.getSelectionSize.apply(SelectionHelper, __spreadArrays([this.files, this.selection], filters));\n  };\n\n  SelectionUtil.prototype.isSelected = function (file) {\n    return SelectionHelper.isSelected(this.selection, file);\n  };\n\n  return SelectionUtil;\n}();\n\nexports.SelectionUtil = SelectionUtil;\n\nvar UpdateableSelectionUtil =\n/** @class */\nfunction (_super) {\n  __extends(UpdateableSelectionUtil, _super);\n\n  function UpdateableSelectionUtil() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  UpdateableSelectionUtil.prototype.update = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    this.protectedUpdate.apply(this, args);\n  };\n\n  return UpdateableSelectionUtil;\n}(SelectionUtil);","map":null,"metadata":{},"sourceType":"script"}