{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.events.emitter.gesture.scroll.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar eventsEngine = require(\"../../events/core/events_engine\");\n\nvar Class = require(\"../../core/class\");\n\nvar abstract = Class.abstract;\n\nvar eventUtils = require(\"../../events/utils\");\n\nvar GestureEmitter = require(\"../../events/gesture/emitter.gesture\");\n\nvar registerEmitter = require(\"../../events/core/emitter_registrator\");\n\nvar animationFrame = require(\"../../animation/frame\");\n\nvar realDevice = require(\"../../core/devices\").real();\n\nvar compareVersions = require(\"../../core/utils/version\").compare;\n\nvar SCROLL_INIT_EVENT = \"dxscrollinit\";\nvar SCROLL_START_EVENT = \"dxscrollstart\";\nvar SCROLL_MOVE_EVENT = \"dxscroll\";\nvar SCROLL_END_EVENT = \"dxscrollend\";\nvar SCROLL_STOP_EVENT = \"dxscrollstop\";\nvar SCROLL_CANCEL_EVENT = \"dxscrollcancel\";\nvar Locker = Class.inherit(function () {\n  var NAMESPACED_SCROLL_EVENT = eventUtils.addNamespace(\"scroll\", \"dxScrollEmitter\");\n  return {\n    ctor: function (element) {\n      this._element = element;\n      this._locked = false;\n      var that = this;\n\n      this._proxiedScroll = function (e) {\n        that._scroll(e);\n      };\n\n      eventsEngine.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);\n    },\n    _scroll: abstract,\n    check: function (e, callback) {\n      if (this._locked) {\n        callback();\n      }\n    },\n    dispose: function () {\n      eventsEngine.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);\n    }\n  };\n}());\nvar TimeoutLocker = Locker.inherit(function () {\n  return {\n    ctor: function (element, timeout) {\n      this.callBase(element);\n      this._timeout = timeout;\n    },\n    _scroll: function () {\n      this._prepare();\n\n      this._forget();\n    },\n    _prepare: function () {\n      if (this._timer) {\n        this._clearTimer();\n      }\n\n      this._locked = true;\n    },\n    _clearTimer: function () {\n      clearTimeout(this._timer);\n      this._locked = false;\n      this._timer = null;\n    },\n    _forget: function () {\n      var that = this;\n      this._timer = setTimeout(function () {\n        that._clearTimer();\n      }, this._timeout);\n    },\n    dispose: function () {\n      this.callBase();\n\n      this._clearTimer();\n    }\n  };\n}());\nvar WheelLocker = TimeoutLocker.inherit(function () {\n  var WHEEL_UNLOCK_TIMEOUT = 400;\n  return {\n    ctor: function (element) {\n      this.callBase(element, WHEEL_UNLOCK_TIMEOUT);\n      this._lastWheelDirection = null;\n    },\n    check: function (e, callback) {\n      this._checkDirectionChanged(e);\n\n      this.callBase(e, callback);\n    },\n    _checkDirectionChanged: function (e) {\n      if (!eventUtils.isDxMouseWheelEvent(e)) {\n        this._lastWheelDirection = null;\n        return;\n      }\n\n      var direction = e.shiftKey || false;\n      var directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;\n      this._lastWheelDirection = direction;\n      this._locked = this._locked && !directionChange;\n    }\n  };\n}());\nvar PointerLocker = TimeoutLocker.inherit(function () {\n  var POINTER_UNLOCK_TIMEOUT = 400;\n  return {\n    ctor: function (element) {\n      this.callBase(element, POINTER_UNLOCK_TIMEOUT);\n    }\n  };\n}());\n!function () {\n  var ios8_greater = realDevice.ios && compareVersions(realDevice.version, [8]) >= 0;\n  var android5_greater = realDevice.android && compareVersions(realDevice.version, [5]) >= 0;\n\n  if (!(ios8_greater || android5_greater)) {\n    return;\n  }\n\n  PointerLocker = Locker.inherit(function () {\n    return {\n      _scroll: function () {\n        this._locked = true;\n        var that = this;\n        animationFrame.cancelAnimationFrame(this._scrollFrame);\n        this._scrollFrame = animationFrame.requestAnimationFrame(function () {\n          that._locked = false;\n        });\n      },\n      check: function (e, callback) {\n        animationFrame.cancelAnimationFrame(this._scrollFrame);\n        animationFrame.cancelAnimationFrame(this._checkFrame);\n        var that = this;\n        var callBase = this.callBase;\n        this._checkFrame = animationFrame.requestAnimationFrame(function () {\n          callBase.call(that, e, callback);\n          that._locked = false;\n        });\n      },\n      dispose: function () {\n        this.callBase();\n        animationFrame.cancelAnimationFrame(this._scrollFrame);\n        animationFrame.cancelAnimationFrame(this._checkFrame);\n      }\n    };\n  }());\n}();\nvar ScrollEmitter = GestureEmitter.inherit(function () {\n  var INERTIA_TIMEOUT = 100;\n  var VELOCITY_CALC_TIMEOUT = 200;\n  var FRAME_DURATION = Math.round(1e3 / 60);\n  return {\n    ctor: function (element) {\n      this.callBase.apply(this, arguments);\n      this.direction = \"both\";\n      this._pointerLocker = new PointerLocker(element);\n      this._wheelLocker = new WheelLocker(element);\n    },\n    validate: function () {\n      return true;\n    },\n    configure: function (data) {\n      if (data.scrollTarget) {\n        this._pointerLocker.dispose();\n\n        this._wheelLocker.dispose();\n\n        this._pointerLocker = new PointerLocker(data.scrollTarget);\n        this._wheelLocker = new WheelLocker(data.scrollTarget);\n      }\n\n      this.callBase(data);\n    },\n    _init: function (e) {\n      this._wheelLocker.check(e, function () {\n        if (eventUtils.isDxMouseWheelEvent(e)) {\n          this._accept(e);\n        }\n      }.bind(this));\n\n      this._pointerLocker.check(e, function () {\n        var skipCheck = this.isNative && eventUtils.isMouseEvent(e);\n\n        if (!eventUtils.isDxMouseWheelEvent(e) && !skipCheck) {\n          this._accept(e);\n        }\n      }.bind(this));\n\n      this._fireEvent(SCROLL_INIT_EVENT, e);\n\n      this._prevEventData = eventUtils.eventData(e);\n    },\n    move: function (e) {\n      this.callBase.apply(this, arguments);\n      e.isScrollingEvent = this.isNative || e.isScrollingEvent;\n    },\n    _start: function (e) {\n      this._savedEventData = eventUtils.eventData(e);\n\n      this._fireEvent(SCROLL_START_EVENT, e);\n\n      this._prevEventData = eventUtils.eventData(e);\n    },\n    _move: function (e) {\n      var currentEventData = eventUtils.eventData(e);\n\n      this._fireEvent(SCROLL_MOVE_EVENT, e, {\n        delta: eventUtils.eventDelta(this._prevEventData, currentEventData)\n      });\n\n      var eventDelta = eventUtils.eventDelta(this._savedEventData, currentEventData);\n\n      if (eventDelta.time > VELOCITY_CALC_TIMEOUT) {\n        this._savedEventData = this._prevEventData;\n      }\n\n      this._prevEventData = eventUtils.eventData(e);\n    },\n    _end: function (e) {\n      var endEventDelta = eventUtils.eventDelta(this._prevEventData, eventUtils.eventData(e));\n      var velocity = {\n        x: 0,\n        y: 0\n      };\n\n      if (!eventUtils.isDxMouseWheelEvent(e) && endEventDelta.time < INERTIA_TIMEOUT) {\n        var eventDelta = eventUtils.eventDelta(this._savedEventData, this._prevEventData);\n        var velocityMultiplier = FRAME_DURATION / eventDelta.time;\n        velocity = {\n          x: eventDelta.x * velocityMultiplier,\n          y: eventDelta.y * velocityMultiplier\n        };\n      }\n\n      this._fireEvent(SCROLL_END_EVENT, e, {\n        velocity: velocity\n      });\n    },\n    _stop: function (e) {\n      this._fireEvent(SCROLL_STOP_EVENT, e);\n    },\n    cancel: function (e) {\n      this.callBase.apply(this, arguments);\n\n      this._fireEvent(SCROLL_CANCEL_EVENT, e);\n    },\n    dispose: function () {\n      this.callBase.apply(this, arguments);\n\n      this._pointerLocker.dispose();\n\n      this._wheelLocker.dispose();\n    },\n    _clearSelection: function () {\n      if (this.isNative) {\n        return;\n      }\n\n      return this.callBase.apply(this, arguments);\n    },\n    _toggleGestureCover: function () {\n      if (this.isNative) {\n        return;\n      }\n\n      return this.callBase.apply(this, arguments);\n    }\n  };\n}());\nregisterEmitter({\n  emitter: ScrollEmitter,\n  events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]\n});\nmodule.exports = {\n  init: SCROLL_INIT_EVENT,\n  start: SCROLL_START_EVENT,\n  move: SCROLL_MOVE_EVENT,\n  end: SCROLL_END_EVENT,\n  stop: SCROLL_STOP_EVENT,\n  cancel: SCROLL_CANCEL_EVENT\n};","map":null,"metadata":{},"sourceType":"script"}