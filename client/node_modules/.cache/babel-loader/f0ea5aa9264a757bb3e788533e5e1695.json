{"ast":null,"code":"/**\r\n * DevExtreme (ui/grid_core/ui.grid_core.editing.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _dom_adapter = require(\"../../core/dom_adapter\");\n\nvar _dom_adapter2 = _interopRequireDefault(_dom_adapter);\n\nvar _window = require(\"../../core/utils/window\");\n\nvar _events_engine = require(\"../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _guid = require(\"../../core/guid\");\n\nvar _guid2 = _interopRequireDefault(_guid);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _uiGrid_core = require(\"./ui.grid_core.modules\");\n\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\n\nvar _click = require(\"../../events/click\");\n\nvar _click2 = _interopRequireDefault(_click);\n\nvar _double_click = require(\"../../events/double_click\");\n\nvar _double_click2 = _interopRequireDefault(_double_click);\n\nvar _pointer = require(\"../../events/pointer\");\n\nvar _pointer2 = _interopRequireDefault(_pointer);\n\nvar _uiGrid_core3 = require(\"./ui.grid_core.utils\");\n\nvar _utils = require(\"../../events/utils\");\n\nvar _dialog = require(\"../dialog\");\n\nvar _dialog2 = _interopRequireDefault(_dialog);\n\nvar _message = require(\"../../localization/message\");\n\nvar _message2 = _interopRequireDefault(_message);\n\nvar _button = require(\"../button\");\n\nvar _button2 = _interopRequireDefault(_button);\n\nvar _popup = require(\"../popup\");\n\nvar _popup2 = _interopRequireDefault(_popup);\n\nvar _ui = require(\"../widget/ui.errors\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nvar _devices = require(\"../../core/devices\");\n\nvar _devices2 = _interopRequireDefault(_devices);\n\nvar _form = require(\"../form\");\n\nvar _form2 = _interopRequireDefault(_form);\n\nvar _hold = require(\"../../events/hold\");\n\nvar _hold2 = _interopRequireDefault(_hold);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nvar _deferred2 = _interopRequireDefault(_deferred);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _icon = require(\"../../core/utils/icon\");\n\nvar _icon2 = _interopRequireDefault(_icon);\n\nvar _ui3 = require(\"../scroll_view/ui.scrollable\");\n\nvar _ui4 = _interopRequireDefault(_ui3);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) {\n    return;\n  }\n\n  if (\"string\" === typeof o) {\n    return _arrayLikeToArray(o, minLen);\n  }\n\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n\n  if (\"Object\" === n && o.constructor) {\n    n = o.constructor.name;\n  }\n\n  if (\"Map\" === n || \"Set\" === n) {\n    return Array.from(o);\n  }\n\n  if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {\n    return _arrayLikeToArray(o, minLen);\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (\"undefined\" !== typeof Symbol && Symbol.iterator in Object(iter)) {\n    return Array.from(iter);\n  }\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    return _arrayLikeToArray(arr);\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (null == len || len > arr.length) {\n    len = arr.length;\n  }\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar EDIT_FORM_CLASS = \"edit-form\";\nvar EDIT_FORM_ITEM_CLASS = \"edit-form-item\";\nvar FOCUS_OVERLAY_CLASS = \"focus-overlay\";\nvar READONLY_CLASS = \"readonly\";\nvar EDIT_POPUP_CLASS = \"edit-popup\";\nvar FORM_BUTTONS_CONTAINER_CLASS = \"form-buttons-container\";\nvar ADD_ROW_BUTTON_CLASS = \"addrow-button\";\nvar DROPDOWN_EDITOR_OVERLAY_CLASS = \"dx-dropdowneditor-overlay\";\nvar LINK_CLASS = \"dx-link\";\nvar EDITOR_CELL_CLASS = \"dx-editor-cell\";\nvar ROW_SELECTED = \"dx-selection\";\nvar EDIT_ROW = \"dx-edit-row\";\nvar EDIT_BUTTON_CLASS = \"dx-edit-button\";\nvar COMMAND_EDIT_CLASS = \"dx-command-edit\";\nvar COMMAND_EDIT_WITH_ICONS_CLASS = COMMAND_EDIT_CLASS + \"-with-icons\";\nvar SCROLLABLE_CONTAINER_CLASS = \"dx-scrollable-container\";\nvar BUTTON_CLASS = \"dx-button\";\nvar INSERT_INDEX = \"__DX_INSERT_INDEX__\";\nvar ROW_CLASS = \"dx-row\";\nvar ROW_REMOVED = \"dx-row-removed\";\nvar ROW_INSERTED = \"dx-row-inserted\";\nvar ROW_MODIFIED = \"dx-row-modified\";\nvar CELL_MODIFIED = \"dx-cell-modified\";\nvar CELL_HIGHLIGHT_OUTLINE = \"dx-highlight-outline\";\nvar EDITING_NAMESPACE = \"dxDataGridEditing\";\nvar DATA_ROW_CLASS = \"dx-data-row\";\nvar CELL_FOCUS_DISABLED_CLASS = \"dx-cell-focus-disabled\";\nvar EDITORS_INPUT_SELECTOR = \"input:not([type='hidden'])\";\nvar FOCUSABLE_ELEMENT_SELECTOR = \"[tabindex], \" + EDITORS_INPUT_SELECTOR;\nvar EDIT_MODE_BATCH = \"batch\";\nvar EDIT_MODE_ROW = \"row\";\nvar EDIT_MODE_CELL = \"cell\";\nvar EDIT_MODE_FORM = \"form\";\nvar EDIT_MODE_POPUP = \"popup\";\nvar DATA_EDIT_DATA_INSERT_TYPE = \"insert\";\nvar DATA_EDIT_DATA_UPDATE_TYPE = \"update\";\nvar DATA_EDIT_DATA_REMOVE_TYPE = \"remove\";\nvar POINTER_EVENTS_TARGET_CLASS = \"dx-pointer-events-target\";\nvar DEFAULT_START_EDIT_ACTION = \"click\";\nvar EDIT_MODES = [EDIT_MODE_BATCH, EDIT_MODE_ROW, EDIT_MODE_CELL, EDIT_MODE_FORM, EDIT_MODE_POPUP];\nvar ROW_BASED_MODES = [EDIT_MODE_ROW, EDIT_MODE_FORM, EDIT_MODE_POPUP];\nvar CELL_BASED_MODES = [EDIT_MODE_BATCH, EDIT_MODE_CELL];\nvar FORM_BASED_MODES = [EDIT_MODE_FORM, EDIT_MODE_POPUP];\nvar MODES_WITH_DELAYED_FOCUS = [EDIT_MODE_ROW, EDIT_MODE_FORM];\nvar TARGET_COMPONENT_NAME = \"targetComponent\";\nvar EDIT_LINK_CLASS = {\n  save: \"dx-link-save\",\n  cancel: \"dx-link-cancel\",\n  edit: \"dx-link-edit\",\n  undelete: \"dx-link-undelete\",\n  \"delete\": \"dx-link-delete\",\n  add: \"dx-link-add\"\n};\nvar EDIT_ICON_CLASS = {\n  save: \"save\",\n  cancel: \"revert\",\n  edit: \"edit\",\n  undelete: \"revert\",\n  \"delete\": \"trash\",\n  add: \"add\"\n};\nvar METHOD_NAMES = {\n  edit: \"editRow\",\n  \"delete\": \"deleteRow\",\n  undelete: \"undeleteRow\",\n  save: \"saveEditData\",\n  cancel: \"cancelEditData\",\n  add: \"addRowByRowIndex\"\n};\nvar ACTION_OPTION_NAMES = {\n  add: \"allowAdding\",\n  edit: \"allowUpdating\",\n  \"delete\": \"allowDeleting\"\n};\nvar BUTTON_NAMES = [\"edit\", \"save\", \"cancel\", \"delete\", \"undelete\"];\nvar EDITING_POPUP_OPTION_NAME = \"editing.popup\";\n\nvar createFailureHandler = function (deferred) {\n  return function (arg) {\n    var error = arg instanceof Error ? arg : new Error(arg && String(arg) || \"Unknown error\");\n    deferred.reject(error);\n  };\n};\n\nvar _getEditMode = function (that) {\n  var editMode = that.option(\"editing.mode\");\n\n  if (EDIT_MODES.indexOf(editMode) !== -1) {\n    return editMode;\n  }\n\n  return EDIT_MODE_ROW;\n};\n\nvar _isRowEditMode = function (that) {\n  var editMode = _getEditMode(that);\n\n  return ROW_BASED_MODES.indexOf(editMode) !== -1;\n};\n\nvar EditingController = _uiGrid_core2.default.ViewController.inherit(function () {\n  var getDefaultEditorTemplate = function (that) {\n    return function (container, options) {\n      var $editor = (0, _renderer2.default)(\"<div>\").appendTo(container);\n      that.getController(\"editorFactory\").createEditor($editor, (0, _extend.extend)({}, options.column, {\n        value: options.value,\n        setValue: options.setValue,\n        row: options.row,\n        parentType: \"dataRow\",\n        width: null,\n        readOnly: !options.setValue,\n        isOnForm: options.isOnForm,\n        id: options.id\n      }));\n    };\n  };\n\n  var getEditingTexts = function (options) {\n    var editingTexts = options.component.option(\"editing.texts\") || {};\n    return {\n      save: editingTexts.saveRowChanges,\n      cancel: editingTexts.cancelRowChanges,\n      edit: editingTexts.editRow,\n      undelete: editingTexts.undeleteRow,\n      \"delete\": editingTexts.deleteRow,\n      add: editingTexts.addRowToNode\n    };\n  };\n\n  var getButtonIndex = function (buttons, name) {\n    var result = -1;\n    buttons.some(function (button, index) {\n      if (getButtonName(button) === name) {\n        result = index;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  function getButtonName(button) {\n    return _type2.default.isObject(button) ? button.name : button;\n  }\n\n  var getEditorType = function (item) {\n    var column = item.column;\n    return item.isCustomEditorType ? item.editorType : column.formItem && column.formItem.editorType;\n  };\n\n  var forEachFormItems = function forEachFormItems(items, callBack) {\n    items.forEach(function (item) {\n      if (item.items || item.tabs) {\n        forEachFormItems(item.items || item.tabs, callBack);\n      } else {\n        callBack(item);\n      }\n    });\n  };\n\n  return {\n    init: function () {\n      var that = this;\n      that._editRowIndex = -1;\n      that._editData = [];\n      that._editColumnIndex = -1;\n      that._columnsController = that.getController(\"columns\");\n      that._dataController = that.getController(\"data\");\n      that._rowsView = that.getView(\"rowsView\");\n      that._editForm = null;\n      that._updateEditFormDeferred = null;\n      that._lastOperation = null;\n\n      if (that._deferreds) {\n        that._deferreds.forEach(function (d) {\n          return d.reject(\"cancel\");\n        });\n      }\n\n      that._deferreds = [];\n\n      if (!that._dataChangedHandler) {\n        that._dataChangedHandler = that._handleDataChanged.bind(that);\n\n        that._dataController.changed.add(that._dataChangedHandler);\n      }\n\n      if (!that._saveEditorHandler) {\n        that.createAction(\"onInitNewRow\", {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        that.createAction(\"onRowInserting\", {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        that.createAction(\"onRowInserted\", {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        that.createAction(\"onEditingStart\", {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        that.createAction(\"onRowUpdating\", {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        that.createAction(\"onRowUpdated\", {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        that.createAction(\"onRowRemoving\", {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        that.createAction(\"onRowRemoved\", {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        var $pointerDownTarget;\n\n        that._pointerDownEditorHandler = function (e) {\n          return $pointerDownTarget = (0, _renderer2.default)(e.target);\n        };\n\n        that._saveEditorHandler = that.createAction(function (e) {\n          var event = e.event;\n          var $target = (0, _renderer2.default)(event.target);\n          var targetComponent = event[TARGET_COMPONENT_NAME];\n\n          if ($pointerDownTarget && $pointerDownTarget.is(\"input\") && !$pointerDownTarget.is($target)) {\n            return;\n          }\n\n          function checkEditorPopup($element) {\n            return $element && !!$element.closest(\".\".concat(DROPDOWN_EDITOR_OVERLAY_CLASS)).length;\n          }\n\n          if (!_isRowEditMode(that) && !that._editCellInProgress) {\n            var isEditorPopup = checkEditorPopup($target) || checkEditorPopup(null === targetComponent || void 0 === targetComponent ? void 0 : targetComponent.$element());\n            var isDomElement = !!$target.closest((0, _window.getWindow)().document).length;\n            var isAnotherComponent = targetComponent && !targetComponent._disposed && targetComponent !== that.component;\n            var isAddRowButton = !!$target.closest(\".\".concat(that.addWidgetPrefix(ADD_ROW_BUTTON_CLASS))).length;\n            var isFocusOverlay = $target.hasClass(that.addWidgetPrefix(FOCUS_OVERLAY_CLASS));\n            var isCellEditMode = _getEditMode(that) === EDIT_MODE_CELL;\n\n            if (!isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && that.isEditing()) && (isDomElement || isAnotherComponent)) {\n              that._closeEditItem.bind(that)($target);\n            }\n          }\n        });\n\n        _events_engine2.default.on(_dom_adapter2.default.getDocument(), _pointer2.default.down, that._pointerDownEditorHandler);\n\n        _events_engine2.default.on(_dom_adapter2.default.getDocument(), _click2.default.name, that._saveEditorHandler);\n      }\n\n      that._updateEditColumn();\n\n      that._updateEditButtons();\n    },\n    getUpdatedData: function (data) {\n      var key = this._dataController.keyOf(data);\n\n      var editData = this._editData;\n      var editIndex = (0, _uiGrid_core3.getIndexByKey)(key, editData);\n\n      if (editData[editIndex]) {\n        return (0, _uiGrid_core3.createObjectWithChanges)(data, editData[editIndex].data);\n      }\n\n      return data;\n    },\n    getInsertedData: function () {\n      return this._editData.filter(function (editData) {\n        return editData.data && editData.type === DATA_EDIT_DATA_INSERT_TYPE;\n      }).map(function (editData) {\n        return editData.data;\n      });\n    },\n    getRemovedData: function () {\n      return this._editData.filter(function (editData) {\n        return editData.oldData && editData.type === DATA_EDIT_DATA_REMOVE_TYPE;\n      }).map(function (editData) {\n        return editData.oldData;\n      });\n    },\n    _fireDataErrorOccurred: function (arg) {\n      if (\"cancel\" === arg) {\n        return;\n      }\n\n      var $popupContent = this.getPopupContent();\n\n      this._dataController.dataErrorOccurred.fire(arg, $popupContent);\n    },\n    _needToCloseEditableCell: function ($targetElement) {\n      var $element = this.component.$element();\n      var result = this.isEditing();\n      var isCurrentComponentElement = !$element || !!$targetElement.closest($element).length;\n\n      if (isCurrentComponentElement) {\n        var isDataRow = $targetElement.closest(\".\" + DATA_ROW_CLASS).length;\n\n        if (isDataRow) {\n          var rowsView = this.getView(\"rowsView\");\n          var $targetCell = $targetElement.closest(\".\" + ROW_CLASS + \"> td\");\n          var rowIndex = rowsView.getRowIndex($targetCell.parent());\n          var columnIndex = rowsView.getCellElements(rowIndex).index($targetCell);\n\n          var visibleColumns = this._columnsController.getVisibleColumns();\n\n          var allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;\n          result = result && !allowEditing && !this.isEditCell(rowIndex, columnIndex);\n        }\n      }\n\n      return result;\n    },\n    _closeEditItem: function ($targetElement) {\n      if (this._needToCloseEditableCell($targetElement)) {\n        this.closeEditCell();\n      }\n    },\n    _handleDataChanged: function (args) {\n      var that = this;\n      var editForm = that._editForm;\n\n      if (\"standard\" === that.option(\"scrolling.mode\")) {\n        that.resetRowAndPageIndices();\n      }\n\n      if (\"prepend\" === args.changeType) {\n        (0, _iterator.each)(that._editData, function (_, editData) {\n          editData.rowIndex += args.items.length;\n        });\n      }\n\n      if (\"refresh\" === args.changeType && _getEditMode(that) === EDIT_MODE_POPUP && editForm && editForm.option(\"visible\")) {\n        this._repaintEditPopup();\n      }\n    },\n    _isDefaultButtonVisible: function (button, options) {\n      var result = true;\n\n      var isRowMode = _isRowEditMode(this);\n\n      var isEditRow = options.row && options.row.rowIndex === this._getVisibleEditRowIndex() && isRowMode;\n\n      switch (button.name) {\n        case \"edit\":\n          result = !isEditRow && this.allowUpdating(options) && isRowMode;\n          break;\n\n        case \"save\":\n        case \"cancel\":\n          result = isEditRow;\n          break;\n\n        case \"delete\":\n          result = !isEditRow && this.allowDeleting(options) && !options.row.removed;\n          break;\n\n        case \"undelete\":\n          result = this.allowDeleting(options) && options.row.removed;\n      }\n\n      return result;\n    },\n    _isButtonVisible: function (button, options) {\n      var visible = button.visible;\n\n      if (!_type2.default.isDefined(visible)) {\n        return this._isDefaultButtonVisible(button, options);\n      }\n\n      return _type2.default.isFunction(visible) ? visible.call(button, {\n        component: options.component,\n        row: options.row,\n        column: options.column\n      }) : visible;\n    },\n    _getButtonConfig: function (button, options) {\n      var _this = this;\n\n      var config = _type2.default.isObject(button) ? button : {};\n      var buttonName = getButtonName(button);\n      var editingTexts = getEditingTexts(options);\n      var methodName = METHOD_NAMES[buttonName];\n      var editingOptions = this.option(\"editing\");\n      var actionName = ACTION_OPTION_NAMES[buttonName];\n      var allowAction = actionName ? editingOptions[actionName] : true;\n      return (0, _extend.extend)({\n        name: buttonName,\n        text: editingTexts[buttonName],\n        cssClass: EDIT_LINK_CLASS[buttonName],\n        onClick: function (e) {\n          var event = e.event;\n          event.stopPropagation();\n          event.preventDefault();\n          setTimeout(function () {\n            options.row && allowAction && _this[methodName] && _this[methodName](options.row.rowIndex);\n          });\n        }\n      }, config);\n    },\n    _getEditingButtons: function (options) {\n      var _this2 = this;\n\n      var buttonIndex;\n      var haveCustomButtons = !!options.column.buttons;\n      var buttons = (options.column.buttons || []).slice();\n\n      if (haveCustomButtons) {\n        buttonIndex = getButtonIndex(buttons, \"edit\");\n\n        if (buttonIndex >= 0) {\n          if (getButtonIndex(buttons, \"save\") < 0) {\n            buttons.splice(buttonIndex + 1, 0, \"save\");\n          }\n\n          if (getButtonIndex(buttons, \"cancel\") < 0) {\n            buttons.splice(getButtonIndex(buttons, \"save\") + 1, 0, \"cancel\");\n          }\n        }\n\n        buttonIndex = getButtonIndex(buttons, \"delete\");\n\n        if (buttonIndex >= 0 && getButtonIndex(buttons, \"undelete\") < 0) {\n          buttons.splice(buttonIndex + 1, 0, \"undelete\");\n        }\n      } else {\n        buttons = BUTTON_NAMES.slice();\n      }\n\n      return buttons.map(function (button) {\n        return _this2._getButtonConfig(button, options);\n      });\n    },\n    _renderEditingButtons: function ($container, buttons, options) {\n      var _this3 = this;\n\n      buttons.forEach(function (button) {\n        if (_this3._isButtonVisible(button, options)) {\n          _this3._createButton($container, button, options);\n        }\n      });\n    },\n    _getEditCommandCellTemplate: function () {\n      var _this4 = this;\n\n      return function (container, options) {\n        var $container = (0, _renderer2.default)(container);\n\n        if (\"data\" === options.rowType) {\n          options.rtlEnabled = _this4.option(\"rtlEnabled\");\n\n          var buttons = _this4._getEditingButtons(options);\n\n          _this4._renderEditingButtons($container, buttons, options);\n\n          options.watch && options.watch(function () {\n            return buttons.map(function (button) {\n              return _this4._isButtonVisible(button, options);\n            });\n          }, function () {\n            $container.empty();\n\n            _this4._renderEditingButtons($container, buttons, options);\n          });\n        } else {\n          (0, _uiGrid_core3.setEmptyText)($container);\n        }\n      };\n    },\n    correctEditRowIndexAfterExpand: function (key) {\n      if (this._editRowIndex > this._dataController.getRowIndexByKey(key)) {\n        this._editRowIndex++;\n      }\n    },\n    correctEditRowIndex: function (getRowIndexCorrection) {\n      this._editRowIndex += getRowIndexCorrection(this._getVisibleEditRowIndex());\n    },\n    isRowEditMode: function () {\n      return _isRowEditMode(this);\n    },\n    isFormEditMode: function () {\n      var editMode = _getEditMode(this);\n\n      return FORM_BASED_MODES.indexOf(editMode) !== -1;\n    },\n    isCellOrBatchEditMode: function () {\n      var editMode = this.getEditMode();\n      return editMode === EDIT_MODE_BATCH || editMode === EDIT_MODE_CELL;\n    },\n    getEditMode: function () {\n      return _getEditMode(this);\n    },\n    getFirstEditableColumnIndex: function () {\n      var columnsController = this.getController(\"columns\");\n      var firstFormItem = this._firstFormItem;\n      var columnIndex;\n\n      if (_getEditMode(this) === EDIT_MODE_FORM && firstFormItem) {\n        var $editFormElements = this._rowsView.getCellElements(this._editRowIndex);\n\n        columnIndex = this._rowsView._getEditFormEditorVisibleIndex($editFormElements, firstFormItem.column);\n      } else {\n        var visibleColumns = columnsController.getVisibleColumns();\n        (0, _iterator.each)(visibleColumns, function (index, column) {\n          if (column.allowEditing) {\n            columnIndex = index;\n            return false;\n          }\n        });\n      }\n\n      return columnIndex;\n    },\n    getFirstEditableCellInRow: function (rowIndex) {\n      var rowsView = this.getView(\"rowsView\");\n      return rowsView && rowsView._getCellElement(rowIndex ? rowIndex : 0, this.getFirstEditableColumnIndex());\n    },\n    getFocusedCellInRow: function (rowIndex) {\n      return this.getFirstEditableCellInRow(rowIndex);\n    },\n    getIndexByKey: function (key, items) {\n      return (0, _uiGrid_core3.getIndexByKey)(key, items);\n    },\n    hasChanges: function (rowIndex) {\n      var that = this;\n      var result = false;\n\n      for (var i = 0; i < that._editData.length; i++) {\n        if (that._editData[i].type && (!_type2.default.isDefined(rowIndex) || that._dataController.getRowIndexByKey(that._editData[i].key) === rowIndex)) {\n          result = true;\n          break;\n        }\n      }\n\n      return result;\n    },\n    dispose: function () {\n      this.callBase();\n      clearTimeout(this._inputFocusTimeoutID);\n\n      _events_engine2.default.off(_dom_adapter2.default.getDocument(), _pointer2.default.down, this._pointerDownEditorHandler);\n\n      _events_engine2.default.off(_dom_adapter2.default.getDocument(), _click2.default.name, this._saveEditorHandler);\n    },\n    optionChanged: function (args) {\n      if (\"editing\" === args.name) {\n        var fullName = args.fullName;\n        var editPopup = this._editPopup;\n\n        if (fullName && 0 === fullName.indexOf(EDITING_POPUP_OPTION_NAME)) {\n          if (editPopup) {\n            var popupOptionName = fullName.slice(EDITING_POPUP_OPTION_NAME.length + 1);\n\n            if (popupOptionName) {\n              editPopup.option(popupOptionName, args.value);\n            } else {\n              editPopup.option(args.value);\n            }\n          }\n        } else {\n          if (editPopup && editPopup.option(\"visible\") && 0 === fullName.indexOf(\"editing.form\")) {\n            this._repaintEditPopup();\n          } else {\n            this.init();\n          }\n        }\n\n        args.handled = true;\n      } else {\n        this.callBase(args);\n      }\n    },\n    publicMethods: function () {\n      return [\"insertRow\", \"addRow\", \"removeRow\", \"deleteRow\", \"undeleteRow\", \"editRow\", \"editCell\", \"closeEditCell\", \"saveEditData\", \"cancelEditData\", \"hasEditData\"];\n    },\n    refresh: function (isPageChanged) {\n      var editMode = _getEditMode(this);\n\n      var needResetIndexes = editMode === EDIT_MODE_BATCH || isPageChanged && \"virtual\" !== this.option(\"scrolling.mode\");\n\n      if (editMode !== EDIT_MODE_BATCH && editMode !== EDIT_MODE_CELL) {\n        this.init();\n      } else {\n        if (needResetIndexes) {\n          this._editRowIndex = -1;\n          this._editColumnIndex = -1;\n        }\n      }\n    },\n    isEditing: function () {\n      return this._editRowIndex > -1;\n    },\n    isEditRow: function (rowIndex) {\n      var editMode = _getEditMode(this);\n\n      return this._getVisibleEditRowIndex() === rowIndex && ROW_BASED_MODES.indexOf(editMode) !== -1;\n    },\n    getEditRowKey: function () {\n      var items = this._dataController.items();\n\n      var item = items[this._getVisibleEditRowIndex()];\n\n      return item && item.key;\n    },\n    getEditRowIndex: function () {\n      return this._getVisibleEditRowIndex();\n    },\n    getEditFormRowIndex: function () {\n      var editMode = _getEditMode(this);\n\n      return editMode === EDIT_MODE_FORM || editMode === EDIT_MODE_POPUP ? this._getVisibleEditRowIndex() : -1;\n    },\n    isEditCell: function (visibleRowIndex, columnIndex) {\n      var hasEditData = !!(Array.isArray(this._editData) && this._editData.length);\n      return hasEditData && this._getVisibleEditRowIndex() === visibleRowIndex && this._editColumnIndex === columnIndex;\n    },\n    getPopupContent: function () {\n      var editMode = _getEditMode(this);\n\n      var popupVisible = this._editPopup && this._editPopup.option(\"visible\");\n\n      if (editMode === EDIT_MODE_POPUP && popupVisible) {\n        return this._$popupContent;\n      }\n    },\n    getEditForm: function () {\n      return this._editForm;\n    },\n    _needInsertItem: function (editData, changeType) {\n      var that = this;\n\n      var dataSource = that._dataController.dataSource();\n\n      var scrollingMode = that.option(\"scrolling.mode\");\n      var pageIndex = dataSource.pageIndex();\n      var beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : pageIndex;\n      var endPageIndex = dataSource.endPageIndex ? dataSource.endPageIndex() : pageIndex;\n\n      if (\"standard\" !== scrollingMode) {\n        switch (changeType) {\n          case \"append\":\n            return editData.key.pageIndex === endPageIndex;\n\n          case \"prepend\":\n            return editData.key.pageIndex === beginPageIndex;\n\n          case \"refresh\":\n            editData.key.rowIndex = 0;\n            editData.key.dataRowIndex = 0;\n            editData.key.pageIndex = 0;\n            break;\n\n          default:\n            return editData.key.pageIndex >= beginPageIndex && editData.key.pageIndex <= endPageIndex;\n        }\n      }\n\n      return editData.key.pageIndex === pageIndex;\n    },\n    _generateNewItem: function (key) {\n      var item = {\n        key: key\n      };\n\n      if (key && key[INSERT_INDEX]) {\n        item[INSERT_INDEX] = key[INSERT_INDEX];\n      }\n\n      return item;\n    },\n    processItems: function (items, change) {\n      var changeType = change.changeType;\n      var dataController = this._dataController;\n      var dataRowIndex = -1;\n      this.update(changeType);\n      var editData = this._editData;\n\n      for (var i = 0; i < editData.length; i++) {\n        var key = editData[i].key;\n\n        if (key) {\n          var rowIndexOffset = dataController.getRowIndexOffset();\n          dataRowIndex = key.dataRowIndex - rowIndexOffset + dataController.getRowIndexDelta();\n\n          if (\"append\" === changeType) {\n            dataRowIndex -= dataController.items(true).length;\n\n            if (change.removeCount) {\n              dataRowIndex += change.removeCount;\n            }\n          }\n\n          var item = this._generateNewItem(key);\n\n          if (dataRowIndex >= 0 && editData[i].type === DATA_EDIT_DATA_INSERT_TYPE && this._needInsertItem(editData[i], changeType, items, item)) {\n            items.splice(key.dataRowIndex ? dataRowIndex : 0, 0, item);\n          }\n        }\n      }\n\n      return items;\n    },\n    processDataItem: function (item, options, generateDataValues) {\n      var that = this;\n      var data;\n      var columns = options.visibleColumns;\n      var key = item.data[INSERT_INDEX] ? item.data.key : item.key;\n      var editIndex = (0, _uiGrid_core3.getIndexByKey)(key, that._editData);\n      item.isEditing = false;\n\n      if (editIndex >= 0) {\n        var editMode = _getEditMode(that);\n\n        var editData = that._editData[editIndex];\n        data = editData.data;\n\n        switch (editData.type) {\n          case DATA_EDIT_DATA_INSERT_TYPE:\n            if (editMode === EDIT_MODE_POPUP) {\n              item.visible = false;\n            }\n\n            item.isNewRow = true;\n            item.key = key;\n            item.data = data;\n            break;\n\n          case DATA_EDIT_DATA_UPDATE_TYPE:\n            item.modified = true;\n            item.oldData = item.data;\n            item.data = (0, _uiGrid_core3.createObjectWithChanges)(item.data, data);\n            item.modifiedValues = generateDataValues(data, columns, true);\n            break;\n\n          case DATA_EDIT_DATA_REMOVE_TYPE:\n            if (editMode === EDIT_MODE_BATCH) {\n              item.data = (0, _uiGrid_core3.createObjectWithChanges)(item.data, data);\n            }\n\n            item.removed = true;\n        }\n      }\n    },\n    insertRow: function () {\n      _ui2.default.log(\"W0002\", \"dxDataGrid\", \"insertRow\", \"15.2\", \"Use the 'addRow' method instead\");\n\n      return this.addRow();\n    },\n    _initNewRow: function (options) {\n      var _this5 = this;\n\n      this.executeAction(\"onInitNewRow\", options);\n\n      if (options.promise) {\n        var deferred = new _deferred.Deferred();\n        (0, _deferred.when)((0, _deferred.fromPromise)(options.promise)).done(deferred.resolve).fail(createFailureHandler(deferred)).fail(function (arg) {\n          return _this5._fireDataErrorOccurred(arg);\n        });\n        return deferred;\n      }\n    },\n    _getInsertKey: function (parentKey) {\n      var that = this;\n      var dataController = that._dataController;\n      var rows = dataController.items();\n\n      var editMode = _getEditMode(that);\n\n      var insertKey = {\n        parentKey: parentKey,\n        pageIndex: dataController.pageIndex(),\n        rowIndex: that._getInsertRowIndex(parentKey)\n      };\n      var row = rows[insertKey.rowIndex];\n\n      if (row && (!row.isEditing && \"detail\" === row.rowType || \"detailAdaptive\" === row.rowType)) {\n        insertKey.rowIndex++;\n      }\n\n      insertKey.dataRowIndex = dataController.getRowIndexOffset() + rows.filter(function (row, index) {\n        return index < insertKey.rowIndex && (\"data\" === row.rowType || \"group\" === row.rowType || row.isNewRow);\n      }).length;\n\n      if (editMode !== EDIT_MODE_BATCH) {\n        that._editRowIndex = insertKey.rowIndex + that._dataController.getRowIndexOffset();\n      }\n\n      insertKey[INSERT_INDEX] = that._getInsertIndex();\n      return insertKey;\n    },\n    _getInsertRowIndex: function (parentKey) {\n      var that = this;\n      var rowsView = that.getView(\"rowsView\");\n\n      var parentRowIndex = that._dataController.getRowIndexByKey(parentKey);\n\n      if (parentRowIndex >= 0) {\n        return parentRowIndex + 1;\n      }\n\n      if (rowsView) {\n        return rowsView.getTopVisibleItemIndex(true);\n      }\n\n      return 0;\n    },\n    _getInsertIndex: function () {\n      var maxInsertIndex = 0;\n\n      this._editData.forEach(function (editItem) {\n        if (editItem.type === DATA_EDIT_DATA_INSERT_TYPE && editItem.key[INSERT_INDEX] > maxInsertIndex) {\n          maxInsertIndex = editItem.key[INSERT_INDEX];\n        }\n      });\n\n      return maxInsertIndex + 1;\n    },\n    addRow: function (parentKey) {\n      var that = this;\n      var dataController = that._dataController;\n      var store = dataController.store();\n      var key = store && store.key();\n      var param = {\n        data: {}\n      };\n\n      var editMode = _getEditMode(that);\n\n      var oldEditRowIndex = that._getVisibleEditRowIndex();\n\n      var deferred = new _deferred.Deferred();\n\n      if (!store) {\n        dataController.fireError(\"E1052\", this.component.NAME);\n        return deferred.reject();\n      }\n\n      if (editMode === EDIT_MODE_CELL && that.hasChanges()) {\n        that.saveEditData().done(function () {\n          if (!that.hasChanges()) {\n            that.addRow(parentKey).done(deferred.resolve).fail(deferred.reject);\n          } else {\n            deferred.reject(\"cancel\");\n          }\n        });\n        return deferred.promise();\n      }\n\n      that.refresh();\n\n      if (!that._allowRowAdding()) {\n        return deferred.reject(\"cancel\");\n      }\n\n      if (!key) {\n        param.data.__KEY__ = String(new _guid2.default());\n      }\n\n      (0, _deferred.when)(that._initNewRow(param, parentKey)).done(function () {\n        if (that._allowRowAdding()) {\n          that._addRowCore(param.data, parentKey, oldEditRowIndex);\n\n          deferred.resolve();\n        } else {\n          deferred.reject(\"cancel\");\n        }\n      }).fail(deferred.reject);\n      return deferred.promise();\n    },\n    _allowRowAdding: function () {\n      var that = this;\n\n      var editMode = _getEditMode(that);\n\n      var insertIndex = that._getInsertIndex();\n\n      if (editMode !== EDIT_MODE_BATCH && insertIndex > 1) {\n        return false;\n      }\n\n      return true;\n    },\n    _addRowCore: function (data, parentKey, initialOldEditRowIndex) {\n      var that = this;\n\n      var oldEditRowIndex = that._getVisibleEditRowIndex();\n\n      var insertKey = that._getInsertKey(parentKey);\n\n      var editMode = _getEditMode(that);\n\n      that._addEditData({\n        key: insertKey,\n        data: data,\n        type: DATA_EDIT_DATA_INSERT_TYPE\n      });\n\n      that._dataController.updateItems({\n        changeType: \"update\",\n        rowIndices: [initialOldEditRowIndex, oldEditRowIndex, insertKey.rowIndex]\n      });\n\n      if (editMode === EDIT_MODE_POPUP) {\n        that._showEditPopup(insertKey.rowIndex);\n      } else {\n        that._focusFirstEditableCellInRow(insertKey.rowIndex);\n      }\n\n      that._afterInsertRow({\n        key: insertKey,\n        data: data\n      });\n    },\n    _focusFirstEditableCellInRow: function (rowIndex) {\n      var that = this;\n      var $firstCell = that.getFirstEditableCellInRow(rowIndex);\n      that._editCellInProgress = true;\n\n      that._delayedInputFocus($firstCell, function () {\n        that._editCellInProgress = false;\n        var $cell = that.getFirstEditableCellInRow(rowIndex);\n        var eventToTrigger = \"dblClick\" === that.option(\"editing.startEditAction\") ? _double_click2.default.name : _click2.default.name;\n        $cell && _events_engine2.default.trigger($cell, eventToTrigger);\n      });\n    },\n    _isEditingStart: function (options) {\n      this.executeAction(\"onEditingStart\", options);\n      return options.cancel;\n    },\n    _beforeEditCell: function (rowIndex, columnIndex, item) {\n      var that = this;\n\n      if (_getEditMode(that) === EDIT_MODE_CELL && !item.isNewRow && that.hasChanges()) {\n        var d = new _deferred.Deferred();\n        that.saveEditData().always(function () {\n          d.resolve(that.hasChanges());\n        });\n        return d;\n      }\n    },\n    _beforeUpdateItems: function () {},\n    _getVisibleEditRowIndex: function () {\n      return this._editRowIndex >= 0 ? this._editRowIndex - this._dataController.getRowIndexOffset() : -1;\n    },\n    editRow: function (rowIndex) {\n      var that = this;\n      var dataController = that._dataController;\n      var items = dataController.items();\n      var item = items[rowIndex];\n      var params = {\n        data: item && item.data,\n        cancel: false\n      };\n\n      var oldEditRowIndex = that._getVisibleEditRowIndex();\n\n      var $editingCell;\n\n      if (!item) {\n        return;\n      }\n\n      if (rowIndex === oldEditRowIndex) {\n        return true;\n      }\n\n      if (!item.isNewRow) {\n        params.key = item.key;\n      }\n\n      if (that._isEditingStart(params)) {\n        return;\n      }\n\n      that.init();\n      that._pageIndex = dataController.pageIndex();\n      that._editRowIndex = (items[0].isNewRow ? rowIndex - 1 : rowIndex) + that._dataController.getRowIndexOffset();\n\n      that._addEditData({\n        data: {},\n        key: item.key,\n        oldData: item.data\n      });\n\n      var rowIndices = [oldEditRowIndex, rowIndex];\n\n      var editMode = _getEditMode(that);\n\n      that._beforeUpdateItems(rowIndices, rowIndex, oldEditRowIndex);\n\n      if (editMode === EDIT_MODE_POPUP) {\n        that._showEditPopup(rowIndex);\n      } else {\n        dataController.updateItems({\n          changeType: \"update\",\n          rowIndices: rowIndices\n        });\n      }\n\n      if (MODES_WITH_DELAYED_FOCUS.indexOf(editMode) !== -1) {\n        $editingCell = that.getFocusedCellInRow(that._getVisibleEditRowIndex());\n\n        that._delayedInputFocus($editingCell, function () {\n          $editingCell && that.component.focus($editingCell);\n        });\n      }\n    },\n    _showEditPopup: function (rowIndex, repaintForm) {\n      var that = this;\n\n      var isMobileDevice = \"desktop\" !== _devices2.default.current().deviceType;\n\n      var popupOptions = (0, _extend.extend)({\n        showTitle: false,\n        fullScreen: isMobileDevice,\n        toolbarItems: [{\n          toolbar: \"bottom\",\n          location: \"after\",\n          widget: \"dxButton\",\n          options: that._getSaveButtonConfig()\n        }, {\n          toolbar: \"bottom\",\n          location: \"after\",\n          widget: \"dxButton\",\n          options: that._getCancelButtonConfig()\n        }],\n        contentTemplate: that._getPopupEditFormTemplate(rowIndex)\n      }, that.option(EDITING_POPUP_OPTION_NAME));\n\n      if (!that._editPopup) {\n        var $popupContainer = (0, _renderer2.default)(\"<div>\").appendTo(that.component.$element()).addClass(that.addWidgetPrefix(EDIT_POPUP_CLASS));\n        that._editPopup = that._createComponent($popupContainer, _popup2.default, {});\n\n        that._editPopup.on(\"hiding\", that._getEditPopupHiddenHandler());\n\n        that._editPopup.on(\"shown\", function (e) {\n          _events_engine2.default.trigger(e.component.$content().find(FOCUSABLE_ELEMENT_SELECTOR).not(\".\" + SCROLLABLE_CONTAINER_CLASS).first(), \"focus\");\n\n          if (repaintForm) {\n            that._editForm && that._editForm.repaint();\n          }\n        });\n      }\n\n      that._editPopup.option(popupOptions);\n\n      that._editPopup.show();\n    },\n    _repaintEditPopup: function () {\n      var rowIndex = this._getVisibleEditRowIndex();\n\n      if (this._editPopup && this._editPopup.option(\"visible\") && rowIndex >= 0) {\n        var defaultAnimation = this._editPopup.option(\"animation\");\n\n        this._editPopup.option(\"animation\", null);\n\n        this._showEditPopup(rowIndex, true);\n\n        this._editPopup.option(\"animation\", defaultAnimation);\n      }\n    },\n    _getEditPopupHiddenHandler: function () {\n      var that = this;\n      return function (e) {\n        if (that.isEditing()) {\n          that.cancelEditData();\n        }\n      };\n    },\n    _getPopupEditFormTemplate: function (rowIndex) {\n      var that = this;\n      var row = that.component.getVisibleRows()[rowIndex];\n      var templateOptions = {\n        row: row,\n        rowType: row.rowType,\n        key: row.key\n      };\n      return function (container) {\n        var formTemplate = that.getEditFormTemplate();\n\n        var scrollable = that._createComponent((0, _renderer2.default)(\"<div>\").appendTo(container), _ui4.default);\n\n        that._$popupContent = scrollable.$content();\n        formTemplate(that._$popupContent, templateOptions, true);\n      };\n    },\n    _getSaveButtonConfig: function () {\n      return {\n        text: this.option(\"editing.texts.saveRowChanges\"),\n        onClick: this.saveEditData.bind(this)\n      };\n    },\n    _getCancelButtonConfig: function () {\n      return {\n        text: this.option(\"editing.texts.cancelRowChanges\"),\n        onClick: this.cancelEditData.bind(this)\n      };\n    },\n    _removeEditDataItem: function (index) {\n      if (index >= 0) {\n        this._editData.splice(index, 1);\n      }\n    },\n    executeOperation: function (deferred, func) {\n      var _this6 = this;\n\n      this._lastOperation && this._lastOperation.reject();\n      this._lastOperation = deferred;\n      this.waitForDeferredOperations().done(function () {\n        if (\"rejected\" === deferred.state()) {\n          return;\n        }\n\n        func();\n        _this6._lastOperation = null;\n      }).fail(function () {\n        deferred.reject();\n        _this6._lastOperation = null;\n      });\n    },\n    waitForDeferredOperations: function () {\n      return _deferred.when.apply(void 0, _toConsumableArray(this._deferreds));\n    },\n    editCell: function (rowIndex, columnIndex) {\n      var _this7 = this;\n\n      var d = new _deferred.Deferred();\n      var coreResult;\n      this.executeOperation(d, function () {\n        coreResult = _this7._editCellCore(rowIndex, columnIndex);\n        (0, _deferred.when)(coreResult).done(d.resolve).fail(d.reject);\n      });\n      return void 0 !== coreResult ? coreResult : d.promise();\n    },\n    _editCellCore: function (rowIndex, columnIndex) {\n      var that = this;\n      var columnsController = that._columnsController;\n      var dataController = that._dataController;\n      var items = dataController.items();\n      var item = items[rowIndex];\n      var params = {\n        data: item && item.data,\n        cancel: false\n      };\n\n      var oldEditRowIndex = that._getVisibleEditRowIndex();\n\n      var visibleColumns = columnsController.getVisibleColumns();\n      var oldColumn = visibleColumns[that._editColumnIndex];\n\n      if (_type2.default.isString(columnIndex)) {\n        columnIndex = columnsController.columnOption(columnIndex, \"index\");\n        columnIndex = columnsController.getVisibleIndex(columnIndex);\n      }\n\n      var column = params.column = visibleColumns[columnIndex];\n\n      if (column && item && (\"data\" === item.rowType || \"detailAdaptive\" === item.rowType) && !item.removed && !_isRowEditMode(that)) {\n        if (that.isEditCell(rowIndex, columnIndex)) {\n          return true;\n        }\n\n        var editRowIndex = rowIndex + dataController.getRowIndexOffset();\n        return (0, _deferred.when)(that._beforeEditCell(rowIndex, columnIndex, item)).done(function (cancel) {\n          if (cancel) {\n            return;\n          }\n\n          if (that._prepareEditCell(params, item, columnIndex, editRowIndex)) {\n            _common2.default.deferRender(function () {\n              that._repaintEditCell(column, oldColumn, oldEditRowIndex);\n            });\n          } else {\n            that._processCanceledEditingCell();\n          }\n        });\n      }\n\n      return false;\n    },\n    _processCanceledEditingCell: function () {},\n    _prepareEditCell: function (params, item, editColumnIndex, editRowIndex) {\n      var that = this;\n\n      if (!item.isNewRow) {\n        params.key = item.key;\n      }\n\n      if (that._isEditingStart(params)) {\n        return false;\n      }\n\n      that._editRowIndex = editRowIndex;\n      that._editColumnIndex = editColumnIndex;\n      that._pageIndex = that._dataController.pageIndex();\n\n      that._addEditData({\n        data: {},\n        key: item.key,\n        oldData: item.data\n      });\n\n      return true;\n    },\n    _repaintEditCell: function (column, oldColumn, oldEditRowIndex) {\n      var that = this;\n      var rowsView = that._rowsView;\n\n      if (!column || !column.showEditorAlways || oldColumn && !oldColumn.showEditorAlways) {\n        that._editCellInProgress = true;\n        that.getController(\"editorFactory\").loseFocus();\n\n        that._dataController.updateItems({\n          changeType: \"update\",\n          rowIndices: [oldEditRowIndex, that._getVisibleEditRowIndex()]\n        });\n      }\n\n      var $cell = rowsView && rowsView._getCellElement(that._getVisibleEditRowIndex(), that._editColumnIndex);\n\n      if ($cell && !$cell.find(\":focus\").length) {\n        that._focusEditingCell(function () {\n          that._editCellInProgress = false;\n        }, $cell, true);\n      } else {\n        that._editCellInProgress = false;\n      }\n    },\n    _delayedInputFocus: function ($cell, beforeFocusCallback, callBeforeFocusCallbackAlways) {\n      var that = this;\n\n      function inputFocus() {\n        if (beforeFocusCallback) {\n          beforeFocusCallback();\n        }\n\n        if ($cell) {\n          var $focusableElement = $cell.find(FOCUSABLE_ELEMENT_SELECTOR).first();\n          (0, _uiGrid_core3.focusAndSelectElement)(that, $focusableElement);\n        }\n\n        that._beforeFocusCallback = null;\n      }\n\n      if (_devices2.default.real().ios || _devices2.default.real().android) {\n        inputFocus();\n      } else {\n        if (that._beforeFocusCallback) {\n          that._beforeFocusCallback();\n        }\n\n        clearTimeout(that._inputFocusTimeoutID);\n\n        if (callBeforeFocusCallbackAlways) {\n          that._beforeFocusCallback = beforeFocusCallback;\n        }\n\n        that._inputFocusTimeoutID = setTimeout(inputFocus);\n      }\n    },\n    _focusEditingCell: function (beforeFocusCallback, $editCell, callBeforeFocusCallbackAlways) {\n      var that = this;\n      var rowsView = that.getView(\"rowsView\");\n      $editCell = $editCell || rowsView && rowsView._getCellElement(that._getVisibleEditRowIndex(), that._editColumnIndex);\n\n      that._delayedInputFocus($editCell, beforeFocusCallback, callBeforeFocusCallbackAlways);\n    },\n    removeRow: function (rowIndex) {\n      _ui2.default.log(\"W0002\", \"dxDataGrid\", \"removeRow\", \"15.2\", \"Use the 'deleteRow' method instead\");\n\n      return this.deleteRow(rowIndex);\n    },\n    deleteRow: function (rowIndex) {\n      var _this8 = this;\n\n      if (\"cell\" === this.option(\"editing.mode\") && this.isEditing()) {\n        var isNewRow = this._dataController.items()[rowIndex].isNewRow;\n\n        this.closeEditCell(null, isNewRow).always(function () {\n          _this8._checkAndDeleteRow(rowIndex);\n        });\n      } else {\n        this._checkAndDeleteRow(rowIndex);\n      }\n    },\n    _checkAndDeleteRow: function (rowIndex) {\n      var that = this;\n      var editingOptions = that.option(\"editing\");\n      var editingTexts = editingOptions && editingOptions.texts;\n      var isBatchMode = editingOptions && editingOptions.mode === EDIT_MODE_BATCH;\n      var confirmDelete = editingOptions && editingOptions.confirmDelete;\n      var confirmDeleteMessage = editingTexts && editingTexts.confirmDeleteMessage;\n\n      var item = that._dataController.items()[rowIndex];\n\n      var allowDeleting = isBatchMode || !that.isEditing() || item.isNewRow;\n\n      if (item && allowDeleting) {\n        if (isBatchMode || !confirmDelete || !confirmDeleteMessage) {\n          that._deleteRowCore(rowIndex);\n        } else {\n          var confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle;\n          var showDialogTitle = _type2.default.isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;\n\n          _dialog2.default.confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(function (confirmResult) {\n            if (confirmResult) {\n              that._deleteRowCore(rowIndex);\n            }\n          });\n        }\n      }\n    },\n    _deleteRowCore: function (rowIndex) {\n      var dataController = this._dataController;\n      var item = dataController.items()[rowIndex];\n      var key = item && item.key;\n\n      var oldEditRowIndex = this._getVisibleEditRowIndex();\n\n      var isBatchMode = this.option(\"editing.mode\") === EDIT_MODE_BATCH;\n      this.refresh();\n      var editIndex = (0, _uiGrid_core3.getIndexByKey)(key, this._editData);\n\n      if (editIndex >= 0) {\n        if (this._editData[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE) {\n          this._removeEditDataItem(editIndex);\n        } else {\n          this._addEditData({\n            key: key,\n            type: DATA_EDIT_DATA_REMOVE_TYPE\n          });\n        }\n      } else {\n        this._addEditData({\n          key: key,\n          oldData: item.data,\n          type: DATA_EDIT_DATA_REMOVE_TYPE\n        });\n      }\n\n      if (isBatchMode) {\n        dataController.updateItems({\n          changeType: \"update\",\n          rowIndices: [oldEditRowIndex, rowIndex]\n        });\n      } else {\n        this.saveEditData();\n      }\n    },\n    undeleteRow: function (rowIndex) {\n      var that = this;\n      var dataController = that._dataController;\n      var item = dataController.items()[rowIndex];\n\n      var oldEditRowIndex = that._getVisibleEditRowIndex();\n\n      var key = item && item.key;\n\n      if (item) {\n        var editIndex = (0, _uiGrid_core3.getIndexByKey)(key, that._editData);\n\n        if (editIndex >= 0) {\n          var editData = that._editData[editIndex];\n\n          if (_type2.default.isEmptyObject(editData.data)) {\n            that._removeEditDataItem(editIndex);\n          } else {\n            that._addEditData({\n              key: key,\n              type: DATA_EDIT_DATA_UPDATE_TYPE\n            });\n          }\n\n          dataController.updateItems({\n            changeType: \"update\",\n            rowIndices: [oldEditRowIndex, rowIndex]\n          });\n        }\n      }\n    },\n    _saveEditDataCore: function (deferreds, results, changes) {\n      var that = this;\n\n      var store = that._dataController.store();\n\n      var isDataSaved = true;\n\n      function executeEditingAction(actionName, params, func) {\n        var deferred = new _deferred.Deferred();\n        that.executeAction(actionName, params);\n        (0, _deferred.when)((0, _deferred.fromPromise)(params.cancel)).done(function (cancel) {\n          if (cancel) {\n            setTimeout(function () {\n              deferred.resolve(\"cancel\");\n            });\n          } else {\n            func(params).done(deferred.resolve).fail(createFailureHandler(deferred));\n          }\n        }).fail(createFailureHandler(deferred));\n        return deferred;\n      }\n\n      (0, _iterator.each)(that._editData, function (index, editData) {\n        var data = editData.data;\n        var oldData = editData.oldData;\n        var type = editData.type;\n        var deferred;\n        var params;\n\n        if (that._beforeSaveEditData(editData, index)) {\n          return;\n        }\n\n        switch (type) {\n          case DATA_EDIT_DATA_REMOVE_TYPE:\n            params = {\n              data: oldData,\n              key: editData.key,\n              cancel: false\n            };\n            deferred = executeEditingAction(\"onRowRemoving\", params, function () {\n              return store.remove(editData.key).done(function (key) {\n                changes.push({\n                  type: \"remove\",\n                  key: key\n                });\n              });\n            });\n            break;\n\n          case DATA_EDIT_DATA_INSERT_TYPE:\n            params = {\n              data: data,\n              cancel: false\n            };\n            deferred = executeEditingAction(\"onRowInserting\", params, function () {\n              return store.insert(params.data).done(function (data, key) {\n                if (_type2.default.isDefined(key)) {\n                  editData.key = key;\n                }\n\n                if (data && _type2.default.isObject(data) && data !== params.data) {\n                  editData.data = data;\n                }\n\n                changes.push({\n                  type: \"insert\",\n                  data: data,\n                  index: 0\n                });\n              });\n            });\n            break;\n\n          case DATA_EDIT_DATA_UPDATE_TYPE:\n            params = {\n              newData: data,\n              oldData: oldData,\n              key: editData.key,\n              cancel: false\n            };\n            deferred = executeEditingAction(\"onRowUpdating\", params, function () {\n              return store.update(editData.key, params.newData).done(function (data, key) {\n                if (data && _type2.default.isObject(data) && data !== params.newData) {\n                  editData.data = data;\n                }\n\n                changes.push({\n                  type: \"update\",\n                  key: key,\n                  data: data\n                });\n              });\n            });\n        }\n\n        if (deferred) {\n          var doneDeferred = new _deferred.Deferred();\n          deferred.always(function (data) {\n            isDataSaved = \"cancel\" !== data;\n            results.push({\n              key: editData.key,\n              result: data\n            });\n          }).always(doneDeferred.resolve);\n          deferreds.push(doneDeferred.promise());\n        }\n      });\n      return isDataSaved;\n    },\n    _processSaveEditDataResult: function (results) {\n      var that = this;\n      var hasSavedData = false;\n\n      var editMode = _getEditMode(that);\n\n      for (var i = 0; i < results.length; i++) {\n        var arg = results[i].result;\n        var cancel = \"cancel\" === arg;\n        var editIndex = (0, _uiGrid_core3.getIndexByKey)(results[i].key, that._editData);\n        var editData = that._editData[editIndex];\n        var isError = arg && arg instanceof Error;\n\n        if (isError) {\n          if (editData) {\n            editData.error = arg;\n          }\n\n          that._fireDataErrorOccurred(arg);\n\n          if (editMode !== EDIT_MODE_BATCH) {\n            if (editData && editData.type === DATA_EDIT_DATA_REMOVE_TYPE) {\n              that._removeEditDataItem(editIndex);\n            }\n\n            break;\n          }\n        } else {\n          if (!cancel || !editData || editMode !== EDIT_MODE_BATCH && editData.type === DATA_EDIT_DATA_REMOVE_TYPE) {\n            that._removeEditDataItem(editIndex);\n\n            hasSavedData = !cancel;\n          }\n        }\n      }\n\n      return hasSavedData;\n    },\n    _fireSaveEditDataEvents: function (editData) {\n      var that = this;\n      (0, _iterator.each)(editData, function (_, itemData) {\n        var data = itemData.data;\n        var key = itemData.key;\n        var type = itemData.type;\n        var params = {\n          key: key,\n          data: data\n        };\n\n        if (itemData.error) {\n          params.error = itemData.error;\n        }\n\n        switch (type) {\n          case DATA_EDIT_DATA_REMOVE_TYPE:\n            that.executeAction(\"onRowRemoved\", (0, _extend.extend)({}, params, {\n              data: itemData.oldData\n            }));\n            break;\n\n          case DATA_EDIT_DATA_INSERT_TYPE:\n            that.executeAction(\"onRowInserted\", params);\n            break;\n\n          case DATA_EDIT_DATA_UPDATE_TYPE:\n            that.executeAction(\"onRowUpdated\", params);\n        }\n      });\n    },\n    saveEditData: function () {\n      var _this9 = this;\n\n      var deferred = new _deferred.Deferred();\n\n      var afterSaveEditData = function (cancel) {\n        (0, _deferred.when)(_this9._afterSaveEditData(cancel)).done(function () {\n          deferred.resolve();\n        });\n      };\n\n      this.waitForDeferredOperations().done(function () {\n        if (_this9._saving) {\n          afterSaveEditData();\n          return;\n        }\n\n        (0, _deferred.when)(_this9._beforeSaveEditData()).done(function (cancel) {\n          if (cancel) {\n            afterSaveEditData(cancel);\n            return;\n          }\n\n          _this9._saveEditDataInner().done(deferred.resolve).fail(deferred.reject);\n        }).fail(deferred.reject);\n      }).fail(deferred.reject);\n      return deferred.promise();\n    },\n    _saveEditDataInner: function () {\n      var _this10 = this;\n\n      var results = [];\n      var deferreds = [];\n      var changes = [];\n      var dataController = this._dataController;\n      var dataSource = dataController.dataSource();\n\n      var editMode = _getEditMode(this);\n\n      var result = new _deferred.Deferred();\n\n      var resetEditIndices = function () {\n        if (editMode !== EDIT_MODE_CELL) {\n          _this10._editColumnIndex = -1;\n          _this10._editRowIndex = -1;\n        }\n      };\n\n      var afterSaveEditData = function (error) {\n        (0, _deferred.when)(_this10._afterSaveEditData()).done(function () {\n          result.resolve(error);\n        });\n      };\n\n      var editData = this._editData.slice(0);\n\n      if (!this._saveEditDataCore(deferreds, results, changes) && editMode === EDIT_MODE_CELL) {\n        this._focusEditingCell();\n      }\n\n      if (deferreds.length) {\n        this._saving = true;\n        dataSource && dataSource.beginLoading();\n\n        _deferred.when.apply(_renderer2.default, deferreds).done(function () {\n          if (_this10._processSaveEditDataResult(results)) {\n            resetEditIndices();\n\n            if (editMode === EDIT_MODE_POPUP && _this10._editPopup) {\n              _this10._editPopup.hide();\n            }\n\n            dataSource && dataSource.endLoading();\n\n            var refreshMode = _this10.option(\"editing.refreshMode\");\n\n            var isFullRefresh = \"reshape\" !== refreshMode && \"repaint\" !== refreshMode;\n\n            if (!isFullRefresh) {\n              dataController.push(changes);\n            }\n\n            (0, _deferred.when)(dataController.refresh({\n              selection: isFullRefresh,\n              reload: isFullRefresh,\n              load: \"reshape\" === refreshMode,\n              changesOnly: _this10.option(\"repaintChangesOnly\")\n            })).always(function () {\n              _this10._fireSaveEditDataEvents(editData);\n            }).done(function () {\n              afterSaveEditData();\n            }).fail(function (error) {\n              afterSaveEditData(error);\n            });\n          } else {\n            dataSource && dataSource.endLoading();\n            result.resolve();\n          }\n        }).fail(function (error) {\n          dataSource && dataSource.endLoading();\n          result.resolve(error);\n        });\n\n        return result.always(function () {\n          _this10._focusEditingCell();\n\n          _this10._saving = false;\n        }).promise();\n      }\n\n      if (_isRowEditMode(this)) {\n        if (!this.hasChanges()) {\n          this.cancelEditData();\n        }\n      } else {\n        if (CELL_BASED_MODES.indexOf(editMode) !== -1) {\n          resetEditIndices();\n          dataController.updateItems();\n        } else {\n          this._focusEditingCell();\n        }\n      }\n\n      afterSaveEditData();\n      return result.promise();\n    },\n    isSaving: function () {\n      return this._saving;\n    },\n    _updateEditColumn: function () {\n      var that = this;\n\n      var isEditColumnVisible = that._isEditColumnVisible();\n\n      var useIcons = that.option(\"editing.useIcons\");\n      var cssClass = COMMAND_EDIT_CLASS + (useIcons ? \" \" + COMMAND_EDIT_WITH_ICONS_CLASS : \"\");\n\n      that._columnsController.addCommandColumn({\n        type: \"buttons\",\n        command: \"edit\",\n        visible: isEditColumnVisible,\n        cssClass: cssClass,\n        width: \"auto\",\n        alignment: \"center\",\n        cellTemplate: that._getEditCommandCellTemplate(),\n        fixedPosition: \"right\"\n      });\n\n      that._columnsController.columnOption(\"command:edit\", {\n        visible: isEditColumnVisible,\n        cssClass: cssClass\n      });\n    },\n    _isEditColumnVisible: function () {\n      var that = this;\n      var editingOptions = that.option(\"editing\");\n\n      if (editingOptions) {\n        var editMode = _getEditMode(that);\n\n        var isVisibleWithCurrentEditMode = false;\n\n        switch (editMode) {\n          case EDIT_MODE_ROW:\n            isVisibleWithCurrentEditMode = editingOptions.allowUpdating || editingOptions.allowAdding;\n            break;\n\n          case EDIT_MODE_FORM:\n          case EDIT_MODE_POPUP:\n            isVisibleWithCurrentEditMode = editingOptions.allowUpdating;\n        }\n\n        return editingOptions.allowDeleting || isVisibleWithCurrentEditMode;\n      }\n    },\n    _updateEditButtons: function () {\n      var that = this;\n      var headerPanel = that.getView(\"headerPanel\");\n      var hasChanges = that.hasChanges();\n\n      if (headerPanel) {\n        headerPanel.setToolbarItemDisabled(\"saveButton\", !hasChanges);\n        headerPanel.setToolbarItemDisabled(\"revertButton\", !hasChanges);\n      }\n    },\n    _applyModified: function ($element) {\n      $element && $element.addClass(CELL_MODIFIED);\n    },\n    _beforeCloseEditCellInBatchMode: function () {},\n    cancelEditData: function () {\n      var that = this;\n\n      var editMode = _getEditMode(that);\n\n      var rowIndex = this._getVisibleEditRowIndex();\n\n      var dataController = that._dataController;\n\n      that._beforeCancelEditData();\n\n      that.init();\n\n      if (ROW_BASED_MODES.indexOf(editMode) !== -1 && rowIndex >= 0) {\n        dataController.updateItems({\n          changeType: \"update\",\n          rowIndices: [rowIndex, rowIndex + 1]\n        });\n      } else {\n        dataController.updateItems({\n          repaintChangesOnly: that.option(\"repaintChangesOnly\")\n        });\n      }\n\n      if (editMode === EDIT_MODE_POPUP) {\n        that._hideEditPopup();\n      }\n    },\n    _hideEditPopup: function () {\n      this._editPopup && this._editPopup.option(\"visible\", false);\n    },\n    hasEditData: function () {\n      return this.hasChanges();\n    },\n    closeEditCell: function (isError, withoutSaveEditData) {\n      var _this11 = this;\n\n      var that = this;\n\n      var result = _deferred2.default.when();\n\n      var oldEditRowIndex = that._getVisibleEditRowIndex();\n\n      if (!_isRowEditMode(that)) {\n        result = _deferred2.default.Deferred();\n        this.executeOperation(result, function () {\n          _this11._closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData);\n\n          result.resolve();\n        });\n      }\n\n      return result.promise();\n    },\n    _closeEditCellCore: function (isError, oldEditRowIndex, withoutSaveEditData) {\n      var that = this;\n\n      var editMode = _getEditMode(that);\n\n      var dataController = that._dataController;\n\n      if (editMode === EDIT_MODE_CELL && that.hasChanges()) {\n        if (!withoutSaveEditData) {\n          that.saveEditData().done(function (error) {\n            if (!that.hasChanges()) {\n              that.closeEditCell(!!error);\n            }\n          });\n        }\n      } else {\n        if (oldEditRowIndex >= 0) {\n          var rowIndices = [oldEditRowIndex];\n          that._editRowIndex = -1;\n          that._editColumnIndex = -1;\n\n          that._beforeCloseEditCellInBatchMode(rowIndices);\n\n          if (!isError) {\n            dataController.updateItems({\n              changeType: \"update\",\n              rowIndices: rowIndices\n            });\n          }\n        }\n      }\n    },\n    update: function (changeType) {\n      var that = this;\n      var dataController = that._dataController;\n\n      if (dataController && that._pageIndex !== dataController.pageIndex()) {\n        if (\"refresh\" === changeType) {\n          that.refresh(true);\n        }\n\n        that._pageIndex = dataController.pageIndex();\n      }\n\n      that._updateEditButtons();\n    },\n    _getRowIndicesForCascadeUpdating: function (row, skipCurrentRow) {\n      return skipCurrentRow ? [] : [row.rowIndex];\n    },\n    addDeferred: function (deferred) {\n      var _this12 = this;\n\n      if (this._deferreds.indexOf(deferred) < 0) {\n        this._deferreds.push(deferred);\n\n        deferred.always(function () {\n          var index = _this12._deferreds.indexOf(deferred);\n\n          if (index >= 0) {\n            _this12._deferreds.splice(index, 1);\n          }\n        });\n      }\n    },\n    _prepareEditDataParams: function (options, value, text) {\n      var _options$row;\n\n      var that = this;\n      var newData = {};\n      var oldData = null === (_options$row = options.row) || void 0 === _options$row ? void 0 : _options$row.data;\n      var rowKey = options.key;\n      var $cellElement = (0, _renderer2.default)(options.cellElement);\n\n      var editMode = _getEditMode(that);\n\n      var deferred = new _deferred.Deferred();\n\n      if (void 0 !== rowKey) {\n        if (editMode === EDIT_MODE_BATCH) {\n          that._applyModified($cellElement, options);\n        }\n\n        options.value = value;\n        var setCellValueResult = (0, _deferred.fromPromise)(options.column.setCellValue(newData, value, (0, _extend.extend)(true, {}, oldData), text));\n        setCellValueResult.done(function () {\n          deferred.resolve({\n            data: newData,\n            key: rowKey,\n            oldData: oldData,\n            type: DATA_EDIT_DATA_UPDATE_TYPE\n          });\n        }).fail(createFailureHandler(deferred)).fail(function (arg) {\n          return that._fireDataErrorOccurred(arg);\n        });\n\n        if (_type2.default.isDefined(text) && options.column.displayValueMap) {\n          options.column.displayValueMap[value] = text;\n        }\n\n        if (options.values) {\n          options.values[options.columnIndex] = value;\n        }\n\n        that.addDeferred(deferred);\n      }\n\n      return deferred;\n    },\n    updateFieldValue: function (options, value, text, forceUpdateRow) {\n      var _this13 = this;\n\n      var rowKey = options.key;\n      var deferred = new _deferred.Deferred();\n\n      if (void 0 === rowKey) {\n        this._dataController.fireError(\"E1043\");\n      }\n\n      if (options.column.setCellValue) {\n        this._prepareEditDataParams(options, value, text).done(function (params) {\n          (0, _deferred.when)(_this13._applyEditDataParams(options, params, forceUpdateRow)).always(function () {\n            deferred.resolve();\n          });\n        });\n      } else {\n        deferred.resolve();\n      }\n\n      return deferred.promise();\n    },\n    _focusPreviousEditingCellIfNeed: function (options) {\n      var that = this;\n\n      if (that.hasEditData() && !that.isEditCell(options.rowIndex, options.columnIndex)) {\n        that._focusEditingCell();\n\n        that._updateEditRow(options.row, true);\n\n        return true;\n      }\n    },\n    _needUpdateRow: function (column) {\n      var visibleColumns = this._columnsController.getVisibleColumns();\n\n      if (!column) {\n        column = visibleColumns[this._editColumnIndex];\n      }\n\n      var isCustomSetCellValue = column && column.setCellValue !== column.defaultSetCellValue;\n      var isCustomCalculateCellValue = visibleColumns.some(function (visibleColumn) {\n        return visibleColumn.calculateCellValue !== visibleColumn.defaultCalculateCellValue;\n      });\n      return isCustomSetCellValue || isCustomCalculateCellValue;\n    },\n    _applyEditDataParams: function (options, params, forceUpdateRow) {\n      var that = this;\n\n      var editMode = _getEditMode(that);\n\n      var isCustomSetCellValue = options.column.setCellValue !== options.column.defaultSetCellValue;\n      var showEditorAlways = options.column.showEditorAlways;\n      var isUpdateInCellMode = editMode === EDIT_MODE_CELL && options.row && !options.row.isNewRow;\n      var focusPreviousEditingCell = showEditorAlways && !forceUpdateRow && isUpdateInCellMode && that.hasEditData() && !that.isEditCell(options.rowIndex, options.columnIndex);\n\n      if (focusPreviousEditingCell) {\n        that._focusEditingCell();\n\n        that._updateEditRow(options.row, true, isCustomSetCellValue);\n\n        return;\n      }\n\n      that._addEditData(params, options.row);\n\n      that._updateEditButtons();\n\n      if (showEditorAlways && !forceUpdateRow) {\n        if (isUpdateInCellMode) {\n          that._editRowIndex = options.row.rowIndex + that._dataController.getRowIndexOffset();\n          that._editColumnIndex = options.columnIndex;\n          return that.saveEditData();\n        } else {\n          if (editMode === EDIT_MODE_BATCH) {\n            forceUpdateRow = that._needUpdateRow(options.column);\n          }\n        }\n      }\n\n      var row = options.row;\n\n      if (row) {\n        if (forceUpdateRow || isCustomSetCellValue) {\n          that._updateEditRow(row, forceUpdateRow, isCustomSetCellValue);\n        } else {\n          if (row.update) {\n            row.update();\n          }\n        }\n      }\n    },\n    _updateEditRowCore: function (row, skipCurrentRow, isCustomSetCellValue) {\n      var that = this;\n      var editForm = that._editForm;\n\n      var editMode = _getEditMode(that);\n\n      if (editMode === EDIT_MODE_POPUP) {\n        if (that.option(\"repaintChangesOnly\")) {\n          row.update && row.update(row);\n        } else {\n          if (editForm) {\n            that._updateEditFormDeferred = new _deferred.Deferred().done(function () {\n              return editForm.repaint();\n            });\n\n            if (!that._updateLockCount) {\n              that._updateEditFormDeferred.resolve();\n            }\n          }\n        }\n      } else {\n        that._dataController.updateItems({\n          changeType: \"update\",\n          rowIndices: that._getRowIndicesForCascadeUpdating(row, skipCurrentRow)\n        });\n      }\n\n      if (isCustomSetCellValue && that._editForm && !row.isNewRow) {\n        that._editForm.validate();\n      }\n    },\n    _endUpdateCore: function () {\n      this._updateEditFormDeferred && this._updateEditFormDeferred.resolve();\n    },\n    _updateEditRow: function (row, forceUpdateRow, isCustomSetCellValue) {\n      var that = this;\n\n      if (forceUpdateRow || !_isRowEditMode(that)) {\n        that._updateEditRowCore(row, !forceUpdateRow, isCustomSetCellValue);\n\n        if (!forceUpdateRow) {\n          that._focusEditingCell();\n        }\n      } else {\n        var deferred = new _deferred.Deferred();\n        that.addDeferred(deferred);\n        setTimeout(function () {\n          var $focusedElement = (0, _renderer2.default)(_dom_adapter2.default.getActiveElement());\n\n          var columnIndex = that._rowsView.getCellIndex($focusedElement, row.rowIndex);\n\n          var focusedElement = $focusedElement.get(0);\n          var selectionRange = (0, _uiGrid_core3.getSelectionRange)(focusedElement);\n\n          that._updateEditRowCore(row, false, isCustomSetCellValue);\n\n          if (columnIndex >= 0) {\n            var $focusedItem = that._rowsView._getCellElement(row.rowIndex, columnIndex);\n\n            that._delayedInputFocus($focusedItem, function () {\n              setTimeout(function () {\n                focusedElement = _dom_adapter2.default.getActiveElement();\n\n                if (selectionRange.selectionStart >= 0) {\n                  (0, _uiGrid_core3.setSelectionRange)(focusedElement, selectionRange);\n                }\n              });\n            });\n          }\n\n          deferred.resolve();\n        });\n      }\n    },\n    _addEditData: function (options, row) {\n      var that = this;\n      var editDataIndex = (0, _uiGrid_core3.getIndexByKey)(options.key, that._editData);\n\n      if (editDataIndex < 0) {\n        editDataIndex = that._editData.length;\n\n        that._editData.push(options);\n      }\n\n      if (that._editData[editDataIndex]) {\n        if (options.data) {\n          that._editData[editDataIndex].data = (0, _uiGrid_core3.createObjectWithChanges)(that._editData[editDataIndex].data, options.data);\n        }\n\n        if ((!that._editData[editDataIndex].type || !options.data) && options.type) {\n          that._editData[editDataIndex].type = options.type;\n        }\n\n        if (row) {\n          row.oldData = that._editData[editDataIndex].oldData;\n          row.data = (0, _uiGrid_core3.createObjectWithChanges)(row.data, options.data);\n        }\n      }\n\n      return editDataIndex;\n    },\n    _getFormEditItemTemplate: function (cellOptions, column) {\n      return column.editCellTemplate || getDefaultEditorTemplate(this);\n    },\n    renderFormEditTemplate: function (detailCellOptions, item, form, container, isReadOnly) {\n      var that = this;\n      var $container = (0, _renderer2.default)(container);\n      var column = item.column;\n      var editorType = getEditorType(item);\n      var rowData = null === detailCellOptions || void 0 === detailCellOptions ? void 0 : detailCellOptions.row.data;\n      var cellOptions = (0, _extend.extend)({}, detailCellOptions, {\n        data: rowData,\n        cellElement: null,\n        isOnForm: true,\n        item: item,\n        column: (0, _extend.extend)({}, column, {\n          editorType: editorType,\n          editorOptions: item.editorOptions\n        }),\n        id: form.getItemID(item.name || item.dataField),\n        columnIndex: column.index,\n        setValue: !isReadOnly && column.allowEditing && function (value) {\n          that.updateFieldValue(cellOptions, value);\n        }\n      });\n      cellOptions.value = column.calculateCellValue(rowData);\n\n      var template = that._getFormEditItemTemplate.bind(that)(cellOptions, column);\n\n      that._rowsView.renderTemplate($container, template, cellOptions, !!$container.closest((0, _window.getWindow)().document).length).done(function () {\n        that._rowsView._updateCell($container, cellOptions);\n      });\n\n      return cellOptions;\n    },\n    getFormEditorTemplate: function (cellOptions, item) {\n      var that = this;\n      var column = this.component.columnOption(item.dataField);\n      return function (options, container) {\n        var $container = (0, _renderer2.default)(container);\n        cellOptions.row.watch && cellOptions.row.watch(function () {\n          return column.selector(cellOptions.row.data);\n        }, function () {\n          var _validator;\n\n          var $editorElement = $container.find(\".dx-widget\").first();\n          var validator = $editorElement.data(\"dxValidator\");\n          var validatorOptions = null === (_validator = validator) || void 0 === _validator ? void 0 : _validator.option();\n          $container.contents().remove();\n          cellOptions = that.renderFormEditTemplate.bind(that)(cellOptions, item, options.component, $container);\n          $editorElement = $container.find(\".dx-widget\").first();\n          validator = $editorElement.data(\"dxValidator\");\n\n          if (validatorOptions && !validator) {\n            $editorElement.dxValidator({\n              validationRules: validatorOptions.validationRules,\n              validationGroup: validatorOptions.validationGroup,\n              dataGetter: validatorOptions.dataGetter\n            });\n          }\n        });\n        cellOptions = that.renderFormEditTemplate.bind(that)(cellOptions, item, options.component, $container);\n      };\n    },\n    getEditFormTemplate: function () {\n      var that = this;\n      return function ($container, detailOptions, renderFormOnly) {\n        var editFormOptions = that.option(\"editing.form\");\n        var items = that.option(\"editing.form.items\");\n        var userCustomizeItem = that.option(\"editing.form.customizeItem\");\n\n        var editData = that._editData[(0, _uiGrid_core3.getIndexByKey)(detailOptions.key, that._editData)];\n\n        var editFormItemClass = that.addWidgetPrefix(EDIT_FORM_ITEM_CLASS);\n        var isCustomEditorType = {};\n\n        if (!items) {\n          var columns = that.getController(\"columns\").getColumns();\n          items = [];\n          (0, _iterator.each)(columns, function (_, column) {\n            if (!column.isBand && !column.type) {\n              items.push({\n                column: column,\n                name: column.name,\n                dataField: column.dataField\n              });\n            }\n          });\n        } else {\n          forEachFormItems(items, function (item) {\n            var itemId = (null === item || void 0 === item ? void 0 : item.name) || (null === item || void 0 === item ? void 0 : item.dataField);\n\n            if (itemId) {\n              isCustomEditorType[itemId] = !!item.editorType;\n            }\n          });\n        }\n\n        that._firstFormItem = void 0;\n        that._editForm = that._createComponent((0, _renderer2.default)(\"<div>\").appendTo($container), _form2.default, (0, _extend.extend)({}, editFormOptions, {\n          items: items,\n          formID: \"dx-\" + new _guid2.default(),\n          validationGroup: editData,\n          customizeItem: function (item) {\n            var column;\n            var itemId = item.name || item.dataField;\n\n            if (item.column || itemId) {\n              column = item.column || that._columnsController.columnOption(item.name ? \"name:\" + item.name : \"dataField:\" + item.dataField);\n            }\n\n            if (column) {\n              item.label = item.label || {};\n              item.label.text = item.label.text || column.caption;\n              item.template = item.template || that.getFormEditorTemplate(detailOptions, item);\n              item.column = column;\n              item.isCustomEditorType = isCustomEditorType[itemId];\n\n              if (column.formItem) {\n                (0, _extend.extend)(item, column.formItem);\n              }\n\n              if (void 0 === item.isRequired && column.validationRules) {\n                item.isRequired = column.validationRules.some(function (rule) {\n                  return \"required\" === rule.type;\n                });\n                item.validationRules = [];\n              }\n\n              var itemVisible = _type2.default.isDefined(item.visible) ? item.visible : true;\n\n              if (!that._firstFormItem && itemVisible) {\n                that._firstFormItem = item;\n              }\n            }\n\n            userCustomizeItem && userCustomizeItem.call(this, item);\n            item.cssClass = _type2.default.isString(item.cssClass) ? item.cssClass + \" \" + editFormItemClass : editFormItemClass;\n          }\n        }));\n\n        if (!renderFormOnly) {\n          var $buttonsContainer = (0, _renderer2.default)(\"<div>\").addClass(that.addWidgetPrefix(FORM_BUTTONS_CONTAINER_CLASS)).appendTo($container);\n\n          that._createComponent((0, _renderer2.default)(\"<div>\").appendTo($buttonsContainer), _button2.default, that._getSaveButtonConfig());\n\n          that._createComponent((0, _renderer2.default)(\"<div>\").appendTo($buttonsContainer), _button2.default, that._getCancelButtonConfig());\n        }\n\n        that._editForm.on(\"contentReady\", function () {\n          that._editPopup && that._editPopup.repaint();\n        });\n      };\n    },\n    getColumnTemplate: function (options) {\n      var that = this;\n      var column = options.column;\n      var rowIndex = options.row && options.row.rowIndex;\n      var template;\n\n      var isRowMode = _isRowEditMode(that);\n\n      var isRowEditing = that.isEditRow(rowIndex);\n      var isCellEditing = that.isEditCell(rowIndex, options.columnIndex);\n      var editingStartOptions;\n\n      if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && (\"data\" === options.rowType || \"detailAdaptive\" === options.rowType) && !column.command) {\n        var allowUpdating = that.allowUpdating(options);\n\n        if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowMode && isRowEditing || !isRowMode)) {\n          if (column.showEditorAlways && !isRowMode) {\n            editingStartOptions = {\n              cancel: false,\n              key: options.row.isNewRow ? void 0 : options.row.key,\n              data: options.row.data,\n              column: column\n            };\n\n            that._isEditingStart(editingStartOptions);\n          }\n\n          if (!editingStartOptions || !editingStartOptions.cancel) {\n            options.setValue = function (value, text) {\n              that.updateFieldValue(options, value, text);\n            };\n          }\n        }\n\n        template = column.editCellTemplate || getDefaultEditorTemplate(that);\n      } else {\n        if (\"detail\" === column.command && \"detail\" === options.rowType && isRowEditing) {\n          template = that.getEditFormTemplate(options);\n        }\n      }\n\n      return template;\n    },\n    _createButton: function ($container, button, options) {\n      var that = this;\n      var icon = EDIT_ICON_CLASS[button.name];\n      var useIcons = that.option(\"editing.useIcons\");\n      var $button = (0, _renderer2.default)(\"<a>\").attr(\"href\", \"#\").addClass(LINK_CLASS).addClass(button.cssClass);\n\n      if (button.template) {\n        that._rowsView.renderTemplate($container, button.template, options, true);\n      } else {\n        if (useIcons && icon || button.icon) {\n          icon = button.icon || icon;\n\n          var iconType = _icon2.default.getImageSourceType(icon);\n\n          if (\"image\" === iconType || \"svg\" === iconType) {\n            $button = _icon2.default.getImageContainer(icon).addClass(button.cssClass);\n          } else {\n            $button.addClass(\"dx-icon\" + (\"dxIcon\" === iconType ? \"-\" : \" \") + icon).attr(\"title\", button.text);\n          }\n\n          $button.addClass(\"dx-link-icon\");\n          $container.addClass(COMMAND_EDIT_WITH_ICONS_CLASS);\n          var localizationName = this.getButtonLocalizationNames()[button.name];\n          localizationName && $button.attr(\"aria-label\", _message2.default.format(localizationName));\n        } else {\n          $button.text(button.text);\n        }\n\n        if (_type2.default.isDefined(button.hint)) {\n          $button.attr(\"title\", button.hint);\n        }\n\n        _events_engine2.default.on($button, (0, _utils.addNamespace)(\"click\", EDITING_NAMESPACE), that.createAction(function (e) {\n          button.onClick.call(button, (0, _extend.extend)({}, e, {\n            row: options.row,\n            column: options.column\n          }));\n          e.event.preventDefault();\n          e.event.stopPropagation();\n        }));\n\n        options.rtlEnabled ? $container.prepend($button, \"&nbsp;\") : $container.append($button, \"&nbsp;\");\n      }\n    },\n    getButtonLocalizationNames: function () {\n      return {\n        edit: \"dxDataGrid-editingEditRow\",\n        save: \"dxDataGrid-editingSaveRowChanges\",\n        \"delete\": \"dxDataGrid-editingDeleteRow\",\n        undelete: \"dxDataGrid-editingUndeleteRow\",\n        cancel: \"dxDataGrid-editingCancelRowChanges\"\n      };\n    },\n    prepareEditButtons: function (headerPanel) {\n      var that = this;\n      var editingOptions = that.option(\"editing\") || {};\n      var editingTexts = that.option(\"editing.texts\") || {};\n      var titleButtonTextByClassNames = {\n        revert: editingTexts.cancelAllChanges,\n        save: editingTexts.saveAllChanges,\n        addRow: editingTexts.addRow\n      };\n      var classNameButtonByNames = {\n        revert: \"cancel\",\n        save: \"save\",\n        addRow: \"addrow\"\n      };\n      var buttonItems = [];\n\n      var prepareButtonItem = function (name, methodName, sortIndex) {\n        var className = classNameButtonByNames[name];\n\n        var onInitialized = function (e) {\n          (0, _renderer2.default)(e.element).addClass(headerPanel._getToolbarButtonClass(EDIT_BUTTON_CLASS + \" \" + that.addWidgetPrefix(className) + \"-button\"));\n        };\n\n        var hintText = titleButtonTextByClassNames[name];\n        var isButtonDisabled = (\"save\" === className || \"cancel\" === className) && !that.hasChanges();\n        return {\n          widget: \"dxButton\",\n          options: {\n            onInitialized: onInitialized,\n            icon: \"edit-button-\" + className,\n            disabled: isButtonDisabled,\n            onClick: function () {\n              setTimeout(function () {\n                that[methodName]();\n              });\n            },\n            text: hintText,\n            hint: hintText\n          },\n          showText: \"inMenu\",\n          name: name + \"Button\",\n          location: \"after\",\n          locateInMenu: \"auto\",\n          sortIndex: sortIndex\n        };\n      };\n\n      if (editingOptions.allowAdding) {\n        buttonItems.push(prepareButtonItem(\"addRow\", \"addRow\", 20));\n      }\n\n      if ((editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting) && _getEditMode(that) === EDIT_MODE_BATCH) {\n        buttonItems.push(prepareButtonItem(\"save\", \"saveEditData\", 21));\n        buttonItems.push(prepareButtonItem(\"revert\", \"cancelEditData\", 22));\n      }\n\n      return buttonItems;\n    },\n    showHighlighting: function ($cell) {\n      var $highlight = $cell.find(\".\" + CELL_HIGHLIGHT_OUTLINE);\n\n      if (\"TD\" === $cell.get(0).tagName && !$highlight.length) {\n        $cell.wrapInner((0, _renderer2.default)(\"<div>\").addClass(CELL_HIGHLIGHT_OUTLINE + \" \" + POINTER_EVENTS_TARGET_CLASS));\n      }\n    },\n    highlightDataCell: function ($cell, parameters) {\n      var isEditableCell = parameters.setValue;\n      var cellModified = this.isCellModified(parameters);\n\n      if (cellModified && parameters.column.setCellValue) {\n        this.showHighlighting($cell);\n        $cell.addClass(CELL_MODIFIED);\n      } else {\n        if (isEditableCell) {\n          this.showHighlighting($cell);\n        }\n      }\n    },\n    resetRowAndPageIndices: function () {\n      var that = this;\n      (0, _iterator.each)(that._editData, function (_, editData) {\n        if (editData.pageIndex !== that._pageIndex) {\n          delete editData.pageIndex;\n          delete editData.rowIndex;\n        }\n      });\n    },\n    _afterInsertRow: function () {},\n    _beforeSaveEditData: function (editData) {\n      if (editData && !_type2.default.isDefined(editData.key) && _type2.default.isDefined(editData.type)) {\n        return true;\n      }\n    },\n    _afterSaveEditData: function () {},\n    _beforeCancelEditData: function () {},\n    _allowEditAction: function (actionName, options) {\n      var allowEditAction = this.option(\"editing.\" + actionName);\n\n      if (_type2.default.isFunction(allowEditAction)) {\n        allowEditAction = allowEditAction({\n          component: this.component,\n          row: options.row\n        });\n      }\n\n      return allowEditAction;\n    },\n    allowUpdating: function (options, eventName) {\n      var startEditAction = this.option(\"editing.startEditAction\") || DEFAULT_START_EDIT_ACTION;\n      var needCallback = arguments.length > 1 ? startEditAction === eventName || \"down\" === eventName : true;\n      return needCallback && this._allowEditAction(\"allowUpdating\", options);\n    },\n    allowDeleting: function (options) {\n      return this._allowEditAction(\"allowDeleting\", options);\n    },\n    isCellModified: function (parameters) {\n      var columnIndex = parameters.columnIndex;\n      var modifiedValues = parameters.row && (parameters.row.isNewRow ? parameters.row.values : parameters.row.modifiedValues);\n      return !!modifiedValues && void 0 !== modifiedValues[columnIndex];\n    }\n  };\n}());\n\nmodule.exports = {\n  defaultOptions: function () {\n    return {\n      editing: {\n        mode: \"row\",\n        refreshMode: \"full\",\n        allowAdding: false,\n        allowUpdating: false,\n        allowDeleting: false,\n        useIcons: false,\n        selectTextOnEditStart: false,\n        confirmDelete: true,\n        texts: {\n          editRow: _message2.default.format(\"dxDataGrid-editingEditRow\"),\n          saveAllChanges: _message2.default.format(\"dxDataGrid-editingSaveAllChanges\"),\n          saveRowChanges: _message2.default.format(\"dxDataGrid-editingSaveRowChanges\"),\n          cancelAllChanges: _message2.default.format(\"dxDataGrid-editingCancelAllChanges\"),\n          cancelRowChanges: _message2.default.format(\"dxDataGrid-editingCancelRowChanges\"),\n          addRow: _message2.default.format(\"dxDataGrid-editingAddRow\"),\n          deleteRow: _message2.default.format(\"dxDataGrid-editingDeleteRow\"),\n          undeleteRow: _message2.default.format(\"dxDataGrid-editingUndeleteRow\"),\n          confirmDeleteMessage: _message2.default.format(\"dxDataGrid-editingConfirmDeleteMessage\"),\n          confirmDeleteTitle: \"\"\n        },\n        form: {\n          colCount: 2\n        },\n        popup: {},\n        startEditAction: \"click\"\n      }\n    };\n  },\n  controllers: {\n    editing: EditingController\n  },\n  extenders: {\n    controllers: {\n      data: {\n        init: function () {\n          this._editingController = this.getController(\"editing\");\n          this.callBase();\n        },\n        reload: function (full, repaintChangesOnly) {\n          !repaintChangesOnly && this._editingController.refresh();\n          return this.callBase.apply(this, arguments);\n        },\n        repaintRows: function () {\n          if (this.getController(\"editing\").isSaving()) {\n            return;\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _updateEditRow: function (items) {\n          var editingController = this._editingController;\n          var editRowIndex = editingController.getEditRowIndex();\n          var editItem = items[editRowIndex];\n\n          if (editItem) {\n            editItem.isEditing = true;\n\n            if (editingController.getEditMode() === EDIT_MODE_FORM) {\n              editItem.rowType = \"detail\";\n            }\n          }\n        },\n        _updateItemsCore: function (change) {\n          this.callBase(change);\n\n          this._updateEditRow(this.items());\n        },\n        _applyChangeUpdate: function (change) {\n          this._updateEditRow(change.items);\n\n          this.callBase(change);\n        },\n        _applyChangesOnly: function (change) {\n          this._updateEditRow(change.items);\n\n          this.callBase(change);\n        },\n        _processItems: function (items, change) {\n          items = this._editingController.processItems(items, change);\n          return this.callBase(items, change);\n        },\n        _processDataItem: function (dataItem, options) {\n          this._editingController.processDataItem(dataItem, options, this.generateDataValues);\n\n          return this.callBase(dataItem, options);\n        },\n        _processItem: function (item, options) {\n          item = this.callBase(item, options);\n\n          if (item.isNewRow) {\n            options.dataIndex--;\n            delete item.dataIndex;\n          }\n\n          return item;\n        },\n        _correctRowIndices: function (getRowIndexCorrection) {\n          this.callBase.apply(this, arguments);\n\n          this._editingController.correctEditRowIndex(getRowIndexCorrection);\n        },\n        _getChangedColumnIndices: function (oldItem, newItem, rowIndex, isLiveUpdate) {\n          var editingController = this.getController(\"editing\");\n          var isRowEditMode = editingController.isRowEditMode();\n\n          if (oldItem.isNewRow !== newItem.isNewRow || oldItem.removed !== newItem.removed || isRowEditMode && oldItem.isEditing !== newItem.isEditing) {\n            return;\n          }\n\n          if (oldItem.rowType === newItem.rowType && isRowEditMode && editingController.isEditRow(rowIndex) && isLiveUpdate) {\n            return [];\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _isCellChanged: function (oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {\n          var editingController = this.getController(\"editing\");\n          var cell = oldRow.cells && oldRow.cells[columnIndex];\n          var isEditing = editingController && editingController.isEditCell(visibleRowIndex, columnIndex);\n\n          if (isLiveUpdate && isEditing) {\n            return false;\n          }\n\n          if (cell && cell.column && !cell.column.showEditorAlways && cell.isEditing !== isEditing) {\n            return true;\n          }\n\n          return this.callBase.apply(this, arguments);\n        }\n      }\n    },\n    views: {\n      rowsView: {\n        init: function () {\n          this.callBase();\n          this._editingController = this.getController(\"editing\");\n        },\n        getCellElements: function (rowIndex) {\n          var $cellElements = this.callBase(rowIndex);\n          var editingController = this._editingController;\n          var editForm = editingController.getEditForm();\n          var editFormRowIndex = editingController.getEditFormRowIndex();\n\n          if (editFormRowIndex === rowIndex && $cellElements && editForm) {\n            return editForm.$element().find(\".\" + this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS) + \", .\" + BUTTON_CLASS);\n          }\n\n          return $cellElements;\n        },\n        getCellIndex: function ($cell, rowIndex) {\n          if (!$cell.is(\"td\") && rowIndex >= 0) {\n            var $cellElements = this.getCellElements(rowIndex);\n            var cellIndex = -1;\n            (0, _iterator.each)($cellElements, function (index, cellElement) {\n              if ((0, _renderer2.default)(cellElement).find($cell).length) {\n                cellIndex = index;\n              }\n            });\n            return cellIndex;\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _getVisibleColumnIndex: function ($cells, rowIndex, columnIdentifier) {\n          var editFormRowIndex = this._editingController.getEditFormRowIndex();\n\n          if (editFormRowIndex === rowIndex && _type2.default.isString(columnIdentifier)) {\n            var column = this._columnsController.columnOption(columnIdentifier);\n\n            return this._getEditFormEditorVisibleIndex($cells, column);\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _getEditFormEditorVisibleIndex: function ($cells, column) {\n          var visibleIndex = -1;\n          (0, _iterator.each)($cells, function (index, cellElement) {\n            var item = (0, _renderer2.default)(cellElement).find(\".dx-field-item-content\").data(\"dx-form-item\");\n\n            if (item && item.column && column && item.column.index === column.index) {\n              visibleIndex = index;\n              return false;\n            }\n          });\n          return visibleIndex;\n        },\n        publicMethods: function () {\n          return this.callBase().concat([\"cellValue\"]);\n        },\n        _getCellTemplate: function (options) {\n          var that = this;\n\n          var template = that._editingController.getColumnTemplate(options);\n\n          return template || that.callBase(options);\n        },\n        _isNativeClick: function () {\n          return (_devices2.default.real().ios || _devices2.default.real().android) && this.option(\"editing.allowUpdating\");\n        },\n        _createTable: function () {\n          var that = this;\n          var $table = that.callBase.apply(that, arguments);\n\n          if (!_isRowEditMode(that) && that.option(\"editing.allowUpdating\")) {\n            _events_engine2.default.on($table, (0, _utils.addNamespace)(_hold2.default.name, \"dxDataGridRowsView\"), \"td:not(.\" + EDITOR_CELL_CLASS + \")\", that.createAction(function () {\n              var editingController = that._editingController;\n\n              if (editingController.isEditing()) {\n                editingController.closeEditCell();\n              }\n            }));\n          }\n\n          return $table;\n        },\n        _createRow: function (row) {\n          var $row = this.callBase(row);\n\n          if (row) {\n            var editingController = this._editingController;\n            var isEditRow = editingController.isEditRow(row.rowIndex);\n            var isRowRemoved = !!row.removed;\n            var isRowInserted = !!row.isNewRow;\n            var isRowModified = !!row.modified;\n\n            if (_getEditMode(this) === EDIT_MODE_BATCH) {\n              isRowRemoved && $row.addClass(ROW_REMOVED);\n            } else {\n              isEditRow && $row.addClass(EDIT_ROW);\n            }\n\n            isRowInserted && $row.addClass(ROW_INSERTED);\n            isRowModified && $row.addClass(ROW_MODIFIED);\n\n            if (isEditRow || isRowInserted || isRowRemoved) {\n              $row.removeClass(ROW_SELECTED);\n            }\n\n            if (isEditRow && \"detail\" === row.rowType) {\n              $row.addClass(this.addWidgetPrefix(EDIT_FORM_CLASS));\n            }\n          }\n\n          return $row;\n        },\n        _getColumnIndexByElement: function ($element) {\n          var $tableElement = $element.closest(\"table\");\n          var $tableElements = this.getTableElements();\n\n          while ($tableElement.length && !$tableElements.filter($tableElement).length) {\n            $element = $tableElement.closest(\"td\");\n            $tableElement = $element.closest(\"table\");\n          }\n\n          return this._getColumnIndexByElementCore($element);\n        },\n        _getColumnIndexByElementCore: function ($element) {\n          var $targetElement = $element.closest(\".\" + ROW_CLASS + \"> td:not(.dx-master-detail-cell)\");\n          return this.getCellIndex($targetElement);\n        },\n        _editCellByClick: function (e, eventName) {\n          var that = this;\n          var editingController = that._editingController;\n          var $targetElement = (0, _renderer2.default)(e.event.target);\n\n          var columnIndex = that._getColumnIndexByElement($targetElement);\n\n          var row = that._dataController.items()[e.rowIndex];\n\n          var allowUpdating = editingController.allowUpdating({\n            row: row\n          }, eventName) || row && row.isNewRow;\n\n          var column = that._columnsController.getVisibleColumns()[columnIndex];\n\n          var allowEditing = allowUpdating && column && (column.allowEditing || editingController.isEditCell(e.rowIndex, columnIndex));\n          var startEditAction = that.option(\"editing.startEditAction\") || \"click\";\n\n          if (\"down\" === eventName) {\n            return column && column.showEditorAlways && allowEditing && editingController.editCell(e.rowIndex, columnIndex);\n          }\n\n          if (\"click\" === eventName && \"dblClick\" === startEditAction && !editingController.isEditCell(e.rowIndex, columnIndex)) {\n            editingController.closeEditCell();\n          }\n\n          if (allowEditing && eventName === startEditAction) {\n            return editingController.editCell(e.rowIndex, columnIndex) || editingController.isEditRow(e.rowIndex);\n          }\n        },\n        _rowPointerDown: function (e) {\n          var _this14 = this;\n\n          this._pointerDownTimeout = setTimeout(function () {\n            _this14._editCellByClick(e, \"down\");\n          });\n        },\n        _rowClick: function (e) {\n          var isEditForm = (0, _renderer2.default)(e.rowElement).hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS));\n          e.event[TARGET_COMPONENT_NAME] = this.component;\n\n          if (!this._editCellByClick(e, \"click\") && !isEditForm) {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        _rowDblClick: function (e) {\n          if (!this._editCellByClick(e, \"dblClick\")) {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        _cellPrepared: function ($cell, parameters) {\n          var editingController = this._editingController;\n          var isCommandCell = !!parameters.column.command;\n          var isEditableCell = parameters.setValue;\n          var isEditing = parameters.isEditing || editingController.isEditRow(parameters.rowIndex) && parameters.column.allowEditing;\n\n          if (\"data\" === parameters.rowType && !parameters.column.command && (isEditing || parameters.column.showEditorAlways)) {\n            var alignment = parameters.column.alignment;\n            $cell.addClass(EDITOR_CELL_CLASS).toggleClass(this.addWidgetPrefix(READONLY_CLASS), !isEditableCell).toggleClass(CELL_FOCUS_DISABLED_CLASS, !isEditableCell);\n\n            if (alignment) {\n              $cell.find(EDITORS_INPUT_SELECTOR).first().css(\"textAlign\", alignment);\n            }\n          }\n\n          if (isEditing) {\n            this._editCellPrepared($cell);\n          }\n\n          if (parameters.column && !isCommandCell) {\n            editingController.highlightDataCell($cell, parameters);\n          }\n\n          this.callBase.apply(this, arguments);\n        },\n        _editCellPrepared: function ($cell) {},\n        _formItemPrepared: function () {},\n        _isFormItem: function (parameters) {\n          var isDetailRow = \"detail\" === parameters.rowType || \"detailAdaptive\" === parameters.rowType;\n\n          var isPopupEditing = \"data\" === parameters.rowType && \"popup\" === _getEditMode(this);\n\n          return (isDetailRow || isPopupEditing) && parameters.item;\n        },\n        _updateCell: function ($cell, parameters) {\n          if (this._isFormItem(parameters)) {\n            this._formItemPrepared(parameters, $cell);\n          } else {\n            this.callBase($cell, parameters);\n          }\n        },\n        _update: function (change) {\n          this.callBase(change);\n\n          if (\"updateSelection\" === change.changeType) {\n            this.getTableElements().children(\"tbody\").children(\".\" + EDIT_ROW).removeClass(ROW_SELECTED);\n          }\n        },\n        _getCellOptions: function (options) {\n          var cellOptions = this.callBase(options);\n          cellOptions.isEditing = this._editingController.isEditCell(cellOptions.rowIndex, cellOptions.columnIndex);\n          return cellOptions;\n        },\n        _renderCellContent: function ($cell, options) {\n          if (\"data\" === options.rowType && _getEditMode(this) === EDIT_MODE_POPUP && false === options.row.visible) {\n            return;\n          }\n\n          this.callBase.apply(this, arguments);\n        },\n        cellValue: function (rowIndex, columnIdentifier, value, text) {\n          var cellOptions = this.getCellOptions(rowIndex, columnIdentifier);\n\n          if (cellOptions) {\n            if (void 0 === value) {\n              return cellOptions.value;\n            } else {\n              this._editingController.updateFieldValue(cellOptions, value, text, true);\n            }\n          }\n        },\n        dispose: function () {\n          this.callBase.apply(this, arguments);\n          clearTimeout(this._pointerDownTimeout);\n        }\n      },\n      headerPanel: {\n        _getToolbarItems: function () {\n          var items = this.callBase();\n          var editButtonItems = this.getController(\"editing\").prepareEditButtons(this);\n          return editButtonItems.concat(items);\n        },\n        optionChanged: function (args) {\n          var fullName = args.fullName;\n\n          switch (args.name) {\n            case \"editing\":\n              var isEditingPopupOption = fullName && 0 === fullName.indexOf(EDITING_POPUP_OPTION_NAME);\n\n              if (!isEditingPopupOption) {\n                this._invalidate();\n              }\n\n              this.callBase(args);\n              break;\n\n            default:\n              this.callBase(args);\n          }\n        },\n        isVisible: function () {\n          var that = this;\n          var editingOptions = that.getController(\"editing\").option(\"editing\");\n          return that.callBase() || editingOptions && (editingOptions.allowAdding || (editingOptions.allowUpdating || editingOptions.allowDeleting) && editingOptions.mode === EDIT_MODE_BATCH);\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}