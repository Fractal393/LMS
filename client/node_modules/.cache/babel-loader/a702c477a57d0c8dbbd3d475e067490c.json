{"ast":null,"code":"/**\r\n * DevExtreme (ui/data_grid/ui.data_grid.grouping.collapsed.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _uiData_grid = require(\"./ui.data_grid.core\");\n\nvar _uiData_gridGrouping = require(\"./ui.data_grid.grouping.core\");\n\nvar _uiData_grid2 = require(\"./ui.data_grid.utils\");\n\nvar _ui = require(\"../widget/ui.errors\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nvar _errors = require(\"../../data/errors\");\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nexports.GroupingHelper = _uiData_gridGrouping.GroupingHelper.inherit(function () {\n  var foreachExpandedGroups = function (that, callback, updateGroups) {\n    return that.foreachGroups(function (groupInfo, parents) {\n      if (groupInfo.isExpanded) {\n        return callback(groupInfo, parents);\n      }\n    }, true, false, updateGroups, updateGroups);\n  };\n\n  var processGroupItems = function processGroupItems(that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {\n    var isExpanded;\n    expandedInfo.items = expandedInfo.items || [];\n    expandedInfo.paths = expandedInfo.paths || [];\n    expandedInfo.count = expandedInfo.count || 0;\n    expandedInfo.lastCount = expandedInfo.lastCount || 0;\n\n    if (!groupsCount) {\n      return;\n    }\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (void 0 !== item.items) {\n        path.push(item.key);\n\n        if (isCustomLoading) {\n          isExpanded = true;\n        } else {\n          var groupInfo = that.findGroupInfo(path);\n          isExpanded = groupInfo && groupInfo.isExpanded;\n        }\n\n        if (!isExpanded) {\n          item.collapsedItems = item.items;\n          item.items = null;\n        } else {\n          if (item.items) {\n            processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded);\n          } else {\n            if (1 === groupsCount && item.count && (!isCustomLoading || isLastGroupExpanded)) {\n              expandedInfo.items.push(item);\n              expandedInfo.paths.push(path.slice(0));\n              expandedInfo.count += expandedInfo.lastCount;\n              expandedInfo.lastCount = item.count;\n            }\n          }\n        }\n\n        path.pop();\n      }\n    }\n  };\n\n  var updateGroupInfoItem = function (that, item, isLastGroupLevel, path, offset) {\n    var groupInfo = that.findGroupInfo(path);\n    var count;\n\n    if (!groupInfo) {\n      if (isLastGroupLevel) {\n        count = item.count > 0 ? item.count : item.items.length;\n      }\n\n      that.addGroupInfo({\n        isExpanded: that._isGroupExpanded(path.length - 1),\n        path: path.slice(0),\n        offset: offset,\n        count: count || 0\n      });\n    } else {\n      if (isLastGroupLevel) {\n        groupInfo.count = item.count > 0 ? item.count : item.items && item.items.length || 0;\n      } else {\n        item.count = groupInfo.count || item.count;\n      }\n\n      groupInfo.offset = offset;\n    }\n  };\n\n  var updateGroupInfos = function updateGroupInfos(that, options, items, loadedGroupCount, groupIndex, path, parentIndex) {\n    var groupCount = options.group ? options.group.length : 0;\n    var isLastGroupLevel = groupCount === loadedGroupCount;\n    var remotePaging = options.remoteOperations.paging;\n    var offset = 0;\n    var totalCount = 0;\n    var count;\n    groupIndex = groupIndex || 0;\n    path = path || [];\n\n    if (remotePaging && !parentIndex) {\n      offset = 0 === groupIndex ? options.skip || 0 : options.skips[groupIndex - 1] || 0;\n    }\n\n    if (groupIndex >= loadedGroupCount) {\n      return items.length;\n    }\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item) {\n        path.push(item.key);\n\n        if (!item.count && !item.items || void 0 === item.items) {\n          return -1;\n        }\n\n        updateGroupInfoItem(that, item, isLastGroupLevel, path, offset + i);\n        count = item.items ? updateGroupInfos(that, options, item.items, loadedGroupCount, groupIndex + 1, path, i) : item.count || -1;\n\n        if (count < 0) {\n          return -1;\n        }\n\n        totalCount += count;\n        path.pop();\n      }\n    }\n\n    return totalCount;\n  };\n\n  var isGroupExpanded = function (groups, groupIndex) {\n    return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded;\n  };\n\n  var getTotalOffset = function (groupInfos, pageSize, offset) {\n    var groupSize;\n    var totalOffset = offset;\n\n    for (var groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {\n      groupSize = groupInfos[groupIndex].offset + 1;\n\n      if (groupIndex > 0) {\n        groupSize += groupInfos[groupIndex - 1].childrenTotalCount;\n\n        if (pageSize) {\n          groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex;\n        }\n      }\n\n      totalOffset += groupSize;\n    }\n\n    return totalOffset;\n  };\n\n  function getContinuationGroupCount(groupOffset, pageSize, groupSize, groupIndex) {\n    groupIndex = groupIndex || 0;\n\n    if (pageSize > 1 && groupSize > 0) {\n      var pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;\n      pageOffset += groupSize - groupIndex - 2;\n\n      if (pageOffset < 0) {\n        pageOffset += pageSize;\n      }\n\n      return Math.floor(pageOffset / (pageSize - groupIndex - 1));\n    }\n\n    return 0;\n  }\n\n  function applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex) {\n    var item = expandedInfo.items[expandedItemIndex];\n    var skip = options.skips && options.skips[groupLevel];\n    var take = options.takes && options.takes[groupLevel];\n    var isLastExpandedItem = expandedItemIndex === expandedInfo.items.length - 1;\n    var isFirstExpandedItem = 0 === expandedItemIndex;\n    var lastExpandedItemSkip = isFirstExpandedItem && skip || 0;\n    var isItemsTruncatedByTake = item.count > take + lastExpandedItemSkip;\n\n    if (isFirstExpandedItem && void 0 !== skip) {\n      item.isContinuation = true;\n    }\n\n    if (isLastExpandedItem && void 0 !== take && isItemsTruncatedByTake) {\n      item.isContinuationOnNextPage = true;\n    }\n  }\n\n  function fillSkipTakeInExpandedInfo(options, expandedInfo, currentGroupCount) {\n    var currentGroupIndex = currentGroupCount - 1;\n    var groupCount = options.group ? options.group.length : 0;\n    expandedInfo.skip = options.skips && options.skips[currentGroupIndex];\n\n    if (options.takes && void 0 !== options.takes[currentGroupIndex]) {\n      if (groupCount === currentGroupCount) {\n        expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0;\n      } else {\n        expandedInfo.take = 0;\n      }\n\n      expandedInfo.take += options.takes[currentGroupIndex];\n    }\n  }\n\n  function isDataDeferred(data) {\n    return !Array.isArray(data);\n  }\n\n  function makeDataDeferred(options) {\n    if (!isDataDeferred(options.data)) {\n      options.data = new _deferred.Deferred();\n    }\n  }\n\n  function loadGroupItems(that, options, loadedGroupCount, expandedInfo, groupLevel, data) {\n    if (!options.isCustomLoading) {\n      expandedInfo = {};\n      processGroupItems(that, data, loadedGroupCount, expandedInfo, []);\n      fillSkipTakeInExpandedInfo(options, expandedInfo, loadedGroupCount);\n    }\n\n    var groupCount = options.group ? options.group.length : 0;\n\n    if (expandedInfo.paths.length && groupCount - loadedGroupCount > 0) {\n      makeDataDeferred(options);\n      loadExpandedGroups(that, options, expandedInfo, loadedGroupCount, groupLevel, data);\n    } else {\n      if (expandedInfo.paths.length && options.storeLoadOptions.group) {\n        makeDataDeferred(options);\n        loadLastLevelGroupItems(that, options, expandedInfo, data);\n      } else {\n        if (isDataDeferred(options.data)) {\n          options.data.resolve(data);\n        }\n      }\n    }\n  }\n\n  function loadExpandedGroups(that, options, expandedInfo, loadedGroupCount, groupLevel, data) {\n    var groups = options.group || [];\n    var currentGroup = groups[groupLevel + 1];\n    var deferreds = [];\n    (0, _iterator.each)(expandedInfo.paths, function (expandedItemIndex) {\n      var loadOptions = {\n        requireTotalCount: false,\n        requireGroupCount: true,\n        group: [currentGroup],\n        groupSummary: options.storeLoadOptions.groupSummary,\n        filter: (0, _uiData_grid2.createGroupFilter)(expandedInfo.paths[expandedItemIndex], {\n          filter: options.storeLoadOptions.filter,\n          group: groups\n        }),\n        select: options.storeLoadOptions.select\n      };\n\n      if (0 === expandedItemIndex) {\n        loadOptions.skip = expandedInfo.skip || 0;\n      }\n\n      if (expandedItemIndex === expandedInfo.paths.length - 1) {\n        loadOptions.take = expandedInfo.take;\n      }\n\n      var loadResult = 0 === loadOptions.take ? [] : that._dataSource.loadFromStore(loadOptions);\n      (0, _deferred.when)(loadResult).done(function (data) {\n        var item = expandedInfo.items[expandedItemIndex];\n        applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex);\n        item.items = data;\n      });\n      deferreds.push(loadResult);\n    });\n\n    _deferred.when.apply(null, deferreds).done(function () {\n      updateGroupInfos(that, options, data, loadedGroupCount + 1);\n      loadGroupItems(that, options, loadedGroupCount + 1, expandedInfo, groupLevel + 1, data);\n    });\n  }\n\n  function loadLastLevelGroupItems(that, options, expandedInfo, data) {\n    var expandedFilters = [];\n    var groups = options.group || [];\n    (0, _iterator.each)(expandedInfo.paths, function (_, expandedPath) {\n      expandedFilters.push((0, _uiData_grid2.createGroupFilter)(expandedPath, {\n        group: options.isCustomLoading ? options.storeLoadOptions.group : groups\n      }));\n    });\n    var filter = options.storeLoadOptions.filter;\n\n    if (!options.storeLoadOptions.isLoadingAll) {\n      filter = (0, _uiData_grid.combineFilters)([filter, (0, _uiData_grid.combineFilters)(expandedFilters, \"or\")]);\n    }\n\n    var loadOptions = (0, _extend.extend)({}, options.storeLoadOptions, {\n      requireTotalCount: false,\n      requireGroupCount: false,\n      group: null,\n      sort: groups.concat((0, _uiData_grid.normalizeSortingInfo)(options.storeLoadOptions.sort || [])),\n      filter: filter\n    });\n\n    var isPagingLocal = that._dataSource.isLastLevelGroupItemsPagingLocal();\n\n    if (!isPagingLocal) {\n      loadOptions.skip = expandedInfo.skip;\n      loadOptions.take = expandedInfo.take;\n    }\n\n    (0, _deferred.when)(0 === expandedInfo.take ? [] : that._dataSource.loadFromStore(loadOptions)).done(function (items, extra) {\n      if (isPagingLocal) {\n        items = that._dataSource.sortLastLevelGroupItems(items, groups, expandedInfo.paths);\n        items = expandedInfo.skip ? items.slice(expandedInfo.skip) : items;\n        items = expandedInfo.take ? items.slice(0, expandedInfo.take) : items;\n      }\n\n      (0, _iterator.each)(expandedInfo.items, function (index, item) {\n        var itemCount = item.count - (0 === index && expandedInfo.skip || 0);\n        var expandedItems = items.splice(0, itemCount);\n        applyContinuationToGroupItem(options, expandedInfo, groups.length - 1, index);\n        item.items = expandedItems;\n      });\n      options.data.resolve(data);\n    }).fail(options.data.reject);\n  }\n\n  var loadGroupTotalCount = function (dataSource, options) {\n    var d = new _deferred.Deferred();\n    var isGrouping = !!(options.group && options.group.length);\n    var loadOptions = (0, _extend.extend)({\n      skip: 0,\n      take: 1,\n      requireGroupCount: isGrouping,\n      requireTotalCount: !isGrouping\n    }, options, {\n      group: isGrouping ? options.group : null\n    });\n    dataSource.load(loadOptions).done(function (data, extra) {\n      var count = extra && (isGrouping ? extra.groupCount : extra.totalCount);\n\n      if (!isFinite(count)) {\n        d.reject(_errors.errors.Error(isGrouping ? \"E4022\" : \"E4021\"));\n        return;\n      }\n\n      d.resolve(count);\n    }).fail(d.reject.bind(d));\n    return d;\n  };\n\n  return {\n    updateTotalItemsCount: function (options) {\n      var totalItemsCount = 0;\n      var totalCount = options.extra && options.extra.totalCount || 0;\n      var groupCount = options.extra && options.extra.groupCount || 0;\n\n      var pageSize = this._dataSource.pageSize();\n\n      var isVirtualPaging = this._isVirtualPaging();\n\n      foreachExpandedGroups(this, function (groupInfo) {\n        groupInfo.childrenTotalCount = 0;\n      });\n      foreachExpandedGroups(this, function (groupInfo, parents) {\n        var totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount);\n        var count = groupInfo.count + groupInfo.childrenTotalCount;\n\n        if (!isVirtualPaging) {\n          count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);\n        }\n\n        if (parents[parents.length - 2]) {\n          parents[parents.length - 2].childrenTotalCount += count;\n        } else {\n          totalItemsCount += count;\n        }\n      });\n      this.callBase(totalItemsCount - totalCount + groupCount);\n    },\n    _isGroupExpanded: function (groupIndex) {\n      var groups = this._dataSource.group();\n\n      return isGroupExpanded(groups, groupIndex);\n    },\n    _updatePagingOptions: function (options, callback) {\n      var that = this;\n\n      var isVirtualPaging = that._isVirtualPaging();\n\n      var pageSize = that._dataSource.pageSize();\n\n      var skips = [];\n      var takes = [];\n      var skipChildrenTotalCount = 0;\n      var childrenTotalCount = 0;\n\n      if (options.take) {\n        foreachExpandedGroups(this, function (groupInfo) {\n          groupInfo.childrenTotalCount = 0;\n          groupInfo.skipChildrenTotalCount = 0;\n        });\n        foreachExpandedGroups(that, function (groupInfo, parents) {\n          var take;\n          var takeCorrection = 0;\n          var parentTakeCorrection = 0;\n          var totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount);\n          var continuationGroupCount = 0;\n          var skipContinuationGroupCount = 0;\n          var groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount;\n          var childrenGroupInfoCount = groupInfoCount;\n          callback && callback(groupInfo, totalOffset);\n          var skip = options.skip - totalOffset;\n\n          if (totalOffset <= options.skip + options.take && groupInfoCount) {\n            take = options.take;\n\n            if (!isVirtualPaging) {\n              continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);\n              groupInfoCount += continuationGroupCount * parents.length;\n              childrenGroupInfoCount += continuationGroupCount;\n\n              if (pageSize && skip >= 0) {\n                takeCorrection = parents.length;\n                parentTakeCorrection = parents.length - 1;\n                skipContinuationGroupCount = Math.floor(skip / pageSize);\n              }\n            }\n\n            if (skip >= 0) {\n              if (totalOffset + groupInfoCount > options.skip) {\n                skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);\n              }\n\n              if (totalOffset + groupInfoCount >= options.skip + take) {\n                takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount);\n              }\n            } else {\n              if (totalOffset + groupInfoCount >= options.skip + take) {\n                takes.unshift(take + skip - groupInfo.childrenTotalCount);\n              }\n            }\n          }\n\n          if (totalOffset <= options.skip) {\n            if (parents[parents.length - 2]) {\n              parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);\n            } else {\n              skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);\n            }\n          }\n\n          if (totalOffset <= options.skip + take) {\n            groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);\n\n            if (parents[parents.length - 2]) {\n              parents[parents.length - 2].childrenTotalCount += groupInfoCount;\n            } else {\n              childrenTotalCount += groupInfoCount;\n            }\n          }\n        });\n        options.skip -= skipChildrenTotalCount;\n        options.take -= childrenTotalCount - skipChildrenTotalCount;\n      }\n\n      options.skips = skips;\n      options.takes = takes;\n    },\n    changeRowExpand: function (path) {\n      var that = this;\n      var groupInfo = that.findGroupInfo(path);\n      var dataSource = that._dataSource;\n      var remoteGroupPaging = dataSource.remoteOperations().groupPaging;\n      var groups = (0, _uiData_grid.normalizeSortingInfo)(dataSource.group());\n\n      if (groupInfo) {\n        groupInfo.isExpanded = !groupInfo.isExpanded;\n\n        if (remoteGroupPaging && groupInfo.isExpanded && path.length < groups.length) {\n          return loadGroupTotalCount(dataSource, {\n            filter: (0, _uiData_grid2.createGroupFilter)(path, {\n              filter: dataSource.lastLoadOptions().filter,\n              group: dataSource.group()\n            }),\n            group: [groups[path.length]],\n            select: dataSource.select()\n          }).done(function (groupCount) {\n            groupInfo.count = groupCount;\n          });\n        }\n\n        return new _deferred.Deferred().resolve();\n      }\n\n      return new _deferred.Deferred().reject();\n    },\n    handleDataLoading: function (options) {\n      var that = this;\n      var storeLoadOptions = options.storeLoadOptions;\n      var groups = (0, _uiData_grid.normalizeSortingInfo)(storeLoadOptions.group || options.loadOptions.group);\n\n      if (options.isCustomLoading || !groups.length) {\n        return;\n      }\n\n      if (options.remoteOperations.grouping) {\n        var remotePaging = that._dataSource.remoteOperations().paging;\n\n        storeLoadOptions.group = (0, _uiData_grid.normalizeSortingInfo)(storeLoadOptions.group);\n        storeLoadOptions.group.forEach(function (group, index) {\n          var isLastGroup = index === storeLoadOptions.group.length - 1;\n          group.isExpanded = !remotePaging || !isLastGroup;\n        });\n      }\n\n      options.group = options.group || groups;\n\n      if (options.remoteOperations.paging) {\n        options.skip = storeLoadOptions.skip;\n        options.take = storeLoadOptions.take;\n        storeLoadOptions.requireGroupCount = true;\n        storeLoadOptions.group = groups.slice(0, 1);\n\n        that._updatePagingOptions(options);\n\n        storeLoadOptions.skip = options.skip;\n        storeLoadOptions.take = options.take;\n      } else {\n        that.foreachGroups(function (groupInfo) {\n          groupInfo.count = 0;\n        });\n      }\n    },\n    handleDataLoadedCore: function (options, callBase) {\n      var that = this;\n      var loadedGroupCount = (0, _uiData_grid.normalizeSortingInfo)(options.storeLoadOptions.group || options.loadOptions.group).length;\n      var groupCount = options.group ? options.group.length : 0;\n      var totalCount;\n      var expandedInfo = {};\n\n      if (options.isCustomLoading) {\n        callBase(options);\n        processGroupItems(that, options.data, loadedGroupCount, expandedInfo, [], options.isCustomLoading, options.storeLoadOptions.isLoadingAll);\n      } else {\n        totalCount = updateGroupInfos(that, options, options.data, loadedGroupCount);\n\n        if (totalCount < 0) {\n          options.data = new _deferred.Deferred().reject(_ui2.default.Error(\"E1037\"));\n          return;\n        }\n\n        if (!options.remoteOperations.paging) {\n          if (loadedGroupCount && options.extra && options.loadOptions.requireTotalCount) {\n            options.extra.totalCount = totalCount;\n            options.extra.groupCount = options.data.length;\n          }\n        }\n\n        if (groupCount && options.storeLoadOptions.requireGroupCount && !isFinite(options.extra.groupCount)) {\n          options.data = new _deferred.Deferred().reject(_errors.errors.Error(\"E4022\"));\n          return;\n        }\n\n        that.updateTotalItemsCount(options);\n\n        if (!options.remoteOperations.paging) {\n          that._updatePagingOptions(options);\n        }\n\n        callBase(options);\n\n        if (!options.remoteOperations.paging) {\n          that._processPaging(options, loadedGroupCount);\n        }\n      }\n\n      loadGroupItems(that, options, loadedGroupCount, expandedInfo, 0, options.data);\n    },\n    _processSkips: function (items, skips, groupCount) {\n      if (!groupCount) {\n        return;\n      }\n\n      var firstItem = items[0];\n      var skip = skips[0];\n      var children = firstItem && firstItem.items;\n\n      if (void 0 !== skip) {\n        firstItem.isContinuation = true;\n\n        if (children) {\n          firstItem.items = children.slice(skip);\n\n          this._processSkips(firstItem.items, skips.slice(1), groupCount - 1);\n        }\n      }\n    },\n    _processTakes: function (items, skips, takes, groupCount, parents) {\n      if (!groupCount || !items) {\n        return;\n      }\n\n      parents = parents || [];\n      var lastItem = items[items.length - 1];\n      var children = lastItem && lastItem.items;\n      var take = takes[0];\n      var skip = skips[0];\n\n      if (lastItem) {\n        var maxTakeCount = lastItem.count - (lastItem.isContinuation && skip || 0) || children.length;\n\n        if (void 0 !== take && maxTakeCount > take) {\n          lastItem.isContinuationOnNextPage = true;\n          parents.forEach(function (parent) {\n            parent.isContinuationOnNextPage = true;\n          });\n\n          if (children) {\n            children = children.slice(0, take);\n            lastItem.items = children;\n          }\n        }\n\n        parents.push(lastItem);\n\n        this._processTakes(children, skips.slice(1), takes.slice(1), groupCount - 1, parents);\n      }\n    },\n    _processPaging: function (options, groupCount) {\n      this._processSkips(options.data, options.skips, groupCount);\n\n      this._processTakes(options.data, options.skips, options.takes, groupCount);\n    },\n    isLastLevelGroupItemsPagingLocal: function () {\n      return false;\n    },\n    sortLastLevelGroupItems: function (items) {\n      return items;\n    },\n    refresh: function (options, isReload, operationTypes) {\n      var that = this;\n      var dataSource = that._dataSource;\n      var storeLoadOptions = options.storeLoadOptions;\n      var group = options.group || options.storeLoadOptions.group;\n      var oldGroups = (0, _uiData_grid.normalizeSortingInfo)(that._group);\n      var isExpanded;\n      var groupIndex;\n\n      function handleGroup(groupInfo, parents) {\n        if (parents.length === groupIndex + 1) {\n          groupInfo.isExpanded = isExpanded;\n        }\n      }\n\n      for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {\n        isExpanded = isGroupExpanded(group, groupIndex);\n\n        if (isGroupExpanded(that._group, groupIndex) !== isExpanded) {\n          that.foreachGroups(handleGroup);\n        }\n      }\n\n      that.callBase.apply(this, arguments);\n\n      if (group && options.remoteOperations.paging && (isReload || operationTypes.reload)) {\n        return foreachExpandedGroups(that, function (groupInfo) {\n          var groupCountQuery = loadGroupTotalCount(dataSource, {\n            filter: (0, _uiData_grid2.createGroupFilter)(groupInfo.path, {\n              filter: storeLoadOptions.filter,\n              group: group\n            }),\n            group: group.slice(groupInfo.path.length),\n            select: storeLoadOptions.select\n          });\n          var groupOffsetQuery = loadGroupTotalCount(dataSource, {\n            filter: (0, _uiData_gridGrouping.createOffsetFilter)(groupInfo.path, {\n              filter: storeLoadOptions.filter,\n              group: group\n            }),\n            group: group.slice(groupInfo.path.length - 1, groupInfo.path.length),\n            select: storeLoadOptions.select\n          });\n          return (0, _deferred.when)(groupOffsetQuery, groupCountQuery).done(function (offset, count) {\n            offset = parseInt(offset.length ? offset[0] : offset);\n            count = parseInt(count.length ? count[0] : count);\n            groupInfo.offset = offset;\n\n            if (groupInfo.count !== count) {\n              groupInfo.count = count;\n              that.updateTotalItemsCount(options);\n            }\n          });\n        }, true);\n      }\n    }\n  };\n}());","map":null,"metadata":{},"sourceType":"script"}