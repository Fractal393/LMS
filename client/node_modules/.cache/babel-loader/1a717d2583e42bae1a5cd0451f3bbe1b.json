{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.scrollable.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _events_engine = require(\"../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _support = require(\"../../core/utils/support\");\n\nvar _support2 = _interopRequireDefault(_support);\n\nvar _browser = require(\"../../core/utils/browser\");\n\nvar _browser2 = _interopRequireDefault(_browser);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _dom = require(\"../../core/utils/dom\");\n\nvar _window = require(\"../../core/utils/window\");\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _dom_adapter = require(\"../../core/dom_adapter\");\n\nvar _dom_adapter2 = _interopRequireDefault(_dom_adapter);\n\nvar _devices = require(\"../../core/devices\");\n\nvar _devices2 = _interopRequireDefault(_devices);\n\nvar _component_registrator = require(\"../../core/component_registrator\");\n\nvar _component_registrator2 = _interopRequireDefault(_component_registrator);\n\nvar _dom_component = require(\"../../core/dom_component\");\n\nvar _dom_component2 = _interopRequireDefault(_dom_component);\n\nvar _selectors = require(\"../widget/selectors\");\n\nvar _selectors2 = _interopRequireDefault(_selectors);\n\nvar _utils = require(\"../../events/utils\");\n\nvar eventUtils = _interopRequireWildcard(_utils);\n\nvar _uiEventsEmitterGesture = require(\"./ui.events.emitter.gesture.scroll\");\n\nvar _uiEventsEmitterGesture2 = _interopRequireDefault(_uiEventsEmitterGesture);\n\nvar _uiScrollable = require(\"./ui.scrollable.simulated\");\n\nvar _uiScrollable2 = _interopRequireDefault(_uiScrollable);\n\nvar _uiScrollable3 = require(\"./ui.scrollable.native\");\n\nvar _uiScrollable4 = _interopRequireDefault(_uiScrollable3);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _getRequireWildcardCache() {\n  if (\"function\" !== typeof WeakMap) {\n    return null;\n  }\n\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (null === obj || \"object\" !== _typeof(obj) && \"function\" !== typeof obj) {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar SCROLLABLE = \"dxScrollable\";\nvar SCROLLABLE_STRATEGY = \"dxScrollableStrategy\";\nvar SCROLLABLE_CLASS = \"dx-scrollable\";\nvar SCROLLABLE_DISABLED_CLASS = \"dx-scrollable-disabled\";\nvar SCROLLABLE_CONTAINER_CLASS = \"dx-scrollable-container\";\nvar SCROLLABLE_WRAPPER_CLASS = \"dx-scrollable-wrapper\";\nvar SCROLLABLE_CONTENT_CLASS = \"dx-scrollable-content\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar BOTH = \"both\";\n\nvar deviceDependentOptions = function () {\n  return [{\n    device: function () {\n      return !_support2.default.nativeScrolling;\n    },\n    options: {\n      useNative: false\n    }\n  }, {\n    device: function (_device) {\n      return !_devices2.default.isSimulator() && \"desktop\" === _devices2.default.real().deviceType && \"generic\" === _device.platform;\n    },\n    options: {\n      bounceEnabled: false,\n      scrollByThumb: true,\n      scrollByContent: _support2.default.touch,\n      showScrollbar: \"onHover\"\n    }\n  }];\n};\n\nvar Scrollable = _dom_component2.default.inherit({\n  _getDefaultOptions: function () {\n    return (0, _extend.extend)(this.callBase(), {\n      disabled: false,\n      onScroll: null,\n      direction: VERTICAL,\n      showScrollbar: \"onScroll\",\n      useNative: true,\n      bounceEnabled: true,\n      scrollByContent: true,\n      scrollByThumb: false,\n      onUpdated: null,\n      onStart: null,\n      onEnd: null,\n      onBounce: null,\n      onStop: null,\n      useSimulatedScrollbar: false,\n      useKeyboard: true,\n      inertiaEnabled: true,\n      pushBackValue: 0,\n      updateManually: false\n    });\n  },\n  _defaultOptionsRules: function () {\n    return this.callBase().concat(deviceDependentOptions(), [{\n      device: function () {\n        return _support2.default.nativeScrolling && \"android\" === _devices2.default.real().platform && !_browser2.default.mozilla;\n      },\n      options: {\n        useSimulatedScrollbar: true\n      }\n    }, {\n      device: function () {\n        return \"ios\" === _devices2.default.real().platform;\n      },\n      options: {\n        pushBackValue: 1\n      }\n    }]);\n  },\n  _initOptions: function (options) {\n    this.callBase(options);\n\n    if (!(\"useSimulatedScrollbar\" in options)) {\n      this._setUseSimulatedScrollbar();\n    }\n  },\n  _setUseSimulatedScrollbar: function () {\n    if (!this.initialOption(\"useSimulatedScrollbar\")) {\n      this.option(\"useSimulatedScrollbar\", !this.option(\"useNative\"));\n    }\n  },\n  _init: function () {\n    this.callBase();\n\n    this._initScrollableMarkup();\n\n    this._locked = false;\n  },\n  _visibilityChanged: function (visible) {\n    if (visible) {\n      this.update();\n\n      this._updateRtlPosition();\n\n      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);\n      delete this._savedScrollOffset;\n    } else {\n      this._savedScrollOffset = this.scrollOffset();\n    }\n  },\n  _initScrollableMarkup: function () {\n    var $element = this.$element().addClass(SCROLLABLE_CLASS);\n    var $container = this._$container = (0, _renderer2.default)(\"<div>\").addClass(SCROLLABLE_CONTAINER_CLASS);\n    var $wrapper = this._$wrapper = (0, _renderer2.default)(\"<div>\").addClass(SCROLLABLE_WRAPPER_CLASS);\n    var $content = this._$content = (0, _renderer2.default)(\"<div>\").addClass(SCROLLABLE_CONTENT_CLASS);\n\n    if (_dom_adapter2.default.hasDocumentProperty(\"onbeforeactivate\") && _browser2.default.msie && _browser2.default.version < 12) {\n      _events_engine2.default.on($element, eventUtils.addNamespace(\"beforeactivate\", SCROLLABLE), function (e) {\n        if (!(0, _renderer2.default)(e.target).is(_selectors2.default.focusable)) {\n          e.preventDefault();\n        }\n      });\n    }\n\n    $content.append($element.contents()).appendTo($container);\n    $container.appendTo($wrapper);\n    $wrapper.appendTo($element);\n  },\n  _dimensionChanged: function () {\n    this.update();\n  },\n  _initMarkup: function () {\n    this.callBase();\n\n    this._renderDirection();\n  },\n  _render: function () {\n    this._renderStrategy();\n\n    this._attachEventHandlers();\n\n    this._renderDisabledState();\n\n    this._createActions();\n\n    this.update();\n    this.callBase();\n\n    this._updateRtlPosition();\n  },\n  _updateRtlPosition: function () {\n    var _this = this;\n\n    this._updateBounds();\n\n    if (this.option(\"rtlEnabled\") && this.option(\"direction\") !== VERTICAL) {\n      _common2.default.deferUpdate(function () {\n        var containerElement = _this._container().get(0);\n\n        var maxLeftOffset = containerElement.scrollWidth - containerElement.clientWidth;\n\n        _common2.default.deferRender(function () {\n          _this.scrollTo({\n            left: maxLeftOffset\n          });\n        });\n      });\n    }\n  },\n  _updateBounds: function () {\n    this._strategy.updateBounds();\n  },\n  _attachEventHandlers: function () {\n    var strategy = this._strategy;\n    var initEventData = {\n      getDirection: strategy.getDirection.bind(strategy),\n      validate: this._validate.bind(this),\n      isNative: this.option(\"useNative\"),\n      scrollTarget: this._$container\n    };\n\n    _events_engine2.default.off(this._$wrapper, \".\" + SCROLLABLE);\n\n    _events_engine2.default.on(this._$wrapper, eventUtils.addNamespace(_uiEventsEmitterGesture2.default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));\n\n    _events_engine2.default.on(this._$wrapper, eventUtils.addNamespace(_uiEventsEmitterGesture2.default.start, SCROLLABLE), strategy.handleStart.bind(strategy));\n\n    _events_engine2.default.on(this._$wrapper, eventUtils.addNamespace(_uiEventsEmitterGesture2.default.move, SCROLLABLE), strategy.handleMove.bind(strategy));\n\n    _events_engine2.default.on(this._$wrapper, eventUtils.addNamespace(_uiEventsEmitterGesture2.default.end, SCROLLABLE), strategy.handleEnd.bind(strategy));\n\n    _events_engine2.default.on(this._$wrapper, eventUtils.addNamespace(_uiEventsEmitterGesture2.default.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy));\n\n    _events_engine2.default.on(this._$wrapper, eventUtils.addNamespace(_uiEventsEmitterGesture2.default.stop, SCROLLABLE), strategy.handleStop.bind(strategy));\n\n    _events_engine2.default.off(this._$container, \".\" + SCROLLABLE);\n\n    _events_engine2.default.on(this._$container, eventUtils.addNamespace(\"scroll\", SCROLLABLE), strategy.handleScroll.bind(strategy));\n  },\n  _validate: function (e) {\n    if (this._isLocked()) {\n      return false;\n    }\n\n    this._updateIfNeed();\n\n    return this._strategy.validate(e);\n  },\n  _initHandler: function () {\n    var strategy = this._strategy;\n    strategy.handleInit.apply(strategy, arguments);\n  },\n  _renderDisabledState: function () {\n    this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option(\"disabled\"));\n\n    if (this.option(\"disabled\")) {\n      this._lock();\n    } else {\n      this._unlock();\n    }\n  },\n  _renderDirection: function () {\n    this.$element().removeClass(\"dx-scrollable-\" + HORIZONTAL).removeClass(\"dx-scrollable-\" + VERTICAL).removeClass(\"dx-scrollable-\" + BOTH).addClass(\"dx-scrollable-\" + this.option(\"direction\"));\n  },\n  _renderStrategy: function () {\n    this._createStrategy();\n\n    this._strategy.render();\n\n    this.$element().data(SCROLLABLE_STRATEGY, this._strategy);\n  },\n  _createStrategy: function () {\n    this._strategy = this.option(\"useNative\") ? new _uiScrollable4.default(this) : new _uiScrollable2.default.SimulatedStrategy(this);\n  },\n  _createActions: function () {\n    this._strategy && this._strategy.createActions();\n  },\n  _clean: function () {\n    this._strategy && this._strategy.dispose();\n  },\n  _optionChanged: function (args) {\n    switch (args.name) {\n      case \"onStart\":\n      case \"onEnd\":\n      case \"onStop\":\n      case \"onUpdated\":\n      case \"onScroll\":\n      case \"onBounce\":\n        this._createActions();\n\n        break;\n\n      case \"direction\":\n        this._resetInactiveDirection();\n\n        this._invalidate();\n\n        break;\n\n      case \"useNative\":\n        this._setUseSimulatedScrollbar();\n\n        this._invalidate();\n\n        break;\n\n      case \"inertiaEnabled\":\n      case \"scrollByContent\":\n      case \"scrollByThumb\":\n      case \"bounceEnabled\":\n      case \"useKeyboard\":\n      case \"showScrollbar\":\n      case \"useSimulatedScrollbar\":\n      case \"pushBackValue\":\n        this._invalidate();\n\n        break;\n\n      case \"disabled\":\n        this._renderDisabledState();\n\n        this._strategy && this._strategy.disabledChanged();\n        break;\n\n      case \"updateManually\":\n        break;\n\n      case \"width\":\n        this.callBase(args);\n\n        this._updateRtlPosition();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _resetInactiveDirection: function () {\n    var inactiveProp = this._getInactiveProp();\n\n    if (!inactiveProp || !_window2.default.hasWindow()) {\n      return;\n    }\n\n    var scrollOffset = this.scrollOffset();\n    scrollOffset[inactiveProp] = 0;\n    this.scrollTo(scrollOffset);\n  },\n  _getInactiveProp: function () {\n    var direction = this.option(\"direction\");\n\n    if (direction === VERTICAL) {\n      return \"left\";\n    }\n\n    if (direction === HORIZONTAL) {\n      return \"top\";\n    }\n  },\n  _location: function () {\n    return this._strategy.location();\n  },\n  _normalizeLocation: function (location) {\n    if (_type2.default.isPlainObject(location)) {\n      var left = _common2.default.ensureDefined(location.left, location.x);\n\n      var top = _common2.default.ensureDefined(location.top, location.y);\n\n      return {\n        left: _type2.default.isDefined(left) ? -left : void 0,\n        top: _type2.default.isDefined(top) ? -top : void 0\n      };\n    } else {\n      var direction = this.option(\"direction\");\n      return {\n        left: direction !== VERTICAL ? -location : void 0,\n        top: direction !== HORIZONTAL ? -location : void 0\n      };\n    }\n  },\n  _isLocked: function () {\n    return this._locked;\n  },\n  _lock: function () {\n    this._locked = true;\n  },\n  _unlock: function () {\n    if (!this.option(\"disabled\")) {\n      this._locked = false;\n    }\n  },\n  _isDirection: function (direction) {\n    var current = this.option(\"direction\");\n\n    if (direction === VERTICAL) {\n      return current !== HORIZONTAL;\n    }\n\n    if (direction === HORIZONTAL) {\n      return current !== VERTICAL;\n    }\n\n    return current === direction;\n  },\n  _updateAllowedDirection: function () {\n    var allowedDirections = this._strategy._allowedDirections();\n\n    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {\n      this._allowedDirectionValue = BOTH;\n    } else {\n      if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {\n        this._allowedDirectionValue = HORIZONTAL;\n      } else {\n        if (this._isDirection(VERTICAL) && allowedDirections.vertical) {\n          this._allowedDirectionValue = VERTICAL;\n        } else {\n          this._allowedDirectionValue = null;\n        }\n      }\n    }\n  },\n  _allowedDirection: function () {\n    return this._allowedDirectionValue;\n  },\n  _container: function () {\n    return this._$container;\n  },\n  $content: function () {\n    return this._$content;\n  },\n  content: function () {\n    return (0, _dom.getPublicElement)(this._$content);\n  },\n  scrollOffset: function () {\n    var location = this._location();\n\n    return {\n      top: -location.top,\n      left: -location.left\n    };\n  },\n  scrollTop: function () {\n    return this.scrollOffset().top;\n  },\n  scrollLeft: function () {\n    return this.scrollOffset().left;\n  },\n  clientHeight: function () {\n    return this._$container.height();\n  },\n  scrollHeight: function () {\n    return this.$content().outerHeight() - 2 * this._strategy.verticalOffset();\n  },\n  clientWidth: function () {\n    return this._$container.width();\n  },\n  scrollWidth: function () {\n    return this.$content().outerWidth();\n  },\n  update: function () {\n    if (!this._strategy) {\n      return;\n    }\n\n    return (0, _deferred.when)(this._strategy.update()).done(function () {\n      this._updateAllowedDirection();\n    }.bind(this));\n  },\n  scrollBy: function (distance) {\n    distance = this._normalizeLocation(distance);\n\n    if (!distance.top && !distance.left) {\n      return;\n    }\n\n    this._updateIfNeed();\n\n    this._strategy.scrollBy(distance);\n  },\n  scrollTo: function (targetLocation) {\n    targetLocation = this._normalizeLocation(targetLocation);\n\n    this._updateIfNeed();\n\n    var location = this._location();\n\n    if (!this.option(\"useNative\")) {\n      targetLocation = this._strategy._applyScaleRatio(targetLocation);\n      location = this._strategy._applyScaleRatio(location);\n    }\n\n    var distance = this._normalizeLocation({\n      left: location.left - _common2.default.ensureDefined(targetLocation.left, location.left),\n      top: location.top - _common2.default.ensureDefined(targetLocation.top, location.top)\n    });\n\n    if (!distance.top && !distance.left) {\n      return;\n    }\n\n    this._strategy.scrollBy(distance);\n  },\n  scrollToElement: function (element, offset) {\n    var $element = (0, _renderer2.default)(element);\n    var elementInsideContent = this.$content().find(element).length;\n    var elementIsInsideContent = $element.parents(\".\" + SCROLLABLE_CLASS).length - $element.parents(\".\" + SCROLLABLE_CONTENT_CLASS).length === 0;\n\n    if (!elementInsideContent || !elementIsInsideContent) {\n      return;\n    }\n\n    var scrollPosition = {\n      top: 0,\n      left: 0\n    };\n    var direction = this.option(\"direction\");\n\n    if (direction !== VERTICAL) {\n      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL, offset);\n    }\n\n    if (direction !== HORIZONTAL) {\n      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL, offset);\n    }\n\n    this.scrollTo(scrollPosition);\n  },\n  scrollToElementTopLeft: function (element) {\n    var $element = (0, _renderer2.default)(element);\n    var elementInsideContent = this.$content().find(element).length;\n    var elementIsInsideContent = $element.parents(\".\" + SCROLLABLE_CLASS).length - $element.parents(\".\" + SCROLLABLE_CONTENT_CLASS).length === 0;\n\n    if (!elementInsideContent || !elementIsInsideContent) {\n      return;\n    }\n\n    var scrollPosition = {\n      top: 0,\n      left: 0\n    };\n    var direction = this.option(\"direction\");\n\n    if (direction !== VERTICAL) {\n      var leftPosition = this._elementPositionRelativeToContent($element, \"left\");\n\n      scrollPosition.left = true === this.option(\"rtlEnabled\") ? leftPosition + $element.width() - this.clientWidth() : leftPosition;\n    }\n\n    if (direction !== HORIZONTAL) {\n      scrollPosition.top = this._elementPositionRelativeToContent($element, \"top\");\n    }\n\n    this.scrollTo(scrollPosition);\n  },\n  getScrollElementPosition: function ($element, direction, offset) {\n    offset = offset || {};\n    var isVertical = direction === VERTICAL;\n    var startOffset = (isVertical ? offset.top : offset.left) || 0;\n    var endOffset = (isVertical ? offset.bottom : offset.right) || 0;\n    var pushBackOffset = isVertical ? this._strategy.verticalOffset() : 0;\n\n    var elementPositionRelativeToContent = this._elementPositionRelativeToContent($element, isVertical ? \"top\" : \"left\");\n\n    var elementPosition = elementPositionRelativeToContent - pushBackOffset;\n    var elementSize = $element[isVertical ? \"outerHeight\" : \"outerWidth\"]();\n    var scrollLocation = isVertical ? this.scrollTop() : this.scrollLeft();\n    var clientSize = isVertical ? this.clientHeight() : this.clientWidth();\n    var startDistance = scrollLocation - elementPosition + startOffset;\n    var endDistance = scrollLocation - elementPosition - elementSize + clientSize - endOffset;\n\n    if (startDistance <= 0 && endDistance >= 0) {\n      return scrollLocation;\n    }\n\n    return scrollLocation - (Math.abs(startDistance) > Math.abs(endDistance) ? endDistance : startDistance);\n  },\n  _elementPositionRelativeToContent: function ($element, prop) {\n    var result = 0;\n\n    while (this._hasScrollContent($element)) {\n      result += $element.position()[prop];\n      $element = $element.offsetParent();\n    }\n\n    return result;\n  },\n  _hasScrollContent: function ($element) {\n    var $content = this.$content();\n    return $element.closest($content).length && !$element.is($content);\n  },\n  _updateIfNeed: function () {\n    if (!this.option(\"updateManually\")) {\n      this.update();\n    }\n  },\n  _useTemplates: function () {\n    return false;\n  }\n});\n\n(0, _component_registrator2.default)(SCROLLABLE, Scrollable);\nmodule.exports = Scrollable;\nmodule.exports.deviceDependentOptions = deviceDependentOptions;","map":null,"metadata":{},"sourceType":"script"}