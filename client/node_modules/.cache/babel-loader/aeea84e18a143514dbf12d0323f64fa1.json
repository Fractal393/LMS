{"ast":null,"code":"/**\n * StringTokenizer.ts class for EJ2-PDF\n * Utility class for working with strings.\n * @private\n */\nvar StringTokenizer =\n/** @class */\nfunction () {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `StringTokenizer` class.\n   * @private\n   */\n  function StringTokenizer(textValue) {\n    /**\n     * Current `position`.\n     * @private\n     */\n    this.currentPosition = 0;\n\n    if (textValue == null) {\n      throw new Error('ArgumentNullException:text');\n    }\n\n    this.text = textValue;\n  }\n\n  Object.defineProperty(StringTokenizer.prototype, \"length\", {\n    // Properties\n\n    /**\n     * Gets text `length`.\n     * @private\n     */\n    get: function () {\n      return this.text.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StringTokenizer.prototype, \"end\", {\n    get: function () {\n      return this.currentPosition === this.text.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StringTokenizer.prototype, \"position\", {\n    /**\n     * Gets or sets the position.\n     * @private\n     */\n    get: function () {\n      return this.currentPosition;\n    },\n    set: function (value) {\n      this.currentPosition = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StringTokenizer.getCharsCount = function (text, symbols) {\n    if (typeof symbols === 'string') {\n      if (text == null) {\n        throw new Error('ArgumentNullException:wholeText');\n      }\n\n      var numSymbols = 0;\n      var curIndex = 0;\n\n      for (;;) {\n        curIndex = text.indexOf(symbols, curIndex);\n\n        if (curIndex === -1) {\n          break;\n        } else {\n          numSymbols++;\n          curIndex++;\n        }\n      }\n\n      return numSymbols;\n    } else {\n      if (text == null) {\n        throw new Error('ArgumentNullException:text');\n      }\n\n      if (symbols == null) {\n        throw new Error('ArgumentNullException:symbols');\n      }\n\n      var count = 0;\n\n      for (var i = 0, len = text.length; i < len; i++) {\n        var ch = text[i];\n\n        if (this.contains(symbols, ch)) {\n          count++;\n        }\n      }\n\n      return count;\n    }\n  };\n  /**\n   * Reads line of the text.\n   * @private\n   */\n\n\n  StringTokenizer.prototype.readLine = function () {\n    var pos = this.currentPosition;\n\n    while (pos < this.length) {\n      var ch = this.text[pos];\n\n      switch (ch) {\n        case '\\r':\n        case '\\n':\n          {\n            var text = this.text.substring(this.currentPosition, pos - this.currentPosition);\n            this.currentPosition = pos + 1;\n\n            if (ch === '\\r' && this.currentPosition < this.length && this.text[this.currentPosition] === '\\n') {\n              this.currentPosition++;\n            }\n\n            return text;\n          }\n      }\n\n      pos++;\n    } // The remaining text.\n\n\n    if (pos > this.currentPosition) {\n      var text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);\n      this.currentPosition = pos;\n      return text2;\n    }\n\n    return null;\n  };\n  /**\n   * Reads line of the text.\n   * @private\n   */\n\n\n  StringTokenizer.prototype.peekLine = function () {\n    var pos = this.currentPosition;\n    var line = this.readLine();\n    this.currentPosition = pos;\n    return line;\n  };\n  /**\n   * Reads a word from the text.\n   * @private\n   */\n\n\n  StringTokenizer.prototype.readWord = function () {\n    var pos = this.currentPosition;\n\n    while (pos < this.length) {\n      var ch = this.text[pos];\n\n      switch (ch) {\n        case '\\r':\n        case '\\n':\n          var textValue = this.text.substr(this.currentPosition, pos - this.currentPosition);\n          this.currentPosition = pos + 1;\n\n          if (ch === '\\r' && this.currentPosition < this.length && this.text[this.currentPosition] === '\\n') {\n            this.currentPosition++;\n          }\n\n          return textValue;\n\n        case ' ':\n        case '\\t':\n          {\n            if (pos === this.currentPosition) {\n              pos++;\n            }\n\n            var text = this.text.substr(this.currentPosition, pos - this.currentPosition);\n            this.currentPosition = pos;\n            return text;\n          }\n      }\n\n      pos++;\n    } // The remaining text.\n\n\n    if (pos > this.currentPosition) {\n      var text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);\n      this.currentPosition = pos;\n      return text2;\n    }\n\n    return null;\n  };\n  /**\n   * Peeks a word from the text.\n   * @private\n   */\n\n\n  StringTokenizer.prototype.peekWord = function () {\n    var pos = this.currentPosition;\n    var word = this.readWord();\n    this.currentPosition = pos;\n    return word;\n  };\n\n  StringTokenizer.prototype.read = function (count) {\n    if (typeof count === 'undefined') {\n      var ch = '0';\n\n      if (!this.end) {\n        ch = this.text[this.currentPosition];\n        this.currentPosition++;\n      }\n\n      return ch;\n    } else {\n      var num = 0;\n      var builder = '';\n\n      while (!this.end && num < count) {\n        var ch = this.read();\n        builder = builder + ch;\n        num++;\n      }\n\n      return builder;\n    }\n  };\n  /**\n   * Peeks char form the data.\n   * @private\n   */\n\n\n  StringTokenizer.prototype.peek = function () {\n    var ch = '0';\n\n    if (!this.end) {\n      ch = this.text[this.currentPosition];\n    }\n\n    return ch;\n  };\n  /**\n   * Closes a reader.\n   * @private\n   */\n\n\n  StringTokenizer.prototype.close = function () {\n    this.text = null;\n  };\n\n  StringTokenizer.prototype.readToEnd = function () {\n    var text;\n\n    if (this.currentPosition === 0) {\n      text = this.text;\n    } else {\n      text = this.text.substring(this.length, this.currentPosition);\n    }\n\n    this.currentPosition = this.length;\n    return text;\n  }; //Implementation\n\n  /**\n   * Checks whether array contains a symbol.\n   * @private\n   */\n\n\n  StringTokenizer.contains = function (array, symbol) {\n    var contains = false;\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === symbol) {\n        contains = true;\n        break;\n      }\n    }\n\n    return contains;\n  }; // Constants\n\n  /**\n   * `Whitespace` symbol.\n   * @private\n   */\n\n\n  StringTokenizer.whiteSpace = ' ';\n  /**\n   * `tab` symbol.\n   * @private\n   */\n\n  StringTokenizer.tab = '\\t';\n  /**\n   * Array of `spaces`.\n   * @private\n   */\n\n  StringTokenizer.spaces = [StringTokenizer.whiteSpace, StringTokenizer.tab];\n  /**\n   * `Pattern` for WhiteSpace.\n   * @private\n   */\n\n  StringTokenizer.whiteSpacePattern = '^[ \\t]+$';\n  return StringTokenizer;\n}();\n\nexport { StringTokenizer };","map":null,"metadata":{},"sourceType":"module"}