{"ast":null,"code":"import { EventHandler, Browser } from '@syncfusion/ej2-base';\nimport { debounce } from '@syncfusion/ej2-base';\n/**\n * InterSectionObserver - class watch whether it enters the viewport.\n * @hidden\n */\n\nvar InterSectionObserver =\n/** @class */\nfunction () {\n  function InterSectionObserver(element, options) {\n    var _this = this;\n\n    this.fromWheel = false;\n    this.touchMove = false;\n    this.options = {};\n    this.sentinelInfo = {\n      'up': {\n        check: function (rect, info) {\n          var top = rect.top - _this.containerRect.top;\n          info.entered = top >= 0;\n          return top + _this.options.pageHeight / 2 >= 0;\n        },\n        axis: 'Y'\n      },\n      'down': {\n        check: function (rect, info) {\n          var cHeight = _this.options.container.clientHeight;\n          var top = rect.bottom;\n          info.entered = rect.bottom <= _this.containerRect.bottom;\n          return top - _this.options.pageHeight / 2 <= _this.options.pageHeight / 2;\n        },\n        axis: 'Y'\n      },\n      'right': {\n        check: function (rect, info) {\n          var right = rect.right;\n          info.entered = right < _this.containerRect.right;\n          return right - _this.containerRect.width <= _this.containerRect.right;\n        },\n        axis: 'X'\n      },\n      'left': {\n        check: function (rect, info) {\n          var left = rect.left;\n          info.entered = left > 0;\n          return left + _this.containerRect.width >= _this.containerRect.left;\n        },\n        axis: 'X'\n      }\n    };\n    this.element = element;\n    this.options = options;\n  }\n\n  InterSectionObserver.prototype.observe = function (callback, onEnterCallback) {\n    var _this = this;\n\n    this.containerRect = this.options.container.getBoundingClientRect();\n    EventHandler.add(this.options.container, 'wheel', function () {\n      return _this.fromWheel = true;\n    }, this);\n    EventHandler.add(this.options.container, 'scroll', this.virtualScrollHandler(callback, onEnterCallback), this);\n  };\n\n  InterSectionObserver.prototype.check = function (direction) {\n    var info = this.sentinelInfo[direction];\n    return info.check(this.element.getBoundingClientRect(), info);\n  };\n\n  InterSectionObserver.prototype.virtualScrollHandler = function (callback, onEnterCallback) {\n    var _this = this;\n\n    var delay = Browser.info.name === 'chrome' ? 200 : 100;\n    var prevTop = 0;\n    var prevLeft = 0;\n    var debounced100 = debounce(callback, delay);\n    var debounced50 = debounce(callback, 50);\n    return function (e) {\n      var top = e.target.scrollTop;\n      var left = e.target.scrollLeft;\n      var direction = prevTop < top ? 'down' : 'up';\n      direction = prevLeft === left ? direction : prevLeft < left ? 'right' : 'left';\n      prevTop = top;\n      prevLeft = left;\n      var current = _this.sentinelInfo[direction];\n\n      if (_this.options.axes.indexOf(current.axis) === -1) {\n        return;\n      }\n\n      var check = _this.check(direction);\n\n      if (current.entered) {\n        onEnterCallback(_this.element, current, direction, {\n          top: top,\n          left: left\n        }, _this.fromWheel, check);\n      }\n\n      if (check) {\n        var fn = debounced100; //this.fromWheel ? this.options.debounceEvent ? debounced100 : callback : debounced100;\n\n        if (current.axis === 'X') {\n          fn = debounced50;\n        }\n\n        fn({\n          direction: direction,\n          sentinel: current,\n          offset: {\n            top: top,\n            left: left\n          },\n          focusElement: document.activeElement\n        });\n      }\n\n      _this.fromWheel = false;\n    };\n  };\n\n  InterSectionObserver.prototype.setPageHeight = function (value) {\n    this.options.pageHeight = value;\n  };\n\n  return InterSectionObserver;\n}();\n\nexport { InterSectionObserver };","map":null,"metadata":{},"sourceType":"module"}