{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Touch, Component, EventHandler, selectAll, getUniqueID } from '@syncfusion/ej2-base';\nimport { NotifyPropertyChanges, Property, Browser, detach } from '@syncfusion/ej2-base';\nimport { classList, isNullOrUndefined } from '@syncfusion/ej2-base';\nvar CLS_ROOT = 'e-hscroll';\nvar CLS_RTL = 'e-rtl';\nvar CLS_DISABLE = 'e-overlay';\nvar CLS_HSCROLLBAR = 'e-hscroll-bar';\nvar CLS_HSCROLLCON = 'e-hscroll-content';\nvar CLS_NAVARROW = 'e-nav-arrow';\nvar CLS_NAVRIGHTARROW = 'e-nav-right-arrow';\nvar CLS_NAVLEFTARROW = 'e-nav-left-arrow';\nvar CLS_HSCROLLNAV = 'e-scroll-nav';\nvar CLS_HSCROLLNAVRIGHT = 'e-scroll-right-nav';\nvar CLS_HSCROLLNAVLEFT = 'e-scroll-left-nav';\nvar CLS_DEVICE = 'e-scroll-device';\nvar CLS_OVERLAY = 'e-scroll-overlay';\nvar CLS_RIGHTOVERLAY = 'e-scroll-right-overlay';\nvar CLS_LEFTOVERLAY = 'e-scroll-left-overlay';\nvar OVERLAY_MAXWID = 40;\n/**\n * HScroll module is introduces horizontal scroller when content exceeds the current viewing area.\n * It can be useful for the components like Toolbar, Tab which needs horizontal scrolling alone.\n * Hidden content can be view by touch moving or icon click.\n * ```html\n * <div id=\"scroll\"/>\n * <script>\n *   var scrollObj = new HScroll();\n *   scrollObj.appendTo(\"#scroll\");\n * </script>\n * ```\n */\n\nvar HScroll =\n/** @class */\nfunction (_super) {\n  __extends(HScroll, _super);\n  /**\n   * Initializes a new instance of the HScroll class.\n   * @param options  - Specifies HScroll model properties as options.\n   * @param element  - Specifies the element for which horizontal scrolling applies.\n   */\n\n\n  function HScroll(options, element) {\n    return _super.call(this, options, element) || this;\n  }\n  /**\n   * Initialize the event handler\n   * @private\n   */\n\n\n  HScroll.prototype.preRender = function () {\n    this.browser = Browser.info.name;\n    this.browserCheck = this.browser === 'mozilla';\n    this.isDevice = Browser.isDevice;\n    this.customStep = true;\n    var element = this.element;\n    this.ieCheck = this.browser === 'edge' || this.browser === 'msie';\n    this.initialize();\n\n    if (element.id === '') {\n      element.id = getUniqueID('hscroll');\n      this.uniqueId = true;\n    }\n\n    element.style.display = 'block';\n\n    if (this.enableRtl) {\n      element.classList.add(CLS_RTL);\n    }\n  };\n  /**\n   * To Initialize the horizontal scroll  rendering\n   * @private\n   */\n\n\n  HScroll.prototype.render = function () {\n    this.touchModule = new Touch(this.element, {\n      scroll: this.touchHandler.bind(this),\n      swipe: this.swipeHandler.bind(this)\n    });\n    EventHandler.add(this.scrollEle, 'scroll', this.scrollHandler, this);\n\n    if (!this.isDevice) {\n      this.createNavIcon(this.element);\n    } else {\n      this.element.classList.add(CLS_DEVICE);\n      this.createOverlay(this.element);\n    }\n\n    this.setScrollState();\n  };\n\n  HScroll.prototype.setScrollState = function () {\n    if (isNullOrUndefined(this.scrollStep) || this.scrollStep < 0) {\n      this.scrollStep = this.scrollEle.offsetWidth;\n      this.customStep = false;\n    } else {\n      this.customStep = true;\n    }\n  };\n\n  HScroll.prototype.initialize = function () {\n    var scrollEle = this.createElement('div', {\n      className: CLS_HSCROLLCON\n    });\n    var scrollDiv = this.createElement('div', {\n      className: CLS_HSCROLLBAR\n    });\n    scrollDiv.setAttribute('tabindex', '-1');\n    var ele = this.element;\n    var innerEle = [].slice.call(ele.children);\n\n    for (var _i = 0, innerEle_1 = innerEle; _i < innerEle_1.length; _i++) {\n      var ele_1 = innerEle_1[_i];\n      scrollEle.appendChild(ele_1);\n    }\n\n    scrollDiv.appendChild(scrollEle);\n    ele.appendChild(scrollDiv);\n    scrollDiv.style.overflowX = 'hidden';\n    this.scrollEle = scrollDiv;\n    this.scrollItems = scrollEle;\n  };\n\n  HScroll.prototype.getPersistData = function () {\n    var keyEntity = ['scrollStep'];\n    return this.addOnPersist(keyEntity);\n  };\n  /**\n   * Returns the current module name.\n   * @returns string\n   * @private\n   */\n\n\n  HScroll.prototype.getModuleName = function () {\n    return 'hScroll';\n  };\n  /**\n   * Removes the control from the DOM and also removes all its related events.\n   * @returns void\n   */\n\n\n  HScroll.prototype.destroy = function () {\n    var ele = this.element;\n    ele.style.display = '';\n    ele.classList.remove(CLS_ROOT);\n    ele.classList.remove(CLS_DEVICE);\n    var nav = selectAll('.e-' + ele.id + '_nav.' + CLS_HSCROLLNAV, ele);\n    var overlay = selectAll('.' + CLS_OVERLAY, ele);\n    [].slice.call(overlay).forEach(function (ele) {\n      detach(ele);\n    });\n\n    for (var _i = 0, _a = [].slice.call(this.scrollItems.children); _i < _a.length; _i++) {\n      var elem = _a[_i];\n      ele.appendChild(elem);\n    }\n\n    if (this.uniqueId) {\n      this.element.removeAttribute('id');\n    }\n\n    detach(this.scrollEle);\n\n    if (nav.length > 0) {\n      detach(nav[0]);\n\n      if (!isNullOrUndefined(nav[1])) {\n        detach(nav[1]);\n      }\n    }\n\n    EventHandler.remove(this.scrollEle, 'scroll', this.scrollHandler);\n    this.touchModule.destroy();\n    this.touchModule = null;\n\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * Specifies the value to disable/enable the HScroll component.\n   * When set to `true` , the component will be disabled.\n   * @param  {boolean} value - Based on this Boolean value, HScroll will be enabled (false) or disabled (true).\n   * @returns void.\n   */\n\n\n  HScroll.prototype.disable = function (value) {\n    var navEles = selectAll('.e-scroll-nav:not(.' + CLS_DISABLE + ')', this.element);\n    value ? this.element.classList.add(CLS_DISABLE) : this.element.classList.remove(CLS_DISABLE);\n    [].slice.call(navEles).forEach(function (el) {\n      el.setAttribute('tabindex', !value ? '0' : '-1');\n    });\n  };\n\n  HScroll.prototype.createOverlay = function (element) {\n    var id = element.id.concat('_nav');\n    var rightOverlayEle = this.createElement('div', {\n      className: CLS_OVERLAY + ' ' + CLS_RIGHTOVERLAY\n    });\n    var clsRight = 'e-' + element.id.concat('_nav ' + CLS_HSCROLLNAV + ' ' + CLS_HSCROLLNAVRIGHT);\n    var rightEle = this.createElement('div', {\n      id: id.concat('_right'),\n      className: clsRight\n    });\n    var navItem = this.createElement('div', {\n      className: CLS_NAVRIGHTARROW + ' ' + CLS_NAVARROW + ' e-icons'\n    });\n    rightEle.appendChild(navItem);\n    var leftEle = this.createElement('div', {\n      className: CLS_OVERLAY + ' ' + CLS_LEFTOVERLAY\n    });\n\n    if (this.ieCheck) {\n      rightEle.classList.add('e-ie-align');\n    }\n\n    element.appendChild(rightOverlayEle);\n    element.appendChild(rightEle);\n    element.insertBefore(leftEle, element.firstChild);\n    this.eventBinding([rightEle]);\n  };\n\n  HScroll.prototype.createNavIcon = function (element) {\n    var id = element.id.concat('_nav');\n    var clsRight = 'e-' + element.id.concat('_nav ' + CLS_HSCROLLNAV + ' ' + CLS_HSCROLLNAVRIGHT);\n    var nav = this.createElement('div', {\n      id: id.concat('_right'),\n      className: clsRight\n    });\n    nav.setAttribute('aria-disabled', 'false');\n    var navItem = this.createElement('div', {\n      className: CLS_NAVRIGHTARROW + ' ' + CLS_NAVARROW + ' e-icons'\n    });\n    var clsLeft = 'e-' + element.id.concat('_nav ' + CLS_HSCROLLNAV + ' ' + CLS_HSCROLLNAVLEFT);\n    var navEle = this.createElement('div', {\n      id: id.concat('_left'),\n      className: clsLeft + ' ' + CLS_DISABLE\n    });\n    navEle.setAttribute('aria-disabled', 'true');\n    var navLeftItem = this.createElement('div', {\n      className: CLS_NAVLEFTARROW + ' ' + CLS_NAVARROW + ' e-icons'\n    });\n    navEle.appendChild(navLeftItem);\n    nav.appendChild(navItem);\n    element.appendChild(nav);\n    element.insertBefore(navEle, element.firstChild);\n\n    if (this.ieCheck) {\n      nav.classList.add('e-ie-align');\n      navEle.classList.add('e-ie-align');\n    }\n\n    this.eventBinding([nav, navEle]);\n  };\n\n  HScroll.prototype.onKeyPress = function (e) {\n    var _this = this;\n\n    if (e.key === 'Enter') {\n      var timeoutFun_1 = function () {\n        _this.keyTimeout = true;\n\n        _this.eleScrolling(10, e.target, true);\n      };\n\n      this.keyTimer = window.setTimeout(function () {\n        timeoutFun_1();\n      }, 100);\n    }\n  };\n\n  HScroll.prototype.onKeyUp = function (e) {\n    if (e.key !== 'Enter') {\n      return;\n    }\n\n    if (this.keyTimeout) {\n      this.keyTimeout = false;\n    } else {\n      e.target.click();\n    }\n\n    clearTimeout(this.keyTimer);\n  };\n\n  HScroll.prototype.eventBinding = function (ele) {\n    var _this = this;\n\n    [].slice.call(ele).forEach(function (el) {\n      new Touch(el, {\n        tapHold: _this.tabHoldHandler.bind(_this),\n        tapHoldThreshold: 500\n      });\n      el.addEventListener('keydown', _this.onKeyPress.bind(_this));\n      el.addEventListener('keyup', _this.onKeyUp.bind(_this));\n      el.addEventListener('mouseup', _this.repeatScroll.bind(_this));\n      el.addEventListener('touchend', _this.repeatScroll.bind(_this));\n      el.addEventListener('contextmenu', function (e) {\n        e.preventDefault();\n      });\n      EventHandler.add(el, 'click', _this.clickEventHandler, _this);\n    });\n  };\n\n  HScroll.prototype.repeatScroll = function () {\n    clearInterval(this.timeout);\n  };\n\n  HScroll.prototype.tabHoldHandler = function (e) {\n    var _this = this;\n\n    var trgt = e.originalEvent.target;\n    trgt = this.contains(trgt, CLS_HSCROLLNAV) ? trgt.firstElementChild : trgt;\n    var scrollDis = 10;\n\n    var timeoutFun = function () {\n      _this.eleScrolling(scrollDis, trgt, true);\n    };\n\n    this.timeout = window.setInterval(function () {\n      timeoutFun();\n    }, 50);\n  };\n\n  HScroll.prototype.contains = function (ele, className) {\n    return ele.classList.contains(className);\n  };\n\n  HScroll.prototype.eleScrolling = function (scrollDis, trgt, isContinuous) {\n    var element = this.scrollEle;\n    var rootEle = this.element;\n    var classList = trgt.classList;\n\n    if (classList.contains(CLS_HSCROLLNAV)) {\n      classList = trgt.querySelector('.' + CLS_NAVARROW).classList;\n    }\n\n    if (this.contains(rootEle, CLS_RTL) && this.browserCheck) {\n      scrollDis = -scrollDis;\n    }\n\n    var scrlLeft = element.scrollLeft;\n\n    if (!this.contains(rootEle, CLS_RTL) || this.browserCheck || this.ieCheck) {\n      if (classList.contains(CLS_NAVRIGHTARROW)) {\n        this.frameScrollRequest(scrollDis, 'add', isContinuous);\n      } else {\n        this.frameScrollRequest(scrollDis, '', isContinuous);\n      }\n    } else {\n      if (classList.contains(CLS_NAVLEFTARROW)) {\n        this.frameScrollRequest(scrollDis, 'add', isContinuous);\n      } else {\n        this.frameScrollRequest(scrollDis, '', isContinuous);\n      }\n    }\n  };\n\n  HScroll.prototype.clickEventHandler = function (e) {\n    this.eleScrolling(this.scrollStep, e.target, false);\n  };\n\n  HScroll.prototype.swipeHandler = function (e) {\n    var swipeEle = this.scrollEle;\n    var distance;\n\n    if (e.velocity <= 1) {\n      distance = e.distanceX / (e.velocity * 10);\n    } else {\n      distance = e.distanceX / e.velocity;\n    }\n\n    var start = 0.5;\n\n    var animate = function () {\n      var step = Math.sin(start);\n\n      if (step <= 0) {\n        window.cancelAnimationFrame(step);\n      } else {\n        if (e.swipeDirection === 'Left') {\n          swipeEle.scrollLeft += distance * step;\n        } else if (e.swipeDirection === 'Right') {\n          swipeEle.scrollLeft -= distance * step;\n        }\n\n        start -= 0.5;\n        window.requestAnimationFrame(animate);\n      }\n    };\n\n    animate();\n  };\n\n  HScroll.prototype.scrollUpdating = function (scrollVal, action) {\n    if (action === 'add') {\n      this.scrollEle.scrollLeft += scrollVal;\n    } else {\n      this.scrollEle.scrollLeft -= scrollVal;\n    }\n  };\n\n  HScroll.prototype.frameScrollRequest = function (scrollVal, action, isContinuous) {\n    var _this = this;\n\n    var step = 10;\n\n    if (isContinuous) {\n      this.scrollUpdating(scrollVal, action);\n      return;\n    }\n\n    if (!this.customStep) {\n      [].slice.call(selectAll('.' + CLS_OVERLAY, this.element)).forEach(function (el) {\n        scrollVal -= el.offsetWidth;\n      });\n    }\n\n    var animate = function () {\n      var scrollValue;\n      var scrollStep;\n\n      if (_this.contains(_this.element, CLS_RTL) && _this.browserCheck) {\n        scrollValue = -scrollVal;\n        scrollStep = -step;\n      } else {\n        scrollValue = scrollVal;\n        scrollStep = step;\n      }\n\n      if (scrollValue < step) {\n        window.cancelAnimationFrame(scrollStep);\n      } else {\n        _this.scrollUpdating(scrollStep, action);\n\n        scrollVal -= scrollStep;\n        window.requestAnimationFrame(animate);\n      }\n    };\n\n    animate();\n  };\n\n  HScroll.prototype.touchHandler = function (e) {\n    var ele = this.scrollEle;\n    var distance;\n    distance = e.distanceX;\n\n    if (this.ieCheck && this.contains(this.element, CLS_RTL)) {\n      distance = -distance;\n    }\n\n    if (e.scrollDirection === 'Left') {\n      ele.scrollLeft = ele.scrollLeft + distance;\n    } else if (e.scrollDirection === 'Right') {\n      ele.scrollLeft = ele.scrollLeft - distance;\n    }\n  };\n\n  HScroll.prototype.arrowDisabling = function (addDisable, removeDisable) {\n    if (this.isDevice) {\n      var arrowEle = isNullOrUndefined(addDisable) ? removeDisable : addDisable;\n      var arrowIcon = arrowEle.querySelector('.' + CLS_NAVARROW);\n\n      if (isNullOrUndefined(addDisable)) {\n        classList(arrowIcon, [CLS_NAVRIGHTARROW], [CLS_NAVLEFTARROW]);\n      } else {\n        classList(arrowIcon, [CLS_NAVLEFTARROW], [CLS_NAVRIGHTARROW]);\n      }\n    } else {\n      addDisable.classList.add(CLS_DISABLE);\n      addDisable.setAttribute('aria-disabled', 'true');\n      addDisable.removeAttribute('tabindex');\n      removeDisable.classList.remove(CLS_DISABLE);\n      removeDisable.setAttribute('aria-disabled', 'false');\n      removeDisable.setAttribute('tabindex', '0');\n    }\n\n    this.repeatScroll();\n  };\n\n  HScroll.prototype.scrollHandler = function (e) {\n    var target = e.target;\n    var width = target.offsetWidth;\n    var rootEle = this.element;\n    var navLeftEle = this.element.querySelector('.' + CLS_HSCROLLNAVLEFT);\n    var navRightEle = this.element.querySelector('.' + CLS_HSCROLLNAVRIGHT);\n    var leftOverlay = this.element.querySelector('.' + CLS_LEFTOVERLAY);\n    var rightOverlay = this.element.querySelector('.' + CLS_RIGHTOVERLAY);\n    var scrollLeft = target.scrollLeft;\n\n    if (scrollLeft <= 0) {\n      scrollLeft = -scrollLeft;\n    }\n\n    if (this.isDevice) {\n      if (this.enableRtl && !(this.browserCheck || this.ieCheck)) {\n        leftOverlay = this.element.querySelector('.' + CLS_RIGHTOVERLAY);\n        rightOverlay = this.element.querySelector('.' + CLS_LEFTOVERLAY);\n      }\n\n      if (scrollLeft < OVERLAY_MAXWID) {\n        leftOverlay.style.width = scrollLeft + 'px';\n      } else {\n        leftOverlay.style.width = '40px';\n      }\n\n      if (target.scrollWidth - Math.ceil(width + scrollLeft) < OVERLAY_MAXWID) {\n        rightOverlay.style.width = target.scrollWidth - Math.ceil(width + scrollLeft) + 'px';\n      } else {\n        rightOverlay.style.width = '40px';\n      }\n    }\n\n    if (scrollLeft === 0) {\n      if (!this.contains(rootEle, CLS_RTL) || this.browserCheck || this.ieCheck) {\n        this.arrowDisabling(navLeftEle, navRightEle);\n      } else {\n        this.arrowDisabling(navRightEle, navLeftEle);\n      }\n    } else if (Math.ceil(width + scrollLeft + .1) >= target.scrollWidth) {\n      if (!this.contains(rootEle, CLS_RTL) || this.browserCheck || this.ieCheck) {\n        this.arrowDisabling(navRightEle, navLeftEle);\n      } else {\n        this.arrowDisabling(navLeftEle, navRightEle);\n      }\n    } else {\n      var disEle = this.element.querySelector('.' + CLS_HSCROLLNAV + '.' + CLS_DISABLE);\n\n      if (disEle) {\n        disEle.classList.remove(CLS_DISABLE);\n        disEle.setAttribute('aria-disabled', 'false');\n        disEle.setAttribute('tabindex', '0');\n      }\n    }\n  };\n  /**\n   * Gets called when the model property changes.The data that describes the old and new values of property that changed.\n   * @param  {HScrollModel} newProp\n   * @param  {HScrollModel} oldProp\n   * @returns void\n   * @private\n   */\n\n\n  HScroll.prototype.onPropertyChanged = function (newProp, oldProp) {\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'scrollStep':\n          this.setScrollState();\n          break;\n\n        case 'enableRtl':\n          newProp.enableRtl ? this.element.classList.add(CLS_RTL) : this.element.classList.remove(CLS_RTL);\n          break;\n      }\n    }\n  };\n\n  __decorate([Property(null)], HScroll.prototype, \"scrollStep\", void 0);\n\n  HScroll = __decorate([NotifyPropertyChanges], HScroll);\n  return HScroll;\n}(Component);\n\nexport { HScroll };","map":null,"metadata":{},"sourceType":"module"}