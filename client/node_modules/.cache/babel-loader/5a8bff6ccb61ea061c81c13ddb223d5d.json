{"ast":null,"code":"/**\r\n * DevExtreme (ui/grid_core/ui.grid_core.column_fixing.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _events_engine = require(\"../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _wheel = require(\"../../events/core/wheel\");\n\nvar _wheel2 = _interopRequireDefault(_wheel);\n\nvar _message = require(\"../../localization/message\");\n\nvar _message2 = _interopRequireDefault(_message);\n\nvar _uiGrid_core = require(\"../grid_core/ui.grid_core.utils\");\n\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _browser = require(\"../../core/utils/browser\");\n\nvar _browser2 = _interopRequireDefault(_browser);\n\nvar _position = require(\"../../core/utils/position\");\n\nvar _translator = require(\"../../animation/translator\");\n\nvar _translator2 = _interopRequireDefault(_translator);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar CONTENT_CLASS = \"content\";\nvar CONTENT_FIXED_CLASS = \"content-fixed\";\nvar MASTER_DETAIL_CELL_CLASS = \"dx-master-detail-cell\";\nvar FIRST_CELL_CLASS = \"dx-first-cell\";\nvar LAST_CELL_CLASS = \"dx-last-cell\";\nvar HOVER_STATE_CLASS = \"dx-state-hover\";\nvar FIXED_COL_CLASS = \"dx-col-fixed\";\nvar FIXED_COLUMNS_CLASS = \"dx-fixed-columns\";\nvar POINTER_EVENTS_TARGET_CLASS = \"dx-pointer-events-target\";\nvar POINTER_EVENTS_NONE_CLASS = \"dx-pointer-events-none\";\nvar COMMAND_TRANSPARENT = \"transparent\";\nvar GROUP_ROW_CLASS = \"dx-group-row\";\n\nvar getTransparentColumnIndex = function (fixedColumns) {\n  var transparentColumnIndex = -1;\n  (0, _iterator.each)(fixedColumns, function (index, column) {\n    if (column.command === COMMAND_TRANSPARENT) {\n      transparentColumnIndex = index;\n      return false;\n    }\n  });\n  return transparentColumnIndex;\n};\n\nvar normalizeColumnWidths = function (fixedColumns, widths, fixedWidths) {\n  var fixedColumnIndex = 0;\n\n  if (fixedColumns && widths && fixedWidths) {\n    for (var i = 0; i < fixedColumns.length; i++) {\n      if (fixedColumns[i].command === COMMAND_TRANSPARENT) {\n        fixedColumnIndex += fixedColumns[i].colspan;\n      } else {\n        if (widths[fixedColumnIndex] < fixedWidths[i]) {\n          widths[fixedColumnIndex] = fixedWidths[i];\n        }\n\n        fixedColumnIndex++;\n      }\n    }\n  }\n\n  return widths;\n};\n\nvar baseFixedColumns = {\n  init: function () {\n    this.callBase();\n    this._isFixedTableRendering = false;\n    this._isFixedColumns = false;\n  },\n  _createCol: function (column) {\n    return this.callBase(column).toggleClass(FIXED_COL_CLASS, !!(this._isFixedTableRendering && (column.fixed || column.command && column.command !== COMMAND_TRANSPARENT)));\n  },\n  _correctColumnIndicesForFixedColumns: function (fixedColumns, change) {\n    var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n    var transparentColspan = fixedColumns[transparentColumnIndex].colspan;\n    var columnIndices = change && change.columnIndices;\n\n    if (columnIndices) {\n      change.columnIndices = columnIndices.map(function (columnIndices) {\n        if (columnIndices) {\n          return columnIndices.map(function (columnIndex) {\n            if (columnIndex < transparentColumnIndex) {\n              return columnIndex;\n            } else {\n              if (columnIndex >= transparentColumnIndex + transparentColspan) {\n                return columnIndex - transparentColspan + 1;\n              }\n            }\n\n            return -1;\n          }).filter(function (columnIndex) {\n            return columnIndex >= 0;\n          });\n        }\n      });\n    }\n  },\n  _renderTable: function (options) {\n    var that = this;\n    var $fixedTable;\n    var fixedColumns = that.getFixedColumns();\n    that._isFixedColumns = !!fixedColumns.length;\n    var $table = that.callBase(options);\n\n    if (that._isFixedColumns) {\n      that._isFixedTableRendering = true;\n      var change = options && options.change;\n      var columnIndices = change && change.columnIndices;\n\n      that._correctColumnIndicesForFixedColumns(fixedColumns, change);\n\n      $fixedTable = that._createTable(fixedColumns);\n\n      that._renderRows($fixedTable, (0, _extend.extend)({}, options, {\n        columns: fixedColumns\n      }));\n\n      that._updateContent($fixedTable, change);\n\n      if (columnIndices) {\n        change.columnIndices = columnIndices;\n      }\n\n      that._isFixedTableRendering = false;\n    } else {\n      that._fixedTableElement && that._fixedTableElement.parent().remove();\n      that._fixedTableElement = null;\n    }\n\n    return $table;\n  },\n  _renderRow: function ($table, options) {\n    var fixedCorrection;\n    var cells = options.row.cells;\n    this.callBase.apply(this, arguments);\n\n    if (this._isFixedTableRendering && cells && cells.length) {\n      fixedCorrection = 0;\n      var fixedCells = options.row.cells || [];\n      cells = cells.slice();\n      options.row.cells = cells;\n\n      for (var i = 0; i < fixedCells.length; i++) {\n        if (fixedCells[i].column && fixedCells[i].column.command === COMMAND_TRANSPARENT) {\n          fixedCorrection = (fixedCells[i].column.colspan || 1) - 1;\n          continue;\n        }\n\n        cells[i + fixedCorrection] = fixedCells[i];\n      }\n    }\n  },\n  _createCell: function (options) {\n    var that = this;\n    var column = options.column;\n    var columnCommand = column && column.command;\n    var rowType = options.rowType;\n    var $cell = that.callBase.apply(that, arguments);\n    var fixedColumns;\n    var prevFixedColumn;\n    var transparentColumnIndex;\n\n    if (that._isFixedTableRendering || \"filter\" === rowType) {\n      fixedColumns = that.getFixedColumns();\n      transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n      prevFixedColumn = fixedColumns[transparentColumnIndex - 1];\n    }\n\n    if (that._isFixedTableRendering) {\n      if (columnCommand === COMMAND_TRANSPARENT) {\n        $cell.addClass(POINTER_EVENTS_NONE_CLASS).toggleClass(FIRST_CELL_CLASS, 0 === transparentColumnIndex || prevFixedColumn && \"expand\" === prevFixedColumn.command).toggleClass(LAST_CELL_CLASS, fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1);\n\n        if (\"freeSpace\" !== rowType) {\n          _uiGrid_core2.default.setEmptyText($cell);\n        }\n      }\n    } else {\n      if (\"filter\" === rowType) {\n        $cell.toggleClass(FIRST_CELL_CLASS, options.columnIndex === transparentColumnIndex);\n      }\n    }\n\n    var isRowAltStyle = that.option(\"rowAlternationEnabled\") && options.isAltRow;\n\n    if (_browser2.default.mozilla && options.column.fixed && \"group\" !== options.rowType && !isRowAltStyle) {\n      $cell.addClass(FIXED_COL_CLASS);\n    }\n\n    return $cell;\n  },\n  _wrapTableInScrollContainer: function () {\n    var $scrollContainer = this.callBase.apply(this, arguments);\n\n    if (this._isFixedTableRendering) {\n      $scrollContainer.addClass(this.addWidgetPrefix(CONTENT_FIXED_CLASS) + \" \" + POINTER_EVENTS_TARGET_CLASS);\n    }\n\n    return $scrollContainer;\n  },\n  _renderCellContent: function ($cell, options) {\n    var that = this;\n    var isEmptyCell;\n    var column = options.column;\n    var isFixedTableRendering = that._isFixedTableRendering;\n    var isGroupCell = \"group\" === options.rowType && (0, _type.isDefined)(column.groupIndex);\n\n    if (isFixedTableRendering && isGroupCell && !column.command && !column.groupCellTemplate) {\n      $cell.css(\"pointerEvents\", \"none\");\n    }\n\n    if (!isFixedTableRendering && that._isFixedColumns) {\n      isEmptyCell = column.fixed || column.command && false !== column.fixed;\n\n      if (isGroupCell) {\n        isEmptyCell = false;\n\n        if (options.row.summaryCells && options.row.summaryCells.length) {\n          var columns = that._columnsController.getVisibleColumns();\n\n          var alignByFixedColumnCellCount = that._getAlignByColumnCellCount ? that._getAlignByColumnCellCount(column.colspan, {\n            columns: columns,\n            row: options.row,\n            isFixed: true\n          }) : 0;\n\n          if (alignByFixedColumnCellCount > 0) {\n            var transparentColumnIndex = getTransparentColumnIndex(that._columnsController.getFixedColumns());\n            isEmptyCell = columns.length - alignByFixedColumnCellCount < transparentColumnIndex;\n          }\n        }\n      }\n\n      if (isEmptyCell) {\n        if (that.option(\"legacyRendering\") || column.command && \"buttons\" !== column.type || \"group\" === options.rowType) {\n          $cell.html(\"&nbsp;\").addClass(column.cssClass);\n          return;\n        } else {\n          $cell.addClass(\"dx-hidden-cell\");\n        }\n      }\n    }\n\n    if (column.command !== COMMAND_TRANSPARENT) {\n      that.callBase($cell, options);\n    }\n  },\n  _getCellElementsCore: function (rowIndex) {\n    var that = this;\n    var cellElements = that.callBase(rowIndex);\n    var isGroupRow = cellElements.parent().hasClass(GROUP_ROW_CLASS);\n    var index = \"columnHeadersView\" === that.name ? rowIndex : void 0;\n\n    if (that._fixedTableElement && cellElements) {\n      var fixedColumns = that.getFixedColumns(index);\n\n      var fixedCellElements = that._getRowElements(that._fixedTableElement).eq(rowIndex).children(\"td\");\n\n      (0, _iterator.each)(fixedCellElements, function (columnIndex, cell) {\n        if (isGroupRow) {\n          if (cellElements[columnIndex] && \"hidden\" !== cell.style.visibility) {\n            cellElements[columnIndex] = cell;\n          }\n        } else {\n          var fixedColumn = fixedColumns[columnIndex];\n\n          if (fixedColumn) {\n            if (fixedColumn.command === COMMAND_TRANSPARENT) {\n              if (fixedCellElements.eq(columnIndex).hasClass(MASTER_DETAIL_CELL_CLASS)) {\n                cellElements[columnIndex] = cell || cellElements[columnIndex];\n              }\n            } else {\n              var fixedColumnIndex = that._columnsController.getVisibleIndex(fixedColumn.index, index);\n\n              cellElements[fixedColumnIndex] = cell || cellElements[fixedColumnIndex];\n            }\n          }\n        }\n      });\n    }\n\n    return cellElements;\n  },\n  getColumnWidths: function () {\n    var that = this;\n    var fixedWidths;\n    var result = that.callBase();\n    var fixedColumns = that.getFixedColumns();\n\n    if (that._fixedTableElement && result.length) {\n      fixedWidths = that.callBase(that._fixedTableElement);\n    }\n\n    return normalizeColumnWidths(fixedColumns, result, fixedWidths);\n  },\n  _getTableElement: function () {\n    var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();\n    return tableElement;\n  },\n  _setTableElement: function (tableElement) {\n    if (this._isFixedTableRendering) {\n      this._fixedTableElement = tableElement.addClass(POINTER_EVENTS_NONE_CLASS);\n    } else {\n      this.callBase(tableElement);\n    }\n  },\n  getColumns: function (rowIndex, $tableElement) {\n    $tableElement = $tableElement || this._getTableElement();\n\n    if (this._isFixedTableRendering || $tableElement && $tableElement.closest(\"table\").parent(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).length) {\n      return this.getFixedColumns(rowIndex);\n    }\n\n    return this.callBase(rowIndex, $tableElement);\n  },\n  getRowIndex: function ($row) {\n    var $fixedTable = this._fixedTableElement;\n\n    if ($fixedTable && $fixedTable.find($row).length) {\n      return this._getRowElements($fixedTable).index($row);\n    }\n\n    return this.callBase($row);\n  },\n  getTableElements: function () {\n    var result = this.callBase.apply(this, arguments);\n\n    if (this._fixedTableElement) {\n      result = (0, _renderer2.default)([result.get(0), this._fixedTableElement.get(0)]);\n    }\n\n    return result;\n  },\n  getFixedColumns: function (rowIndex) {\n    return this._columnsController.getFixedColumns(rowIndex);\n  },\n  getFixedColumnsOffset: function () {\n    var offset = {\n      left: 0,\n      right: 0\n    };\n    var $transparentColumn;\n\n    if (this._fixedTableElement) {\n      $transparentColumn = this.getTransparentColumnElement();\n      var positionTransparentColumn = $transparentColumn.position();\n      offset = {\n        left: positionTransparentColumn.left,\n        right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)\n      };\n    }\n\n    return offset;\n  },\n  getTransparentColumnElement: function () {\n    return this._fixedTableElement && this._fixedTableElement.find(\".\" + POINTER_EVENTS_NONE_CLASS).first();\n  },\n  getFixedTableElement: function () {\n    return this._fixedTableElement;\n  },\n  isFixedColumns: function () {\n    return this._isFixedColumns;\n  },\n  _resizeCore: function () {\n    this.callBase();\n    this.synchronizeRows();\n  },\n  setColumnWidths: function (options) {\n    var columns;\n\n    var visibleColumns = this._columnsController.getVisibleColumns();\n\n    var widths = options.widths;\n    var isWidthsSynchronized = widths && widths.length && (0, _type.isDefined)(visibleColumns[0].visibleWidth);\n    var optionNames = options.optionNames;\n    var isColumnWidthChanged = optionNames && optionNames.width;\n    var useVisibleColumns = false;\n    this.callBase.apply(this, arguments);\n\n    if (this._fixedTableElement) {\n      if (this.option(\"legacyRendering\")) {\n        useVisibleColumns = widths && widths.length && !this.isScrollbarVisible(true);\n      } else {\n        var hasAutoWidth = widths && widths.some(function (width) {\n          return \"auto\" === width;\n        });\n        useVisibleColumns = hasAutoWidth && (!isWidthsSynchronized || !this.isScrollbarVisible(true));\n      }\n\n      if (useVisibleColumns) {\n        columns = visibleColumns;\n      }\n\n      this.callBase((0, _extend.extend)({}, options, {\n        $tableElement: this._fixedTableElement,\n        columns: columns,\n        fixed: true\n      }));\n    }\n\n    if (isWidthsSynchronized || isColumnWidthChanged && this.option(\"wordWrapEnabled\")) {\n      this.synchronizeRows();\n    }\n  },\n  _createColGroup: function (columns) {\n    if (!this.option(\"legacyRendering\") && this._isFixedTableRendering && !this.option(\"columnAutoWidth\")) {\n      var visibleColumns = this._columnsController.getVisibleColumns();\n\n      var useVisibleColumns = visibleColumns.filter(function (column) {\n        return !column.width;\n      }).length;\n\n      if (useVisibleColumns) {\n        columns = visibleColumns;\n      }\n    }\n\n    return this.callBase(columns);\n  },\n  _getClientHeight: function (element) {\n    var boundingClientRectElement = element.getBoundingClientRect && (0, _position.getBoundingRect)(element);\n    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight;\n  },\n  synchronizeRows: function () {\n    var that = this;\n    var rowHeights = [];\n    var fixedRowHeights = [];\n    var rowIndex;\n    var $rowElements;\n    var $fixedRowElements;\n    var $contentElement;\n\n    if (that._isFixedColumns && that._tableElement && that._fixedTableElement) {\n      var heightTable = that._getClientHeight(that._tableElement.get(0));\n\n      var heightFixedTable = that._getClientHeight(that._fixedTableElement.get(0));\n\n      $rowElements = that._getRowElements(that._tableElement);\n      $fixedRowElements = that._getRowElements(that._fixedTableElement);\n      $contentElement = that._findContentElement();\n\n      if (heightTable !== heightFixedTable) {\n        $contentElement && $contentElement.css(\"height\", heightTable);\n        $rowElements.css(\"height\", \"\");\n        $fixedRowElements.css(\"height\", \"\");\n\n        for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {\n          rowHeights.push(that._getClientHeight($rowElements.get(rowIndex)));\n          fixedRowHeights.push(that._getClientHeight($fixedRowElements.get(rowIndex)));\n        }\n\n        for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {\n          var rowHeight = rowHeights[rowIndex];\n          var fixedRowHeight = fixedRowHeights[rowIndex];\n\n          if (rowHeight > fixedRowHeight) {\n            $fixedRowElements.eq(rowIndex).css(\"height\", rowHeight);\n          } else {\n            if (rowHeight < fixedRowHeight) {\n              $rowElements.eq(rowIndex).css(\"height\", fixedRowHeight);\n            }\n          }\n        }\n\n        $contentElement && $contentElement.css(\"height\", \"\");\n      }\n    }\n  },\n  setScrollerSpacing: function (width) {\n    var rtlEnabled = this.option(\"rtlEnabled\");\n    this.callBase(width);\n    this.element().children(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).css({\n      paddingLeft: rtlEnabled ? width : \"\",\n      paddingRight: !rtlEnabled ? width : \"\"\n    });\n  }\n};\nvar ColumnHeadersViewFixedColumnsExtender = (0, _extend.extend)({}, baseFixedColumns, {\n  _getRowVisibleColumns: function (rowIndex) {\n    if (this._isFixedTableRendering) {\n      return this.getFixedColumns(rowIndex);\n    }\n\n    return this.callBase(rowIndex);\n  },\n  getContextMenuItems: function (options) {\n    var that = this;\n    var column = options.column;\n    var columnFixingOptions = that.option(\"columnFixing\");\n    var items = that.callBase(options);\n\n    if (options.row && \"header\" === options.row.rowType) {\n      if (column && column.allowFixing) {\n        var onItemClick = function (params) {\n          switch (params.itemData.value) {\n            case \"none\":\n              that._columnsController.columnOption(column.index, \"fixed\", false);\n\n              break;\n\n            case \"left\":\n              that._columnsController.columnOption(column.index, {\n                fixed: true,\n                fixedPosition: \"left\"\n              });\n\n              break;\n\n            case \"right\":\n              that._columnsController.columnOption(column.index, {\n                fixed: true,\n                fixedPosition: \"right\"\n              });\n\n          }\n        };\n\n        items = items || [];\n        items.push({\n          text: columnFixingOptions.texts.fix,\n          beginGroup: true,\n          items: [{\n            text: columnFixingOptions.texts.leftPosition,\n            value: \"left\",\n            disabled: column.fixed && (!column.fixedPosition || \"left\" === column.fixedPosition),\n            onItemClick: onItemClick\n          }, {\n            text: columnFixingOptions.texts.rightPosition,\n            value: \"right\",\n            disabled: column.fixed && \"right\" === column.fixedPosition,\n            onItemClick: onItemClick\n          }]\n        }, {\n          text: columnFixingOptions.texts.unfix,\n          value: \"none\",\n          disabled: !column.fixed,\n          onItemClick: onItemClick\n        });\n      }\n    }\n\n    return items;\n  },\n  getFixedColumnElements: function (rowIndex) {\n    var that = this;\n\n    if ((0, _type.isDefined)(rowIndex)) {\n      return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children();\n    }\n\n    var columnElements = that.getColumnElements();\n    var $transparentColumnElement = that.getTransparentColumnElement();\n\n    if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {\n      var transparentColumnIndex = getTransparentColumnIndex(that.getFixedColumns());\n      columnElements.splice(transparentColumnIndex, $transparentColumnElement.get(0).colSpan, $transparentColumnElement.get(0));\n    }\n\n    return columnElements;\n  },\n  getColumnWidths: function () {\n    var that = this;\n    var fixedWidths;\n    var result = that.callBase();\n    var $fixedColumnElements = that.getFixedColumnElements();\n    var fixedColumns = that.getFixedColumns();\n\n    if (that._fixedTableElement) {\n      if ($fixedColumnElements && $fixedColumnElements.length) {\n        fixedWidths = that._getWidths($fixedColumnElements);\n      } else {\n        fixedWidths = that.callBase(that._fixedTableElement);\n      }\n    }\n\n    return normalizeColumnWidths(fixedColumns, result, fixedWidths);\n  }\n});\nvar RowsViewFixedColumnsExtender = (0, _extend.extend)({}, baseFixedColumns, {\n  _detachHoverEvents: function () {\n    this._fixedTableElement && _events_engine2.default.off(this._fixedTableElement, \"mouseover mouseout\", \".dx-data-row\");\n    this._tableElement && _events_engine2.default.off(this._tableElement, \"mouseover mouseout\", \".dx-data-row\");\n  },\n  _attachHoverEvents: function () {\n    var that = this;\n\n    var attachHoverEvent = function ($table) {\n      _events_engine2.default.on($table, \"mouseover mouseout\", \".dx-data-row\", that.createAction(function (args) {\n        var event = args.event;\n        var rowIndex = that.getRowIndex((0, _renderer2.default)(event.target).closest(\".dx-row\"));\n        var isHover = \"mouseover\" === event.type;\n\n        if (rowIndex >= 0) {\n          that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);\n          that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);\n        }\n      }));\n    };\n\n    if (that._fixedTableElement && that._tableElement) {\n      attachHoverEvent(that._fixedTableElement);\n      attachHoverEvent(that._tableElement);\n    }\n  },\n  _findContentElement: function () {\n    var that = this;\n    var $content;\n    var scrollTop;\n    var contentClass = that.addWidgetPrefix(CONTENT_CLASS);\n    var element = that.element();\n    var scrollDelay = _browser2.default.mozilla ? 60 : 0;\n\n    if (element && that._isFixedTableRendering) {\n      $content = element.children(\".\" + contentClass);\n      var scrollable = that.getScrollable();\n\n      if (!$content.length && scrollable) {\n        $content = (0, _renderer2.default)(\"<div>\").addClass(contentClass);\n\n        _events_engine2.default.on($content, \"scroll\", function (e) {\n          clearTimeout(that._fixedScrollTimeout);\n          that._fixedScrollTimeout = setTimeout(function () {\n            scrollTop = (0, _renderer2.default)(e.target).scrollTop();\n            scrollable.scrollTo({\n              y: scrollTop\n            });\n          }, scrollDelay);\n        });\n\n        _events_engine2.default.on($content, _wheel2.default.name, function (e) {\n          var $nearestScrollable = (0, _renderer2.default)(e.target).closest(\".dx-scrollable\");\n\n          if (scrollable && scrollable.$element().is($nearestScrollable)) {\n            scrollTop = scrollable.scrollTop();\n            scrollable.scrollTo({\n              y: scrollTop - e.delta\n            });\n\n            if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth()) {\n              return false;\n            }\n          }\n        });\n\n        $content.appendTo(element);\n      }\n\n      return $content;\n    }\n\n    return that.callBase();\n  },\n  _updateScrollable: function () {\n    this.callBase();\n    var scrollable = this.getScrollable();\n    var scrollTop = scrollable && scrollable.scrollOffset().top;\n\n    this._updateFixedTablePosition(scrollTop);\n  },\n  _renderContent: function (contentElement, tableElement) {\n    if (this._isFixedTableRendering) {\n      return contentElement.empty().addClass(this.addWidgetPrefix(CONTENT_CLASS) + \" \" + this.addWidgetPrefix(CONTENT_FIXED_CLASS) + \" \" + POINTER_EVENTS_TARGET_CLASS).append(tableElement);\n    }\n\n    return this.callBase(contentElement, tableElement);\n  },\n  _getGroupCellOptions: function (options) {\n    if (this._isFixedTableRendering) {\n      return this.callBase((0, _extend.extend)({}, options, {\n        columns: this._columnsController.getVisibleColumns()\n      }));\n    }\n\n    return this.callBase(options);\n  },\n  _renderGroupedCells: function ($row, options) {\n    return this.callBase($row, (0, _extend.extend)({}, options, {\n      columns: this._columnsController.getVisibleColumns()\n    }));\n  },\n  _renderGroupSummaryCells: function ($row, options) {\n    if (this._isFixedTableRendering) {\n      this.callBase($row, (0, _extend.extend)({}, options, {\n        columns: this._columnsController.getVisibleColumns()\n      }));\n    } else {\n      this.callBase($row, options);\n    }\n  },\n  _hasAlignByColumnSummaryItems: function (columnIndex, options) {\n    var result = this.callBase.apply(this, arguments);\n    var column = options.columns[columnIndex];\n\n    if (options.isFixed) {\n      return column.fixed && (result || \"right\" === column.fixedPosition);\n    }\n\n    return result && !column.fixed;\n  },\n  _renderGroupSummaryCellsCore: function ($groupCell, options, groupCellColSpan, alignByColumnCellCount) {\n    var alignByFixedColumnCellCount;\n\n    if (this._isFixedTableRendering) {\n      options.isFixed = true;\n      alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);\n      options.isFixed = false;\n      var startColumnIndex = options.columns.length - alignByFixedColumnCellCount;\n      options = (0, _extend.extend)({}, options, {\n        columns: this.getFixedColumns()\n      });\n      var transparentColumnIndex = getTransparentColumnIndex(options.columns);\n\n      if (startColumnIndex < transparentColumnIndex) {\n        alignByFixedColumnCellCount -= options.columns[transparentColumnIndex].colspan - 1 || 0;\n        groupCellColSpan -= options.columns[transparentColumnIndex].colspan - 1 || 0;\n      } else {\n        if (alignByColumnCellCount > 0) {\n          $groupCell.css(\"visibility\", \"hidden\");\n        }\n      }\n\n      alignByColumnCellCount = alignByFixedColumnCellCount;\n    }\n\n    this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount);\n  },\n  _getSummaryCellIndex: function (columnIndex, columns) {\n    if (this._isFixedTableRendering) {\n      var transparentColumnIndex = getTransparentColumnIndex(columns);\n\n      if (columnIndex > transparentColumnIndex) {\n        columnIndex += columns[transparentColumnIndex].colspan - 1;\n      }\n\n      return columnIndex;\n    }\n\n    return this.callBase.apply(this, arguments);\n  },\n  _renderCore: function (change) {\n    this._detachHoverEvents();\n\n    this.callBase(change);\n    var isFixedColumns = this._isFixedColumns;\n    this.element().toggleClass(FIXED_COLUMNS_CLASS, isFixedColumns);\n\n    if (this.option(\"hoverStateEnabled\") && isFixedColumns) {\n      this._attachHoverEvents();\n    }\n  },\n  setRowsOpacity: function (columnIndex, value) {\n    this.callBase(columnIndex, value);\n\n    var $rows = this._getRowElements(this._fixedTableElement);\n\n    this._setRowsOpacityCore($rows, this.getFixedColumns(), columnIndex, value);\n  },\n  optionChanged: function (args) {\n    var that = this;\n    that.callBase(args);\n\n    if (\"hoverStateEnabled\" === args.name && that._isFixedColumns) {\n      args.value ? this._attachHoverEvents() : this._detachHoverEvents();\n    }\n  },\n  getCellIndex: function ($cell) {\n    var $fixedTable = this._fixedTableElement;\n    var cellIndex = 0;\n\n    if ($fixedTable && $cell.is(\"td\") && $cell.closest($fixedTable).length) {\n      var columns = this.getFixedColumns();\n      (0, _iterator.each)(columns, function (index, column) {\n        if (index === $cell[0].cellIndex) {\n          return false;\n        }\n\n        if (column.colspan) {\n          cellIndex += column.colspan;\n          return;\n        }\n\n        cellIndex++;\n      });\n      return cellIndex;\n    }\n\n    return this.callBase.apply(this, arguments);\n  },\n  _updateFixedTablePosition: function (scrollTop, needFocus) {\n    if (this._fixedTableElement && this._tableElement) {\n      var $focusedElement;\n      var editorFactory = this.getController(\"editorFactory\");\n\n      this._fixedTableElement.parent().scrollTop(scrollTop);\n\n      if (needFocus) {\n        $focusedElement = editorFactory.focus();\n        $focusedElement && editorFactory.focus($focusedElement);\n      }\n    }\n  },\n  setScrollerSpacing: function (vWidth, hWidth) {\n    var that = this;\n    var styles = {\n      marginBottom: 0\n    };\n    var $fixedContent = that.element().children(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS));\n\n    if ($fixedContent.length && that._fixedTableElement) {\n      $fixedContent.css(styles);\n\n      that._fixedTableElement.css(styles);\n\n      styles[that.option(\"rtlEnabled\") ? \"marginLeft\" : \"marginRight\"] = vWidth;\n      styles.marginBottom = hWidth;\n\n      var useNativeScrolling = that._scrollable && that._scrollable.option(\"useNative\");\n\n      (useNativeScrolling ? $fixedContent : that._fixedTableElement).css(styles);\n    }\n  },\n  _getElasticScrollTop: function (e) {\n    var elasticScrollTop = 0;\n    var scrollbarWidth = this.getScrollbarWidth(true);\n\n    if (e.scrollOffset.top < 0) {\n      elasticScrollTop = -e.scrollOffset.top;\n    } else {\n      if (e.reachedBottom) {\n        var scrollableContent = this._findContentElement();\n\n        var scrollableContainer = e.component._container();\n\n        var maxScrollTop = Math.max(scrollableContent.height() + scrollbarWidth - scrollableContainer.height(), 0);\n        elasticScrollTop = maxScrollTop - e.scrollOffset.top;\n      }\n    }\n\n    return elasticScrollTop;\n  },\n  _applyElasticScrolling: function (e) {\n    if (this._fixedTableElement) {\n      var elasticScrollTop = this._getElasticScrollTop(e);\n\n      if (0 !== Math.ceil(elasticScrollTop)) {\n        _translator2.default.move(this._fixedTableElement, {\n          top: elasticScrollTop\n        });\n      } else {\n        this._fixedTableElement.css(\"transform\", \"\");\n      }\n    }\n  },\n  _handleScroll: function (e) {\n    this._updateFixedTablePosition(e.scrollOffset.top, true);\n\n    this._applyElasticScrolling(e);\n\n    this.callBase(e);\n  },\n  _updateContentPosition: function (isRender) {\n    this.callBase.apply(this, arguments);\n\n    if (!isRender) {\n      this._updateFixedTablePosition(this._scrollTop);\n    }\n  },\n  _afterRowPrepared: function (e) {\n    if (this._isFixedTableRendering) {\n      return;\n    }\n\n    this.callBase(e);\n  },\n  _scrollToElement: function ($element) {\n    this.callBase($element, this.getFixedColumnsOffset());\n  },\n  dispose: function () {\n    this.callBase.apply(this, arguments);\n    clearTimeout(this._fixedScrollTimeout);\n  }\n});\nvar FooterViewFixedColumnsExtender = baseFixedColumns;\nmodule.exports = {\n  defaultOptions: function () {\n    return {\n      columnFixing: {\n        enabled: false,\n        texts: {\n          fix: _message2.default.format(\"dxDataGrid-columnFixingFix\"),\n          unfix: _message2.default.format(\"dxDataGrid-columnFixingUnfix\"),\n          leftPosition: _message2.default.format(\"dxDataGrid-columnFixingLeftPosition\"),\n          rightPosition: _message2.default.format(\"dxDataGrid-columnFixingRightPosition\")\n        }\n      }\n    };\n  },\n  extenders: {\n    views: {\n      columnHeadersView: ColumnHeadersViewFixedColumnsExtender,\n      rowsView: RowsViewFixedColumnsExtender,\n      footerView: FooterViewFixedColumnsExtender\n    },\n    controllers: function () {\n      var normalizeColumnIndicesByPoints = function (columns, fixedColumns, pointsByColumns) {\n        var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n        var correctIndex = columns.length - fixedColumns.length;\n        (0, _iterator.each)(pointsByColumns, function (_, point) {\n          if (point.index > transparentColumnIndex) {\n            point.columnIndex += correctIndex;\n            point.index += correctIndex;\n          }\n        });\n        return pointsByColumns;\n      };\n\n      return {\n        draggingHeader: {\n          _generatePointsByColumns: function (options) {\n            var visibleColumns = options.columns;\n            var targetDraggingPanel = options.targetDraggingPanel;\n\n            if (targetDraggingPanel && \"headers\" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {\n              if (options.sourceColumn.fixed) {\n                if (!options.rowIndex) {\n                  options.columnElements = targetDraggingPanel.getFixedColumnElements(0);\n                }\n\n                options.columns = targetDraggingPanel.getFixedColumns(options.rowIndex);\n                var pointsByColumns = this.callBase(options);\n                normalizeColumnIndicesByPoints(visibleColumns, options.columns, pointsByColumns);\n                return pointsByColumns;\n              }\n            }\n\n            return this.callBase(options);\n          },\n          _pointCreated: function (point, columns, location, sourceColumn) {\n            var result = this.callBase.apply(this, arguments);\n\n            var $transparentColumn = this._columnHeadersView.getTransparentColumnElement();\n\n            if (!result && \"headers\" === location && $transparentColumn && $transparentColumn.length) {\n              var boundingRect = (0, _position.getBoundingRect)($transparentColumn.get(0));\n\n              if (sourceColumn && sourceColumn.fixed) {\n                return \"right\" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left;\n              } else {\n                return point.x < boundingRect.left || point.x > boundingRect.right;\n              }\n            }\n\n            return result;\n          }\n        },\n        columnsResizer: {\n          _generatePointsByColumns: function () {\n            var that = this;\n            var columnsController = that._columnsController;\n\n            var columns = columnsController && that._columnsController.getVisibleColumns();\n\n            var fixedColumns = columnsController && that._columnsController.getFixedColumns();\n\n            var cells = that._columnHeadersView.getFixedColumnElements();\n\n            var pointsByFixedColumns = [];\n            that.callBase();\n\n            if (cells && cells.length > 0) {\n              pointsByFixedColumns = _uiGrid_core2.default.getPointsByColumns(cells, function (point) {\n                return that._pointCreated(point, cells.length, fixedColumns);\n              });\n              that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, fixedColumns, pointsByFixedColumns);\n            }\n          },\n          _pointCreated: function (point, cellsLength, columns) {\n            var isWidgetResizingMode = \"widget\" === this.option(\"columnResizingMode\");\n\n            if (point.index > 0 && point.index < cellsLength) {\n              var currentColumn = columns[point.columnIndex - 1] || {};\n              var nextColumn = columns[point.columnIndex] || {};\n\n              if (currentColumn.fixed || nextColumn.fixed) {\n                point.columnIndex -= 1;\n                return !((currentColumn.allowResizing || currentColumn.command === COMMAND_TRANSPARENT) && (isWidgetResizingMode || nextColumn.allowResizing || nextColumn.command === COMMAND_TRANSPARENT));\n              }\n            }\n\n            return this.callBase.apply(this, arguments);\n          },\n          _getTargetPoint: function (pointsByColumns, currentX, deltaX) {\n            var $transparentColumn = this._columnHeadersView.getTransparentColumnElement();\n\n            if ($transparentColumn && $transparentColumn.length) {\n              var boundingRect = (0, _position.getBoundingRect)($transparentColumn.get(0));\n\n              if (currentX <= boundingRect.left || currentX >= boundingRect.right) {\n                return this.callBase(this._pointsByFixedColumns, currentX, deltaX);\n              }\n            }\n\n            return this.callBase(pointsByColumns, currentX, deltaX);\n          }\n        }\n      };\n    }()\n  }\n};","map":null,"metadata":{},"sourceType":"script"}