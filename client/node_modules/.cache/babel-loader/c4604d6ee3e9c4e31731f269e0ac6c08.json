{"ast":null,"code":"import { PdfGrid } from './pdf-grid';\nimport { PdfGridCellStyle } from './styles/style';\nimport { PdfStringLayouter } from './../../graphics/fonts/string-layouter';\nimport { PdfDocument } from './../../document/pdf-document';\nimport { PdfStringFormat } from './../../graphics/fonts/pdf-string-format';\nimport { RectangleF, PointF, SizeF } from './../../drawing/pdf-drawing';\nimport { PdfDashStyle, PdfLineCap } from './../../graphics/enum';\nimport { PdfBorderOverlapStyle } from './../tables/light-tables/enum';\nimport { PdfSolidBrush } from './../../graphics/brushes/pdf-solid-brush';\nimport { PdfColor } from './../../graphics/pdf-color';\nimport { PdfImage } from './../../graphics/images/pdf-image';\nimport { PdfBitmap } from './../../graphics/images/pdf-bitmap';\nimport { PdfTextWebLink } from './../../annotations/pdf-text-web-link';\nimport { PdfLayoutType } from './../../graphics/figures/enum';\nimport { PdfGridLayouter, PdfGridLayoutFormat } from './../../structured-elements/grid/layout/grid-layouter';\nimport { PdfLayoutParams } from '../../../implementation/graphics/figures/base/element-layouter';\n/**\n * `PdfGridCell` class represents the schema of a cell in a 'PdfGrid'.\n */\n\nvar PdfGridCell =\n/** @class */\nfunction () {\n  function PdfGridCell(row) {\n    /**\n     * `Width` of the cell.\n     * @default 0\n     * @private\n     */\n    this.cellWidth = 0;\n    /**\n     * `Height` of the cell.\n     * @default 0\n     * @private\n     */\n\n    this.cellHeight = 0;\n    /**\n     * `tempval`to stores current width .\n     * @default 0\n     * @private\n     */\n\n    this.tempval = 0;\n    this.fontSpilt = false;\n    /**\n     * Specifies weather the `cell is drawn`.\n     * @default true\n     * @private\n     */\n\n    this.finsh = true;\n    /**\n     * The `remaining height` of row span.\n     * @default 0\n     * @private\n     */\n\n    this.rowSpanRemainingHeight = 0;\n    this.hasRowSpan = false;\n    this.hasColSpan = false;\n    /**\n     * the 'isFinish' is set to page finish\n     */\n\n    this.isFinish = true;\n    /**\n     * The `present' to store the current cell.\n     * @default false\n     * @private\n     */\n\n    this.present = false;\n    this.gridRowSpan = 1;\n    this.colSpan = 1;\n\n    if (typeof row !== 'undefined') {\n      this.gridRow = row;\n    }\n  }\n\n  Object.defineProperty(PdfGridCell.prototype, \"isCellMergeContinue\", {\n    //Properties\n    get: function () {\n      return this.internalIsCellMergeContinue;\n    },\n    set: function (value) {\n      this.internalIsCellMergeContinue = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"isRowMergeContinue\", {\n    get: function () {\n      return this.internalIsRowMergeContinue;\n    },\n    set: function (value) {\n      this.internalIsRowMergeContinue = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"isCellMergeStart\", {\n    get: function () {\n      return this.internalIsCellMergeStart;\n    },\n    set: function (value) {\n      this.internalIsCellMergeStart = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"isRowMergeStart\", {\n    get: function () {\n      return this.internalIsRowMergeStart;\n    },\n    set: function (value) {\n      this.internalIsRowMergeStart = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"remainingString\", {\n    /**\n     * Gets or sets the `remaining string` after the row split between pages.\n     * @private\n     */\n    get: function () {\n      return this.remaining;\n    },\n    set: function (value) {\n      this.remaining = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"FinishedDrawingCell\", {\n    /**\n     * Gets or sets the `FinishedDrawingCell` .\n     * @private\n     */\n    get: function () {\n      return this.isFinish;\n    },\n    set: function (value) {\n      this.isFinish = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"stringFormat\", {\n    /**\n     * Gets or sets the `string format`.\n     * @private\n     */\n    get: function () {\n      if (this.format == null) {\n        this.format = new PdfStringFormat();\n      }\n\n      return this.format;\n    },\n    set: function (value) {\n      this.format = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"row\", {\n    /**\n     * Gets or sets the parent `row`.\n     * @private\n     */\n    get: function () {\n      return this.gridRow;\n    },\n    set: function (value) {\n      this.gridRow = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"value\", {\n    /**\n     * Gets or sets the `value` of the cell.\n     * @private\n     */\n    get: function () {\n      return this.objectValue;\n    },\n    set: function (value) {\n      this.objectValue = value;\n\n      if (this.objectValue instanceof PdfGrid) {\n        this.row.grid.isSingleGrid = false;\n        var grid = this.objectValue;\n        grid.ParentCell = this;\n        this.objectValue.isChildGrid = true;\n        var rowCount = this.row.grid.rows.count;\n\n        for (var i = 0; i < rowCount; i++) {\n          var row = this.row.grid.rows.getRow(i);\n          var colCount = row.cells.count;\n\n          for (var j = 0; j < colCount; j++) {\n            var cell = row.cells.getCell(j);\n            cell.parent = this;\n          }\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"rowSpan\", {\n    /**\n     * Gets or sets a value that indicates the total number of rows that cell `spans` within a PdfGrid.\n     * @private\n     */\n    get: function () {\n      return this.gridRowSpan;\n    },\n    set: function (value) {\n      if (value < 1) {\n        throw new Error('ArgumentException : Invalid span specified, must be greater than or equal to 1');\n      } else {\n        this.gridRowSpan = value;\n        this.row.rowSpanExists = true;\n        this.row.grid.hasRowSpanSpan = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"style\", {\n    /**\n     * Gets or sets the cell `style`.\n     * @private\n     */\n    get: function () {\n      if (this.cellStyle == null) {\n        this.cellStyle = new PdfGridCellStyle();\n      }\n\n      return this.cellStyle;\n    },\n    set: function (value) {\n      this.cellStyle = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"height\", {\n    /**\n     * Gets the `height` of the PdfGrid cell.[Read-Only].\n     * @private\n     */\n    get: function () {\n      if (this.cellHeight === 0) {\n        this.cellHeight = this.measureHeight();\n      }\n\n      return this.cellHeight;\n    },\n    set: function (value) {\n      this.cellHeight = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"columnSpan\", {\n    /**\n     * Gets or sets a value that indicates the total number of columns that cell `spans` within a PdfGrid.\n     * @private\n     */\n    get: function () {\n      return this.colSpan;\n    },\n    set: function (value) {\n      if (value < 1) {\n        throw Error('Invalid span specified, must be greater than or equal to 1');\n      } else {\n        this.colSpan = value;\n        this.row.columnSpanExists = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridCell.prototype, \"width\", {\n    /**\n     * Gets the `width` of the PdfGrid cell.[Read-Only].\n     * @private\n     */\n    get: function () {\n      if (this.cellWidth === 0 || this.row.grid.isComplete) {\n        this.cellWidth = this.measureWidth();\n      }\n\n      return Math.round(this.cellWidth);\n    },\n    set: function (value) {\n      this.cellWidth = value;\n    },\n    enumerable: true,\n    configurable: true\n  }); //Implementation\n\n  /**\n   * `Calculates the width`.\n   * @private\n   */\n\n  PdfGridCell.prototype.measureWidth = function () {\n    // .. Calculate the cell text width.\n    // .....Add border widths, cell spacings and paddings to the width.\n    var width = 0;\n    var layouter = new PdfStringLayouter();\n\n    if (typeof this.objectValue === 'string') {\n      /* tslint:disable */\n      var slr = layouter.layout(this.objectValue, this.getTextFont(), this.stringFormat, new SizeF(Number.MAX_VALUE, Number.MAX_VALUE), false, new SizeF(0, 0));\n      width += slr.actualSize.width;\n      width += (this.style.borders.left.width + this.style.borders.right.width) * 2;\n    } else if (this.objectValue instanceof PdfGrid) {\n      width = this.objectValue.size.width; //width += this.objectValue.style.cellSpacing;\n    } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {\n      width += this.objectValue.width;\n    } else if (this.objectValue instanceof PdfTextWebLink) {\n      var webLink = this.objectValue;\n      var result = layouter.layout(webLink.text, webLink.font, webLink.stringFormat, new SizeF(0, 0), false, new SizeF(0, 0));\n      /* tslint:enable */\n\n      width += result.actualSize.width;\n      width += (this.style.borders.left.width + this.style.borders.right.width) * 2;\n    }\n\n    if (!(this.objectValue instanceof PdfGrid)) {\n      if (this.style.cellPadding != null) {\n        width += this.style.cellPadding.left + this.style.cellPadding.right;\n      } else {\n        width += this.row.grid.style.cellPadding.left + this.row.grid.style.cellPadding.right;\n      }\n    } else {\n      if (this.style.cellPadding != null || typeof this.style.cellPadding !== 'undefined') {\n        if (typeof this.style.cellPadding.left !== 'undefined' && this.style.cellPadding.hasLeftPad) {\n          width += this.style.cellPadding.left;\n        }\n\n        if (typeof this.style.cellPadding.right !== 'undefined' && this.style.cellPadding.hasRightPad) {\n          width += this.style.cellPadding.right;\n        }\n      } else {\n        if (typeof this.row.grid.style.cellPadding.left !== 'undefined' && this.row.grid.style.cellPadding.hasLeftPad) {\n          width += this.row.grid.style.cellPadding.left;\n        }\n\n        if (typeof this.row.grid.style.cellPadding.right !== 'undefined' && this.row.grid.style.cellPadding.hasRightPad) {\n          width += this.row.grid.style.cellPadding.right;\n        }\n      }\n    }\n\n    width += this.row.grid.style.cellSpacing;\n    return width;\n  };\n  /**\n   * Draw the `cell background`.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.drawCellBackground = function (graphics, bounds) {\n    var backgroundBrush = this.getBackgroundBrush(); //graphics.isTemplateGraphics = true;\n\n    if (backgroundBrush != null) {\n      graphics.save();\n      graphics.drawRectangle(backgroundBrush, bounds.x, bounds.y, bounds.width, bounds.height);\n      graphics.restore();\n    }\n\n    if (this.style.backgroundImage != null) {\n      var image = this.getBackgroundImage();\n      graphics.drawImage(this.style.backgroundImage, bounds.x, bounds.y, bounds.width, bounds.height);\n    }\n  };\n  /**\n   * `Adjusts the text layout area`.\n   * @private\n   */\n\n  /* tslint:disable */\n\n\n  PdfGridCell.prototype.adjustContentLayoutArea = function (bounds) {\n    //Add Padding value to its Cell Bounds\n    var returnBounds = new RectangleF(bounds.x, bounds.y, bounds.width, bounds.height);\n\n    if (!(this.objectValue instanceof PdfGrid)) {\n      if (typeof this.style.cellPadding === 'undefined' || this.style.cellPadding == null) {\n        returnBounds.x += this.gridRow.grid.style.cellPadding.left + this.cellStyle.borders.left.width;\n        returnBounds.y += this.gridRow.grid.style.cellPadding.top + this.cellStyle.borders.top.width;\n        returnBounds.width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;\n        returnBounds.height -= this.gridRow.grid.style.cellPadding.bottom + this.gridRow.grid.style.cellPadding.top;\n        returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;\n      } else {\n        returnBounds.x += this.style.cellPadding.left + this.cellStyle.borders.left.width;\n        returnBounds.y += this.style.cellPadding.top + this.cellStyle.borders.top.width;\n        returnBounds.width -= this.style.cellPadding.right + this.style.cellPadding.left;\n        returnBounds.width -= this.cellStyle.borders.left.width + this.cellStyle.borders.right.width;\n        returnBounds.height -= this.style.cellPadding.bottom + this.style.cellPadding.top;\n        returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;\n\n        if (this.rowSpan === 1) {\n          returnBounds.width -= this.style.borders.left.width;\n        }\n      }\n    } else {\n      if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n        if (typeof this.gridRow.grid.style.cellPadding.left !== 'undefined' && this.gridRow.grid.style.cellPadding.hasLeftPad) {\n          returnBounds.x += this.gridRow.grid.style.cellPadding.left + this.cellStyle.borders.left.width;\n          returnBounds.width -= this.gridRow.grid.style.cellPadding.left;\n        }\n\n        if (typeof this.gridRow.grid.style.cellPadding.top !== 'undefined' && this.gridRow.grid.style.cellPadding.hasTopPad) {\n          returnBounds.y += this.gridRow.grid.style.cellPadding.top + this.cellStyle.borders.top.width;\n          returnBounds.height -= this.gridRow.grid.style.cellPadding.top;\n        }\n\n        if (typeof this.gridRow.grid.style.cellPadding.right !== 'undefined' && this.gridRow.grid.style.cellPadding.hasRightPad) {\n          returnBounds.width -= this.gridRow.grid.style.cellPadding.right;\n        }\n\n        if (typeof this.gridRow.grid.style.cellPadding.bottom !== 'undefined' && this.gridRow.grid.style.cellPadding.hasBottomPad) {\n          returnBounds.height -= this.gridRow.grid.style.cellPadding.bottom;\n        }\n      } else {\n        if (typeof this.style.cellPadding.left !== 'undefined' && this.style.cellPadding.hasLeftPad) {\n          returnBounds.x += this.style.cellPadding.left + this.cellStyle.borders.left.width;\n          returnBounds.width -= this.style.cellPadding.left;\n        }\n\n        if (typeof this.style.cellPadding.top !== 'undefined' && this.style.cellPadding.hasTopPad) {\n          returnBounds.y += this.style.cellPadding.top + this.cellStyle.borders.top.width;\n          returnBounds.height -= this.style.cellPadding.top;\n        }\n\n        if (typeof this.style.cellPadding.right !== 'undefined' && this.style.cellPadding.hasRightPad) {\n          returnBounds.width -= this.style.cellPadding.right;\n        }\n\n        if (typeof this.style.cellPadding.bottom !== 'undefined' && this.style.cellPadding.hasBottomPad) {\n          returnBounds.height -= this.style.cellPadding.bottom;\n        }\n      }\n\n      returnBounds.width -= this.cellStyle.borders.left.width + this.cellStyle.borders.right.width;\n      returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;\n    }\n\n    return returnBounds;\n  };\n  /**\n   * `Draws` the specified graphics.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.draw = function (graphics, bounds, cancelSubsequentSpans) {\n    var isrowbreak = false;\n    /*if (!this.row.grid.isSingleGrid)\n    {\n        //Check whether the Grid Span to Nextpage\n        if ((this.remainingString != null) || (PdfGridLayouter.repeatRowIndex != -1))\n        {\n            this.DrawParentCells(graphics, bounds, true);\n        }\n        else if (this.row.grid.rows.count > 1)\n        {\n            for (let i : number  = 0; i < this.row.grid.rows.count; i++)\n            {\n                if (this.row == this.row.grid.rows.getRow(i))\n                {\n                    if (this.row.grid.rows.getRow(i).rowBreakHeight > 0)\n                        isrowbreak = true;\n                    if ((i > 0) && (isrowbreak))\n                        this.DrawParentCells(graphics, bounds, false);\n                }\n            }\n        }\n    } */\n\n    var result = null;\n    /*if (cancelSubsequentSpans)\n    {\n        //..Cancel all subsequent cell spans, if no space exists.\n        let currentCellIndex : number = this.row.cells.indexOf(this);\n        for (let i : number = currentCellIndex + 1; i <= currentCellIndex + this.colSpan; i++)\n        {\n            this.row.cells.getCell(i).isCellMergeContinue = false;\n            this.row.cells.getCell(i).isRowMergeContinue = false;\n        }\n        this.colSpan = 1;\n    }*/\n    //..Skip cells which were already covered by spanmap.\n\n    if (this.internalIsCellMergeContinue || this.internalIsRowMergeContinue) {\n      if (this.internalIsCellMergeContinue && this.row.grid.style.allowHorizontalOverflow) {\n        if (this.row.rowOverflowIndex > 0 && this.row.cells.indexOf(this) != this.row.rowOverflowIndex + 1 || this.row.rowOverflowIndex == 0 && this.internalIsCellMergeContinue) {\n          return result;\n        }\n      } else {\n        return result;\n      }\n    } //Adjust bounds with Row and Column Spacing\n\n\n    bounds = this.adjustOuterLayoutArea(bounds, graphics);\n    this.drawCellBackground(graphics, bounds);\n    var textPen = this.getTextPen();\n    var textBrush = this.getTextBrush();\n\n    if (typeof textPen === 'undefined' && typeof textBrush === 'undefined') {\n      textBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    }\n\n    var font = this.getTextFont();\n    var strFormat = this.getStringFormat();\n    var innerLayoutArea = bounds;\n\n    if (innerLayoutArea.height >= graphics.clientSize.height) {\n      // If to break row to next page.\n      if (this.row.grid.allowRowBreakAcrossPages) {\n        innerLayoutArea.height -= innerLayoutArea.y; //bounds.height -= bounds.y;\n        // if(this.row.grid.isChildGrid)\n        // {\n        //     innerLayoutArea.height -= this.row.grid.ParentCell.row.grid.style.cellPadding.bottom;\n        // }\n      } // if user choose to cut the row whose height is more than page height.\n      // else\n      // {\n      //     innerLayoutArea.height = graphics.clientSize.height;\n      //     bounds.height = graphics.clientSize.height;\n      // }\n\n    }\n\n    innerLayoutArea = this.adjustContentLayoutArea(innerLayoutArea);\n\n    if (typeof this.objectValue === 'string' || typeof this.remaining === 'string') {\n      var temp = void 0;\n      var layoutRectangle = void 0;\n      if (innerLayoutArea.height < font.height) layoutRectangle = new RectangleF(innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, font.height);else layoutRectangle = innerLayoutArea;\n\n      if (innerLayoutArea.height < font.height && this.row.grid.isChildGrid && this.row.grid.ParentCell != null) {\n        var height = layoutRectangle.height - this.row.grid.ParentCell.row.grid.style.cellPadding.bottom - this.row.grid.style.cellPadding.bottom;\n\n        if (this.row.grid.splitChildRowIndex != -1) {\n          this.fontSpilt = true;\n          this.row.rowFontSplit = true;\n        }\n\n        if (height > 0 && height < font.height) layoutRectangle.height = height; // else if (height + this.row.grid.style.cellPadding.bottom > 0 && height + this.row.grid.style.cellPadding.bottom < font.height)\n        //     layoutRectangle.height = height + this.row.grid.style.cellPadding.bottom;\n        // else if (bounds.height < font.height)\n        //     layoutRectangle.height = bounds.height;\n        // else if (bounds.height - this.row.grid.ParentCell.row.grid.style.cellPadding.bottom < font.height)\n        //     layoutRectangle.height = bounds.height - this.row.grid.ParentCell.row.grid.style.cellPadding.bottom;                        \n      }\n\n      if (this.gridRow.grid.style.cellSpacing != 0) {\n        layoutRectangle.width -= this.gridRow.grid.style.cellSpacing;\n        bounds.width -= this.gridRow.grid.style.cellSpacing;\n      }\n\n      if (this.isFinish) {\n        // if (this.row.grid.splitChildRowIndex != -1 && !this.row.grid.isChildGrid && typeof this.remaining === 'undefined'){\n        //     this.remaining = '';\n        //     graphics.drawString(this.remaining, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n        // } else {\n        temp = this.remaining === '' ? this.remaining : this.objectValue;\n        graphics.drawString(temp, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n\n        if (this.row.grid.splitChildRowIndex != -1 && !this.row.grid.isChildGrid && typeof this.remaining === 'undefined') {\n          this.remaining = ''; //graphics.drawString(this.remaining, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n        }\n      } else {\n        if (typeof this.remaining == 'undefined' || this.remaining === null) {\n          this.remaining = '';\n        }\n\n        if (this.row.repeatFlag) {\n          graphics.drawString(this.remaining, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n        } //  else {\n        //     if(this.row.grid.ParentCell.row.repeatFlag) {\n        //         graphics.drawString((this.remaining as string), font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);                    \n        //     } else {\n        //         layoutRectangle.height = this.row.height;\n        //         graphics.drawString((this.objectValue as string), font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n        //         bounds.height = this.row.height;\n        //     }\n        //  }\n\n\n        this.isFinish = true; //graphics.drawString((this.remaining as string), font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);\n      }\n\n      result = graphics.stringLayoutResult; // if(this.row.grid.isChildGrid && this.row.rowBreakHeight > 0 && result !=null) {\n      //     bounds.height -= this.row.grid.ParentCell.row.grid.style.cellPadding.bottom;\n      // }\n    } else if (this.objectValue instanceof PdfGrid) {\n      var childGrid = this.objectValue;\n      childGrid.isChildGrid = true;\n      childGrid.ParentCell = this;\n      var layoutRect = void 0;\n      layoutRect = innerLayoutArea;\n\n      if (this.gridRow.grid.style.cellSpacing != 0) {\n        bounds.width -= this.gridRow.grid.style.cellSpacing;\n      } // layoutRect = bounds;\n      // if (this.style.cellPadding != null){\n      //     layoutRect = bounds;            \n      // } else if((this.row.grid.style.cellPadding != null) && (childGrid.style.cellPadding.bottom === 0.5) && (childGrid.style.cellPadding.top === 0.5)\n      //                               && (childGrid.style.cellPadding.left === 5.76) && (childGrid.style.cellPadding.right === 5.76)\n      //                               && (this.gridRow.grid.style.cellSpacing === 0) && (childGrid.style.cellSpacing === 0)) {\n      //     layoutRect = innerLayoutArea;\n      // }\n      // if(this.objectValue.style.cellPadding != null && typeof this.objectValue.style.cellPadding !== 'undefined'){\n      //     layoutRect = bounds;\n      // }           \n\n\n      var layouter = new PdfGridLayouter(childGrid);\n      var format = new PdfGridLayoutFormat();\n      if (this.row.grid.LayoutFormat != null) format = this.row.grid.LayoutFormat;else format.layout = PdfLayoutType.Paginate;\n      var param = new PdfLayoutParams();\n\n      if (graphics.layer != null) {\n        // Define layout parameters.\n        param.page = graphics.page;\n        param.bounds = layoutRect;\n        param.format = format; //Set the span \n\n        childGrid.setSpan();\n        childGrid.checkSpan(); // Draw the child grid.\n\n        var childGridResult = layouter.Layouter(param); //let childGridResult : PdfLayoutResult = layouter.innerLayout(param);\n\n        this.value = childGrid;\n\n        if (this.row.grid.splitChildRowIndex !== -1) {\n          this.height = this.row.rowBreakHeightValue;\n        }\n\n        if (param.page != childGridResult.page) //&& (isWidthGreaterthanParent != true))\n          {\n            childGridResult.bounds.height = this.row.rowBreakHeightValue;\n            if (this.row.rowBreakHeight == 0) this.row.NestedGridLayoutResult = childGridResult;else this.row.rowBreakHeight = this.row.rowBreakHeightValue; //bounds.height = this.row.rowBreakHeight;\n            //After drawing paginated nested grid, the bounds of the parent grid in start page should be corrected for borders.\n            //bounds.height = graphics.clientSize.height - bounds.y;\n          }\n      }\n    } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {\n      var imageBounds = void 0;\n\n      if (this.objectValue.width <= innerLayoutArea.width) {\n        imageBounds = new RectangleF(innerLayoutArea.x, innerLayoutArea.y, this.objectValue.width, innerLayoutArea.height);\n      } else {\n        imageBounds = innerLayoutArea;\n      }\n\n      graphics.drawImage(this.objectValue, imageBounds.x, imageBounds.y, imageBounds.width, imageBounds.height);\n    } else if (this.objectValue instanceof PdfTextWebLink) {\n      this.objectValue.draw(graphics.currentPage, innerLayoutArea);\n    } else if (typeof this.objectValue === 'undefined') {\n      this.objectValue = \"\";\n      graphics.drawString(this.objectValue, font, textPen, textBrush, innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, innerLayoutArea.height, strFormat);\n\n      if (this.style.cellPadding != null && this.style.cellPadding.bottom == 0 && this.style.cellPadding.left == 0 && this.style.cellPadding.right == 0 && this.style.cellPadding.top == 0) {\n        bounds.width -= this.style.borders.left.width + this.style.borders.right.width;\n      }\n\n      if (this.gridRow.grid.style.cellSpacing != 0) {\n        bounds.width -= this.gridRow.grid.style.cellSpacing;\n      }\n    }\n\n    if (this.style.borders != null) {\n      if (!this.fontSpilt) this.drawCellBorders(graphics, bounds);else {\n        if (this.row.grid.ParentCell.row.grid.splitChildRowIndex != -1) {\n          this.row.rowFontSplit = false;\n          this.drawCellBorders(graphics, bounds);\n        }\n      }\n    }\n\n    return result;\n  };\n  /* tslint:enable */\n\n  /**\n   * Draws the `cell border` constructed by drawing lines.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.drawCellBorders = function (graphics, bounds) {\n    if (this.row.grid.style.borderOverlapStyle === PdfBorderOverlapStyle.Inside) {\n      bounds.x += this.style.borders.left.width;\n      bounds.y += this.style.borders.top.width;\n      bounds.width -= this.style.borders.right.width;\n      bounds.height -= this.style.borders.bottom.width;\n    }\n\n    var p1 = new PointF(bounds.x, bounds.y + bounds.height);\n    var p2 = new PointF(bounds.x, bounds.y);\n    var pen = this.cellStyle.borders.left;\n\n    if (this.cellStyle.borders.left.dashStyle === PdfDashStyle.Solid) {\n      pen.lineCap = PdfLineCap.Square;\n    } // SetTransparency(ref graphics, pen);\n\n\n    if (pen.width !== 0) {\n      graphics.drawLine(pen, p1, p2);\n    }\n\n    p1 = new PointF(bounds.x + bounds.width, bounds.y);\n    p2 = new PointF(bounds.x + bounds.width, bounds.y + bounds.height);\n    pen = this.cellStyle.borders.right;\n\n    if (bounds.x + bounds.width > graphics.clientSize.width - pen.width / 2) {\n      p1 = new PointF(graphics.clientSize.width - pen.width / 2, bounds.y);\n      p2 = new PointF(graphics.clientSize.width - pen.width / 2, bounds.y + bounds.height);\n    }\n\n    if (this.cellStyle.borders.right.dashStyle === PdfDashStyle.Solid) {\n      pen.lineCap = PdfLineCap.Square;\n    }\n\n    if (pen.width !== 0) {\n      graphics.drawLine(pen, p1, p2);\n    }\n\n    p1 = new PointF(bounds.x, bounds.y);\n    p2 = new PointF(bounds.x + bounds.width, bounds.y);\n    pen = this.cellStyle.borders.top;\n\n    if (this.cellStyle.borders.top.dashStyle === PdfDashStyle.Solid) {\n      pen.lineCap = PdfLineCap.Square;\n    }\n\n    if (pen.width !== 0) {\n      graphics.drawLine(pen, p1, p2);\n    }\n\n    p1 = new PointF(bounds.x + bounds.width, bounds.y + bounds.height);\n    p2 = new PointF(bounds.x, bounds.y + bounds.height);\n    pen = this.cellStyle.borders.bottom;\n\n    if (bounds.y + bounds.height > graphics.clientSize.height - pen.width / 2) {\n      p1 = new PointF(bounds.x + bounds.width, graphics.clientSize.height - pen.width / 2);\n      p2 = new PointF(bounds.x, graphics.clientSize.height - pen.width / 2);\n    }\n\n    if (this.cellStyle.borders.bottom.dashStyle === PdfDashStyle.Solid) {\n      pen.lineCap = PdfLineCap.Square;\n    }\n\n    if (pen.width !== 0) {\n      graphics.drawLine(pen, p1, p2);\n    }\n  }; // private setTransparency(graphics : PdfGraphics, pen : PdfPen) : void {\n  //     let alpha : number = (pen.color.a / 255)as number;\n  //     graphics.save();\n  //     graphics.setTransparency(alpha);\n  // }\n\n  /**\n   * `Adjusts the outer layout area`.\n   * @private\n   */\n\n  /* tslint:disable */\n\n\n  PdfGridCell.prototype.adjustOuterLayoutArea = function (bounds, g) {\n    var isHeader = false;\n    var cellSpacing = this.row.grid.style.cellSpacing;\n\n    if (cellSpacing > 0) {\n      bounds = new RectangleF(bounds.x + cellSpacing, bounds.y + cellSpacing, bounds.width - cellSpacing, bounds.height - cellSpacing);\n    }\n\n    var currentColIndex = this.row.cells.indexOf(this);\n\n    if (this.columnSpan > 1 || this.row.rowOverflowIndex > 0 && currentColIndex == this.row.rowOverflowIndex + 1 && this.isCellMergeContinue) {\n      var span = this.columnSpan;\n\n      if (span == 1 && this.isCellMergeContinue) {\n        for (var j = currentColIndex + 1; j < this.row.grid.columns.count; j++) {\n          if (this.row.cells.getCell(j).isCellMergeContinue) span++;else break;\n        }\n      }\n\n      var totalWidth = 0;\n\n      for (var i = currentColIndex; i < currentColIndex + span; i++) {\n        if (this.row.grid.style.allowHorizontalOverflow) {\n          var width = void 0;\n          var compWidth = this.row.grid.size.width < g.clientSize.width ? this.row.grid.size.width : g.clientSize.width;\n\n          if (this.row.grid.size.width > g.clientSize.width) {\n            width = bounds.x + totalWidth + this.row.grid.columns.getColumn(i).width;\n          } else {\n            width = totalWidth + this.row.grid.columns.getColumn(i).width;\n          }\n\n          if (width > compWidth) {\n            break;\n          }\n        }\n\n        totalWidth += this.row.grid.columns.getColumn(i).width;\n      }\n\n      totalWidth -= this.row.grid.style.cellSpacing;\n      bounds.width = totalWidth;\n    }\n\n    if (this.rowSpan > 1 || this.row.rowSpanExists) {\n      var span = this.rowSpan;\n      var currentRowIndex = this.row.grid.rows.rowCollection.indexOf(this.row);\n\n      if (currentRowIndex == -1) {\n        currentRowIndex = this.row.grid.headers.indexOf(this.row);\n\n        if (currentRowIndex != -1) {\n          isHeader = true;\n        }\n      } // if (span == 1 && this.isCellMergeContinue) {\n      //         for (let j : number = currentRowIndex + 1; j < this.row.grid.rows.count; j++)\n      //         {\n      //             let flag : boolean = (isHeader ? this.row.grid.headers.getHeader(j).cells.getCell(currentColIndex).isCellMergeContinue : this.row.grid.rows.getRow(j).cells.getCell(currentColIndex).isCellMergeContinue);\n      //             if (flag)\n      //                 span++;\n      //             else\n      //                 break;\n      //         }\n      // }\n\n\n      var totalHeight = 0;\n      var max = 0;\n\n      for (var i = currentRowIndex; i < currentRowIndex + span; i++) {\n        totalHeight += isHeader ? this.row.grid.headers.getHeader(i).height : this.row.grid.rows.getRow(i).height;\n        var row = this.row.grid.rows.getRow(i);\n        var rowIndex = this.row.grid.rows.rowCollection.indexOf(row);\n        /*if (this.rowSpan > 1)\n            {\n                for (let k : number = 0; k < this.row.cells.count; k++) {\n                    let cell : PdfGridCell = this.row.cells.getCell(k);\n                    if(cell.rowSpan>1)\n                    {\n                        let tempHeight : number =0;\n                        \n                        for (let j :number = i; j < i +cell.rowSpan; j++)\n                        {\n                            if (!this.row.grid.rows.getRow(j).isRowSpanRowHeightSet)\n                                this.row.grid.rows.getRow(j).isRowHeightSet = false;\n                            tempHeight += this.row.grid.rows.getRow(j).height;\n                            if (!this.row.grid.rows.getRow(j).isRowSpanRowHeightSet)\n                                this.row.grid.rows.getRow(j).isRowHeightSet = true;\n                        }\n                        //To check the Row spanned cell height is greater than the total spanned row height.\n                        if(cell.height>tempHeight)\n                        {\n                            if (max < (cell.height - tempHeight))\n                            {\n                                max = cell.height - tempHeight;\n                                if (this.rowSpanRemainingHeight != 0 && max > this.rowSpanRemainingHeight)\n                                {\n                                    max += this.rowSpanRemainingHeight;\n                                }\n                                let index :number = row.cells.indexOf(cell);\n                                //set the m_rowspanRemainingHeight to last rowspanned row.\n                                this.row.grid.rows.getRow((rowIndex +cell.rowSpan) - 1).cells.getCell(index).rowSpanRemainingHeight = max;\n                                this.rowSpanRemainingHeight = this.row.grid.rows.getRow((rowIndex + cell.rowSpan) - 1).cells.getCell(index).rowSpanRemainingHeight;\n                            }\n                        }\n                    }\n                }\n            }\n            if (!this.row.grid.rows.getRow(i).isRowSpanRowHeightSet)\n            this.row.grid.rows.getRow(i).isRowHeightSet = true;*/\n      }\n\n      var cellIndex = this.row.cells.indexOf(this);\n      totalHeight -= this.row.grid.style.cellSpacing; // if (this.row.cells.getCell(cellIndex).height > totalHeight && (!this.row.grid.rows.getRow((currentRowIndex + span) - 1).isRowHeightSet)) {\n      //      this.row.grid.rows.getRow((currentRowIndex + span) - 1).cells.getCell(cellIndex).rowSpanRemainingHeight = this.row.cells.getCell(cellIndex).height - totalHeight;\n      //      totalHeight = this.row.cells.getCell(cellIndex).height;\n      //      bounds.height = totalHeight;\n      // } else {\n\n      bounds.height = totalHeight; //  }\n\n      if (!this.row.rowMergeComplete) {\n        bounds.height = totalHeight;\n      }\n    }\n\n    return bounds;\n  };\n  /* tslint:enable */\n\n  /**\n   * Gets the `text font`.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.getTextFont = function () {\n    if (typeof this.style.font !== 'undefined' && this.style.font != null) {\n      return this.style.font;\n    } else if (typeof this.row.style.font !== 'undefined' && this.row.style.font != null) {\n      return this.row.style.font;\n    } else if (typeof this.row.grid.style.font !== 'undefined' && this.row.grid.style.font != null) {\n      return this.row.grid.style.font;\n    } else {\n      return PdfDocument.defaultFont;\n    }\n  };\n  /**\n   * Gets the `text brush`.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.getTextBrush = function () {\n    if (typeof this.style.textBrush !== 'undefined' && this.style.textBrush != null) {\n      return this.style.textBrush;\n    } else if (typeof this.row.style.textBrush !== 'undefined' && this.row.style.textBrush != null) {\n      return this.row.style.textBrush;\n    } else {\n      return this.row.grid.style.textBrush;\n    }\n  };\n  /**\n   * Gets the `text pen`.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.getTextPen = function () {\n    if (typeof this.style.textPen !== 'undefined' && this.style.textPen != null) {\n      return this.style.textPen;\n    } else if (typeof this.row.style.textPen !== 'undefined' && this.row.style.textPen != null) {\n      return this.row.style.textPen;\n    } else {\n      return this.row.grid.style.textPen;\n    }\n  };\n  /**\n   * Gets the `background brush`.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.getBackgroundBrush = function () {\n    if (typeof this.style.backgroundBrush !== 'undefined' && this.style.backgroundBrush != null) {\n      return this.style.backgroundBrush;\n    } else if (typeof this.row.style.backgroundBrush !== 'undefined' && this.row.style.backgroundBrush != null) {\n      return this.row.style.backgroundBrush;\n    } else {\n      return this.row.grid.style.backgroundBrush;\n    }\n  };\n  /**\n   * Gets the `background image`.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.getBackgroundImage = function () {\n    if (typeof this.style.backgroundImage !== 'undefined' && this.style.backgroundImage != null) {\n      return this.style.backgroundImage;\n    } else if (typeof this.row.style.backgroundImage !== 'undefined' && this.row.style.backgroundImage != null) {\n      return this.row.style.backgroundImage;\n    } else {\n      return this.row.grid.style.backgroundImage;\n    }\n  };\n  /**\n   * Gets the current `StringFormat`.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.getStringFormat = function () {\n    if (typeof this.style.stringFormat !== 'undefined' && this.style.stringFormat != null) {\n      return this.style.stringFormat;\n    } else {\n      return this.stringFormat;\n    }\n  };\n  /**\n   * Calculates the `height`.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.measureHeight = function () {\n    // .. Calculate the cell text height.\n    // .....Add border widths, cell spacings and paddings to the height.\n    var width = this.calculateWidth(); // //check whether the Current PdfGridCell has padding\n\n    if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n      width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left; //width -= (this.style.borders.left.width + this.style.borders.right.width);\n    } else {\n      width -= this.style.cellPadding.right + this.style.cellPadding.left;\n      width -= this.style.borders.left.width + this.style.borders.right.width;\n    }\n\n    var height = 0;\n    var layouter = new PdfStringLayouter();\n\n    if (typeof this.objectValue === 'string' || typeof this.remaining === 'string') {\n      var currentValue = this.objectValue;\n      /* tslint:disable */\n\n      if (!this.isFinish) currentValue = !(this.remaining === null || this.remaining === '' || typeof this.remaining === 'undefined') ? this.remaining : this.objectValue;\n      var slr = null;\n      var cellIndex = this.row.cells.indexOf(this);\n\n      if (this.gridRow.grid.style.cellSpacing != 0) {\n        width -= this.gridRow.grid.style.cellSpacing * 2;\n      }\n\n      if (!this.row.cells.getCell(cellIndex).hasColSpan && !this.row.cells.getCell(cellIndex).hasRowSpan) {\n        if (this.gridRow.grid.isChildGrid) {\n          if (width < 0) {\n            this.tempval = width;\n\n            if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n              this.tempval += this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;\n            } else {\n              this.tempval += this.style.cellPadding.right + this.style.cellPadding.left;\n              this.tempval += this.style.borders.left.width + this.style.borders.right.width;\n            }\n          } else {\n            this.tempval = width;\n          }\n\n          slr = layouter.layout(currentValue, this.getTextFont(), this.stringFormat, new SizeF(this.tempval, 0), false, new SizeF(0, 0));\n          height += slr.actualSize.height;\n        } else {\n          slr = layouter.layout(currentValue, this.getTextFont(), this.stringFormat, new SizeF(width, 0), false, new SizeF(0, 0));\n          height += slr.actualSize.height;\n        }\n      }\n      /* tslint:enable */\n\n\n      height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;\n    } else if (this.objectValue instanceof PdfGrid) {\n      var cellIndex = this.row.cells.indexOf(this);\n      var internalWidth = 0;\n\n      if (this.style.cellPadding != null || typeof this.style.cellPadding !== 'undefined') {\n        internalWidth = this.calculateWidth();\n\n        if (typeof this.style.cellPadding.left !== 'undefined' && this.style.cellPadding.hasLeftPad) {\n          internalWidth -= this.style.cellPadding.left;\n        }\n\n        if (typeof this.style.cellPadding.right !== 'undefined' && this.style.cellPadding.hasRightPad) {\n          internalWidth -= this.style.cellPadding.right;\n        }\n      } else if (this.row.grid.style.cellPadding != null || typeof this.row.grid.style.cellPadding !== 'undefined') {\n        internalWidth = this.calculateWidth();\n\n        if (typeof this.row.grid.style.cellPadding.left !== 'undefined' && this.row.grid.style.cellPadding.hasLeftPad) {\n          internalWidth -= this.row.grid.style.cellPadding.left;\n        }\n\n        if (typeof this.row.grid.style.cellPadding.right !== 'undefined' && this.row.grid.style.cellPadding.hasRightPad) {\n          internalWidth -= this.row.grid.style.cellPadding.right;\n        }\n      } else {\n        internalWidth = this.calculateWidth();\n      }\n\n      this.objectValue.tempWidth = internalWidth;\n\n      if (!this.row.cells.getCell(cellIndex).hasColSpan && !this.row.cells.getCell(cellIndex).hasRowSpan) {\n        height = this.objectValue.size.height;\n      } else {\n        height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;\n      }\n\n      if (this.gridRow.grid.style.cellSpacing !== 0) {\n        width -= this.gridRow.grid.style.cellSpacing * 2; //height += (this.row.grid.style.cellPadding.top + this.row.grid.style.cellPadding.bottom);\n      }\n\n      if (this.style.cellPadding != null || typeof this.style.cellPadding !== 'undefined') {\n        if (typeof this.row.grid.style.cellPadding.top !== 'undefined' && this.row.grid.style.cellPadding.hasTopPad) {\n          height += this.row.grid.style.cellPadding.top;\n        }\n\n        if (this.row.grid.style.cellPadding.hasBottomPad && typeof this.row.grid.style.cellPadding.bottom !== 'undefined') {\n          height += this.row.grid.style.cellPadding.bottom;\n        }\n      }\n\n      height += this.objectValue.style.cellSpacing;\n    } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {\n      height += this.objectValue.height;\n    } else if (this.objectValue instanceof PdfTextWebLink) {\n      var webLink = this.objectValue;\n      /* tslint:disable */\n\n      var slr = layouter.layout(webLink.text, webLink.font, webLink.stringFormat, new SizeF(width, 0), false, new SizeF(0, 0));\n      /* tslint:enable */\n\n      height += slr.actualSize.height;\n      height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;\n    } else if (typeof this.objectValue === 'undefined') {\n      if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n        width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;\n      } else {\n        width -= this.style.cellPadding.right + this.style.cellPadding.left;\n        width -= this.style.borders.left.width + this.style.borders.right.width;\n      }\n\n      height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;\n    } //Add padding top and bottom value to height\n\n\n    if (!(this.objectValue instanceof PdfGrid)) {\n      if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n        height += this.row.grid.style.cellPadding.top + this.row.grid.style.cellPadding.bottom;\n      } else {\n        height += this.style.cellPadding.top + this.style.cellPadding.bottom;\n      }\n    } else {\n      if (this.style.cellPadding == null || typeof this.style.cellPadding === 'undefined') {\n        if (typeof this.row.grid.style.cellPadding.top !== 'undefined' && this.row.grid.style.cellPadding.hasTopPad) {\n          height += this.row.grid.style.cellPadding.top;\n        }\n\n        if (typeof this.row.grid.style.cellPadding.bottom !== 'undefined' && this.row.grid.style.cellPadding.hasBottomPad) {\n          height += this.row.grid.style.cellPadding.bottom;\n        }\n      } else {\n        if (typeof this.style.cellPadding.top !== 'undefined' && this.style.cellPadding.hasTopPad) {\n          height += this.style.cellPadding.top;\n        }\n\n        if (typeof this.style.cellPadding.bottom !== 'undefined' && this.style.cellPadding.hasBottomPad) {\n          height += this.style.cellPadding.bottom;\n        }\n      }\n    }\n\n    height += this.row.grid.style.cellSpacing;\n    return height;\n  };\n  /**\n   * return the calculated `width` of the cell.\n   * @private\n   */\n\n\n  PdfGridCell.prototype.calculateWidth = function () {\n    var cellIndex = this.row.cells.indexOf(this);\n    var rowindex = this.row.grid.rows.rowCollection.indexOf(this.row);\n    var columnSpan = this.columnSpan;\n    var width = 0;\n\n    if (columnSpan === 1) {\n      for (var i = 0; i < columnSpan; i++) {\n        width += this.row.grid.columns.getColumn(cellIndex + i).width;\n      }\n    } else if (columnSpan > 1) {\n      for (var i = 0; i < columnSpan; i++) {\n        width += this.row.grid.columns.getColumn(cellIndex + i).width;\n\n        if (i + 1 < columnSpan) {\n          this.row.cells.getCell(cellIndex + i + 1).hasColSpan = true;\n        }\n      }\n    }\n\n    if (this.parent != null && this.parent.row.width > 0) {\n      if (this.row.grid.isChildGrid && this.parent != null && this.row.width > this.parent.row.width) {\n        width = 0;\n\n        for (var j = 0; j < this.parent.columnSpan; j++) {\n          width += this.parent.row.grid.columns.getColumn(j).width;\n        }\n\n        width = width / this.row.cells.count;\n      }\n    }\n\n    return width;\n  };\n\n  return PdfGridCell;\n}();\n\nexport { PdfGridCell };\n/**\n * `PdfGridCellCollection` class provides access to an ordered,\n * strongly typed collection of 'PdfGridCell' objects.\n * @private\n */\n\nvar PdfGridCellCollection =\n/** @class */\nfunction () {\n  //Constructor\n\n  /**\n   * Initializes a new instance of the `PdfGridCellCollection` class with the row.\n   * @private\n   */\n  function PdfGridCellCollection(row) {\n    /**\n     * @hidden\n     * @private\n     */\n    this.cells = [];\n    this.gridRow = row;\n  } //Properties\n\n  /**\n   * Gets the current `cell`.\n   * @private\n   */\n\n\n  PdfGridCellCollection.prototype.getCell = function (index) {\n    if (index < 0 || index >= this.count) {\n      throw new Error('IndexOutOfRangeException');\n    }\n\n    return this.cells[index];\n  };\n\n  Object.defineProperty(PdfGridCellCollection.prototype, \"count\", {\n    /**\n     * Gets the cells `count`.[Read-Only].\n     * @private\n     */\n    get: function () {\n      return this.cells.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  PdfGridCellCollection.prototype.add = function (cell) {\n    if (typeof cell === 'undefined') {\n      var tempcell = new PdfGridCell();\n      this.add(tempcell);\n      return cell;\n    } else {\n      cell.row = this.gridRow;\n      this.cells.push(cell);\n    }\n  };\n  /**\n   * Returns the `index of` a particular cell in the collection.\n   * @private\n   */\n\n\n  PdfGridCellCollection.prototype.indexOf = function (cell) {\n    return this.cells.indexOf(cell);\n  };\n\n  return PdfGridCellCollection;\n}();\n\nexport { PdfGridCellCollection };","map":null,"metadata":{},"sourceType":"module"}