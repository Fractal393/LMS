{"ast":null,"code":"import * as events from '../base/constant';\nimport { Workbook } from '@syncfusion/ej2-excel-export';\nimport { isNullOrUndefined, getEnumValue, compile, getValue, detach, extend, isBlazor } from '@syncfusion/ej2-base';\nimport { Data } from '../actions/data';\nimport { ExportHelper, ExportValueFormatter } from './export-helper';\nimport { SummaryModelGenerator, GroupSummaryModelGenerator, CaptionSummaryModelGenerator } from '../services/summary-model-generator';\nimport { CellType, AggregateTemplateType } from '../base/enum';\nimport { Query, DataManager } from '@syncfusion/ej2-data';\nimport { getPrintGridModel, getUid, isExportColumns, updateColumnTypeForExportColumns, prepareColumns } from '../base/util';\n/**\n * @hidden\n * `ExcelExport` module is used to handle the Excel export action.\n */\n\nvar ExcelExport =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the Grid Excel Export module.\n   * @hidden\n   */\n  function ExcelExport(parent, locator) {\n    /* tslint:disable-next-line:no-any */\n    this.book = {};\n    this.workSheet = [];\n    this.rows = [];\n    this.columns = [];\n    this.styles = [];\n    this.rowLength = 1;\n    this.expType = 'AppendToSheet';\n    this.includeHiddenColumn = false;\n    this.isCsvExport = false;\n    this.isElementIdChanged = false;\n    this.foreignKeyData = {};\n    this.gridPool = {};\n    this.parent = parent;\n    this.helper = new ExportHelper(parent);\n    this.locator = locator;\n    this.l10n = this.locator.getService('localization');\n  }\n  /**\n   * For internal use only - Get the module name.\n   */\n\n\n  ExcelExport.prototype.getModuleName = function () {\n    return 'ExcelExport';\n  };\n\n  ExcelExport.prototype.init = function (gObj) {\n    if (gObj.element !== null && gObj.element.id === '') {\n      gObj.element.id = new Date().toISOString();\n      this.isElementIdChanged = true;\n    }\n\n    this.parent = gObj;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.isExporting = undefined;\n    this.book = {};\n    this.workSheet = [];\n    this.rows = [];\n    this.columns = [];\n    this.styles = [];\n    this.rowLength = 1;\n    this.footer = undefined;\n    this.expType = 'AppendToSheet';\n    this.includeHiddenColumn = false;\n    this.exportValueFormatter = new ExportValueFormatter(gObj.locale);\n    gObj.id = getUid('main-grid');\n    this.gridPool[gObj.id] = false;\n  };\n  /**\n   * Export Grid to Excel file.\n   * @param  {exportProperties} exportProperties - Defines the export properties of the Grid.\n   * @param  {isMultipleExport} isMultipleExport - Defines is multiple Grid's are exported.\n   * @param  {workbook} workbook - Defined the Workbook if multiple Grid is exported.\n   * @param  {isCsv} isCsv - true if export to CSV.\n   * @return {Promise<any>}\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n\n  /* tslint:disable-next-line:no-any */\n\n\n  ExcelExport.prototype.Map = function (grid, exportProperties, isMultipleExport, workbook, isCsv, isBlob) {\n    var gObj = grid;\n    var cancel = 'cancel';\n    var isBlb = 'isBlob';\n    var csv = 'isCsv';\n    var workbk = 'workbook';\n    var isMultiEx = 'isMultipleExport';\n    this.gridPool = {};\n\n    if (grid.childGrid && !(!isNullOrUndefined(exportProperties) && exportProperties.hierarchyExportMode === 'None')) {\n      grid.expandedRows = getPrintGridModel(grid).expandedRows;\n    }\n\n    var args = {\n      requestType: 'beforeExcelExport',\n      gridObject: gObj,\n      cancel: false,\n      isMultipleExport: isMultipleExport,\n      workbook: workbook,\n      isCsv: isCsv,\n      isBlob: isBlob\n    };\n    gObj.trigger(events.beforeExcelExport, args);\n\n    if (args[cancel]) {\n      return new Promise(function (resolve, reject) {\n        return resolve();\n      });\n    }\n\n    this.parent.log('exporting_begin', this.getModuleName());\n    this.data = new Data(gObj);\n    this.isExporting = true;\n    this.isBlob = args[isBlb];\n\n    if (args[csv]) {\n      this.isCsvExport = args[csv];\n    } else {\n      this.isCsvExport = false;\n    }\n\n    if (isExportColumns(exportProperties)) {\n      updateColumnTypeForExportColumns(exportProperties, gObj);\n    }\n\n    return this.processRecords(gObj, exportProperties, args[isMultiEx], args[workbk]);\n  };\n\n  ExcelExport.prototype.exportingSuccess = function (resolve) {\n    this.isExporting = false;\n    this.parent.trigger(events.excelExportComplete, this.isBlob ? {\n      promise: this.blobPromise\n    } : {});\n    this.parent.log('exporting_complete', this.getModuleName());\n    resolve(this.book);\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  ExcelExport.prototype.processRecords = function (gObj, exportProperties, isMultipleExport, workbook) {\n    var _this = this;\n\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.dataSource)) {\n      if (!(exportProperties.dataSource instanceof DataManager)) {\n        exportProperties.dataSource = new DataManager(exportProperties.dataSource);\n      }\n\n      var query_1 = exportProperties.query ? exportProperties.query : new Query();\n\n      if (isNullOrUndefined(query_1.isCountRequired) || gObj.aggregates) {\n        query_1.isCountRequired = true;\n      }\n\n      return new Promise(function (resolve, reject) {\n        var dataManager = exportProperties.dataSource.executeQuery(query_1);\n        dataManager.then(function (r) {\n          _this.init(gObj);\n\n          _this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, r).then(function () {\n            _this.exportingSuccess(resolve);\n          });\n        });\n      });\n    } else if (!isNullOrUndefined(exportProperties) && exportProperties.exportType === 'CurrentPage') {\n      return new Promise(function (resolve, reject) {\n        _this.init(gObj);\n\n        _this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, _this.parent.getCurrentViewRecords());\n\n        _this.exportingSuccess(resolve);\n      });\n    } else {\n      var allPromise_1 = [];\n      allPromise_1.push(this.data.getData({}, ExportHelper.getQuery(gObj, this.data)));\n      allPromise_1.push(this.helper.getColumnData(gObj));\n      return new Promise(function (resolve, reject) {\n        Promise.all(allPromise_1).then(function (e) {\n          _this.init(gObj);\n\n          _this.processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, e[0]).then(function () {\n            _this.exportingSuccess(resolve);\n          });\n        }).catch(function (e) {\n          reject(_this.book);\n\n          _this.parent.trigger(events.actionFailure, e);\n        });\n      });\n    }\n  };\n  /* tslint:disable-next-line:max-func-body-length */\n\n\n  ExcelExport.prototype.processInnerRecords = function (gObj, exportProperties,\n  /* tslint:disable-next-line:no-any */\n  isMultipleExport, workbook, r) {\n    var _this = this;\n\n    this.groupedColLength = gObj.groupSettings.columns.length;\n    var blankRows = 5;\n    var separator;\n    var rows = [];\n    var isExportPropertiesPresent = !isNullOrUndefined(exportProperties);\n\n    if (isExportPropertiesPresent && !isNullOrUndefined(exportProperties.multipleExport)) {\n      /* tslint:disable-next-line:max-line-length */\n      this.expType = !isNullOrUndefined(exportProperties.multipleExport.type) ? exportProperties.multipleExport.type : 'AppendToSheet';\n\n      if (!isNullOrUndefined(exportProperties.multipleExport.blankRows)) {\n        blankRows = exportProperties.multipleExport.blankRows;\n      }\n    }\n\n    if (isNullOrUndefined(workbook)) {\n      this.workSheet = [];\n      this.rows = [];\n      this.columns = [];\n      this.styles = [];\n    } else if (this.expType === 'NewSheet') {\n      this.workSheet = workbook.worksheets;\n      this.rows = [];\n      this.columns = [];\n      this.styles = workbook.styles;\n    } else {\n      this.workSheet = [];\n      this.rows = workbook.worksheets[0].rows;\n      this.columns = workbook.worksheets[0].columns;\n      this.styles = workbook.styles;\n      this.rowLength = this.rows[this.rows.length - 1].index + blankRows;\n      this.rowLength++;\n    }\n\n    if (isExportPropertiesPresent) {\n      if (!isNullOrUndefined(isMultipleExport)) {\n        if (!isNullOrUndefined(exportProperties.header) && (isMultipleExport || this.expType === 'NewSheet')) {\n          this.processExcelHeader(JSON.parse(JSON.stringify(exportProperties.header)));\n        }\n\n        if (!isNullOrUndefined(exportProperties.footer)) {\n          if (this.expType === 'AppendToSheet') {\n            if (!isMultipleExport) {\n              this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n            }\n          } else {\n            this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n          }\n        }\n      } else {\n        if (!isNullOrUndefined(exportProperties.header)) {\n          this.processExcelHeader(JSON.parse(JSON.stringify(exportProperties.header)));\n        }\n\n        if (!isNullOrUndefined(exportProperties.footer)) {\n          this.footer = JSON.parse(JSON.stringify(exportProperties.footer));\n        }\n      }\n    }\n\n    this.includeHiddenColumn = isExportPropertiesPresent ? exportProperties.includeHiddenColumn : false;\n    return new Promise(function (resolve, reject) {\n      gObj.childGridLevel = 0;\n      rows = _this.processGridExport(gObj, exportProperties, r);\n      _this.globalResolve = resolve;\n      _this.gridPool[gObj.id] = true;\n\n      _this.helper.checkAndExport(_this.gridPool, _this.globalResolve);\n    }).then(function () {\n      var organisedRows = [];\n\n      _this.organiseRows(rows, rows[0].index, organisedRows);\n\n      _this.rows = _this.rows.concat(organisedRows); //footer template add\n\n      if (!isNullOrUndefined(_this.footer)) {\n        if (_this.expType === 'AppendToSheet' && !isMultipleExport || _this.expType === 'NewSheet') {\n          _this.processExcelFooter(_this.footer);\n        }\n      }\n\n      var sheet = {};\n\n      if (_this.columns.length > 0) {\n        sheet.columns = _this.columns;\n      }\n      /* tslint:disable-next-line:no-any */\n\n\n      sheet.rows = _this.rows;\n\n      _this.workSheet.push(sheet);\n\n      _this.book.worksheets = _this.workSheet;\n      _this.book.styles = _this.styles;\n      gObj.notify('finalPageSetup', _this.book);\n\n      if (!isMultipleExport) {\n        if (_this.isCsvExport) {\n          if (isBlazor() && gObj.isServerRendered) {\n            _this.book.isServerRendered = gObj.isServerRendered;\n          }\n\n          if (isExportPropertiesPresent && !isNullOrUndefined(exportProperties.separator) && exportProperties.separator !== ',') {\n            separator = exportProperties.separator;\n          }\n          /* tslint:disable-next-line:max-line-length */\n\n\n          var book = new Workbook(_this.book, 'csv', gObj.locale, gObj.currencyCode, separator);\n\n          if (!_this.isBlob) {\n            if (isExportPropertiesPresent && exportProperties.fileName) {\n              book.save(exportProperties.fileName);\n            } else {\n              book.save('Export.csv');\n            }\n          } else {\n            _this.blobPromise = book.saveAsBlob('text/csv');\n          }\n        } else {\n          var book = new Workbook(_this.book, 'xlsx', gObj.locale, gObj.currencyCode);\n\n          if (!_this.isBlob) {\n            if (isExportPropertiesPresent && exportProperties.fileName) {\n              book.save(exportProperties.fileName);\n            } else {\n              book.save('Export.xlsx');\n            }\n          } else {\n            _this.blobPromise = book.saveAsBlob('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n          }\n        }\n\n        if (_this.isElementIdChanged) {\n          gObj.element.id = '';\n        }\n\n        delete gObj.expandedRows;\n      }\n\n      return workbook;\n    });\n  };\n\n  ExcelExport.prototype.organiseRows = function (rows, initialIndex, organisedRows) {\n    if (!rows.length) {\n      return initialIndex;\n    }\n\n    for (var i = 0; i < rows.length; i++) {\n      var row = rows[i];\n      var childRows = row.childRows;\n\n      if (childRows) {\n        row.index = initialIndex++;\n        delete row.childRows;\n        organisedRows.push(row);\n        initialIndex = this.organiseRows(childRows, initialIndex, organisedRows);\n      } else {\n        row.index = initialIndex++;\n        organisedRows.push(row);\n      }\n    }\n\n    return initialIndex;\n  };\n\n  ExcelExport.prototype.processGridExport = function (gObj, exportProperties, r) {\n    var excelRows = [];\n\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.theme)) {\n      this.theme = exportProperties.theme;\n    }\n\n    if (gObj.childGrid && !isNullOrUndefined(exportProperties)) {\n      gObj.hierarchyPrintMode = exportProperties.hierarchyExportMode || 'Expanded';\n    }\n\n    var helper = new ExportHelper(gObj);\n    var gColumns = isExportColumns(exportProperties) ? prepareColumns(exportProperties.columns, gObj.enableColumnVirtualization) : helper.getGridExportColumns(gObj.columns);\n    var headerRow = helper.getHeaders(gColumns, this.includeHiddenColumn);\n    var groupIndent = gObj.groupSettings.columns.length;\n    excelRows = this.processHeaderContent(gObj, headerRow, groupIndent, excelRows);\n    /* tslint:disable-next-line:max-line-length */\n\n    if (!isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.dataSource) && !(exportProperties.dataSource instanceof DataManager)) {\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, exportProperties.dataSource, excelRows, helper);\n    } else if (!isNullOrUndefined(exportProperties) && exportProperties.exportType === 'CurrentPage') {\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, gObj.currentViewData, excelRows, helper);\n    } else {\n      excelRows = this.processRecordContent(gObj, r, headerRow, exportProperties, undefined, excelRows, helper);\n    }\n\n    gObj.notify(events.exportDataBound, {\n      excelRows: excelRows,\n      type: 'excel'\n    });\n    return excelRows;\n  };\n\n  ExcelExport.prototype.processRecordContent = function (gObj, returnType, headerRow, exportProperties, currentViewRecords, excelRow, helper) {\n    var record;\n\n    if (!isNullOrUndefined(currentViewRecords) && currentViewRecords.length) {\n      record = currentViewRecords;\n    } else {\n      record = returnType.result;\n    }\n\n    if (!isNullOrUndefined(record.level)) {\n      this.processGroupedRows(gObj, record, headerRow, record.level, 0, exportProperties, excelRow, helper);\n    } else {\n      this.processRecordRows(gObj, record, headerRow, 0, 0, exportProperties, excelRow, helper);\n    }\n\n    if (!isNullOrUndefined(returnType.aggregates)) {\n      if (!isNullOrUndefined(currentViewRecords)) {\n        this.processAggregates(gObj, returnType.result, excelRow, currentViewRecords);\n      } else {\n        var result = returnType.result.GroupGuid ? returnType.result.records : returnType.result;\n        this.processAggregates(gObj, result, excelRow, null, null, null, headerRow.columns);\n      }\n    }\n\n    return excelRow;\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  ExcelExport.prototype.processGroupedRows = function (gObj, dataSource, headerRow, level, startIndex, excelExportProperties, excelRows, helper) {\n    for (var _i = 0, dataSource_1 = dataSource; _i < dataSource_1.length; _i++) {\n      var item = dataSource_1[_i];\n      var cells = [];\n      var index = 1;\n      /* tslint:disable-next-line:no-any */\n\n      var cell = {};\n      cell.index = index + level;\n      var col = gObj.getColumnByField(item.field);\n      /* tslint:disable-next-line:no-any */\n\n      var args = {\n        value: item.key,\n        column: col,\n        style: undefined,\n        isForeignKey: col.isForeignColumn()\n      };\n      var value = gObj.getColumnByField(item.field).headerText + ': ' + (!col.enableGroupByFormat ? this.exportValueFormatter.formatCellValue(args) : item.key) + ' - ';\n\n      if (item.count > 1) {\n        value += item.count + ' items';\n      } else {\n        value += item.count + ' item';\n      }\n\n      var cArgs = {\n        captionText: value,\n        type: this.isCsvExport ? 'CSV' : 'Excel'\n      };\n      this.parent.trigger(events.exportGroupCaption, cArgs);\n      cell.value = cArgs.captionText;\n      cell.style = this.getCaptionThemeStyle(this.theme);\n      var captionModelGen = new CaptionSummaryModelGenerator(gObj);\n      var groupCaptionSummaryRows = captionModelGen.generateRows(item);\n      this.fillAggregates(gObj, groupCaptionSummaryRows, dataSource.level + dataSource.childLevels, excelRows, this.rowLength);\n      cells.push(cell);\n\n      if (excelRows[excelRows.length - 1].cells.length > 0) {\n        var lIndex = dataSource.level + dataSource.childLevels + groupCaptionSummaryRows[0].cells.length;\n        var hIndex = 0;\n\n        for (var _a = 0, _b = excelRows[excelRows.length - 1].cells; _a < _b.length; _a++) {\n          var tCell = _b[_a];\n\n          if (tCell.index < lIndex) {\n            lIndex = tCell.index;\n          }\n\n          if (tCell.index > hIndex) {\n            hIndex = tCell.index;\n          }\n\n          if (cells[cells.length - 1].index !== tCell.index) {\n            cells.push(tCell);\n          }\n        }\n\n        if (lIndex - cell.index > 1) {\n          cell.colSpan = lIndex - cell.index;\n        }\n\n        while (hIndex < headerRow.columns.length + level + dataSource.childLevels) {\n          /* tslint:disable-next-line:no-any */\n          var sCell = {};\n          sCell.index = hIndex + 1;\n          sCell.style = this.getCaptionThemeStyle(this.theme);\n          cells.push(sCell);\n          hIndex++;\n        }\n      } else {\n        var span = 0; //Calculation for column span when group caption dont have aggregates\n\n        for (var _c = 0, _d = headerRow.columns; _c < _d.length; _c++) {\n          var col_1 = _d[_c];\n\n          if (col_1.visible) {\n            span++;\n          }\n        }\n\n        cell.colSpan = dataSource.childLevels + span;\n      }\n\n      excelRows[excelRows.length - 1].cells = cells;\n      this.rowLength++;\n\n      if (this.groupedColLength < 8 && level > 1) {\n        var grouping = {\n          outlineLevel: level - 1,\n          isCollapsed: true\n        };\n        excelRows[excelRows.length - 1].grouping = grouping;\n      }\n\n      if (!isNullOrUndefined(dataSource.childLevels) && dataSource.childLevels > 0) {\n        this.processGroupedRows(gObj, item.items, headerRow, item.items.level, startIndex, excelExportProperties, excelRows, helper);\n      } else {\n        startIndex = this.processRecordRows(gObj, item.items, headerRow, level, startIndex, excelExportProperties, excelRows, helper);\n        this.processAggregates(gObj, item, excelRows, undefined, level, true);\n      }\n    }\n  };\n\n  ExcelExport.prototype.processRecordRows = function (gObj, record, headerRow, level, startIndex, excelExportProperties, excelRows, helper) {\n    var index = 1;\n    var cells = [];\n    var columns = headerRow.columns;\n    var rows = helper.getGridRowModel(columns, record, gObj, startIndex);\n\n    for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n      var row = rows_1[_i];\n      cells = [];\n      startIndex++;\n      index = 1;\n\n      for (var c = 0, len = row.cells.length; c < len; c++) {\n        var gCell = row.cells[c];\n\n        if (gCell.cellType !== CellType.Data) {\n          continue;\n        }\n\n        var column = gCell.column;\n        var field = column.field;\n        var cellValue = !isNullOrUndefined(field) ? column.valueAccessor(field, row.data, column) : '';\n        var value = !isNullOrUndefined(cellValue) ? cellValue : '';\n        var fkData = void 0;\n\n        if (column.isForeignColumn && column.isForeignColumn()) {\n          fkData = helper.getFData(value, column);\n          value = getValue(column.foreignKeyValue, fkData);\n        }\n\n        if (!isNullOrUndefined(value)) {\n          var cell = {};\n          /* tslint:disable-next-line:no-any */\n\n          var excelCellArgs = {\n            data: row.data,\n            column: column,\n            foreignKeyData: fkData,\n            value: value,\n            style: undefined,\n            colSpan: 1,\n            cell: cell\n          };\n          gObj.trigger(events.excelQueryCellInfo, excelCellArgs);\n          cell = excelCellArgs.cell;\n          cell.index = index + level + gObj.childGridLevel;\n          cell.value = excelCellArgs.value;\n\n          if (excelCellArgs.data === '' && gObj.childGridLevel && index === 1) {\n            var style = {};\n            style.hAlign = 'left';\n            excelCellArgs = {\n              style: style\n            };\n            cell.colSpan = gObj.getVisibleColumns().length;\n            cell.value = this.l10n.getConstant('EmptyRecord');\n          }\n\n          if (excelCellArgs.colSpan > 1) {\n            cell.colSpan = excelCellArgs.colSpan;\n          }\n\n          if (!isNullOrUndefined(excelCellArgs.style)) {\n            var styleIndex = this.getColumnStyle(gObj, index + level);\n            cell.style = this.mergeOptions(this.styles[styleIndex], excelCellArgs.style);\n          } else {\n            cell.style = {\n              name: gObj.element.id + 'column' + (index + level)\n            };\n          }\n\n          cells.push(cell);\n        }\n\n        index++;\n      }\n\n      var excelRow = {\n        index: this.rowLength++,\n        cells: cells\n      };\n\n      if (this.groupedColLength < 8 && level > 0) {\n        excelRow.grouping = {\n          outlineLevel: level,\n          isCollapsed: true\n        };\n        excelRows.push(excelRow);\n      } else {\n        excelRows.push(excelRow);\n      }\n\n      if (!isNullOrUndefined(gObj.childGrid)) {\n        gObj.isPrinting = true;\n        var exportType = !isNullOrUndefined(excelExportProperties) && excelExportProperties.exportType ? excelExportProperties.exportType : 'AllPages';\n        var returnVal = this.helper.createChildGrid(gObj, row, exportType, this.gridPool);\n        var childGridObj = returnVal.childGrid;\n        var element = returnVal.element;\n        childGridObj.actionFailure = helper.failureHandler(this.gridPool, childGridObj, this.globalResolve);\n        childGridObj.childGridLevel = gObj.childGridLevel + 1;\n        var args = {\n          childGrid: childGridObj,\n          row: row,\n          exportProperties: excelExportProperties\n        };\n        this.parent.trigger(events.exportDetailDataBound, args);\n        childGridObj.beforeDataBound = this.childGridCell(excelRow, childGridObj, excelExportProperties, row);\n        childGridObj.appendTo(element);\n      }\n\n      gObj.notify(events.exportRowDataBound, {\n        rowObj: row,\n        type: 'excel',\n        excelRows: excelRows\n      });\n    }\n\n    return startIndex;\n  };\n\n  ExcelExport.prototype.childGridCell = function (excelRow, childGridObj, excelExportProps, gRow) {\n    var _this = this;\n\n    return function (result) {\n      childGridObj.beforeDataBound = null;\n      result.cancel = true;\n\n      if (result.result.length === 0) {\n        result.result = [''];\n      }\n\n      excelRow.childRows = _this.processGridExport(childGridObj, excelExportProps, result);\n      var intent = _this.parent.groupSettings.columns.length;\n      var rows = excelRow.childRows;\n\n      for (var i = 0; i < rows.length; i++) {\n        rows[i].grouping = {\n          outlineLevel: intent + childGridObj.childGridLevel,\n          isCollapsed: !gRow.isExpand,\n          isHidden: !gRow.isExpand\n        };\n      }\n\n      childGridObj.destroy();\n      detach(childGridObj.element);\n      _this.gridPool[childGridObj.id] = true;\n\n      _this.helper.checkAndExport(_this.gridPool, _this.globalResolve);\n\n      return excelRow;\n    };\n  }; // tslint:disable-next-line:max-line-length\n\n\n  ExcelExport.prototype.processAggregates = function (gObj, rec, excelRows, currentViewRecords, indent, byGroup, columns) {\n    var summaryModel = new SummaryModelGenerator(gObj);\n\n    if (gObj.aggregates.length && this.parent !== gObj) {\n      gObj.aggregateModule.prepareSummaryInfo();\n    }\n\n    var data = undefined;\n\n    if (!isNullOrUndefined(currentViewRecords)) {\n      data = currentViewRecords;\n    } else {\n      data = rec;\n    }\n\n    if (indent === undefined) {\n      indent = 0;\n    }\n\n    if (gObj.groupSettings.columns.length > 0 && byGroup) {\n      var groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n      var groupSummaryRows = groupSummaryModel.generateRows(data, {\n        level: data.level\n      });\n\n      if (groupSummaryRows.length > 0) {\n        excelRows = this.fillAggregates(gObj, groupSummaryRows, indent, excelRows);\n      }\n    } else {\n      indent = gObj.groupSettings.columns.length > 0 && !byGroup ? gObj.groupSettings.columns.length : indent;\n      var sRows = summaryModel.generateRows(data, rec.aggregates, null, null, columns);\n\n      if (sRows.length > 0 && !byGroup) {\n        excelRows = this.fillAggregates(gObj, sRows, indent, excelRows);\n      }\n    }\n\n    return excelRows;\n  }; // tslint:disable-next-line:max-line-length\n\n\n  ExcelExport.prototype.fillAggregates = function (gObj, rows, indent, excelRows, customIndex) {\n    for (var _i = 0, rows_2 = rows; _i < rows_2.length; _i++) {\n      var row = rows_2[_i];\n      var cells = [];\n      var index = 0;\n\n      for (var _a = 0, _b = row.cells; _a < _b.length; _a++) {\n        var cell = _b[_a];\n        /* tslint:disable-next-line:no-any */\n\n        var eCell = {};\n\n        if (cell.cellType === CellType.DetailFooterIntent) {\n          continue;\n        }\n\n        if (cell.visible || this.includeHiddenColumn) {\n          index++;\n\n          if (cell.isDataCell) {\n            var footerTemplate = !isNullOrUndefined(cell.column.footerTemplate);\n            var groupFooterTemplate = !isNullOrUndefined(cell.column.groupFooterTemplate);\n            var groupCaptionTemplate = !isNullOrUndefined(cell.column.groupCaptionTemplate);\n            eCell.index = index + indent + gObj.childGridLevel;\n\n            if (footerTemplate) {\n              eCell.value = this.getAggreateValue(CellType.Summary, cell.column.footerTemplate, cell, row);\n            } else if (groupFooterTemplate) {\n              eCell.value = this.getAggreateValue(CellType.GroupSummary, cell.column.groupFooterTemplate, cell, row);\n            } else if (groupCaptionTemplate) {\n              eCell.value = this.getAggreateValue(CellType.CaptionSummary, cell.column.groupCaptionTemplate, cell, row);\n            } else {\n              for (var _c = 0, _d = Object.keys(row.data[cell.column.field]); _c < _d.length; _c++) {\n                var key = _d[_c];\n\n                if (key === cell.column.type) {\n                  if (!isNullOrUndefined(row.data[cell.column.field].Sum)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - sum\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Average)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - average\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Max)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - max\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Min)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - min\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Count)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - count\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].TrueCount)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - truecount\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].FalseCount)) {\n                    eCell.value = row.data[cell.column.field][cell.column.field + \" - falsecount\"];\n                  } else if (!isNullOrUndefined(row.data[cell.column.field].Custom)) {\n                    eCell.value = row.data[cell.column.field].Custom;\n                  }\n                }\n              }\n            }\n\n            eCell.style = this.getCaptionThemeStyle(this.theme); //{ name: gObj.element.id + 'column' + index };\n\n            this.aggregateStyle(cell.column, eCell.style, cell.column.field);\n            var gridCellStyle = cell.attributes.style;\n\n            if (gridCellStyle.textAlign) {\n              eCell.style.hAlign = gridCellStyle.textAlign.toLowerCase();\n            }\n\n            var args = {\n              row: row,\n              type: footerTemplate ? AggregateTemplateType.Footer : groupFooterTemplate ? AggregateTemplateType.GroupFooter : AggregateTemplateType.GroupCaption,\n              style: eCell\n            };\n            this.parent.trigger(events.excelAggregateQueryCellInfo, args);\n            cells.push(eCell);\n          } else {\n            if (customIndex === undefined) {\n              eCell.index = index + indent + gObj.childGridLevel;\n              eCell.style = this.getCaptionThemeStyle(this.theme); //{ name: gObj.element.id + 'column' + index };\n\n              cells.push(eCell);\n            }\n          }\n        }\n      }\n\n      if (!isNullOrUndefined(customIndex)) {\n        excelRows.push({\n          index: customIndex,\n          cells: cells\n        });\n      } else {\n        var row_1 = {};\n\n        if (this.groupedColLength < 8 && this.groupedColLength > 0) {\n          var dummyOutlineLevel = 'outlineLevel';\n          var dummyGrouping = 'grouping';\n          var level = excelRows[excelRows.length - 1][dummyGrouping][dummyOutlineLevel];\n          var grouping = {\n            outlineLevel: level,\n            isCollapsed: true\n          };\n          row_1 = {\n            index: this.rowLength++,\n            cells: cells,\n            grouping: grouping\n          };\n        } else {\n          row_1 = {\n            index: this.rowLength++,\n            cells: cells\n          };\n        }\n\n        excelRows.push(row_1);\n      }\n    }\n\n    return excelRows;\n  };\n\n  ExcelExport.prototype.aggregateStyle = function (col, style, field) {\n    var column = this.parent.getColumnByField(field);\n\n    if (typeof col.format === 'object') {\n      var format = col.format;\n      style.numberFormat = !isNullOrUndefined(format.format) ? format.format : format.skeleton;\n\n      if (!isNullOrUndefined(format.type)) {\n        style.type = format.type.toLowerCase();\n      }\n    } else {\n      style.numberFormat = col.format;\n    }\n\n    if (!isNullOrUndefined(column) && isNullOrUndefined(style.type)) {\n      style.type = column.type.toLowerCase();\n    }\n  };\n\n  ExcelExport.prototype.getAggreateValue = function (cellType, template, cell, row) {\n    var templateFn = {};\n    templateFn[getEnumValue(CellType, cell.cellType)] = compile(template);\n    /* tslint:disable-next-line:max-line-length */\n\n    var txt = templateFn[getEnumValue(CellType, cell.cellType)](row.data[cell.column.field ? cell.column.field : cell.column.columnName]);\n    return txt[0].textContent;\n  };\n\n  ExcelExport.prototype.mergeOptions = function (JSON1, JSON2) {\n    var result = {};\n    var attrname = Object.keys(JSON1);\n\n    for (var index = 0; index < attrname.length; index++) {\n      if (attrname[index] !== 'name') {\n        result[attrname[index]] = JSON1[attrname[index]];\n      }\n    }\n\n    attrname = Object.keys(JSON2);\n\n    for (var index = 0; index < attrname.length; index++) {\n      if (attrname[index] !== 'name') {\n        result[attrname[index]] = JSON2[attrname[index]];\n      }\n    }\n\n    return result;\n  };\n\n  ExcelExport.prototype.getColumnStyle = function (gObj, columnIndex) {\n    var index = 0;\n\n    for (var _i = 0, _a = this.styles; _i < _a.length; _i++) {\n      var style = _a[_i];\n\n      if (style.name === gObj.element.id + 'column' + columnIndex) {\n        return index;\n      }\n\n      index++;\n    }\n\n    return undefined;\n  };\n\n  ExcelExport.prototype.processHeaderContent = function (gObj, headerRow, indent, excelRows) {\n    var rowIndex = 1;\n    var gridRows = headerRow.rows; // Column collection with respect to the records in the grid\n\n    var gridColumns = headerRow.columns;\n    var spannedCells = [];\n\n    if (indent > 0) {\n      var index = 0;\n\n      while (index !== indent) {\n        this.columns.push({\n          index: index + 1,\n          width: 30\n        });\n        index++;\n      }\n    }\n\n    for (var row = 0; row < gridRows.length; row++) {\n      var currentCellIndex = 1 + indent;\n      var cells = [];\n\n      for (var column = 0; column < gridRows[row].cells.length; column++) {\n        /* tslint:disable-next-line:no-any */\n        var style = {};\n        var cell = {};\n        var gridCell = gridRows[row].cells[column];\n\n        if (gridCell.cellType === CellType.HeaderIndent || gridCell.cellType === CellType.DetailHeader) {\n          continue;\n        }\n\n        var result = {\n          contains: true,\n          index: 1\n        };\n\n        while (result.contains) {\n          result = this.getIndex(spannedCells, rowIndex, currentCellIndex);\n          currentCellIndex = result.index;\n\n          if (!result.contains) {\n            cell.index = result.index + gObj.childGridLevel;\n            break;\n          }\n        }\n\n        if (!isNullOrUndefined(gridCell.rowSpan) && gridCell.rowSpan !== 1) {\n          cell.rowSpan = gridCell.rowSpan;\n\n          for (var i = rowIndex; i < gridCell.rowSpan + rowIndex; i++) {\n            var spannedCell = {\n              rowIndex: 0,\n              columnIndex: 0\n            };\n            spannedCell.rowIndex = i;\n            spannedCell.columnIndex = currentCellIndex;\n            spannedCells.push(spannedCell);\n          }\n        }\n\n        if (!isNullOrUndefined(gridCell.colSpan) && gridCell.colSpan !== 1) {\n          cell.colSpan = gridCell.colSpan;\n          currentCellIndex = currentCellIndex + cell.colSpan - 1;\n        }\n\n        cell.value = gridCell.column.headerText;\n        style = this.getHeaderThemeStyle(this.theme);\n\n        if (!isNullOrUndefined(gridCell.column.textAlign)) {\n          style.hAlign = gridCell.column.textAlign.toLowerCase();\n        }\n\n        if (!isNullOrUndefined(gridCell.column.headerTextAlign)) {\n          style.hAlign = gridCell.column.headerTextAlign.toLowerCase();\n        }\n\n        var excelHeaderCellArgs = {\n          cell: cell,\n          gridCell: gridCell,\n          style: style\n        };\n        gObj.trigger(events.excelHeaderQueryCellInfo, excelHeaderCellArgs);\n        cell.style = excelHeaderCellArgs.style;\n        cells.push(cell);\n        currentCellIndex++;\n      }\n\n      excelRows.push({\n        index: this.rowLength++,\n        cells: cells\n      });\n    }\n\n    for (var col = 0; col < gridColumns.length; col++) {\n      this.parseStyles(gObj, gridColumns[col], this.getRecordThemeStyle(this.theme), indent + col + 1);\n    }\n\n    return excelRows;\n  };\n\n  ExcelExport.prototype.getHeaderThemeStyle = function (theme) {\n    var style = {};\n    style.fontSize = 12;\n    style.borders = {\n      color: '#E0E0E0'\n    };\n    style.bold = true;\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.header)) {\n      style = this.updateThemeStyle(theme.header, style);\n    }\n\n    return style;\n  };\n\n  ExcelExport.prototype.updateThemeStyle = function (themestyle, style) {\n    return extend(style, themestyle);\n  };\n\n  ExcelExport.prototype.getCaptionThemeStyle = function (theme) {\n    var style = {};\n    style.fontSize = 13;\n    style.backColor = '#F6F6F6';\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.caption)) {\n      style = this.updateThemeStyle(theme.caption, style);\n    }\n\n    return style;\n  };\n\n  ExcelExport.prototype.getRecordThemeStyle = function (theme) {\n    var style = {};\n    style.fontSize = 13;\n    style.borders = {\n      color: '#E0E0E0'\n    };\n\n    if (!isNullOrUndefined(theme) && !isNullOrUndefined(theme.record)) {\n      style = this.updateThemeStyle(theme.record, style);\n    }\n\n    return style;\n  };\n\n  ExcelExport.prototype.processExcelHeader = function (header) {\n    if (!isNullOrUndefined(header.rows) && (this.expType === 'NewSheet' || this.rowLength === 1)) {\n      var noRows = void 0;\n\n      if (header.headerRows === undefined) {\n        this.rowLength = header.rows.length;\n      } else {\n        this.rowLength = header.headerRows;\n      }\n\n      if (this.rowLength < header.rows.length) {\n        noRows = this.rowLength;\n      } else {\n        noRows = header.rows.length;\n      }\n\n      this.rowLength++;\n\n      for (var row = 0; row < noRows; row++) {\n        var json = header.rows[row]; //Row index\n\n        if (!(json.index !== null && !isNullOrUndefined(json.index))) {\n          json.index = row + 1;\n        }\n\n        this.updatedCellIndex(json);\n      }\n    }\n  };\n\n  ExcelExport.prototype.updatedCellIndex = function (json) {\n    var cellsLength = json.cells.length;\n\n    for (var cellId = 0; cellId < cellsLength; cellId++) {\n      var jsonCell = json.cells[cellId]; //cell index\n\n      if (!(jsonCell.index !== null && !isNullOrUndefined(jsonCell.index))) {\n        jsonCell.index = cellId + 1;\n      }\n    }\n\n    this.rows.push(json);\n  };\n\n  ExcelExport.prototype.processExcelFooter = function (footer) {\n    if (!isNullOrUndefined(footer.rows)) {\n      var noRows = void 0;\n\n      if (footer.footerRows === undefined) {\n        this.rowLength += footer.rows.length;\n      } else {\n        if (footer.footerRows > footer.rows.length) {\n          this.rowLength += footer.footerRows - footer.rows.length;\n          noRows = footer.rows.length;\n        } else {\n          noRows = footer.footerRows;\n        }\n      }\n\n      for (var row = 0; row < noRows; row++) {\n        var json = footer.rows[row]; //Row index\n\n        if (json.index === null || json.index === undefined) {\n          json.index = this.rowLength++;\n        } else {\n          json.index += this.rowLength;\n        }\n\n        this.updatedCellIndex(json);\n      }\n    }\n  };\n\n  ExcelExport.prototype.getIndex = function (spannedCells, rowIndex, columnIndex) {\n    for (var _i = 0, spannedCells_1 = spannedCells; _i < spannedCells_1.length; _i++) {\n      var spannedCell = spannedCells_1[_i];\n\n      if (spannedCell.rowIndex === rowIndex && spannedCell.columnIndex === columnIndex) {\n        columnIndex = columnIndex + 1;\n        return {\n          contains: true,\n          index: columnIndex\n        };\n      }\n    }\n\n    return {\n      contains: false,\n      index: columnIndex\n    };\n  };\n\n  ExcelExport.prototype.parseStyles = function (gObj, col, style, index) {\n    if (!isNullOrUndefined(col.format)) {\n      if (typeof col.format === 'object') {\n        var format = col.format;\n        style.numberFormat = !isNullOrUndefined(format.format) ? format.format : format.skeleton;\n\n        if (!isNullOrUndefined(format.type)) {\n          style.type = format.type.toLowerCase();\n        }\n      } else {\n        style.numberFormat = col.format;\n        style.type = col.type;\n      }\n    }\n\n    if (!isNullOrUndefined(col.textAlign)) {\n      style.hAlign = col.textAlign.toLowerCase();\n    }\n\n    if (Object.keys(style).length > 0) {\n      style.name = gObj.element.id + 'column' + index;\n      this.styles.push(style);\n    }\n\n    if (!isNullOrUndefined(col.width)) {\n      this.columns.push({\n        index: index + gObj.childGridLevel,\n        width: typeof col.width === 'number' ? col.width : this.helper.getConvertedWidth(col.width)\n      });\n    }\n  };\n  /**\n   * To destroy the excel export\n   * @return {void}\n   * @hidden\n   */\n\n\n  ExcelExport.prototype.destroy = function () {//destroy for exporting\n  };\n\n  return ExcelExport;\n}();\n\nexport { ExcelExport };","map":null,"metadata":{},"sourceType":"module"}