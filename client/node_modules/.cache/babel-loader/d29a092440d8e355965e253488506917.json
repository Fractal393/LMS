{"ast":null,"code":"import { extend, isNullOrUndefined, isBlazor, getValue } from '../util';\nimport { ParserBase as parser } from './parser-base';\nimport { IntlBase as base } from './intl-base';\nvar formatRegex = /(^[ncpa]{1})([0-1]?[0-9]|20)?$/i;\nvar parseRegex = /^([^0-9]*)(([0-9,]*[0-9]+)(\\.[0-9]+)?)([Ee][+-]?[0-9]+)?([^0-9]*)$/;\nvar groupRegex = /,/g;\nvar latnDecimalRegex = /^[0-9]*(\\.[0-9]+)?$/;\nvar keys = ['minusSign', 'infinity'];\n/**\n * Module for Number Parser.\n * @private\n */\n\nvar NumberParser =\n/** @class */\nfunction () {\n  function NumberParser() {}\n  /**\n   * Returns the parser function for given skeleton.\n   * @param {string} -  Specifies the culture name to be which formatting.\n   * @param {NumberFormatOptions} - Specific the format in which number  will parsed.\n   * @param {cldr} - Specifies the global cldr data collection.\n   * @return Function.\n   */\n\n\n  NumberParser.numberParser = function (culture, option, cldr) {\n    var _this = this;\n\n    var dependable = base.getDependables(cldr, culture, '', true);\n    var parseOptions = {\n      custom: true\n    };\n    var numOptions;\n\n    if (base.formatRegex.test(option.format) || !option.format) {\n      extend(parseOptions, base.getProperNumericSkeleton(option.format || 'N'));\n      parseOptions.custom = false;\n    } else {\n      extend(parseOptions, base.customFormat(option.format, null, null));\n    }\n\n    var numbers = getValue('numbers', dependable.parserObject);\n    numOptions = parser.getCurrentNumericOptions(dependable.parserObject, parser.getNumberingSystem(cldr), true, isBlazor());\n    parseOptions.symbolRegex = parser.getSymbolRegex(Object.keys(numOptions.symbolMatch)); // tslint:disable-next-line:no-any\n\n    parseOptions.infinity = numOptions.symbolNumberSystem[keys[1]];\n    var symbolpattern;\n\n    if (!isBlazor()) {\n      symbolpattern = base.getSymbolPattern(parseOptions.type, numOptions.numberSystem, dependable.numericObject, parseOptions.isAccount);\n\n      if (symbolpattern) {\n        symbolpattern = symbolpattern.replace(/\\u00A4/g, base.defaultCurrency);\n        var split = symbolpattern.split(';');\n        parseOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, '');\n        parseOptions.pData = base.getFormatData(split[0], true, '');\n      }\n    } else {\n      parseOptions.nData = extend({}, {}, getValue(parseOptions.type + 'nData', numbers));\n      parseOptions.pData = extend({}, {}, getValue(parseOptions.type + 'pData', numbers));\n\n      if (parseOptions.type === 'currency' && option.currency) {\n        base.replaceBlazorCurrency([parseOptions.pData, parseOptions.nData], getValue('currencySymbol', numbers), option.currency);\n      }\n    }\n\n    return function (value) {\n      return _this.getParsedNumber(value, parseOptions, numOptions);\n    };\n  };\n  /**\n   * Returns parsed number for the provided formatting options\n   * @param {string} value\n   * @param {NumericParts} options\n   * @param {NumericOptions} numOptions\n   * @returns {number}\n   */\n\n\n  NumberParser.getParsedNumber = function (value, options, numOptions) {\n    var isNegative;\n    var isPercent;\n    var tempValue;\n    var lead;\n    var end;\n    var ret;\n\n    if (value.indexOf(options.infinity) !== -1) {\n      return Infinity;\n    } else {\n      value = parser.convertValueParts(value, options.symbolRegex, numOptions.symbolMatch);\n      value = parser.convertValueParts(value, numOptions.numberParseRegex, numOptions.numericPair);\n\n      if (value.indexOf('.') === 0) {\n        value = '0' + value;\n      }\n\n      var matches = value.match(parseRegex);\n\n      if (isNullOrUndefined(matches)) {\n        return NaN;\n      }\n\n      lead = matches[1];\n      tempValue = matches[2];\n      var exponent = matches[5];\n      end = matches[6];\n      isNegative = options.custom ? lead === options.nData.nlead && end === options.nData.nend : lead.indexOf(options.nData.nlead) !== -1 && end.indexOf(options.nData.nend) !== -1;\n      isPercent = isNegative ? options.nData.isPercent : options.pData.isPercent;\n      tempValue = tempValue.replace(groupRegex, '');\n\n      if (exponent) {\n        tempValue += exponent;\n      }\n\n      ret = +tempValue;\n\n      if (options.type === 'percent' || isPercent) {\n        ret = ret / 100;\n      }\n\n      if (options.custom || options.fractionDigits) {\n        ret = parseFloat(ret.toFixed(options.custom ? isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits : options.fractionDigits));\n      }\n\n      if (isNegative) {\n        ret *= -1;\n      }\n\n      return ret;\n    }\n  };\n\n  return NumberParser;\n}();\n\nexport { NumberParser };","map":null,"metadata":{},"sourceType":"module"}