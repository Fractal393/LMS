{"ast":null,"code":"/**\r\n * DevExtreme (ui/number_box/number_box.caret.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar fitIntoRange = require(\"../../core/utils/math\").fitIntoRange;\n\nvar escapeRegExp = require(\"../../core/utils/common\").escapeRegExp;\n\nvar number = require(\"../../localization/number\");\n\nvar getCaretBoundaries = function (text, format) {\n  if (\"string\" === typeof format) {\n    var signParts = format.split(\";\");\n    var sign = number.getSign(text, format);\n    signParts[1] = signParts[1] || \"-\" + signParts[0];\n    format = signParts[sign < 0 ? 1 : 0];\n\n    var mockEscapedStubs = function (str) {\n      return str.replace(/'([^']*)'/g, function (str) {\n        return str.split(\"\").map(function () {\n          return \" \";\n        }).join(\"\").substr(2);\n      });\n    };\n\n    format = mockEscapedStubs(format);\n    var prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\n    var postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\n    return {\n      start: prefixStubLength,\n      end: text.length - postfixStubLength\n    };\n  } else {\n    return {\n      start: 0,\n      end: text.length\n    };\n  }\n};\n\nvar _getDigitCountBeforeIndex = function (index, text) {\n  var decimalSeparator = number.getDecimalSeparator();\n  var regExp = new RegExp(\"[^0-9\" + escapeRegExp(decimalSeparator) + \"]\", \"g\");\n  var textBeforePosition = text.slice(0, index);\n  return textBeforePosition.replace(regExp, \"\").length;\n};\n\nvar _reverseText = function (text) {\n  return text.split(\"\").reverse().join(\"\");\n};\n\nvar _getDigitPositionByIndex = function (digitIndex, text) {\n  if (!digitIndex) {\n    return -1;\n  }\n\n  var regExp = /[0-9]/g;\n  var counter = 1;\n  var index = null;\n  var result = regExp.exec(text);\n\n  while (result) {\n    index = result.index;\n\n    if (!digitIndex || counter >= digitIndex) {\n      return index;\n    }\n\n    counter++;\n    result = regExp.exec(text);\n  }\n\n  return null === index ? text.length : index;\n};\n\nvar _trimNonNumericCharsFromEnd = function (text) {\n  return text.replace(/[^0-9e]+$/, \"\");\n};\n\nvar getCaretWithOffset = function (caret, offset) {\n  if (void 0 === caret.start) {\n    caret = {\n      start: caret,\n      end: caret\n    };\n  }\n\n  return {\n    start: caret.start + offset,\n    end: caret.end + offset\n  };\n};\n\nvar getCaretAfterFormat = function (text, formatted, caret, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var point = number.getDecimalSeparator();\n  var isSeparatorBasedText = isSeparatorBasedString(text);\n  var pointPosition = isSeparatorBasedText ? 0 : text.indexOf(point);\n  var newPointPosition = formatted.indexOf(point);\n  var textParts = isSeparatorBasedText ? text.split(text[pointPosition]) : text.split(point);\n  var formattedParts = formatted.split(point);\n  var isCaretOnFloat = pointPosition !== -1 && caret.start > pointPosition;\n\n  if (isCaretOnFloat) {\n    var relativeIndex = caret.start - pointPosition - 1;\n\n    var digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);\n\n    var newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\n    return getCaretInBoundaries(newPosition, formatted, format);\n  } else {\n    var formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);\n\n    var positionFromEnd = textParts[0].length - caret.start;\n\n    var digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));\n\n    var newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));\n\n    var newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);\n    return getCaretInBoundaries(newPositionFromBegin, formatted, format);\n  }\n};\n\nfunction isSeparatorBasedString(text) {\n  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);\n}\n\nvar isCaretInBoundaries = function (caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretInBoundaries(caret, text, format);\n  return caret.start >= boundaries.start && caret.end <= boundaries.end;\n};\n\nfunction getCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretBoundaries(text, format);\n  var adjustedCaret = {\n    start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\n    end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\n  };\n  return adjustedCaret;\n}\n\nvar getCaretOffset = function (previousText, newText, format) {\n  var previousBoundaries = getCaretBoundaries(previousText, format);\n  var newBoundaries = getCaretBoundaries(newText, format);\n  return newBoundaries.start - previousBoundaries.start;\n};\n\nexports.getCaretBoundaries = getCaretBoundaries;\nexports.isCaretInBoundaries = isCaretInBoundaries;\nexports.getCaretWithOffset = getCaretWithOffset;\nexports.getCaretInBoundaries = getCaretInBoundaries;\nexports.getCaretAfterFormat = getCaretAfterFormat;\nexports.getCaretOffset = getCaretOffset;","map":null,"metadata":{},"sourceType":"script"}