{"ast":null,"code":"import { Browser, isBlazor, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { isGroupAdaptive } from '../base/util';\nimport { RowModelGenerator } from '../services/row-model-generator';\nimport { GroupModelGenerator } from '../services/group-model-generator';\n/**\n * Content module is used to render grid content\n */\n\nvar VirtualRowModelGenerator =\n/** @class */\nfunction () {\n  function VirtualRowModelGenerator(parent) {\n    this.cOffsets = {};\n    this.cache = {};\n    this.rowCache = {};\n    this.data = {};\n    this.groups = {};\n    this.parent = parent;\n    this.model = this.parent.pageSettings;\n    this.rowModelGenerator = this.parent.allowGrouping ? new GroupModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  }\n\n  VirtualRowModelGenerator.prototype.generateRows = function (data, notifyArgs) {\n    var info = notifyArgs.virtualInfo = notifyArgs.virtualInfo || this.getData();\n    var xAxis = info.sentinelInfo && info.sentinelInfo.axis === 'X';\n    var page = !xAxis && info.loadNext && !info.loadSelf ? info.nextInfo.page : info.page;\n    var result = [];\n    var center = ~~(this.model.pageSize / 2);\n    var indexes = this.getBlockIndexes(page);\n    var loadedBlocks = [];\n    this.checkAndResetCache(notifyArgs.requestType);\n\n    if (isGroupAdaptive(this.parent) && this.parent.vcRows.length) {\n      return result = this.parent.vcRows;\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      for (var i = 0; i < info.blockIndexes.length; i++) {\n        if (this.isBlockAvailable(info.blockIndexes[i])) {\n          this.cache[info.blockIndexes[i]] = this.rowModelGenerator.refreshRows(this.cache[info.blockIndexes[i]]);\n        }\n      }\n    }\n\n    if (isBlazor() && this.parent.isServerRendered) {\n      var virtualStartIdx = 'virtualStartIndex';\n      var startIndex = 'startIndex';\n      var endIndex = 'endIndex';\n\n      if (!notifyArgs[virtualStartIdx] && Object.keys(this.rowCache).length === 0) {\n        for (var i = 0; i < data.length; i++) {\n          var args = [];\n          args.push(data[i]);\n          this.rowCache[i] = this.rowModelGenerator.generateRows(args, {\n            startIndex: i\n          })[0];\n        }\n\n        var j = 0;\n\n        for (var i = 0; i < this.parent.pageSettings.pageSize; i++) {\n          result[j] = this.rowCache[i];\n          j++;\n        }\n      } else if (notifyArgs[virtualStartIdx]) {\n        var virtualStartIndex = notifyArgs[startIndex];\n        var cacheindex = [];\n\n        for (var i = 0; i < Object.keys(this.rowCache).length; i++) {\n          cacheindex.push(Number(Object.keys(this.rowCache)[i]));\n        }\n\n        for (var i = 0; i < data.length; i++) {\n          var args = [];\n          var check = cacheindex.indexOf(virtualStartIndex);\n          args.push(data[i]);\n\n          if (check === -1) {\n            this.rowCache[virtualStartIndex] = this.rowModelGenerator.generateRows(args, {\n              startIndex: virtualStartIndex\n            })[0];\n          }\n\n          virtualStartIndex++;\n        }\n      }\n\n      if (!isNullOrUndefined(notifyArgs[virtualStartIdx])) {\n        var j = 0;\n\n        for (var i = notifyArgs[startIndex]; i < notifyArgs[endIndex]; i++) {\n          result[j] = this.rowCache[i];\n          j++;\n        }\n      }\n    } else {\n      var values = info.blockIndexes;\n\n      for (var i = 0; i < values.length; i++) {\n        if (!this.isBlockAvailable(values[i])) {\n          var rows = this.rowModelGenerator.generateRows(data, {\n            virtualInfo: info,\n            startIndex: this.getStartIndex(values[i], data)\n          });\n\n          if (isGroupAdaptive(this.parent) && !this.parent.vcRows.length) {\n            this.parent.vRows = rows;\n            this.parent.vcRows = rows;\n          }\n\n          var median = void 0;\n\n          if (isGroupAdaptive(this.parent)) {\n            median = this.model.pageSize / 2;\n\n            if (!this.isBlockAvailable(indexes[0])) {\n              this.cache[indexes[0]] = rows.slice(0, median);\n            }\n\n            if (!this.isBlockAvailable(indexes[1])) {\n              this.cache[indexes[1]] = rows.slice(median, this.model.pageSize);\n            }\n          } else {\n            median = ~~Math.max(rows.length, this.model.pageSize) / 2;\n\n            if (!this.isBlockAvailable(indexes[0])) {\n              this.cache[indexes[0]] = rows.slice(0, median);\n            }\n\n            if (!this.isBlockAvailable(indexes[1])) {\n              this.cache[indexes[1]] = rows.slice(median);\n            }\n          }\n        }\n\n        if (this.parent.groupSettings.columns.length && !xAxis && this.cache[values[i]]) {\n          this.cache[values[i]] = this.updateGroupRow(this.cache[values[i]], values[i]);\n        }\n\n        result.push.apply(result, this.cache[values[i]]);\n\n        if (this.isBlockAvailable(values[i])) {\n          loadedBlocks.push(values[i]);\n        }\n      }\n\n      info.blockIndexes = loadedBlocks;\n    }\n\n    if (!isBlazor() || isBlazor() && !this.parent.isServerRendered) {\n      var grouping = 'records';\n\n      if (this.parent.allowGrouping) {\n        this.parent.currentViewData[grouping] = result.map(function (m) {\n          return m.data;\n        });\n      } else {\n        this.parent.currentViewData = result.map(function (m) {\n          return m.data;\n        });\n      }\n    }\n\n    return result;\n  };\n\n  VirtualRowModelGenerator.prototype.getBlockIndexes = function (page) {\n    return [page + (page - 1), page * 2];\n  };\n\n  VirtualRowModelGenerator.prototype.getPage = function (block) {\n    return block % 2 === 0 ? block / 2 : (block + 1) / 2;\n  };\n\n  VirtualRowModelGenerator.prototype.isBlockAvailable = function (value) {\n    return value in this.cache;\n  };\n\n  VirtualRowModelGenerator.prototype.getData = function () {\n    return {\n      page: this.model.currentPage,\n      blockIndexes: this.getBlockIndexes(this.model.currentPage),\n      direction: 'down',\n      columnIndexes: this.parent.getColumnIndexesInView()\n    };\n  };\n\n  VirtualRowModelGenerator.prototype.getStartIndex = function (blk, data, full) {\n    if (full === void 0) {\n      full = true;\n    }\n\n    var page = this.getPage(blk);\n    var even = blk % 2 === 0;\n    var index = (page - 1) * this.model.pageSize;\n    return full || !even ? index : index + ~~(this.model.pageSize / 2);\n  };\n\n  VirtualRowModelGenerator.prototype.getColumnIndexes = function (content) {\n    var _this = this;\n\n    if (content === void 0) {\n      content = this.parent.getHeaderContent().querySelector('.e-headercontent');\n    }\n\n    if (this.parent.getFrozenColumns()) {\n      content = content.querySelector('.e-movableheader');\n    }\n\n    var indexes = [];\n    var sLeft = content.scrollLeft | 0;\n    var keys = Object.keys(this.cOffsets);\n    var cWidth = content.getBoundingClientRect().width;\n    sLeft = Math.min(this.cOffsets[keys.length - 1] - cWidth, sLeft);\n    var calWidth = Browser.isDevice ? 2 * cWidth : cWidth / 2;\n    var left = sLeft + cWidth + (sLeft === 0 ? calWidth : 0);\n    keys.some(function (offset, indx, input) {\n      var iOffset = Number(offset);\n      var offsetVal = _this.cOffsets[offset];\n      var border = sLeft - calWidth <= offsetVal && left + calWidth >= offsetVal;\n\n      if (border) {\n        indexes.push(iOffset);\n      }\n\n      return left + calWidth < offsetVal;\n    });\n\n    if (isBlazor() && this.parent.isServerRendered) {\n      this.parent.contentModule.startColIndex = indexes[0];\n      this.parent.contentModule.endColIndex = indexes[indexes.length - 1];\n    }\n\n    this.addFrozenIndex(indexes);\n    return indexes;\n  };\n\n  VirtualRowModelGenerator.prototype.addFrozenIndex = function (indexes) {\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization && indexes[0] === 0) {\n      for (var i = 0; i < this.parent.getFrozenColumns(); i++) {\n        indexes.push(indexes[indexes.length - 1] + 1);\n      }\n    }\n  };\n\n  VirtualRowModelGenerator.prototype.checkAndResetCache = function (action) {\n    var actions = ['paging', 'refresh', 'sorting', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', 'save', 'delete'];\n\n    if (this.parent.getFrozenColumns() && this.parent.frozenRows && this.parent.enableColumnVirtualization && action === 'reorder') {\n      actions.splice(actions.indexOf(action), 1);\n    }\n\n    var clear = actions.some(function (value) {\n      return action === value;\n    });\n\n    if (clear) {\n      this.cache = {};\n      this.data = {};\n      this.groups = {};\n    }\n\n    return clear;\n  };\n\n  VirtualRowModelGenerator.prototype.refreshColOffsets = function () {\n    var _this = this;\n\n    var col = 0;\n    this.cOffsets = {};\n    var gLen = this.parent.groupSettings.columns.length;\n    var cols = this.parent.columns;\n    var cLen = cols.length;\n\n    var isVisible = function (column) {\n      return column.visible && (!_this.parent.groupSettings.showGroupedColumn ? _this.parent.groupSettings.columns.indexOf(column.field) < 0 : column.visible);\n    };\n\n    var c = this.parent.groupSettings.columns;\n\n    for (var i = 0; i < c.length; i++) {\n      this.cOffsets[i] = (this.cOffsets[i - 1] | 0) + 30;\n    }\n\n    var blocks = Array.apply(null, Array(cLen)).map(function () {\n      return col++;\n    });\n\n    for (var j = 0; j < blocks.length; j++) {\n      blocks[j] = blocks[j] + gLen;\n      this.cOffsets[blocks[j]] = (this.cOffsets[blocks[j] - 1] | 0) + (isVisible(cols[j]) ? parseInt(cols[j].width, 10) : 0);\n    }\n  };\n\n  VirtualRowModelGenerator.prototype.updateGroupRow = function (current, block) {\n    var currentFirst = current[0];\n    var rows = [];\n    var keys = Object.keys(this.cache);\n\n    for (var i = 0; i < keys.length; i++) {\n      if (Number(keys[i]) < block) {\n        rows = rows.concat(this.cache[keys[i]]);\n      }\n    }\n\n    if (currentFirst && currentFirst.isDataRow || block % 2 === 0) {\n      return current;\n    }\n\n    return this.iterateGroup(current, rows);\n  };\n\n  VirtualRowModelGenerator.prototype.iterateGroup = function (current, rows) {\n    var currentFirst = current[0];\n    var offset = 0;\n\n    if (currentFirst && currentFirst.isDataRow) {\n      return current;\n    }\n\n    var isPresent = current.some(function (row) {\n      return rows.some(function (oRow, index) {\n        var res = oRow && oRow.data.field !== undefined && oRow.data.field === row.data.field && oRow.data.key === row.data.key;\n\n        if (res) {\n          offset = index;\n        }\n\n        return res;\n      });\n    });\n\n    if (isPresent) {\n      current.shift();\n      current = this.iterateGroup(current, rows.slice(offset));\n    }\n\n    return current;\n  };\n\n  VirtualRowModelGenerator.prototype.getRows = function () {\n    var rows = [];\n    var isBlazorServerRendered = isBlazor() && this.parent.isServerRendered ? true : false;\n    var keys = isBlazorServerRendered ? Object.keys(this.rowCache) : Object.keys(this.cache);\n\n    for (var i = 0; i < keys.length; i++) {\n      rows = isBlazorServerRendered ? rows.concat(this.rowCache[keys[i]]) : rows.concat(this.cache[keys[i]]);\n    }\n\n    return rows;\n  };\n\n  return VirtualRowModelGenerator;\n}();\n\nexport { VirtualRowModelGenerator };","map":null,"metadata":{},"sourceType":"module"}