{"ast":null,"code":"/**\r\n * DevExtreme (ui/data_grid/ui.data_grid.grouping.expanded.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _data = require(\"../../core/utils/data\");\n\nvar _utils = require(\"../../data/utils\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _store_helper = require(\"../../data/store_helper\");\n\nvar _uiData_grid = require(\"./ui.data_grid.core\");\n\nvar _uiData_gridGrouping = require(\"./ui.data_grid.grouping.core\");\n\nvar _uiData_grid2 = require(\"./ui.data_grid.utils\");\n\nvar _query = require(\"../../data/query\");\n\nvar _query2 = _interopRequireDefault(_query);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar loadTotalCount = function (dataSource, options) {\n  var d = new _deferred.Deferred();\n  var loadOptions = (0, _extend.extend)({\n    skip: 0,\n    take: 1,\n    requireTotalCount: true\n  }, options);\n  dataSource.load(loadOptions).done(function (data, extra) {\n    d.resolve(extra && extra.totalCount);\n  }).fail(d.reject.bind(d));\n  return d;\n};\n\nexports.GroupingHelper = _uiData_gridGrouping.GroupingHelper.inherit(function () {\n  var foreachCollapsedGroups = function (that, callback, updateOffsets) {\n    return that.foreachGroups(function (groupInfo) {\n      if (!groupInfo.isExpanded) {\n        return callback(groupInfo);\n      }\n    }, false, false, updateOffsets, true);\n  };\n\n  var correctSkipLoadOption = function (that, skip) {\n    var skipCorrection = 0;\n    var resultSkip = skip || 0;\n\n    if (skip) {\n      foreachCollapsedGroups(that, function (groupInfo) {\n        if (groupInfo.offset - skipCorrection >= skip) {\n          return false;\n        }\n\n        skipCorrection += groupInfo.count - 1;\n      });\n      resultSkip += skipCorrection;\n    }\n\n    return resultSkip;\n  };\n\n  var processGroupItems = function processGroupItems(that, items, path, offset, skipFirstItem, take) {\n    var removeLastItemsCount = 0;\n    var needRemoveFirstItem = false;\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (void 0 !== item.items) {\n        path.push(item.key);\n        var groupInfo = that.findGroupInfo(path);\n\n        if (groupInfo && !groupInfo.isExpanded) {\n          item.collapsedItems = item.items;\n          item.items = null;\n          offset += groupInfo.count;\n          take--;\n\n          if (take < 0) {\n            removeLastItemsCount++;\n          }\n\n          if (skipFirstItem) {\n            needRemoveFirstItem = true;\n          }\n        } else {\n          if (item.items) {\n            var offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);\n\n            if (skipFirstItem) {\n              if (offsetInfo.offset - offset > 1) {\n                item.isContinuation = true;\n              } else {\n                needRemoveFirstItem = true;\n              }\n            }\n\n            offset = offsetInfo.offset;\n            take = offsetInfo.take;\n\n            if (take < 0) {\n              if (item.items.length) {\n                item.isContinuationOnNextPage = true;\n              } else {\n                removeLastItemsCount++;\n              }\n            }\n          }\n        }\n\n        path.pop();\n      } else {\n        if (skipFirstItem) {\n          needRemoveFirstItem = true;\n        }\n\n        offset++;\n        take--;\n\n        if (take < 0) {\n          removeLastItemsCount++;\n        }\n      }\n\n      skipFirstItem = false;\n    }\n\n    if (needRemoveFirstItem) {\n      items.splice(0, 1);\n    }\n\n    if (removeLastItemsCount) {\n      items.splice(-removeLastItemsCount, removeLastItemsCount);\n    }\n\n    return {\n      offset: offset,\n      take: take\n    };\n  };\n\n  var pathEquals = function (path1, path2) {\n    if (path1.length !== path2.length) {\n      return false;\n    }\n\n    for (var i = 0; i < path1.length; i++) {\n      if (!(0, _utils.keysEqual)(null, path1[i], path2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var updateGroupOffsets = function updateGroupOffsets(that, items, path, offset, additionalGroupInfo) {\n    if (!items) {\n      return;\n    }\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (\"key\" in item && void 0 !== item.items) {\n        path.push(item.key);\n\n        if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {\n          additionalGroupInfo.offset = offset;\n        }\n\n        var groupInfo = that.findGroupInfo(path);\n\n        if (groupInfo && !item.isContinuation) {\n          groupInfo.offset = offset;\n        }\n\n        if (groupInfo && !groupInfo.isExpanded) {\n          offset += groupInfo.count;\n        } else {\n          offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);\n        }\n\n        path.pop();\n      } else {\n        offset++;\n      }\n    }\n\n    return offset;\n  };\n\n  var removeGroupLoadOption = function (storeLoadOptions, loadOptions) {\n    if (loadOptions.group) {\n      var groups = (0, _uiData_grid.normalizeSortingInfo)(loadOptions.group);\n      var sorts = (0, _uiData_grid.normalizeSortingInfo)(storeLoadOptions.sort);\n      storeLoadOptions.sort = (0, _store_helper.arrangeSortingInfo)(groups, sorts);\n      delete loadOptions.group;\n    }\n  };\n\n  var createNotGroupFilter = function (path, storeLoadOptions, group) {\n    var groups = (0, _uiData_grid.normalizeSortingInfo)(group || storeLoadOptions.group);\n    var filter = [];\n\n    for (var i = 0; i < path.length; i++) {\n      var filterElement = [];\n\n      for (var j = 0; j <= i; j++) {\n        filterElement.push([groups[j].selector, i === j ? \"<>\" : \"=\", path[j]]);\n      }\n\n      filter.push((0, _uiData_grid.combineFilters)(filterElement));\n    }\n\n    filter = (0, _uiData_grid.combineFilters)(filter, \"or\");\n    return (0, _uiData_grid.combineFilters)([filter, storeLoadOptions.filter]);\n  };\n\n  var getGroupCount = function getGroupCount(item, groupCount) {\n    var count = item.count || item.items.length;\n\n    if (!item.count && groupCount > 1) {\n      count = 0;\n\n      for (var i = 0; i < item.items.length; i++) {\n        count += getGroupCount(item.items[i], groupCount - 1);\n      }\n    }\n\n    return count;\n  };\n\n  return {\n    handleDataLoading: function (options) {\n      var that = this;\n      var storeLoadOptions = options.storeLoadOptions;\n      var collapsedGroups = [];\n      var collapsedItemsCount = 0;\n      var skipFirstItem = false;\n      var take;\n      var group = options.loadOptions.group;\n      var skipCorrection = 0;\n      removeGroupLoadOption(storeLoadOptions, options.loadOptions);\n      options.group = options.group || group;\n\n      if (options.isCustomLoading) {\n        return;\n      }\n\n      var loadOptions = (0, _extend.extend)({}, storeLoadOptions);\n      loadOptions.skip = correctSkipLoadOption(that, storeLoadOptions.skip);\n\n      if (loadOptions.skip && loadOptions.take && group) {\n        loadOptions.skip--;\n        loadOptions.take++;\n        skipFirstItem = true;\n      }\n\n      if (loadOptions.take && group) {\n        take = loadOptions.take;\n        loadOptions.take++;\n      }\n\n      foreachCollapsedGroups(that, function (groupInfo) {\n        if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {\n          return false;\n        } else {\n          if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {\n            skipCorrection += groupInfo.count - 1;\n            collapsedGroups.push(groupInfo);\n            collapsedItemsCount += groupInfo.count;\n          }\n        }\n      });\n      (0, _iterator.each)(collapsedGroups, function () {\n        loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group);\n      });\n      options.storeLoadOptions = loadOptions;\n      options.collapsedGroups = collapsedGroups;\n      options.collapsedItemsCount = collapsedItemsCount;\n      options.skip = loadOptions.skip || 0;\n      options.skipFirstItem = skipFirstItem;\n      options.take = take;\n    },\n    handleDataLoaded: function (options, callBase) {\n      var that = this;\n      var data = options.data;\n      var collapsedGroups = options.collapsedGroups;\n      var groups = (0, _uiData_grid.normalizeSortingInfo)(options.group);\n      var groupCount = groups.length;\n\n      function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {\n        if (!data || !path.length || !groups.length) {\n          return;\n        }\n\n        var keyValue;\n        var i;\n        var pathValue = (0, _data.toComparable)(path[0], true);\n\n        for (i = 0; i < data.length; i++) {\n          keyValue = (0, _data.toComparable)(data[i].key, true);\n\n          if (offset >= collapsedGroup.offset || pathValue === keyValue) {\n            break;\n          } else {\n            offset += getGroupCount(data[i], groups.length);\n          }\n        }\n\n        if (!data.length || pathValue !== keyValue) {\n          data.splice(i, 0, {\n            key: path[0],\n            items: [],\n            count: 1 === path.length ? collapsedGroup.count : void 0\n          });\n        }\n\n        appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset);\n      }\n\n      if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {\n        options.extra.totalCount += options.collapsedItemsCount;\n      }\n\n      callBase(options);\n\n      if (groupCount) {\n        var query = (0, _query2.default)(data);\n        (0, _store_helper.multiLevelGroup)(query, groups).enumerate().done(function (groupedData) {\n          data = groupedData;\n        });\n\n        if (collapsedGroups) {\n          for (var pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {\n            appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip);\n          }\n        }\n\n        if (!options.isCustomLoading) {\n          processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);\n        }\n\n        options.data = data;\n      }\n    },\n    isGroupItemCountable: function (item) {\n      return null === item.items;\n    },\n    updateTotalItemsCount: function () {\n      var itemsCountCorrection = 0;\n      foreachCollapsedGroups(this, function (groupInfo) {\n        if (groupInfo.count) {\n          itemsCountCorrection -= groupInfo.count - 1;\n        }\n      });\n      this.callBase(itemsCountCorrection);\n    },\n    changeRowExpand: function (path) {\n      var that = this;\n      var dataSource = that._dataSource;\n      var beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();\n      var dataSourceItems = dataSource.items();\n      var offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());\n      var groupInfo = that.findGroupInfo(path);\n      var groupCountQuery;\n\n      if (groupInfo && !groupInfo.isExpanded) {\n        groupCountQuery = new _deferred.Deferred().resolve(groupInfo.count);\n      } else {\n        groupCountQuery = loadTotalCount(dataSource, {\n          filter: (0, _uiData_grid2.createGroupFilter)(path, {\n            filter: dataSource.filter(),\n            group: dataSource.group()\n          })\n        });\n      }\n\n      return (0, _deferred.when)(groupCountQuery).done(function (count) {\n        count = parseInt(count.length ? count[0] : count);\n\n        if (groupInfo) {\n          updateGroupOffsets(that, dataSourceItems, [], offset);\n          groupInfo.isExpanded = !groupInfo.isExpanded;\n          groupInfo.count = count;\n        } else {\n          groupInfo = {\n            offset: -1,\n            count: count,\n            path: path,\n            isExpanded: false\n          };\n          updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);\n\n          if (groupInfo.offset >= 0) {\n            that.addGroupInfo(groupInfo);\n          }\n        }\n\n        that.updateTotalItemsCount();\n      }).fail(function () {\n        dataSource._eventsStrategy.fireEvent(\"loadError\", arguments);\n      });\n    },\n    allowCollapseAll: function () {\n      return false;\n    },\n    refresh: function (options, isReload, operationTypes) {\n      var that = this;\n      var storeLoadOptions = options.storeLoadOptions;\n      var dataSource = that._dataSource;\n      this.callBase.apply(this, arguments);\n\n      if (isReload || operationTypes.reload) {\n        return foreachCollapsedGroups(that, function (groupInfo) {\n          var groupCountQuery = loadTotalCount(dataSource, {\n            filter: (0, _uiData_grid2.createGroupFilter)(groupInfo.path, storeLoadOptions)\n          });\n          var groupOffsetQuery = loadTotalCount(dataSource, {\n            filter: (0, _uiData_gridGrouping.createOffsetFilter)(groupInfo.path, storeLoadOptions)\n          });\n          return (0, _deferred.when)(groupOffsetQuery, groupCountQuery).done(function (offset, count) {\n            offset = parseInt(offset.length ? offset[0] : offset);\n            count = parseInt(count.length ? count[0] : count);\n            groupInfo.offset = offset;\n\n            if (groupInfo.count !== count) {\n              groupInfo.count = count;\n              that.updateTotalItemsCount();\n            }\n          });\n        }, true);\n      }\n    }\n  };\n}());","map":null,"metadata":{},"sourceType":"script"}