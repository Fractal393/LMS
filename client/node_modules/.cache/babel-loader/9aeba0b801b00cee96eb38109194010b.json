{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Component, Property, setStyleAttribute, ChildProperty, compile, isBlazor } from '@syncfusion/ej2-base';\nimport { NotifyPropertyChanges, addClass, Collection, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { Event, EventHandler, selectAll, removeClass, select, Browser, detach, formatUnit } from '@syncfusion/ej2-base';\nimport { SanitizeHtmlHelper, extend } from '@syncfusion/ej2-base';\nvar ROOT = 'e-splitter';\nvar HORIZONTAL_PANE = 'e-splitter-horizontal';\nvar VERTICAL_PANE = 'e-splitter-vertical';\nvar PANE = 'e-pane';\nvar SPLIT_H_PANE = 'e-pane-horizontal';\nvar SPLIT_V_PANE = 'e-pane-vertical';\nvar SPLIT_BAR = 'e-split-bar';\nvar SPLIT_H_BAR = 'e-split-bar-horizontal';\nvar SPLIT_V_BAR = 'e-split-bar-vertical';\nvar STATIC_PANE = 'e-static-pane';\nvar SCROLL_PANE = 'e-scrollable';\nvar RESIZE_BAR = 'e-resize-handler';\nvar RESIZABLE_BAR = 'e-resizable-split-bar';\nvar SPLIT_BAR_HOVER = 'e-split-bar-hover';\nvar SPLIT_BAR_ACTIVE = 'e-split-bar-active';\nvar HIDE_HANDLER = 'e-hide-handler';\nvar SPLIT_TOUCH = 'e-splitter-touch';\nvar DISABLED = 'e-disabled';\nvar RTL = 'e-rtl';\nvar E_ICONS = 'e-icons';\nvar COLLAPSIBLE = 'e-collapsible';\nvar NAVIGATE_ARROW = 'e-navigate-arrow';\nvar ARROW_RIGHT = 'e-arrow-right';\nvar ARROW_LEFT = 'e-arrow-left';\nvar ARROW_UP = 'e-arrow-up';\nvar ARROW_DOWN = 'e-arrow-down';\nvar HIDE_ICON = 'e-icon-hidden';\nvar EXPAND_PANE = 'e-expanded';\nvar COLLAPSE_PANE = 'e-collapsed';\nvar PANE_HIDDEN = 'e-pane-hidden';\nvar RESIZABLE_PANE = 'e-resizable';\nvar LAST_BAR = 'e-last-bar';\nvar BAR_SIZE_DEFAULT = 1;\n/**\n * Interface to configure pane properties such as its content, size, min, max, resizable, collapsed and collapsible.\n */\n\nvar PaneProperties =\n/** @class */\nfunction (_super) {\n  __extends(PaneProperties, _super);\n\n  function PaneProperties() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property()], PaneProperties.prototype, \"size\", void 0);\n\n  __decorate([Property(false)], PaneProperties.prototype, \"collapsible\", void 0);\n\n  __decorate([Property(false)], PaneProperties.prototype, \"collapsed\", void 0);\n\n  __decorate([Property(true)], PaneProperties.prototype, \"resizable\", void 0);\n\n  __decorate([Property(null)], PaneProperties.prototype, \"min\", void 0);\n\n  __decorate([Property(null)], PaneProperties.prototype, \"max\", void 0);\n\n  __decorate([Property()], PaneProperties.prototype, \"content\", void 0);\n\n  __decorate([Property('')], PaneProperties.prototype, \"cssClass\", void 0);\n\n  return PaneProperties;\n}(ChildProperty);\n\nexport { PaneProperties };\n/**\n * Splitter is a layout user interface (UI) control that has resizable and collapsible split panes.\n * The container can be split into multiple panes, which are oriented horizontally or vertically.\n * The separator (divider) splits the panes and resizes and expands/collapses the panes.\n * The splitter is placed inside the split pane to make a nested layout user interface.\n *\n * ```html\n * <div id=\"splitter\">\n *  <div> Left Pane </div>\n *  <div> Center Pane </div>\n *  <div> Right Pane </div>\n * </div>\n * ```\n * ```typescript\n * <script>\n *   var splitterObj = new Splitter({ width: '300px', height: '200px'});\n *   splitterObj.appendTo('#splitter');\n * </script>\n * ```\n */\n\nvar Splitter =\n/** @class */\nfunction (_super) {\n  __extends(Splitter, _super);\n  /**\n   * Initializes a new instance of the Splitter class.\n   * @param options  - Specifies Splitter model properties as options.\n   * @param element  - Specifies the element that is rendered as an Splitter.\n   */\n\n\n  function Splitter(options, element) {\n    var _this = _super.call(this, options, element) || this;\n\n    _this.allPanes = [];\n    _this.paneOrder = [];\n    _this.separatorOrder = [];\n    _this.allBars = [];\n    _this.previousCoordinates = {};\n    _this.currentCoordinates = {};\n    _this.updatePrePaneInPercentage = false;\n    _this.updateNextPaneInPercentage = false;\n    _this.panesDimensions = [];\n    _this.border = 0;\n    _this.validDataAttributes = ['data-size', 'data-min', 'data-max', 'data-collapsible', 'data-resizable', 'data-content', 'data-collapsed'];\n    _this.validElementAttributes = ['data-orientation', 'data-width', 'data-height'];\n    _this.iconsDelay = 300;\n    _this.templateElement = [];\n    _this.collapseFlag = false;\n    _this.expandFlag = true;\n    return _this;\n  }\n  /**\n   * Gets called when the model property changes.The data that describes the old and new values of the property that changed.\n   * @param  {SplitterModel} newProp\n   * @param  {SplitterModel} oldProp\n   * @returns void\n   * @private\n   */\n\n\n  Splitter.prototype.onPropertyChanged = function (newProp, oldProp) {\n    if (!this.element.classList.contains(ROOT)) {\n      return;\n    }\n\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'height':\n          this.setSplitterSize(this.element, newProp.height, 'height');\n          break;\n\n        case 'width':\n          this.setSplitterSize(this.element, newProp.width, 'width');\n          break;\n\n        case 'cssClass':\n          this.setCssClass(this.element, newProp.cssClass);\n          break;\n\n        case 'enabled':\n          this.isEnabled(this.enabled);\n          break;\n\n        case 'separatorSize':\n          this.setSeparatorSize(newProp.separatorSize);\n          break;\n\n        case 'orientation':\n          this.changeOrientation(newProp.orientation);\n          break;\n\n        case 'paneSettings':\n          if (!(newProp.paneSettings instanceof Array && oldProp.paneSettings instanceof Array)) {\n            var paneCounts = Object.keys(newProp.paneSettings);\n\n            for (var i = 0; i < paneCounts.length; i++) {\n              var index = parseInt(Object.keys(newProp.paneSettings)[i], 10);\n              var changedPropsCount = Object.keys(newProp.paneSettings[index]).length;\n\n              for (var j = 0; j < changedPropsCount; j++) {\n                var property = Object.keys(newProp.paneSettings[index])[j];\n\n                switch (property) {\n                  case 'content':\n                    var newValue = Object(newProp.paneSettings[index])[property];\n\n                    if (!isNullOrUndefined(newValue)) {\n                      this.allPanes[index].innerHTML = '';\n                      this.setTemplate(newValue, this.allPanes[index]);\n                    }\n\n                    break;\n\n                  case 'resizable':\n                    var newVal = Object(newProp.paneSettings[index])[property];\n                    this.resizableModel(index, newVal);\n                    break;\n\n                  case 'collapsible':\n                    this.collapsibleModelUpdate(index);\n                    break;\n\n                  case 'collapsed':\n                    newProp.paneSettings[index].collapsed ? this.isCollapsed(index) : this.collapsedOnchange(index);\n                    break;\n\n                  case 'cssClass':\n                    this.setCssClass(this.allPanes[index], newProp.paneSettings[index].cssClass);\n                    break;\n\n                  case 'size':\n                    var newValSize = Object(newProp.paneSettings[index])[property];\n\n                    if (newValSize !== '' && !isNullOrUndefined(newValSize)) {\n                      this.updatePaneSize(newValSize, index);\n                    }\n\n                    break;\n                }\n              }\n            }\n          } else {\n            this.destroyPaneSettings();\n            this.allBars = [];\n            this.allPanes = [];\n            this.createSplitPane(this.element);\n            this.addSeparator(this.element);\n            this.getPanesDimensions();\n            this.setRTL(this.enableRtl);\n            this.isCollapsed();\n          }\n\n          break;\n\n        case 'enableRtl':\n          this.setRTL(newProp.enableRtl);\n          break;\n      }\n    }\n  };\n\n  Splitter.prototype.updatePaneSize = function (newValSize, index) {\n    this.allPanes[index].style.flexBasis = newValSize;\n    var flexPaneIndexes = [];\n    var staticPaneWidth;\n    var flexCount = 0;\n\n    for (var i = 0; i < this.allPanes.length; i++) {\n      if (!this.paneSettings[i].size && !(this.allPanes[i].innerText === '')) {\n        flexPaneIndexes[flexCount] = i;\n        flexCount++;\n      } else if (this.paneSettings[i].size) {\n        staticPaneWidth = this.orientation === 'Horizontal' ? this.allPanes[index].offsetWidth : this.allPanes[index].offsetHeight;\n      }\n    }\n\n    staticPaneWidth = this.orientation === 'Horizontal' ? this.allBars[0].offsetWidth * this.allBars.length + staticPaneWidth : this.allBars[0].offsetHeight * this.allBars.length + staticPaneWidth;\n    var flexPaneWidth = (this.orientation === 'Horizontal' ? this.element.offsetWidth : this.element.offsetHeight) - staticPaneWidth - this.border * 2;\n    var avgDiffWidth = flexPaneWidth / flexPaneIndexes.length;\n\n    for (var j = 0; j < flexPaneIndexes.length; j++) {\n      this.allPanes[flexPaneIndexes[j]].style.flexBasis = avgDiffWidth + 'px';\n    }\n\n    this.allPanes[index].classList.add(STATIC_PANE);\n  };\n\n  Splitter.prototype.preRender = function () {\n    this.wrapper = this.element.cloneNode(true);\n    this.wrapperParent = this.element.parentElement;\n\n    if (!this.checkBlazor()) {\n      removeClass([this.wrapper], ['e-control', 'e-lib', ROOT]);\n      var orientation_1 = this.orientation === 'Horizontal' ? HORIZONTAL_PANE : VERTICAL_PANE;\n      addClass([this.element], orientation_1);\n    }\n\n    var name = Browser.info.name;\n    var css = name === 'msie' ? 'e-ie' : '';\n    this.setCssClass(this.element, css);\n\n    if (Browser.isDevice) {\n      addClass([this.element], SPLIT_TOUCH);\n    }\n  };\n\n  Splitter.prototype.getPersistData = function () {\n    return this.addOnPersist([]);\n  };\n  /**\n   * Returns the current module name.\n   * @returns string\n   * @private\n   */\n\n\n  Splitter.prototype.getModuleName = function () {\n    return 'splitter';\n  };\n  /**\n   * To Initialize the control rendering\n   * @private\n   */\n\n\n  Splitter.prototype.render = function () {\n    if (!this.checkBlazor()) {\n      this.checkDataAttributes();\n      this.setCssClass(this.element, this.cssClass);\n      this.isEnabled(this.enabled);\n      this.setDimension(this.getHeight(this.element), this.getWidth(this.element));\n    }\n\n    this.createSplitPane(this.element);\n    this.addSeparator(this.element);\n    this.getPanesDimensions();\n    this.setPaneSettings();\n\n    if (!this.checkBlazor()) {\n      this.setRTL(this.enableRtl);\n    }\n\n    this.collapseFlag = true;\n    this.isCollapsed();\n    this.collapseFlag = false;\n    EventHandler.add(document, 'touchstart click', this.onDocumentClick, this);\n    this.renderComplete();\n    window.addEventListener('resize', this.reportWindowSize.bind(this), true);\n    EventHandler.add(this.element, 'keydown', this.onMove, this);\n  };\n\n  Splitter.prototype.onDocumentClick = function (e) {\n    if (!e.target.classList.contains(SPLIT_BAR) && !isNullOrUndefined(this.currentSeparator)) {\n      this.currentSeparator.classList.remove(SPLIT_BAR_HOVER);\n      this.currentSeparator.classList.remove(SPLIT_BAR_ACTIVE);\n    }\n  };\n\n  Splitter.prototype.checkPaneSize = function (e) {\n    var prePaneSize;\n    var nextPaneSize;\n    var splitBarSize = isNullOrUndefined(this.separatorSize) ? BAR_SIZE_DEFAULT : this.separatorSize;\n    prePaneSize = this.orientation === 'Horizontal' ? this.previousPane.offsetWidth : this.previousPane.offsetHeight;\n    nextPaneSize = this.orientation === 'Horizontal' ? this.nextPane.offsetWidth : this.nextPane.offsetHeight;\n\n    if (this.previousPane.style.flexBasis.indexOf('%') > 0 || this.nextPane.style.flexBasis.indexOf('%') > 0) {\n      var previousFlexBasis = this.updatePaneFlexBasis(this.previousPane);\n      var nextFlexBasis = this.updatePaneFlexBasis(this.nextPane);\n      this.totalPercent = previousFlexBasis + nextFlexBasis;\n      this.totalWidth = this.convertPercentageToPixel(this.totalPercent + '%');\n\n      if (e.type === 'keydown' && !isNullOrUndefined(e.keyCode)) {\n        if ((e.keyCode === 39 || e.keyCode === 40) && nextPaneSize > 0) {\n          this.previousPane.style.flexBasis = previousFlexBasis + 1 + '%';\n          this.nextPane.style.flexBasis = nextFlexBasis - 1 + '%';\n        } else if ((e.keyCode === 37 || e.keyCode === 38) && prePaneSize > 0) {\n          this.previousPane.style.flexBasis = previousFlexBasis - 1 + '%';\n          this.nextPane.style.flexBasis = nextFlexBasis + 1 + '%';\n        }\n      }\n    } else {\n      this.totalWidth = this.orientation === 'Horizontal' ? this.previousPane.offsetWidth + this.nextPane.offsetWidth : this.previousPane.offsetHeight + this.nextPane.offsetHeight;\n\n      if (e.type === 'keydown' && !isNullOrUndefined(e.keyCode)) {\n        if ((e.keyCode === 39 || e.keyCode === 40) && nextPaneSize > 0) {\n          this.addStaticPaneClass();\n          this.previousPane.style.flexBasis = prePaneSize + splitBarSize + 'px';\n          this.nextPane.style.flexBasis = nextPaneSize < splitBarSize ? '0px' : nextPaneSize - splitBarSize + 'px';\n        } else if ((e.keyCode === 37 || e.keyCode === 38) && prePaneSize > 0) {\n          this.addStaticPaneClass();\n          this.previousPane.style.flexBasis = prePaneSize < splitBarSize ? '0px' : prePaneSize - splitBarSize + 'px';\n          this.nextPane.style.flexBasis = nextPaneSize + splitBarSize + 'px';\n        }\n      }\n    }\n  };\n\n  Splitter.prototype.onMove = function (event) {\n    if (this.allPanes.length > 1) {\n      var index = this.getSeparatorIndex(this.currentSeparator);\n      var isPrevpaneCollapsed = this.previousPane.classList.contains(COLLAPSE_PANE);\n      var isPrevpaneExpanded = this.previousPane.classList.contains(EXPAND_PANE);\n      var isNextpaneCollapsed = this.nextPane.classList.contains(COLLAPSE_PANE);\n\n      if ((this.orientation !== 'Horizontal' && event.keyCode === 38 || this.orientation === 'Horizontal' && event.keyCode === 39 || this.orientation === 'Horizontal' && event.keyCode === 37 || this.orientation !== 'Horizontal' && event.keyCode === 40) && (!isPrevpaneExpanded && !isNextpaneCollapsed && !isPrevpaneCollapsed || isPrevpaneExpanded && !isNextpaneCollapsed) && document.activeElement.classList.contains(SPLIT_BAR) && this.paneSettings[index].resizable && this.paneSettings[index + 1].resizable) {\n        this.checkPaneSize(event);\n        this.triggerResizing(event);\n      } else if (event.keyCode === 13 && this.paneSettings[index].collapsible && document.activeElement.classList.contains(SPLIT_BAR)) {\n        if (!this.previousPane.classList.contains(COLLAPSE_PANE)) {\n          this.collapse(index);\n          addClass([this.currentSeparator], SPLIT_BAR_ACTIVE);\n        } else {\n          this.expand(index);\n          addClass([this.currentSeparator], SPLIT_BAR_ACTIVE);\n        }\n      }\n    }\n  };\n\n  ;\n  /**\n   * @hidden\n   */\n\n  Splitter.prototype.sanitizeHelper = function (value) {\n    if (this.enableHtmlSanitizer) {\n      var item = SanitizeHtmlHelper.beforeSanitize();\n      var beforeEvent = {\n        cancel: false,\n        helper: null\n      };\n      extend(item, item, beforeEvent);\n      this.trigger('beforeSanitizeHtml', item);\n\n      if (item.cancel && !isNullOrUndefined(item.helper)) {\n        value = item.helper(value);\n      } else if (!item.cancel) {\n        value = SanitizeHtmlHelper.serializeValue(item, value);\n      }\n    }\n\n    return value;\n  };\n\n  Splitter.prototype.checkDataAttributes = function () {\n    var api;\n    var value; // Element values\n\n    for (var dataIndex = 0; dataIndex < this.validElementAttributes.length; dataIndex++) {\n      value = this.element.getAttribute(this.validElementAttributes[dataIndex]);\n\n      if (!isNullOrUndefined(value)) {\n        api = this.removeDataPrefix(this.validElementAttributes[dataIndex]); // tslint:disable-next-line\n\n        this[api] = value;\n      }\n    } // Pane values\n\n\n    for (var paneIndex = 0; paneIndex < this.element.children.length; paneIndex++) {\n      for (var dataAttr = 0; dataAttr < this.validDataAttributes.length; dataAttr++) {\n        value = this.element.children[paneIndex].getAttribute(this.validDataAttributes[dataAttr]);\n\n        if (!isNullOrUndefined(value)) {\n          api = this.removeDataPrefix(this.validDataAttributes[dataAttr]);\n          value = api === 'collapsible' || api === 'resizable' ? value === 'true' : value;\n\n          if (isNullOrUndefined(this.paneSettings[paneIndex])) {\n            this.paneSettings[paneIndex] = {\n              size: '',\n              min: null,\n              max: null,\n              content: '',\n              resizable: true,\n              collapsible: false,\n              collapsed: false\n            };\n          } // tslint:disable-next-line\n\n\n          var paneAPI = this.paneSettings[paneIndex][api];\n\n          if (api === 'resizable' || api === 'collapsible' || api === 'collapsed') {\n            // tslint:disable-next-line\n            this.paneSettings[paneIndex][api] = value;\n          }\n\n          if (isNullOrUndefined(paneAPI) || paneAPI === '') {\n            // tslint:disable-next-line\n            this.paneSettings[paneIndex][api] = value;\n          }\n        }\n      }\n    }\n  };\n\n  Splitter.prototype.destroyPaneSettings = function () {\n    [].slice.call(this.element.children).forEach(function (el) {\n      detach(el);\n    });\n    this.restoreElem();\n  };\n\n  Splitter.prototype.checkBlazor = function () {\n    return isBlazor() && this.isServerRendered;\n  };\n\n  Splitter.prototype.setPaneSettings = function () {\n    var childCount = this.allPanes.length;\n    var paneCollection = [];\n    var paneValue = {\n      size: '',\n      min: null,\n      max: null,\n      content: '',\n      resizable: true,\n      collapsed: false,\n      collapsible: false,\n      cssClass: ''\n    };\n\n    for (var i = 0; i < childCount; i++) {\n      if (isNullOrUndefined(this.paneSettings[i])) {\n        paneCollection[i] = paneValue;\n      } else {\n        paneCollection[i] = this.paneSettings[i];\n      }\n    }\n\n    this.setProperties({\n      'paneSettings': paneCollection\n    }, true);\n  };\n\n  Splitter.prototype.checkArrow = function (paneIndex, targetArrow) {\n    return this.allBars[paneIndex].querySelector('.' + NAVIGATE_ARROW + '.' + targetArrow);\n  };\n\n  Splitter.prototype.removeDataPrefix = function (attribute) {\n    return attribute.slice(attribute.lastIndexOf('-') + 1);\n  };\n\n  Splitter.prototype.setRTL = function (rtl) {\n    rtl ? addClass([this.element], RTL) : removeClass([this.element], RTL);\n  };\n\n  Splitter.prototype.setSplitterSize = function (element, size, property) {\n    var style = property === 'width' ? {\n      'width': formatUnit(size)\n    } : {\n      'height': formatUnit(size)\n    };\n    setStyleAttribute(element, style);\n  };\n\n  Splitter.prototype.getPanesDimensions = function () {\n    for (var index = 0; index < this.allPanes.length; index++) {\n      this.orientation === 'Horizontal' ? this.panesDimensions.push(this.allPanes[index].getBoundingClientRect().width) : this.panesDimensions.push(this.allPanes[index].getBoundingClientRect().height);\n    }\n  };\n\n  Splitter.prototype.setCssClass = function (element, className) {\n    if (className) {\n      addClass([element], className.split(className.indexOf(',') > -1 ? ',' : ' '));\n    }\n  };\n\n  Splitter.prototype.hideResizer = function (target) {\n    addClass([select('.' + RESIZE_BAR, target)], HIDE_HANDLER);\n  };\n\n  Splitter.prototype.showResizer = function (target) {\n    if (!isNullOrUndefined(this.previousPane) && this.previousPane.classList.contains(RESIZABLE_PANE) && !isNullOrUndefined(this.nextPane) && this.nextPane.classList.contains(RESIZABLE_PANE)) {\n      removeClass([select('.' + RESIZE_BAR, target)], HIDE_HANDLER);\n    }\n  };\n\n  Splitter.prototype.resizableModel = function (index, newVal) {\n    var paneIndex;\n    var i = index;\n    paneIndex = index === this.allBars.length ? index - 1 : index;\n    EventHandler.remove(this.allBars[paneIndex], 'mousedown', this.onMouseDown);\n\n    if (newVal) {\n      EventHandler.add(this.allBars[paneIndex], 'mousedown', this.onMouseDown, this);\n\n      if (this.isResizable()) {\n        this.showResizer(this.allBars[paneIndex]);\n        removeClass([select('.' + RESIZE_BAR, this.allBars[paneIndex])], HIDE_HANDLER);\n        this.allBars[paneIndex].classList.add(RESIZABLE_BAR);\n        index === this.allBars.length ? this.allPanes[index].classList.add(RESIZABLE_PANE) : this.allPanes[paneIndex].classList.add(RESIZABLE_PANE);\n        this.updateResizablePanes(i);\n      }\n    } else {\n      this.updateResizablePanes(i);\n      this.hideResizer(this.allBars[paneIndex]);\n      this.allBars[paneIndex].classList.remove(RESIZABLE_BAR);\n      index === this.allBars.length ? this.allPanes[index].classList.remove(RESIZABLE_PANE) : this.allPanes[paneIndex].classList.remove(RESIZABLE_PANE);\n    }\n  };\n\n  Splitter.prototype.collapsibleModelUpdate = function (index) {\n    var arrow2;\n    var arrow1;\n    var paneIndex;\n    paneIndex = index === this.allBars.length ? index - 1 : index;\n    arrow2 = this.orientation === 'Horizontal' ? this.checkArrow(paneIndex, ARROW_LEFT) : this.checkArrow(paneIndex, ARROW_UP);\n    arrow1 = this.orientation === 'Horizontal' ? this.checkArrow(paneIndex, ARROW_RIGHT) : this.checkArrow(paneIndex, ARROW_DOWN);\n    this.paneCollapsible(this.allPanes[index], index);\n    this.updateCollapseIcons(paneIndex, arrow1, arrow2);\n  };\n\n  Splitter.prototype.collapseArrow = function (barIndex, arrow) {\n    return selectAll('.' + arrow, this.allBars[barIndex])[0];\n  };\n\n  Splitter.prototype.updateIsCollapsed = function (index, collapseArrow, lastBarArrow) {\n    if (!isNullOrUndefined(index)) {\n      var targetEle = void 0;\n      var lastBarIndex = index === this.allBars.length;\n      var barIndex = lastBarIndex ? index - 1 : index;\n\n      if (!lastBarIndex && this.allPanes[index + 1].classList.contains(COLLAPSE_PANE) && index !== 0) {\n        targetEle = this.collapseArrow(barIndex - 1, lastBarArrow);\n      } else {\n        targetEle = lastBarIndex ? this.collapseArrow(barIndex, lastBarArrow) : this.collapseArrow(barIndex, collapseArrow);\n      }\n\n      targetEle.click();\n    }\n  };\n\n  Splitter.prototype.isCollapsed = function (index) {\n    var _this = this;\n\n    if (!isNullOrUndefined(index) && this.paneSettings[index].collapsed && isNullOrUndefined(this.allPanes[index].classList.contains(COLLAPSE_PANE))) {\n      return;\n    }\n\n    this.expandFlag = false;\n\n    if (!isNullOrUndefined(index)) {\n      this.collapseFlag = true;\n      var targetEle = void 0;\n      var lastBarIndex = index === this.allBars.length;\n      var barIndex = lastBarIndex ? index - 1 : index;\n\n      if (!lastBarIndex && this.allPanes[index + 1].classList.contains(COLLAPSE_PANE) && index !== 0) {\n        targetEle = this.collapseArrow(barIndex - 1, this.targetArrows().lastBarArrow);\n      } else {\n        targetEle = lastBarIndex ? this.collapseArrow(barIndex, this.targetArrows().lastBarArrow) : this.collapseArrow(barIndex, this.targetArrows().collapseArrow);\n      }\n\n      var event_1 = {\n        target: targetEle\n      };\n      var eventArgs = this.beforeAction(event_1);\n      this.trigger('beforeCollapse', eventArgs, function (beforeCollapseArgs) {\n        if (!beforeCollapseArgs.cancel) {\n          var collapsedindex = [];\n          collapsedindex[0] = index;\n          var j = 1;\n\n          for (var i = 0; i < _this.allPanes.length; i++) {\n            if (_this.allPanes[i].classList.contains(COLLAPSE_PANE)) {\n              collapsedindex[j] = i;\n              j++;\n            }\n          }\n\n          collapsedindex = collapsedindex.sort();\n\n          _this.updateIsCollapsed(index, _this.targetArrows().collapseArrow, _this.targetArrows().lastBarArrow);\n\n          for (var i = 0; i < collapsedindex.length; i++) {\n            if (!_this.allPanes[collapsedindex[i]].classList.contains(COLLAPSE_PANE)) {\n              _this.updateIsCollapsed(collapsedindex[i], _this.targetArrows().collapseArrow, _this.targetArrows().lastBarArrow);\n            }\n          }\n\n          for (var i = collapsedindex.length; i > 0; i--) {\n            if (!_this.allPanes[collapsedindex[i - 1]].classList.contains(COLLAPSE_PANE)) {\n              var targetArrow = _this.targetArrows();\n\n              _this.updateIsCollapsed(collapsedindex[i - 1], targetArrow.collapseArrow, targetArrow.lastBarArrow);\n            }\n          }\n\n          var collapseEventArgs = _this.afterAction(event_1);\n\n          _this.trigger('collapsed', collapseEventArgs);\n\n          _this.collapseFlag = false;\n        }\n      });\n    } else {\n      for (var m = 0; m < this.allPanes.length; m++) {\n        if (!isNullOrUndefined(this.paneSettings[m]) && this.paneSettings[m].collapsed) {\n          this.updateIsCollapsed(m, this.targetArrows().collapseArrow, this.targetArrows().lastBarArrow);\n        }\n      }\n\n      for (var m = this.allPanes.length - 1; m >= 0; m--) {\n        if (!isNullOrUndefined(this.paneSettings[m]) && this.paneSettings[m].collapsed && !this.allPanes[m].classList.contains(COLLAPSE_PANE)) {\n          var collapseArrow = this.orientation === 'Horizontal' ? ARROW_RIGHT : ARROW_DOWN;\n\n          if (m !== 0) {\n            var targetEle = this.collapseArrow(m - 1, collapseArrow);\n            targetEle.click();\n          }\n\n          if (!this.nextPane.classList.contains(COLLAPSE_PANE)) {\n            var targetEle = this.collapseArrow(m - 1, collapseArrow);\n            targetEle.click();\n          }\n        }\n      }\n    }\n\n    this.expandFlag = true;\n  };\n\n  Splitter.prototype.targetArrows = function () {\n    this.splitterProperty();\n    return {\n      collapseArrow: this.orientation === 'Horizontal' ? ARROW_LEFT : ARROW_UP,\n      lastBarArrow: this.orientation === 'Vertical' ? ARROW_DOWN : ARROW_RIGHT\n    };\n  };\n\n  Splitter.prototype.collapsedOnchange = function (index) {\n    if (!isNullOrUndefined(this.paneSettings[index]) && !isNullOrUndefined(this.paneSettings[index].collapsed) && this.allPanes[index].classList.contains(COLLAPSE_PANE)) {\n      this.updateIsCollapsed(index, this.targetArrows().lastBarArrow, this.targetArrows().collapseArrow);\n    }\n  };\n\n  Splitter.prototype.isEnabled = function (enabled) {\n    enabled ? removeClass([this.element], DISABLED) : addClass([this.element], DISABLED);\n  };\n\n  Splitter.prototype.setSeparatorSize = function (size) {\n    var sizeValue = isNullOrUndefined(size) ? 'auto' : size + 'px';\n    var separator = this.orientation === 'Horizontal' ? SPLIT_H_BAR : SPLIT_V_BAR;\n\n    for (var index = 0; index < this.allBars.length; index++) {\n      var splitBar = selectAll('.' + separator, this.element)[index];\n      var resizeBar = selectAll('.' + RESIZE_BAR, splitBar)[0];\n\n      if (this.orientation === 'Horizontal') {\n        splitBar.style.width = sizeValue;\n\n        if (!isNullOrUndefined(resizeBar)) {\n          resizeBar.style.width = sizeValue;\n        }\n      } else {\n        splitBar.style.height = sizeValue;\n\n        if (!isNullOrUndefined(resizeBar)) {\n          resizeBar.style.height = sizeValue;\n        }\n      }\n    }\n  };\n\n  Splitter.prototype.changeOrientation = function (orientation) {\n    var isVertical = orientation === 'Vertical';\n    this.element.classList.remove(isVertical ? HORIZONTAL_PANE : VERTICAL_PANE);\n    this.element.classList.add(isVertical ? VERTICAL_PANE : HORIZONTAL_PANE);\n\n    for (var index = 0; index < this.allPanes.length; index++) {\n      this.allPanes[index].classList.remove(isVertical ? SPLIT_H_PANE : SPLIT_V_PANE);\n      this.allPanes[index].classList.add(isVertical ? SPLIT_V_PANE : SPLIT_H_PANE);\n    }\n\n    for (var index = 0; index < this.allBars.length; index++) {\n      detach(this.allBars[index]);\n    }\n\n    this.allBars = [];\n    this.addSeparator(this.element);\n  };\n\n  Splitter.prototype.checkSplitPane = function (currentBar, elementIndex) {\n    var paneEle = this.collectPanes(currentBar.parentElement.children)[elementIndex];\n    return paneEle;\n  };\n\n  Splitter.prototype.collectPanes = function (childNodes) {\n    var elements = [];\n\n    for (var i = 0; i < childNodes.length; i++) {\n      if (childNodes[i].classList.contains(PANE)) {\n        elements.push(childNodes[i]);\n      }\n    }\n\n    return elements;\n  };\n\n  Splitter.prototype.getPrevPane = function (currentBar, order) {\n    return this.checkSplitPane(currentBar, (order - 1) / 2);\n  };\n\n  Splitter.prototype.getNextPane = function (currentBar, order) {\n    return this.checkSplitPane(currentBar, (order - 1) / 2 + 1);\n  };\n\n  Splitter.prototype.updateSeparatorSize = function (resizeHanlder) {\n    var sizeValue = isNullOrUndefined(this.separatorSize) ? '1px' : this.separatorSize + 'px';\n    this.orientation === 'Horizontal' ? resizeHanlder.style.width = sizeValue : resizeHanlder.style.height = sizeValue;\n  };\n\n  Splitter.prototype.addResizeHandler = function (currentBar) {\n    var resizeHanlder = this.createElement('div');\n    addClass([resizeHanlder], [RESIZE_BAR, E_ICONS]);\n    this.updateSeparatorSize(resizeHanlder);\n    currentBar.appendChild(resizeHanlder);\n  };\n\n  Splitter.prototype.getHeight = function (target) {\n    var height = this.height;\n    height = target.style.height !== '' && this.height === '100%' ? target.style.height : this.height;\n    return height;\n  };\n\n  Splitter.prototype.getWidth = function (target) {\n    var width = this.width;\n    width = target.style.width !== '' && this.width === '100%' ? target.style.width : this.width;\n    return width;\n  };\n\n  Splitter.prototype.setDimension = function (height, width) {\n    setStyleAttribute(this.element, {\n      'height': height,\n      'width': width\n    });\n  };\n\n  Splitter.prototype.updateCollapseIcons = function (index, arrow1, arrow2) {\n    if (!isNullOrUndefined(this.paneSettings[index])) {\n      if (!isNullOrUndefined(this.paneSettings[index].collapsible)) {\n        this.paneSettings[index].collapsible ? removeClass([arrow2], [HIDE_ICON]) : addClass([arrow2], [HIDE_ICON]);\n\n        if (!isNullOrUndefined(this.paneSettings[index + 1])) {\n          this.paneSettings[index + 1].collapsible ? removeClass([arrow1], [HIDE_ICON]) : addClass([arrow1], [HIDE_ICON]);\n        }\n\n        if (!isNullOrUndefined(this.paneSettings[index + 1])) {\n          if (this.paneSettings[index + 1].collapsible) {\n            this.paneSettings[index + 1].collapsible ? removeClass([arrow1], [HIDE_ICON]) : addClass([arrow1], [HIDE_ICON]);\n          }\n        }\n      }\n    }\n  };\n\n  Splitter.prototype.updateIconClass = function () {\n    if (this.orientation === 'Horizontal') {\n      this.leftArrow = ARROW_LEFT;\n      this.rightArrow = ARROW_RIGHT;\n    } else {\n      this.leftArrow = ARROW_UP;\n      this.rightArrow = ARROW_DOWN;\n    }\n  };\n\n  Splitter.prototype.createSeparator = function (i) {\n    var separator = this.createElement('div');\n    this.allBars.push(separator);\n    var arrow1 = this.createElement('button');\n    var arrow2 = this.createElement('button');\n    arrow1.setAttribute('tabindex', '-1');\n    arrow2.setAttribute('tabindex', '-1');\n    arrow1.setAttribute('aria-label', 'Toggle navigation');\n    arrow2.setAttribute('aria-label', 'Toggle navigation');\n    arrow1.setAttribute('type', 'button');\n    arrow2.setAttribute('type', 'button');\n    var size;\n    var proxy;\n    size = isNullOrUndefined(this.separatorSize) ? '1px' : this.separatorSize + 'px';\n\n    if (this.orientation === 'Horizontal') {\n      this.updateIconClass();\n      addClass([arrow2], [NAVIGATE_ARROW, ARROW_LEFT, HIDE_ICON]);\n      addClass([arrow1], [NAVIGATE_ARROW, ARROW_RIGHT, HIDE_ICON]);\n      addClass([separator], [SPLIT_BAR, SPLIT_H_BAR]);\n      separator.style.width = size;\n    } else {\n      addClass([arrow1], [NAVIGATE_ARROW, ARROW_DOWN, HIDE_ICON]);\n      addClass([arrow2], [NAVIGATE_ARROW, ARROW_UP, HIDE_ICON]);\n      addClass([separator], [SPLIT_BAR, SPLIT_V_BAR]);\n      this.updateIconClass();\n      separator.style.height = size;\n    }\n\n    this.addMouseActions(separator);\n    separator.appendChild(arrow2);\n    this.addResizeHandler(separator);\n    separator.appendChild(arrow1);\n    this.updateCollapseIcons(i, arrow1, arrow2);\n    separator.setAttribute('tabindex', '0');\n    proxy = this;\n    separator.addEventListener('focus', function () {\n      separator.classList.add(SPLIT_BAR_ACTIVE);\n      proxy.currentSeparator = separator;\n      proxy.getPaneDetails();\n    });\n    separator.addEventListener('blur', function () {\n      separator.classList.remove(SPLIT_BAR_ACTIVE);\n    });\n    return separator;\n  };\n\n  Splitter.prototype.updateResizablePanes = function (index) {\n    this.getPaneDetails();\n    this.isResizable() ? this.allPanes[index].classList.add(RESIZABLE_PANE) : this.allPanes[index].classList.remove(RESIZABLE_PANE);\n  };\n\n  Splitter.prototype.addSeparator = function (target) {\n    var _this = this;\n\n    var childCount = this.allPanes.length;\n    var clonedEle = target.children;\n    var separator;\n    var proxy;\n\n    if (this.checkBlazor()) {\n      for (var j = 0; j < this.element.children.length; j++) {\n        if (this.element.children[j].classList.contains(SPLIT_BAR)) {\n          this.allBars.push(this.element.children[j]);\n        }\n      }\n    }\n\n    for (var i = 0; i < childCount; i++) {\n      if (i < childCount - 1) {\n        if (!this.checkBlazor()) {\n          separator = this.createSeparator(i);\n          setStyleAttribute(separator, {\n            'order': i * 2 + 1\n          });\n          this.separatorOrder.push(i * 2 + 1);\n          clonedEle[i].parentNode.appendChild(separator);\n          this.currentSeparator = separator;\n          separator.setAttribute('role', 'separator');\n          separator.setAttribute('aria-orientation', this.orientation.toLowerCase());\n        }\n\n        if (this.checkBlazor()) {\n          proxy = this;\n          separator = this.allBars[i];\n          this.updateIconClass();\n        }\n\n        if (!this.checkBlazor()) {\n          this.wireClickEvents();\n        }\n\n        if (this.checkBlazor() && !isNullOrUndefined(separator)) {\n          this.currentSeparator = separator;\n          this.addMouseActions(separator);\n          this.wireClickEvents();\n          separator.addEventListener('focus', function () {\n            if (document.activeElement.classList.contains('e-split-bar')) {\n              proxy.currentSeparator = document.activeElement;\n              proxy.currentSeparator.classList.add(SPLIT_BAR_ACTIVE);\n            }\n\n            _this.getPaneDetails();\n          });\n          separator.addEventListener('blur', function () {\n            proxy.currentSeparator.classList.remove(SPLIT_BAR_ACTIVE);\n          });\n        }\n\n        if (!isNullOrUndefined(separator)) {\n          if (this.isResizable()) {\n            EventHandler.add(separator, 'mousedown', this.onMouseDown, this);\n            var eventName = Browser.info.name === 'msie' ? 'pointerdown' : 'touchstart';\n            EventHandler.add(separator, eventName, this.onMouseDown, this);\n            separator.classList.add(RESIZABLE_BAR);\n            this.updateResizablePanes(i);\n          } else {\n            addClass([select('.' + RESIZE_BAR, separator)], HIDE_HANDLER);\n          }\n        }\n      } else {\n        if (separator) {\n          addClass([separator], LAST_BAR);\n        }\n\n        if (childCount > 1) {\n          this.updateResizablePanes(i);\n        }\n      }\n    }\n\n    if (Browser.info.name === 'msie') {\n      var allBar = this.element.querySelectorAll('.e-splitter .e-resize-handler');\n\n      for (var i = 0; i < allBar.length; i++) {\n        var sepSize = isNullOrUndefined(this.separatorSize) ? 1 : this.separatorSize;\n        allBar[i].style.paddingLeft = sepSize / 2 + 'px';\n        allBar[i].style.paddingRight = sepSize / 2 + 'px';\n      }\n    }\n  };\n\n  Splitter.prototype.isResizable = function () {\n    var resizable = false;\n\n    if (!isNullOrUndefined(this.paneSettings[this.getPreviousPaneIndex()]) && this.paneSettings[this.getPreviousPaneIndex()].resizable && !isNullOrUndefined(this.paneSettings[this.getNextPaneIndex()]) && this.paneSettings[this.getNextPaneIndex()].resizable || isNullOrUndefined(this.paneSettings[this.getNextPaneIndex()])) {\n      resizable = true;\n    }\n\n    return resizable;\n  };\n\n  Splitter.prototype.addMouseActions = function (separator) {\n    var _this = this;\n\n    var sTout;\n    var hoverTimeOut;\n    separator.addEventListener('mouseenter', function () {\n      /* istanbul ignore next */\n      sTout = setTimeout(function () {\n        addClass([separator], [SPLIT_BAR_HOVER]);\n      }, _this.iconsDelay);\n    });\n    separator.addEventListener('mouseleave', function () {\n      clearTimeout(sTout);\n      removeClass([separator], [SPLIT_BAR_HOVER]);\n    });\n    separator.addEventListener('mouseout', function () {\n      clearTimeout(hoverTimeOut);\n    });\n    separator.addEventListener('mouseover', function () {\n      /* istanbul ignore next */\n      hoverTimeOut = setTimeout(function () {\n        addClass([separator], [SPLIT_BAR_HOVER]);\n      }, _this.iconsDelay);\n    });\n  };\n\n  Splitter.prototype.getEventType = function (e) {\n    return e.indexOf('mouse') > -1 ? 'mouse' : 'touch';\n  };\n\n  Splitter.prototype.updateCurrentSeparator = function (target) {\n    this.currentSeparator = this.isSeparator(target) ? target.parentElement : target;\n  };\n\n  Splitter.prototype.isSeparator = function (target) {\n    return target.classList.contains(SPLIT_BAR) ? false : true;\n  };\n\n  Splitter.prototype.isMouseEvent = function (e) {\n    var isMouse = false;\n\n    if (this.getEventType(e.type) === 'mouse' || !isNullOrUndefined(e.pointerType) && this.getEventType(e.pointerType) === 'mouse') {\n      isMouse = true;\n    }\n\n    return isMouse;\n  };\n\n  Splitter.prototype.updateCursorPosition = function (e, type) {\n    if (this.isMouseEvent(e)) {\n      this.changeCoordinates({\n        x: e.pageX,\n        y: e.pageY\n      }, type);\n    } else {\n      var eventType = Browser.info.name !== 'msie' ? e.touches[0] : e;\n      this.changeCoordinates({\n        x: eventType.pageX,\n        y: eventType.pageY\n      }, type);\n    }\n  };\n\n  Splitter.prototype.changeCoordinates = function (coordinates, type) {\n    if (type === 'previous') {\n      this.previousCoordinates = coordinates;\n    } else {\n      this.currentCoordinates = coordinates;\n    }\n  };\n\n  Splitter.prototype.reportWindowSize = function () {\n    var _this = this;\n\n    var paneCount = this.allPanes.length;\n\n    for (var i = 0; i < paneCount; i++) {\n      if (isNullOrUndefined(this.paneSettings[i].size)) {\n        this.allPanes[i].classList.remove(STATIC_PANE);\n      }\n\n      if (paneCount - 1 === i) {\n        var staticPaneCount = this.element.querySelectorAll('.' + STATIC_PANE).length;\n\n        if (staticPaneCount === paneCount) {\n          removeClass([this.allPanes[i]], STATIC_PANE);\n        }\n      }\n    }\n\n    setTimeout(function () {\n      _this.updateSplitterSize();\n    }, 200);\n  };\n\n  Splitter.prototype.updateSplitterSize = function () {\n    var totalWidth = 0;\n    var flexPaneIndexes = [];\n    var flexCount = 0;\n    var children = this.element.children;\n\n    for (var i = 0; i < children.length; i++) {\n      totalWidth += this.orientation === 'Horizontal' ? children[i].offsetWidth : children[i].offsetHeight;\n    }\n\n    for (var j = 0; j < this.allBars.length; j++) {\n      totalWidth += this.orientation === 'Horizontal' ? parseInt(getComputedStyle(this.allBars[j]).marginLeft, 10) + parseInt(getComputedStyle(this.allBars[j]).marginLeft, 10) : parseInt(getComputedStyle(this.allBars[j]).marginTop, 10) + parseInt(getComputedStyle(this.allBars[j]).marginBottom, 10);\n    }\n\n    var diff = this.orientation === 'Horizontal' ? this.element.offsetWidth - (this.border * 2 + totalWidth) : this.element.offsetHeight - (this.border * 2 + totalWidth);\n\n    for (var i = 0; i < this.allPanes.length; i++) {\n      if (!this.paneSettings[i].size && !(this.allPanes[i].innerText === '')) {\n        flexPaneIndexes[flexCount] = i;\n        flexCount++;\n      }\n    }\n\n    var avgDiffWidth = diff / flexPaneIndexes.length;\n\n    for (var j = 0; j < flexPaneIndexes.length; j++) {\n      this.allPanes[flexPaneIndexes[j]].style.flexBasis = this.orientation === 'Horizontal' ? this.allPanes[flexPaneIndexes[j]].offsetWidth + avgDiffWidth + 'px' : this.allPanes[flexPaneIndexes[j]].offsetHeight + avgDiffWidth + 'px';\n    }\n  };\n\n  Splitter.prototype.wireResizeEvents = function () {\n    EventHandler.add(document, 'mousemove', this.onMouseMove, this);\n    EventHandler.add(document, 'mouseup', this.onMouseUp, this);\n    var touchMoveEvent = Browser.info.name === 'msie' ? 'pointermove' : 'touchmove';\n    var touchEndEvent = Browser.info.name === 'msie' ? 'pointerup' : 'touchend';\n    EventHandler.add(document, touchMoveEvent, this.onMouseMove, this);\n    EventHandler.add(document, touchEndEvent, this.onMouseUp, this);\n  };\n\n  Splitter.prototype.unwireResizeEvents = function () {\n    window.removeEventListener('resize', this.reportWindowSize.bind(this));\n    var touchMoveEvent = Browser.info.name === 'msie' ? 'pointermove' : 'touchmove';\n    var touchEndEvent = Browser.info.name === 'msie' ? 'pointerup' : 'touchend';\n    EventHandler.remove(document, 'mousemove', this.onMouseMove);\n    EventHandler.remove(document, 'mouseup', this.onMouseUp);\n    EventHandler.remove(document, touchMoveEvent, this.onMouseMove);\n    EventHandler.remove(document, touchEndEvent, this.onMouseUp);\n  };\n\n  Splitter.prototype.wireClickEvents = function () {\n    EventHandler.add(this.currentSeparator, 'touchstart click', this.clickHandler, this);\n  };\n\n  Splitter.prototype.clickHandler = function (e) {\n    if (!e.target.classList.contains(NAVIGATE_ARROW)) {\n      var hoverBars = selectAll('.' + ROOT + ' > .' + SPLIT_BAR + '.' + SPLIT_BAR_HOVER);\n\n      if (hoverBars.length > 0) {\n        removeClass(hoverBars, SPLIT_BAR_HOVER);\n      }\n\n      e.target.classList.add(SPLIT_BAR_HOVER);\n    }\n\n    var icon = e.target;\n\n    if (icon.classList.contains(ARROW_LEFT) || icon.classList.contains(ARROW_UP)) {\n      this.collapseAction(e);\n    }\n\n    if (icon.classList.contains(ARROW_RIGHT) || icon.classList.contains(ARROW_DOWN)) {\n      this.expandAction(e);\n    }\n\n    var totalWidth = 0;\n    var children = this.element.children;\n\n    for (var i = 0; i < children.length; i++) {\n      totalWidth += this.orientation === 'Horizontal' ? children[i].offsetWidth : children[i].offsetHeight;\n    }\n\n    if (totalWidth > this.element.offsetWidth) {\n      this.updateSplitterSize();\n    }\n  };\n\n  Splitter.prototype.expandAction = function (e) {\n    var _this = this;\n\n    this.splitterDetails(e);\n    var eventArgs = this.beforeAction(e);\n\n    if (this.expandFlag) {\n      this.trigger('beforeExpand', eventArgs, function (beforeExpandArgs) {\n        if (!beforeExpandArgs.cancel) {\n          _this.expandPane(e);\n        }\n\n        var expandEventArgs = _this.afterAction(e);\n\n        _this.trigger('expanded', expandEventArgs);\n      });\n    } else {\n      this.expandPane(e);\n    }\n  };\n\n  Splitter.prototype.expandPane = function (e) {\n    var collapseCount = this.element.querySelectorAll('.' + COLLAPSE_PANE).length;\n    var flexStatus = !this.previousPane.classList.contains(COLLAPSE_PANE) && this.previousPane.classList.contains(STATIC_PANE) && !this.nextPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.classList.contains(EXPAND_PANE) && this.nextPane.nextElementSibling.classList.contains(PANE) && !this.nextPane.nextElementSibling.classList.contains(STATIC_PANE) && !(collapseCount === this.allPanes.length - 2);\n    var collapseClass = [COLLAPSE_PANE, PANE_HIDDEN];\n\n    if (!this.previousPane.classList.contains(COLLAPSE_PANE)) {\n      removeClass([this.nextPane], EXPAND_PANE);\n      removeClass([this.previousPane], collapseClass);\n      addClass([this.previousPane], EXPAND_PANE);\n      addClass([this.nextPane], collapseClass);\n\n      if (this.expandFlag) {\n        this.updatePaneSettings(this.nextPaneIndex, true);\n      }\n    } else {\n      removeClass([this.previousPane], collapseClass);\n      removeClass([this.nextPane], EXPAND_PANE);\n\n      if (this.expandFlag) {\n        this.updatePaneSettings(this.prevPaneIndex, false);\n      }\n    }\n\n    this.updateIconsOnExpand(e);\n    this.previousPane.setAttribute('aria-expanded', 'true');\n    this.nextPane.setAttribute('aria-expanded', 'false');\n    this.updateFlexGrow(this.checkStaticPanes());\n\n    if (flexStatus) {\n      this.previousPane.classList.remove(EXPAND_PANE);\n      this.previousPane.style.flexGrow = '';\n    }\n  };\n\n  Splitter.prototype.checkStaticPanes = function () {\n    var staticPane = true;\n\n    for (var i = 0; i < this.allPanes.length; i++) {\n      if (!this.allPanes[i].classList.contains(COLLAPSE_PANE) && staticPane) {\n        if (this.allPanes[i].classList.contains(STATIC_PANE)) {\n          staticPane = true;\n        } else {\n          staticPane = false;\n        }\n      }\n    }\n\n    return staticPane;\n  };\n\n  Splitter.prototype.updateFlexGrow = function (status) {\n    var panes = this.allPanes;\n\n    for (var i = 0; i < panes.length; i++) {\n      if (panes[i].classList.contains(EXPAND_PANE)) {\n        panes[i].style.flexGrow = '1';\n      } else if (panes[i].classList.contains(COLLAPSE_PANE)) {\n        panes[i].style.flexGrow = '0';\n      } else {\n        panes[i].style.flexGrow = '';\n      }\n\n      if (status && !this.nextPane.classList.contains(COLLAPSE_PANE)) {\n        this.nextPane.style.flexGrow = '1';\n      }\n    }\n  };\n\n  Splitter.prototype.hideTargetBarIcon = function (targetBar, targetArrow) {\n    addClass([select('.' + targetArrow, targetBar)], HIDE_ICON);\n  };\n\n  Splitter.prototype.showTargetBarIcon = function (targetBar, targetArrow) {\n    removeClass([select('.' + targetArrow, targetBar)], HIDE_ICON);\n  };\n\n  Splitter.prototype.updateIconsOnCollapse = function (e) {\n    this.splitterProperty();\n\n    if (this.previousPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.classList.contains(COLLAPSE_PANE)) {\n      addClass([e.target], HIDE_ICON);\n\n      if (this.paneSettings[this.prevPaneIndex].collapsible) {\n        this.showCurrentBarIcon();\n      }\n\n      this.resizableModel(this.currentBarIndex, false);\n\n      if (this.previousPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.classList.contains(COLLAPSE_PANE) && !this.paneSettings[this.prevPaneIndex].collapsible) {\n        this.hideTargetBarIcon(this.prevBar, this.rightArrow);\n      }\n\n      if (this.previousPane.previousElementSibling && !this.previousPane.previousElementSibling.classList.contains(COLLAPSE_PANE)) {\n        if (this.previousPane.classList.contains(COLLAPSE_PANE) && this.paneSettings[this.prevPaneIndex].collapsible) {\n          this.showTargetBarIcon(this.prevBar, this.leftArrow);\n        } else if (!this.paneSettings[this.prevPaneIndex].collapsible) {\n          this.hideTargetBarIcon(this.prevBar, this.leftArrow);\n        }\n      }\n\n      if (!isNullOrUndefined(this.prevBar)) {\n        this.resizableModel(this.currentBarIndex - 1, false);\n        this.hideTargetBarIcon(this.prevBar, this.arrow);\n      }\n\n      if (!this.paneSettings[this.prevPaneIndex].collapsible) {\n        this.hideTargetBarIcon(this.currentSeparator, this.rightArrow);\n      }\n    } else if (!this.splitInstance.prevPaneCollapsed && !this.splitInstance.nextPaneExpanded) {\n      if (this.paneSettings[this.currentBarIndex].resizable) {\n        this.resizableModel(this.currentBarIndex, true);\n      }\n\n      if (!this.splitInstance.nextPaneNextEle.classList.contains(COLLAPSE_PANE) && this.paneSettings[this.currentBarIndex + 1].resizable) {\n        this.resizableModel(this.currentBarIndex + 1, true);\n      }\n\n      if (!this.paneSettings[this.currentBarIndex].collapsible) {\n        addClass([e.target], HIDE_ICON);\n      }\n\n      if (this.previousPane && this.prevPaneIndex === 0 && this.paneSettings[this.prevPaneIndex].collapsible) {\n        this.showTargetBarIcon(this.currentSeparator, this.leftArrow);\n      }\n\n      if (this.nextPane && this.nextPaneIndex === this.allPanes.length - 1 && this.paneSettings[this.nextPaneIndex].collapsible) {\n        this.showTargetBarIcon(this.getPrevBar(this.nextPaneIndex), this.rightArrow);\n      }\n\n      if (!this.previousPane.classList.contains(COLLAPSE_PANE) && this.paneSettings[this.nextPaneIndex].collapsible) {\n        this.showTargetBarIcon(this.currentSeparator, this.rightArrow);\n      }\n\n      if (!isNullOrUndefined(this.nextBar)) {\n        if (this.nextPane.nextElementSibling && this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE) && this.paneSettings[this.nextPaneIndex + 1].collapsible || !this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE) && this.paneSettings[this.nextPaneIndex].collapsible) {\n          this.showTargetBarIcon(this.nextBar, this.leftArrow);\n        } else if (!this.paneSettings[this.splitInstance.nextPaneIndex + 1].collapsible && this.paneSettings[this.currentBarIndex]) {\n          this.hideTargetBarIcon(this.nextBar, this.arrow);\n        }\n      }\n\n      if (!(this.nextPaneIndex === this.allPanes.length - 1) && this.nextPane.nextElementSibling && !this.nextPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE) && !this.paneSettings[this.nextPaneIndex + 1].collapsible) {\n        this.hideTargetBarIcon(this.nextBar, this.rightArrow);\n      }\n    }\n  };\n\n  Splitter.prototype.collapseAction = function (e) {\n    var _this = this;\n\n    this.splitterDetails(e);\n    var eventArgs = this.beforeAction(e);\n\n    if (this.collapseFlag) {\n      this.collapsePane(e);\n    } else {\n      this.trigger('beforeCollapse', eventArgs, function (beforeCollapseArgs) {\n        if (!beforeCollapseArgs.cancel) {\n          _this.collapsePane(e);\n\n          var collapseEventArgs = _this.afterAction(e);\n\n          _this.trigger('collapsed', collapseEventArgs);\n        }\n      });\n    }\n  };\n\n  Splitter.prototype.collapsePane = function (e) {\n    var collapseCount = this.element.querySelectorAll('.' + COLLAPSE_PANE).length;\n    var flexStatus = this.previousPane.classList.contains(STATIC_PANE) && !this.previousPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.classList.contains(COLLAPSE_PANE) && this.nextPane.nextElementSibling.classList.contains(PANE) && !this.nextPane.nextElementSibling.classList.contains(STATIC_PANE) && !this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE) && !(collapseCount === this.allPanes.length - 2) || this.nextPane.classList.contains(COLLAPSE_PANE) && !this.previousPane.classList.contains(STATIC_PANE) && this.nextPane.classList.contains(STATIC_PANE);\n    var collapseClass = [COLLAPSE_PANE, PANE_HIDDEN];\n\n    if (this.nextPane.classList.contains(COLLAPSE_PANE)) {\n      removeClass([this.previousPane], EXPAND_PANE);\n      removeClass([this.nextPane], collapseClass);\n\n      if (!this.collapseFlag) {\n        this.updatePaneSettings(this.nextPaneIndex, false);\n      }\n    } else {\n      removeClass([this.previousPane], EXPAND_PANE);\n      removeClass([this.nextPane], collapseClass);\n      addClass([this.nextPane], EXPAND_PANE);\n      addClass([this.previousPane], collapseClass);\n\n      if (!this.collapseFlag) {\n        this.updatePaneSettings(this.prevPaneIndex, true);\n      }\n    }\n\n    this.updateIconsOnCollapse(e);\n    this.previousPane.setAttribute('aria-expanded', 'false');\n    this.nextPane.setAttribute('aria-expanded', 'true');\n    this.updateFlexGrow(this.checkStaticPanes());\n\n    if (flexStatus) {\n      this.nextPane.classList.remove(EXPAND_PANE);\n      this.nextPane.style.flexGrow = '';\n    }\n  };\n\n  Splitter.prototype.beforeAction = function (e) {\n    var eventArgs = isBlazor() ? {\n      element: this.element,\n      event: e,\n      index: [this.prevPaneIndex, this.nextPaneIndex],\n      separator: this.currentSeparator,\n      cancel: false\n    } : {\n      element: this.element,\n      event: e,\n      pane: [this.previousPane, this.nextPane],\n      index: [this.prevPaneIndex, this.nextPaneIndex],\n      separator: this.currentSeparator,\n      cancel: false\n    };\n    return eventArgs;\n  };\n\n  Splitter.prototype.updatePaneSettings = function (index, collapsed) {\n    this.paneSettings[index].collapsed = collapsed;\n  };\n\n  Splitter.prototype.splitterProperty = function () {\n    this.splitInstance = {\n      currentBarIndex: this.currentBarIndex,\n      nextPaneCollapsible: this.nextPane.classList.contains(COLLAPSIBLE),\n      prevPaneCollapsible: this.previousPane.classList.contains(COLLAPSIBLE),\n      prevPaneExpanded: this.previousPane.classList.contains(EXPAND_PANE),\n      nextPaneExpanded: this.nextPane.classList.contains(EXPAND_PANE),\n      nextPaneCollapsed: this.nextPane.classList.contains(COLLAPSE_PANE),\n      prevPaneCollapsed: this.previousPane.classList.contains(COLLAPSE_PANE),\n      nextPaneIndex: this.getNextPaneIndex(),\n      prevPaneIndex: this.getPreviousPaneIndex(),\n      nextPaneNextEle: this.nextPane.nextElementSibling,\n      prevPanePreEle: this.previousPane.previousElementSibling\n    };\n  };\n\n  Splitter.prototype.showCurrentBarIcon = function () {\n    removeClass([select('.' + this.arrow, this.currentSeparator)], HIDE_ICON);\n  };\n\n  Splitter.prototype.updateIconsOnExpand = function (e) {\n    this.splitterProperty();\n    addClass([e.target], HIDE_ICON);\n\n    if (!this.splitInstance.prevPaneExpanded && !this.splitInstance.nextPaneCollapsed) {\n      if (this.paneSettings[this.prevPaneIndex].collapsible) {\n        this.showCurrentBarIcon();\n      }\n\n      if (this.paneSettings[this.nextPaneIndex].collapsible) {\n        removeClass([e.target], HIDE_ICON);\n      }\n\n      if (this.paneSettings[this.currentBarIndex].resizable) {\n        this.resizableModel(this.currentBarIndex, true);\n      }\n\n      if (!isNullOrUndefined(this.prevBar) && !this.splitInstance.prevPanePreEle.classList.contains(COLLAPSE_PANE)) {\n        if (this.paneSettings[this.currentBarIndex - 1].resizable) {\n          this.resizableModel(this.currentBarIndex - 1, true);\n        }\n\n        if (this.paneSettings[this.prevPaneIndex].collapsible) {\n          this.showTargetBarIcon(this.prevBar, this.rightArrow);\n        }\n\n        if (!this.paneSettings[this.currentBarIndex - 1].collapsible) {\n          this.hideTargetBarIcon(this.prevBar, this.arrow);\n\n          if (this.paneSettings[this.currentBarIndex].collapsible && !this.paneSettings[this.currentBarIndex + 1].collapsible) {\n            this.hideTargetBarIcon(this.currentSeparator, this.rightArrow);\n          }\n        } else if (this.paneSettings[this.currentBarIndex].collapsible && !this.paneSettings[this.currentBarIndex + 1].collapsible) {\n          this.hideTargetBarIcon(this.currentSeparator, this.rightArrow);\n        }\n      } else {\n        if (this.previousPane.previousElementSibling && this.paneSettings[this.prevPaneIndex].collapsible && this.previousPane.previousElementSibling.classList.contains(COLLAPSE_PANE) && this.paneSettings[this.prevPaneIndex - 1].collapsible) {\n          this.showTargetBarIcon(this.prevBar, this.rightArrow);\n        }\n\n        if (!this.paneSettings[this.currentBarIndex + 1].collapsible) {\n          this.hideTargetBarIcon(this.currentSeparator, this.rightArrow);\n        }\n      }\n    } else if (this.splitInstance.prevPaneExpanded && this.splitInstance.nextPaneCollapsed) {\n      this.resizableModel(this.currentBarIndex, false);\n      this.resizableModel(this.currentBarIndex + 1, false);\n\n      if (this.paneSettings[this.nextPaneIndex].collapsible) {\n        this.showCurrentBarIcon();\n      }\n\n      if (!isNullOrUndefined(this.nextBar)) {\n        this.hideTargetBarIcon(this.nextBar, this.arrow);\n      }\n\n      if (this.nextPane && this.nextPaneIndex === this.allPanes.length - 1 && !this.paneSettings[this.nextPaneIndex].collapsible && this.splitInstance.nextPaneCollapsed) {\n        this.hideTargetBarIcon(this.currentSeparator, this.arrow);\n      }\n\n      if (!(this.nextPaneIndex === this.allPanes.length - 1) && this.nextPane.nextElementSibling && this.nextPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE) && this.paneSettings[this.nextPaneIndex].collapsible) {\n        this.showTargetBarIcon(this.nextBar, this.rightArrow);\n      }\n    }\n  };\n\n  Splitter.prototype.afterAction = function (e) {\n    var eventArgs = isBlazor() ? {\n      element: this.element,\n      event: e,\n      index: [this.prevPaneIndex, this.nextPaneIndex],\n      separator: this.currentSeparator\n    } : {\n      element: this.element,\n      event: e,\n      pane: [this.previousPane, this.nextPane],\n      index: [this.prevPaneIndex, this.nextPaneIndex],\n      separator: this.currentSeparator\n    };\n    return eventArgs;\n  };\n\n  Splitter.prototype.currentIndex = function (e) {\n    this.currentBarIndex = this.getSeparatorIndex(e.target.parentElement);\n  };\n\n  Splitter.prototype.getSeparatorIndex = function (target) {\n    var separator = this.orientation === 'Horizontal' ? SPLIT_H_BAR : SPLIT_V_BAR;\n\n    if (this.checkBlazor() && this.allBars.length < 1) {\n      this.allBars = selectAll('.' + separator, this.element);\n    }\n\n    var array = [].slice.call(this.allBars);\n    return array.indexOf(target);\n  };\n\n  Splitter.prototype.getPrevBar = function (currentBar) {\n    var prevbar = this.allBars[currentBar - 1];\n    return prevbar;\n  };\n\n  Splitter.prototype.getNextBar = function (currentBar) {\n    var prevbar = this.allBars[currentBar + 1];\n    return prevbar;\n  };\n\n  Splitter.prototype.updateBars = function (index) {\n    this.prevBar = this.getPrevBar(index);\n    this.nextBar = this.getNextBar(index);\n  };\n\n  Splitter.prototype.splitterDetails = function (e) {\n    if (this.orientation === 'Horizontal') {\n      this.arrow = e.target.classList.contains(ARROW_LEFT) ? ARROW_RIGHT : ARROW_LEFT;\n    } else {\n      this.arrow = e.target.classList.contains(ARROW_UP) ? ARROW_DOWN : ARROW_UP;\n    }\n\n    this.updateCurrentSeparator(e.target);\n    this.currentIndex(e);\n    this.updateBars(this.currentBarIndex);\n    this.getPaneDetails();\n  };\n\n  Splitter.prototype.triggerResizing = function (e) {\n    var eventArgs = isBlazor() ? {\n      element: this.element,\n      event: e,\n      index: [this.prevPaneIndex, this.nextPaneIndex],\n      paneSize: [this.prePaneDimenson, this.nextPaneDimension],\n      separator: this.currentSeparator\n    } : {\n      element: this.element,\n      event: e,\n      pane: [this.previousPane, this.nextPane],\n      index: [this.prevPaneIndex, this.nextPaneIndex],\n      paneSize: [this.prePaneDimenson, this.nextPaneDimension],\n      separator: this.currentSeparator\n    };\n    this.trigger('resizing', eventArgs);\n  };\n\n  Splitter.prototype.onMouseDown = function (e) {\n    var _this = this;\n\n    e.preventDefault();\n    var target = e.target;\n\n    if (target.classList.contains(NAVIGATE_ARROW)) {\n      return;\n    }\n\n    this.updateCurrentSeparator(target);\n    addClass([this.currentSeparator], SPLIT_BAR_ACTIVE);\n    this.updateCursorPosition(e, 'previous');\n    this.getPaneDetails();\n    var eventArgs = isBlazor() ? {\n      element: this.element,\n      event: e,\n      index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()],\n      separator: this.currentSeparator,\n      cancel: false\n    } : {\n      element: this.element,\n      event: e,\n      pane: [this.previousPane, this.nextPane],\n      index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()],\n      separator: this.currentSeparator,\n      cancel: false\n    };\n\n    for (var i = 0; i < this.element.querySelectorAll('iframe').length; i++) {\n      this.element.querySelectorAll('iframe')[i].style.pointerEvents = 'none';\n    }\n\n    this.trigger('resizeStart', eventArgs, function (resizeStartArgs) {\n      if (!resizeStartArgs.cancel) {\n        _this.wireResizeEvents();\n\n        _this.checkPaneSize(e);\n      }\n    });\n  };\n\n  Splitter.prototype.updatePaneFlexBasis = function (pane) {\n    var previous;\n\n    if (pane.style.flexBasis.indexOf('%') > 0) {\n      previous = this.removePercentageUnit(pane.style.flexBasis);\n    } else {\n      if (pane.style.flexBasis !== '') {\n        previous = this.convertPixelToPercentage(this.convertPixelToNumber(pane.style.flexBasis));\n      } else {\n        var offset = this.orientation === 'Horizontal' ? pane.offsetWidth : pane.offsetHeight;\n        previous = this.convertPixelToPercentage(offset);\n      }\n    }\n\n    return previous;\n  };\n\n  Splitter.prototype.removePercentageUnit = function (value) {\n    return parseFloat(value.slice(0, value.indexOf('%')));\n  };\n\n  Splitter.prototype.convertPercentageToPixel = function (value, targetElement) {\n    var percentage = value.toString();\n    var convertedValue;\n\n    if (percentage.indexOf('%') > -1) {\n      convertedValue = parseFloat(percentage.slice(0, percentage.indexOf('%')));\n      var offsetValue = void 0;\n\n      if (!isNullOrUndefined(targetElement)) {\n        offsetValue = this.panesDimensions[this.allPanes.indexOf(targetElement)];\n      } else {\n        offsetValue = this.orientation === 'Horizontal' ? this.element.offsetWidth : this.element.offsetHeight;\n      }\n\n      convertedValue = Math.ceil(offsetValue * (convertedValue / 100));\n    } else {\n      convertedValue = parseInt(percentage, 10);\n    }\n\n    return convertedValue;\n  };\n\n  Splitter.prototype.convertPixelToPercentage = function (value) {\n    var offsetValue = this.orientation === 'Horizontal' ? this.element.offsetWidth : this.element.offsetHeight;\n    return value / offsetValue * 100;\n  };\n\n  Splitter.prototype.convertPixelToNumber = function (value) {\n    if (value.indexOf('p') > -1) {\n      return parseFloat(value.slice(0, value.indexOf('p')));\n    } else {\n      return parseFloat(value);\n    }\n  };\n\n  Splitter.prototype.calcDragPosition = function (rectValue, offsetValue) {\n    var separatorPosition;\n    var separator;\n    separatorPosition = this.orientation === 'Horizontal' ? this.currentCoordinates.x - rectValue : this.currentCoordinates.y - rectValue;\n    separator = separatorPosition / offsetValue;\n    separator = separator > 1 ? 1 : separator < 0 ? 0 : separator;\n    return separator * offsetValue;\n  };\n\n  Splitter.prototype.getSeparatorPosition = function (e) {\n    this.updateCursorPosition(e, 'current');\n    var rectBound = this.orientation === 'Horizontal' ? this.element.getBoundingClientRect().left : this.element.getBoundingClientRect().top;\n    var offSet = this.orientation === 'Horizontal' ? this.element.offsetWidth : this.element.offsetHeight;\n    return this.calcDragPosition(rectBound, offSet);\n  };\n\n  Splitter.prototype.getMinMax = function (paneIndex, target, selection) {\n    var defaultVal = selection === 'min' ? 0 : null; // tslint:disable-next-line\n\n    var paneValue = null;\n\n    if (selection === 'min') {\n      if (!isNullOrUndefined(this.paneSettings[paneIndex]) && !isNullOrUndefined(this.paneSettings[paneIndex].min)) {\n        paneValue = this.paneSettings[paneIndex].min;\n      }\n    } else {\n      if (!isNullOrUndefined(this.paneSettings[paneIndex]) && !isNullOrUndefined(this.paneSettings[paneIndex].max)) {\n        paneValue = this.paneSettings[paneIndex].max;\n      }\n    }\n\n    if (this.paneSettings.length > 0 && !isNullOrUndefined(this.paneSettings[paneIndex]) && !isNullOrUndefined(paneValue)) {\n      if (paneValue.indexOf('%') > 0) {\n        paneValue = this.convertPercentageToPixel(paneValue).toString();\n      }\n\n      return this.convertPixelToNumber(paneValue);\n    } else {\n      return defaultVal;\n    }\n  };\n\n  Splitter.prototype.getPreviousPaneIndex = function () {\n    var prePaneIndex = (parseInt(this.currentSeparator.style.order, 10) - 1) / 2;\n    return prePaneIndex;\n  };\n\n  Splitter.prototype.getNextPaneIndex = function () {\n    var nextPaneIndex = (parseInt(this.currentSeparator.style.order, 10) - 1) / 2;\n    return nextPaneIndex + 1;\n  };\n\n  Splitter.prototype.getPaneDetails = function () {\n    var prevPane = null;\n    var nextPane = null;\n    this.order = parseInt(this.currentSeparator.style.order, 10);\n\n    if (this.allPanes.length > 1) {\n      prevPane = this.getPrevPane(this.currentSeparator, this.order);\n      nextPane = this.getNextPane(this.currentSeparator, this.order);\n    }\n\n    if (prevPane && nextPane) {\n      this.previousPane = prevPane;\n      this.nextPane = nextPane;\n      this.prevPaneIndex = this.getPreviousPaneIndex();\n      this.nextPaneIndex = this.getNextPaneIndex();\n    } else {\n      return;\n    }\n  };\n\n  Splitter.prototype.getPaneHeight = function (pane) {\n    return this.orientation === 'Horizontal' ? pane.offsetWidth.toString() : pane.offsetHeight.toString();\n  };\n\n  Splitter.prototype.isValidSize = function (paneIndex) {\n    var isValid = false;\n\n    if (!isNullOrUndefined(this.paneSettings[paneIndex]) && !isNullOrUndefined(this.paneSettings[paneIndex].size) && this.paneSettings[paneIndex].size.indexOf('%') > -1) {\n      isValid = true;\n    }\n\n    return isValid;\n  };\n\n  Splitter.prototype.getPaneDimensions = function () {\n    this.previousPaneHeightWidth = this.previousPane.style.flexBasis === '' ? this.getPaneHeight(this.previousPane) : this.previousPane.style.flexBasis;\n    this.nextPaneHeightWidth = this.nextPane.style.flexBasis === '' ? this.getPaneHeight(this.nextPane) : this.nextPane.style.flexBasis;\n\n    if (this.isValidSize(this.prevPaneIndex)) {\n      this.previousPaneHeightWidth = this.convertPercentageToPixel(this.previousPaneHeightWidth).toString();\n      this.updatePrePaneInPercentage = true;\n    }\n\n    if (this.isValidSize(this.nextPaneIndex)) {\n      this.nextPaneHeightWidth = this.convertPercentageToPixel(this.nextPaneHeightWidth).toString();\n      this.updateNextPaneInPercentage = true;\n    }\n\n    this.prePaneDimenson = this.convertPixelToNumber(this.previousPaneHeightWidth.toString());\n    this.nextPaneDimension = this.convertPixelToNumber(this.nextPaneHeightWidth.toString());\n  };\n\n  Splitter.prototype.checkCoordinates = function (pageX, pageY) {\n    var coordinatesChanged = true;\n\n    if (pageX === this.previousCoordinates.x || pageY === this.previousCoordinates.y) {\n      coordinatesChanged = false;\n    }\n\n    return coordinatesChanged;\n  };\n\n  Splitter.prototype.isCursorMoved = function (e) {\n    var cursorMoved = true;\n\n    if (this.getEventType(e.type) === 'mouse' || !isNullOrUndefined(e.pointerType) && this.getEventType(e.pointerType) === 'mouse') {\n      cursorMoved = this.checkCoordinates(e.pageX, e.pageY);\n    } else {\n      cursorMoved = Browser.info.name !== 'msie' ? this.checkCoordinates(e.touches[0].pageX, e.touches[0].pageY) : this.checkCoordinates(e.pageX, e.pageY);\n    }\n\n    return cursorMoved;\n  };\n\n  Splitter.prototype.getBorder = function () {\n    this.border = 0;\n    var border = this.orientation === 'Horizontal' ? (this.element.offsetWidth - this.element.clientWidth) / 2 : (this.element.offsetHeight - this.element.clientHeight) / 2;\n    this.border = Browser.info.name !== 'chrome' ? this.border : border;\n  };\n\n  Splitter.prototype.onMouseMove = function (e) {\n    if (!this.isCursorMoved(e)) {\n      return;\n    }\n\n    this.getPaneDetails();\n    this.getPaneDimensions();\n    this.triggerResizing(e);\n    var left = this.validateDraggedPosition(this.getSeparatorPosition(e), this.prePaneDimenson, this.nextPaneDimension);\n    var separatorNewPosition;\n    this.getBorder();\n\n    if (this.orientation === 'Horizontal') {\n      separatorNewPosition = this.element.getBoundingClientRect().left + left - this.currentSeparator.getBoundingClientRect().left + this.border;\n    } else {\n      separatorNewPosition = this.element.getBoundingClientRect().top + left - this.currentSeparator.getBoundingClientRect().top + this.border;\n    }\n\n    this.nextPaneHeightWidth = typeof this.nextPaneHeightWidth === 'string' && this.nextPaneHeightWidth.indexOf('p') > -1 ? this.convertPixelToNumber(this.nextPaneHeightWidth) : parseInt(this.nextPaneHeightWidth, 10);\n    this.prevPaneCurrentWidth = separatorNewPosition + this.convertPixelToNumber(this.previousPaneHeightWidth);\n    this.nextPaneCurrentWidth = this.nextPaneHeightWidth - separatorNewPosition;\n    this.validateMinMaxValues();\n\n    if (this.nextPaneCurrentWidth < 0) {\n      this.nextPaneCurrentWidth = 0;\n    }\n    /* istanbul ignore next */\n\n\n    if (this.prevPaneCurrentWidth < 0) {\n      this.prevPaneCurrentWidth = 0;\n    }\n\n    if (this.nextPaneCurrentWidth + this.prevPaneCurrentWidth > this.totalWidth) {\n      if (this.nextPaneCurrentWidth < this.prevPaneCurrentWidth) {\n        this.prevPaneCurrentWidth = this.prevPaneCurrentWidth - (this.nextPaneCurrentWidth + this.prevPaneCurrentWidth - this.totalWidth);\n      } else {\n        this.nextPaneCurrentWidth = this.nextPaneCurrentWidth - (this.nextPaneCurrentWidth + this.prevPaneCurrentWidth - this.totalWidth);\n      }\n    }\n    /* istanbul ignore next */\n\n\n    if (this.nextPaneCurrentWidth + this.prevPaneCurrentWidth < this.totalWidth) {\n      var difference = this.totalWidth - (this.nextPaneCurrentWidth + this.prevPaneCurrentWidth);\n      this.nextPaneCurrentWidth = this.nextPaneCurrentWidth + difference;\n    }\n\n    this.calculateCurrentDimensions();\n    this.addStaticPaneClass();\n    this.previousPane.style.flexBasis = this.prevPaneCurrentWidth;\n    this.nextPane.style.flexBasis = this.nextPaneCurrentWidth;\n\n    if (!(this.allPanes.length > 2)) {\n      this.updateSplitterSize();\n    }\n  };\n\n  Splitter.prototype.validateMinRange = function (paneIndex, paneCurrentWidth, pane) {\n    var paneMinRange = null;\n    var paneMinDimensions;\n    var difference = 0;\n    var validatedVal;\n\n    if (!isNullOrUndefined(this.paneSettings[paneIndex]) && !isNullOrUndefined(this.paneSettings[paneIndex].min)) {\n      paneMinRange = this.paneSettings[paneIndex].min.toString();\n    }\n\n    if (!isNullOrUndefined(paneMinRange)) {\n      if (paneMinRange.indexOf('%') > 0) {\n        paneMinRange = this.convertPercentageToPixel(paneMinRange).toString();\n      }\n\n      paneMinDimensions = this.convertPixelToNumber(paneMinRange);\n\n      if (paneCurrentWidth < paneMinDimensions) {\n        difference = paneCurrentWidth - paneMinDimensions <= 0 ? 0 : paneCurrentWidth - paneMinDimensions;\n        this.totalWidth = this.totalWidth - difference;\n        this.totalPercent = this.convertPixelToPercentage(this.totalWidth);\n        validatedVal = paneMinDimensions;\n      }\n    }\n\n    return isNullOrUndefined(validatedVal) ? paneCurrentWidth : validatedVal;\n  };\n\n  Splitter.prototype.validateMaxRange = function (paneIndex, paneCurrentWidth, pane) {\n    var paneMaxRange = null;\n    var paneMaxDimensions;\n    var validatedVal;\n\n    if (!isNullOrUndefined(this.paneSettings[paneIndex]) && !isNullOrUndefined(this.paneSettings[paneIndex].max)) {\n      paneMaxRange = this.paneSettings[paneIndex].max.toString();\n    }\n\n    if (!isNullOrUndefined(paneMaxRange)) {\n      if (paneMaxRange.indexOf('%') > 0) {\n        paneMaxRange = this.convertPercentageToPixel(paneMaxRange).toString();\n      }\n\n      paneMaxDimensions = this.convertPixelToNumber(paneMaxRange);\n\n      if (paneCurrentWidth > paneMaxDimensions) {\n        this.totalWidth = this.totalWidth - (paneCurrentWidth - paneMaxDimensions);\n        this.totalPercent = this.convertPixelToPercentage(this.totalWidth);\n        validatedVal = paneMaxDimensions;\n      }\n    }\n\n    return isNullOrUndefined(validatedVal) ? paneCurrentWidth : validatedVal;\n  };\n\n  Splitter.prototype.validateMinMaxValues = function () {\n    //validate previous pane minimum range\n    this.prevPaneCurrentWidth = this.validateMinRange(this.prevPaneIndex, this.prevPaneCurrentWidth, this.previousPane); // Validate next pane minimum range\n\n    this.nextPaneCurrentWidth = this.validateMinRange(this.nextPaneIndex, this.nextPaneCurrentWidth, this.nextPane); // validate previous pane maximum range\n\n    this.prevPaneCurrentWidth = this.validateMaxRange(this.prevPaneIndex, this.prevPaneCurrentWidth, this.previousPane); // validate next pane maximum range\n\n    this.nextPaneCurrentWidth = this.validateMaxRange(this.nextPaneIndex, this.nextPaneCurrentWidth, this.nextPane);\n  };\n\n  Splitter.prototype.equatePaneWidths = function () {\n    var difference;\n\n    if (this.prevPaneCurrentWidth + this.nextPaneCurrentWidth > this.totalPercent) {\n      difference = this.prevPaneCurrentWidth + this.nextPaneCurrentWidth - this.totalPercent;\n      this.prevPaneCurrentWidth = this.prevPaneCurrentWidth - difference / 2 + '%';\n      this.nextPaneCurrentWidth = this.nextPaneCurrentWidth - difference / 2 + '%';\n    }\n\n    if (this.prevPaneCurrentWidth + this.nextPaneCurrentWidth < this.totalPercent) {\n      difference = this.totalPercent - (this.prevPaneCurrentWidth + this.nextPaneCurrentWidth);\n      this.prevPaneCurrentWidth = this.prevPaneCurrentWidth + difference / 2 + '%';\n      this.nextPaneCurrentWidth = this.nextPaneCurrentWidth + difference / 2 + '%';\n    }\n  };\n\n  Splitter.prototype.calculateCurrentDimensions = function () {\n    if (this.updatePrePaneInPercentage || this.updateNextPaneInPercentage) {\n      this.prevPaneCurrentWidth = Math.round(Number(Math.round(this.convertPixelToPercentage(this.prevPaneCurrentWidth) * 10) / 10));\n      this.nextPaneCurrentWidth = Math.round(Number(Math.round(this.convertPixelToPercentage(this.nextPaneCurrentWidth) * 10) / 10));\n\n      if (this.prevPaneCurrentWidth === 0) {\n        this.nextPaneCurrentWidth = this.totalPercent;\n      }\n\n      if (this.nextPaneCurrentWidth === 0) {\n        this.prevPaneCurrentWidth = this.totalPercent;\n      }\n\n      if (this.prevPaneCurrentWidth + this.nextPaneCurrentWidth !== this.totalPercent) {\n        this.equatePaneWidths();\n      } else {\n        this.prevPaneCurrentWidth = this.prevPaneCurrentWidth + '%';\n        this.nextPaneCurrentWidth = this.nextPaneCurrentWidth + '%';\n      }\n\n      this.prevPaneCurrentWidth = this.updatePrePaneInPercentage ? this.prevPaneCurrentWidth : this.convertPercentageToPixel(this.prevPaneCurrentWidth) + 'px';\n      this.nextPaneCurrentWidth = this.updateNextPaneInPercentage ? this.nextPaneCurrentWidth : this.convertPercentageToPixel(this.nextPaneCurrentWidth) + 'px';\n      this.updatePrePaneInPercentage = false;\n      this.updateNextPaneInPercentage = false;\n    } else {\n      this.prevPaneCurrentWidth = this.prevPaneCurrentWidth + 'px';\n      this.nextPaneCurrentWidth = this.nextPaneCurrentWidth + 'px';\n    }\n  };\n\n  Splitter.prototype.addStaticPaneClass = function () {\n    if (!this.previousPane.classList.contains(STATIC_PANE)) {\n      this.previousPane.classList.add(STATIC_PANE);\n    }\n\n    if (!this.nextPane.classList.contains(STATIC_PANE)) {\n      this.nextPane.classList.add(STATIC_PANE);\n    }\n  };\n\n  Splitter.prototype.validateDraggedPosition = function (draggedPos, prevPaneHeightWidth, nextPaneHeightWidth) {\n    var separatorTopLeft = this.orientation === 'Horizontal' ? this.currentSeparator.offsetLeft : this.currentSeparator.offsetTop;\n    var prePaneRange = separatorTopLeft - prevPaneHeightWidth;\n    var nextPaneRange = nextPaneHeightWidth + separatorTopLeft;\n    var pane1MinSize = this.getMinMax(this.prevPaneIndex, this.previousPane, 'min');\n    var pane2MinSize = this.getMinMax(this.nextPaneIndex, this.nextPane, 'min');\n    var pane1MaxSize = this.getMinMax(this.prevPaneIndex, this.previousPane, 'max');\n    var pane2MaxSize = this.getMinMax(this.nextPaneIndex, this.nextPane, 'max');\n    var validatedSize = draggedPos;\n\n    if (draggedPos > nextPaneRange - pane2MinSize) {\n      validatedSize = nextPaneRange - pane2MinSize;\n    } else if (draggedPos < prePaneRange + pane1MinSize) {\n      validatedSize = prePaneRange + pane1MinSize;\n    }\n\n    if (!isNullOrUndefined(pane1MaxSize)) {\n      if (draggedPos > prePaneRange + pane1MaxSize) {\n        validatedSize = prePaneRange + pane1MaxSize;\n      }\n    } else if (!isNullOrUndefined(pane2MaxSize)) {\n      if (draggedPos < nextPaneRange - pane2MaxSize) {\n        validatedSize = nextPaneRange - pane2MaxSize;\n      }\n    }\n\n    return validatedSize;\n  };\n\n  Splitter.prototype.onMouseUp = function (e) {\n    removeClass([this.currentSeparator], SPLIT_BAR_ACTIVE);\n    this.unwireResizeEvents();\n    var eventArgs = isBlazor() ? {\n      event: e,\n      element: this.element,\n      index: [this.prevPaneIndex, this.nextPaneIndex],\n      separator: this.currentSeparator,\n      paneSize: [this.prePaneDimenson, this.nextPaneDimension]\n    } : {\n      event: e,\n      element: this.element,\n      pane: [this.previousPane, this.nextPane],\n      index: [this.prevPaneIndex, this.nextPaneIndex],\n      separator: this.currentSeparator,\n      paneSize: [this.prePaneDimenson, this.nextPaneDimension]\n    };\n\n    for (var i = 0; i < this.element.querySelectorAll('iframe').length; i++) {\n      this.element.querySelectorAll('iframe')[i].style.pointerEvents = 'auto';\n    }\n\n    this.trigger('resizeStop', eventArgs);\n  };\n\n  Splitter.prototype.panesDimension = function (index, child) {\n    var childCount = child.length;\n    var size;\n    parseInt(this.getHeight(this.element), 10);\n\n    if (!isNullOrUndefined(this.paneSettings[index])) {\n      if (!isNullOrUndefined(this.paneSettings[index].size)) {\n        size = this.paneSettings[index].size;\n\n        if (index < childCount) {\n          setStyleAttribute(child[index], {\n            'flex-basis': size,\n            'order': index * 2\n          });\n\n          if (index < childCount - 1 && this.paneSettings[index].size !== '') {\n            addClass([child[index]], STATIC_PANE);\n          } else if (!this.sizeFlag) {\n            child[index].style.flexBasis = null;\n          }\n\n          if (index === childCount - 1 && this.sizeFlag && this.paneSettings[index].size !== '') {\n            addClass([child[index]], STATIC_PANE);\n          }\n        }\n      } else {\n        this.sizeFlag = true;\n        setStyleAttribute(child[index], {\n          'order': index * 2\n        });\n      }\n    } else {\n      setStyleAttribute(child[index], {\n        'order': index * 2\n      });\n    }\n\n    this.paneOrder.push(index * 2);\n  };\n\n  Splitter.prototype.setTemplate = function (template, toElement) {\n    toElement.innerHTML = '';\n    template = typeof template === 'string' ? this.sanitizeHelper(template) : template;\n    this.templateCompile(toElement, template);\n  }; // tslint:disable-next-line\n\n\n  Splitter.prototype.templateCompile = function (ele, cnt) {\n    var blazorContain = Object.keys(window);\n    var tempEle = this.createElement('div');\n    this.compileElement(tempEle, cnt, 'content');\n\n    if (tempEle.childNodes.length !== 0) {\n      [].slice.call(tempEle.childNodes).forEach(function (childEle) {\n        ele.appendChild(childEle);\n      });\n    }\n  };\n\n  Splitter.prototype.compileElement = function (ele, val, prop) {\n    var blazorContain = Object.keys(window);\n\n    if (typeof val === 'string') {\n      if (val[0] === '.' || val[0] === '#') {\n        var eleVal = document.querySelector(val);\n\n        if (!isNullOrUndefined(eleVal)) {\n          this.templateElement.push(eleVal);\n\n          if (eleVal.style.display === 'none') {\n            eleVal.style.removeProperty('display');\n          }\n\n          if (eleVal.getAttribute('style') === '') {\n            eleVal.removeAttribute('style');\n          }\n\n          ele.appendChild(eleVal);\n          return;\n        } else {\n          val = val.trim();\n        }\n      } else {\n        val = val.trim();\n      }\n    }\n\n    var templateFn;\n\n    if (!isNullOrUndefined(val.outerHTML)) {\n      templateFn = compile(val.outerHTML);\n    } else {\n      templateFn = compile(val);\n    }\n\n    var templateFUN;\n\n    if (!isNullOrUndefined(templateFn)) {\n      if (isBlazor() && !this.isStringTemplate) {\n        templateFUN = templateFn({}, this, prop, this.element.id + 'content' + this.allPanes.length.toString(), this.isStringTemplate);\n      } else {\n        templateFUN = templateFn({}, this, prop, this.element.id + 'content' + this.allPanes.length.toString(), true);\n      }\n    }\n\n    if (!isNullOrUndefined(templateFn) && templateFUN.length > 0) {\n      [].slice.call(templateFUN).forEach(function (el) {\n        ele.appendChild(el);\n      });\n    }\n  };\n\n  Splitter.prototype.paneCollapsible = function (pane, index) {\n    this.paneSettings[index].collapsible ? addClass([pane], COLLAPSIBLE) : removeClass([pane], COLLAPSIBLE);\n  };\n\n  Splitter.prototype.createSplitPane = function (target) {\n    var childCount = target.children.length;\n\n    if (!this.checkBlazor()) {\n      for (var i = 0; i < this.paneSettings.length; i++) {\n        if (childCount < this.paneSettings.length) {\n          var childElement = this.createElement('div');\n          this.element.appendChild(childElement);\n          childCount = childCount + 1;\n        }\n      }\n    }\n\n    childCount = target.children.length;\n    var child = [].slice.call(target.children);\n    this.sizeFlag = false;\n\n    if (childCount > 0) {\n      for (var i = 0; i < childCount; i++) {\n        // To accept only div and span element as pane\n        if (child[i].nodeName === 'DIV' || child[i].nodeName === 'SPAN') {\n          if (this.checkBlazor() && child[i].classList.contains(PANE)) {\n            this.allPanes.push(child[i]);\n          } else if (!this.checkBlazor()) {\n            this.allPanes.push(child[i]);\n          }\n\n          if (!this.checkBlazor()) {\n            if (this.orientation === 'Horizontal') {\n              addClass([child[i]], [PANE, SPLIT_H_PANE, SCROLL_PANE]);\n              this.panesDimension(i, child);\n            } else {\n              addClass([child[i]], [PANE, SPLIT_V_PANE, SCROLL_PANE]);\n              this.panesDimension(i, child);\n            }\n\n            if (!isNullOrUndefined(this.paneSettings[i]) && !isNullOrUndefined(this.paneSettings[i].content)) {\n              this.setTemplate(this.paneSettings[i].content, child[i]);\n            }\n\n            if (!isNullOrUndefined(this.paneSettings[i]) && this.paneSettings[i].cssClass) {\n              this.setCssClass(child[i], this.paneSettings[i].cssClass);\n            }\n\n            if (!isNullOrUndefined(this.paneSettings[i])) {\n              this.paneCollapsible(child[i], i);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  ;\n  /**\n   * expands corresponding pane based on the index is passed.\n   * @param { number } index - Specifies the index value of the corresponding pane to be expanded at initial rendering of splitter.\n   * @returns void\n   */\n\n  Splitter.prototype.expand = function (index) {\n    this.collapsedOnchange(index);\n    this.updatePaneSettings(index, false);\n  };\n  /**\n   * collapses corresponding pane based on the index is passed.\n   * @param { number } index - Specifies the index value of the corresponding pane to be collapsed at initial rendering of splitter.\n   * @returns void\n   */\n\n\n  Splitter.prototype.collapse = function (index) {\n    this.isCollapsed(index);\n    this.updatePaneSettings(index, true);\n  };\n  /**\n   * Removes the control from the DOM and also removes all its related events.\n   * @returns void\n   */\n\n\n  Splitter.prototype.destroy = function () {\n    if (!this.isDestroyed) {\n      if (!this.checkBlazor()) {\n        _super.prototype.destroy.call(this);\n      }\n\n      EventHandler.remove(document, 'touchstart click', this.onDocumentClick);\n\n      while (this.element.attributes.length > 0) {\n        this.element.removeAttribute(this.element.attributes[0].name);\n      }\n\n      if (this.checkBlazor()) {\n        var splitNodes = this.element.children;\n\n        for (var i = splitNodes.length - 1; i >= 0; i--) {\n          detach(splitNodes[i]);\n        }\n      } else {\n        this.element.innerHTML = this.wrapper.innerHTML;\n\n        for (var i = 0; i < this.wrapper.attributes.length; i++) {\n          this.element.setAttribute(this.wrapper.attributes[i].name, this.wrapper.attributes[i].value);\n        }\n      }\n\n      if (this.refreshing) {\n        addClass([this.element], ['e-control', 'e-lib', ROOT]);\n        this.allBars = [];\n        this.allPanes = [];\n      }\n\n      this.restoreElem();\n    }\n  };\n\n  Splitter.prototype.restoreElem = function () {\n    if (this.templateElement.length > 0) {\n      for (var i = 0; i < this.templateElement.length; i++) {\n        this.templateElement[i].style.display = 'none';\n        document.body.appendChild(this.templateElement[i]);\n      }\n    }\n  };\n\n  Splitter.prototype.addPaneClass = function (pane) {\n    this.orientation === 'Horizontal' ? addClass([pane], [PANE, SPLIT_H_PANE, SCROLL_PANE]) : addClass([pane], [PANE, SPLIT_V_PANE, SCROLL_PANE]);\n    return pane;\n  };\n\n  Splitter.prototype.removePaneOrders = function (paneClass) {\n    var panes = document.querySelectorAll('.' + paneClass);\n\n    for (var i = 0; i < panes.length; i++) {\n      panes[i].style.removeProperty('order');\n    }\n  };\n\n  Splitter.prototype.setPaneOrder = function () {\n    for (var i = 0; i < this.allPanes.length; i++) {\n      this.panesDimension(i, this.allPanes);\n    }\n  };\n\n  Splitter.prototype.removeSeparator = function () {\n    for (var i = 0; i < this.allBars.length; i++) {\n      detach(this.allBars[i]);\n    }\n\n    this.allBars = [];\n  };\n\n  Splitter.prototype.updatePanes = function () {\n    this.setPaneOrder();\n    this.removeSeparator();\n    this.addSeparator(this.element);\n  };\n  /**\n   * Allows you to add a pane dynamically to the specified index position by passing the pane properties.\n   * @param { PanePropertiesModel } paneProperties - Specifies the pane’s properties that apply to new pane.\n   * @param { number } index - Specifies the index where the pane will be inserted.\n   * @returns void\n   */\n\n\n  Splitter.prototype.addPane = function (paneProperties, index) {\n    var newPane = this.createElement('div');\n    newPane = this.addPaneClass(newPane);\n    index = index > this.allPanes.length + 1 ? this.allPanes.length : index;\n    var paneDetails = {\n      size: isNullOrUndefined(paneProperties.size) ? '' : paneProperties.size,\n      min: isNullOrUndefined(paneProperties.min) ? null : paneProperties.min,\n      max: isNullOrUndefined(paneProperties.max) ? null : paneProperties.max,\n      content: isNullOrUndefined(paneProperties.content) ? '' : paneProperties.content,\n      resizable: isNullOrUndefined(paneProperties.resizable) ? true : paneProperties.resizable,\n      collapsible: isNullOrUndefined(paneProperties.collapsible) ? false : paneProperties.collapsible,\n      collapsed: isNullOrUndefined(paneProperties.collapsed) ? false : paneProperties.collapsed,\n      cssClass: isNullOrUndefined(paneProperties.cssClass) ? '' : paneProperties.cssClass\n    };\n    this.paneSettings.splice(index, 0, paneDetails);\n    this.setProperties({\n      'paneSettings': this.paneSettings\n    }, true);\n\n    if (this.orientation === 'Horizontal') {\n      this.element.insertBefore(newPane, this.element.querySelectorAll('.' + SPLIT_H_PANE)[index]);\n      this.removePaneOrders(SPLIT_H_PANE);\n    } else {\n      this.element.insertBefore(newPane, this.element.querySelectorAll('.' + SPLIT_V_PANE)[index]);\n      this.removePaneOrders(SPLIT_V_PANE);\n    }\n\n    this.allPanes.splice(index, 0, newPane);\n    this.updatePanes();\n    this.setTemplate(this.paneSettings[index].content, newPane);\n    this.setCssClass(this.allPanes[index], paneProperties.cssClass);\n    this.allPanes[this.allPanes.length - 1].classList.remove(STATIC_PANE);\n  };\n  /**\n   * Allows you to remove the specified pane dynamically by passing its index value.\n   * @param { number } index - Specifies the index value to remove the corresponding pane.\n   * @returns void\n   */\n\n\n  Splitter.prototype.removePane = function (index) {\n    index = index > this.allPanes.length + 1 ? this.allPanes.length : index;\n    var elementClass = this.orientation === 'Horizontal' ? SPLIT_H_PANE : SPLIT_V_PANE;\n\n    if (isNullOrUndefined(this.element.querySelectorAll('.' + elementClass)[index])) {\n      return;\n    }\n\n    detach(this.element.querySelectorAll('.' + elementClass)[index]);\n    this.allPanes.splice(index, 1);\n    this.removePaneOrders(elementClass);\n    this.updatePanes();\n    this.paneSettings.splice(index, 1);\n    this.setProperties({\n      'paneSettings': this.paneSettings\n    }, true);\n\n    if (this.allPanes.length > 0) {\n      this.allPanes[this.allPanes.length - 1].classList.remove(STATIC_PANE);\n    }\n  };\n\n  __decorate([Property('100%')], Splitter.prototype, \"height\", void 0);\n\n  __decorate([Property('100%')], Splitter.prototype, \"width\", void 0);\n\n  __decorate([Collection([], PaneProperties)], Splitter.prototype, \"paneSettings\", void 0);\n\n  __decorate([Property('Horizontal')], Splitter.prototype, \"orientation\", void 0);\n\n  __decorate([Property('')], Splitter.prototype, \"cssClass\", void 0);\n\n  __decorate([Property(true)], Splitter.prototype, \"enabled\", void 0);\n\n  __decorate([Property(true)], Splitter.prototype, \"enableHtmlSanitizer\", void 0);\n\n  __decorate([Property(null)], Splitter.prototype, \"separatorSize\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"beforeSanitizeHtml\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"created\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"resizeStart\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"resizing\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"resizeStop\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"beforeCollapse\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"beforeExpand\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"collapsed\", void 0);\n\n  __decorate([Event()], Splitter.prototype, \"expanded\", void 0);\n\n  Splitter = __decorate([NotifyPropertyChanges], Splitter);\n  return Splitter;\n}(Component);\n\nexport { Splitter };","map":null,"metadata":{},"sourceType":"module"}