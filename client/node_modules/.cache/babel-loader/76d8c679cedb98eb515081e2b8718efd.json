{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.scrollable.native.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _events_engine = require(\"../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _utils = require(\"../../events/utils\");\n\nvar eventUtils = _interopRequireWildcard(_utils);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _devices = require(\"../../core/devices\");\n\nvar _devices2 = _interopRequireDefault(_devices);\n\nvar _class = require(\"../../core/class\");\n\nvar _class2 = _interopRequireDefault(_class);\n\nvar _ui = require(\"./ui.scrollbar\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nfunction _getRequireWildcardCache() {\n  if (\"function\" !== typeof WeakMap) {\n    return null;\n  }\n\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (null === obj || \"object\" !== _typeof(obj) && \"function\" !== typeof obj) {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar SCROLLABLE_NATIVE = \"dxNativeScrollable\";\nvar SCROLLABLE_NATIVE_CLASS = \"dx-scrollable-native\";\nvar SCROLLABLE_SCROLLBAR_SIMULATED = \"dx-scrollable-scrollbar-simulated\";\nvar SCROLLABLE_SCROLLBARS_HIDDEN = \"dx-scrollable-scrollbars-hidden\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar HIDE_SCROLLBAR_TIMEOUT = 500;\n\nvar NativeStrategy = _class2.default.inherit({\n  ctor: function (scrollable) {\n    this._init(scrollable);\n  },\n  _init: function (scrollable) {\n    this._component = scrollable;\n    this._$element = scrollable.$element();\n    this._$container = scrollable._$container;\n    this._$content = scrollable._$content;\n    this._direction = scrollable.option(\"direction\");\n    this._useSimulatedScrollbar = scrollable.option(\"useSimulatedScrollbar\");\n    this._showScrollbar = scrollable.option(\"showScrollbar\");\n    this.option = scrollable.option.bind(scrollable);\n    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);\n    this._isLocked = scrollable._isLocked.bind(scrollable);\n    this._isDirection = scrollable._isDirection.bind(scrollable);\n    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);\n  },\n  render: function () {\n    this._renderPushBackOffset();\n\n    var device = _devices2.default.real();\n\n    var deviceType = device.platform;\n\n    this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + \"-\" + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._showScrollbar);\n\n    if (this._showScrollbar && this._useSimulatedScrollbar) {\n      this._renderScrollbars();\n    }\n  },\n  updateBounds: _common.noop,\n  _renderPushBackOffset: function () {\n    var pushBackValue = this.option(\"pushBackValue\");\n\n    if (!pushBackValue && !this._component._lastPushBackValue) {\n      return;\n    }\n\n    this._$content.css({\n      paddingTop: pushBackValue,\n      paddingBottom: pushBackValue\n    });\n\n    this._component._lastPushBackValue = pushBackValue;\n  },\n  _renderScrollbars: function () {\n    this._scrollbars = {};\n    this._hideScrollbarTimeout = 0;\n\n    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);\n\n    this._renderScrollbar(VERTICAL);\n\n    this._renderScrollbar(HORIZONTAL);\n  },\n  _renderScrollbar: function (direction) {\n    if (!this._isDirection(direction)) {\n      return;\n    }\n\n    this._scrollbars[direction] = new _ui2.default((0, _renderer2.default)(\"<div>\").appendTo(this._$element), {\n      direction: direction,\n      expandable: this._component.option(\"scrollByThumb\")\n    });\n  },\n  handleInit: _common.noop,\n  handleStart: function () {\n    this._disablePushBack = true;\n  },\n  handleMove: function (e) {\n    if (this._isLocked()) {\n      e.cancel = true;\n      return;\n    }\n\n    if (this._allowedDirection()) {\n      e.originalEvent.isScrollingEvent = true;\n    }\n  },\n  handleEnd: function () {\n    this._disablePushBack = false;\n  },\n  handleCancel: _common.noop,\n  handleStop: _common.noop,\n  _eachScrollbar: function (callback) {\n    callback = callback.bind(this);\n    (0, _iterator.each)(this._scrollbars || {}, function (direction, scrollbar) {\n      callback(scrollbar, direction);\n    });\n  },\n  createActions: function () {\n    this._scrollAction = this._createActionByOption(\"onScroll\");\n    this._updateAction = this._createActionByOption(\"onUpdated\");\n  },\n  _createActionArgs: function () {\n    var location = this.location();\n\n    var containerElement = this._$container.get(0);\n\n    return {\n      event: this._eventForUserAction,\n      scrollOffset: {\n        top: -location.top,\n        left: -location.left\n      },\n      reachedLeft: this._isDirection(HORIZONTAL) ? location.left >= 0 : void 0,\n      reachedRight: this._isDirection(HORIZONTAL) ? Math.abs(location.left) >= containerElement.scrollWidth - containerElement.clientWidth : void 0,\n      reachedTop: this._isDirection(VERTICAL) ? location.top >= 0 : void 0,\n      reachedBottom: this._isDirection(VERTICAL) ? Math.abs(location.top) >= containerElement.scrollHeight - containerElement.clientHeight - 2 * this.option(\"pushBackValue\") : void 0\n    };\n  },\n  handleScroll: function (e) {\n    if (!this._isScrollLocationChanged()) {\n      e.stopImmediatePropagation();\n      return;\n    }\n\n    this._eventForUserAction = e;\n\n    this._moveScrollbars();\n\n    this._scrollAction(this._createActionArgs());\n\n    this._lastLocation = this.location();\n\n    this._pushBackFromBoundary();\n  },\n  _pushBackFromBoundary: function () {\n    var pushBackValue = this.option(\"pushBackValue\");\n\n    if (!pushBackValue || this._disablePushBack) {\n      return;\n    }\n\n    var scrollOffset = this._containerSize.height - this._contentSize.height;\n\n    var scrollTopPos = this._$container.scrollTop();\n\n    var scrollBottomPos = scrollOffset + scrollTopPos - 2 * pushBackValue;\n\n    if (!scrollTopPos) {\n      this._$container.scrollTop(pushBackValue);\n    } else {\n      if (!scrollBottomPos) {\n        this._$container.scrollTop(pushBackValue - scrollOffset);\n      }\n    }\n  },\n  _isScrollLocationChanged: function () {\n    var currentLocation = this.location();\n    var lastLocation = this._lastLocation || {};\n    var isTopChanged = lastLocation.top !== currentLocation.top;\n    var isLeftChanged = lastLocation.left !== currentLocation.left;\n    return isTopChanged || isLeftChanged;\n  },\n  _moveScrollbars: function () {\n    this._eachScrollbar(function (scrollbar) {\n      scrollbar.moveTo(this.location());\n      scrollbar.option(\"visible\", true);\n    });\n\n    this._hideScrollbars();\n  },\n  _hideScrollbars: function () {\n    clearTimeout(this._hideScrollbarTimeout);\n    this._hideScrollbarTimeout = setTimeout(function () {\n      this._eachScrollbar(function (scrollbar) {\n        scrollbar.option(\"visible\", false);\n      });\n    }.bind(this), HIDE_SCROLLBAR_TIMEOUT);\n  },\n  location: function () {\n    return {\n      left: -this._$container.scrollLeft(),\n      top: this.option(\"pushBackValue\") - this._$container.scrollTop()\n    };\n  },\n  disabledChanged: _common.noop,\n  update: function () {\n    this._update();\n\n    this._updateAction(this._createActionArgs());\n  },\n  _update: function () {\n    this._updateDimensions();\n\n    this._updateScrollbars();\n  },\n  _updateDimensions: function () {\n    this._containerSize = {\n      height: this._$container.height(),\n      width: this._$container.width()\n    };\n    this._componentContentSize = {\n      height: this._component.$content().height(),\n      width: this._component.$content().width()\n    };\n    this._contentSize = {\n      height: this._$content.height(),\n      width: this._$content.width()\n    };\n\n    this._pushBackFromBoundary();\n  },\n  _updateScrollbars: function () {\n    this._eachScrollbar(function (scrollbar, direction) {\n      var dimension = direction === VERTICAL ? \"height\" : \"width\";\n      scrollbar.option({\n        containerSize: this._containerSize[dimension],\n        contentSize: this._componentContentSize[dimension]\n      });\n      scrollbar.update();\n    });\n  },\n  _allowedDirections: function () {\n    return {\n      vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,\n      horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width\n    };\n  },\n  dispose: function () {\n    var className = this._$element.get(0).className;\n\n    var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + \"\\\\S*\", \"g\");\n\n    if (scrollableNativeRegexp.test(className)) {\n      this._$element.removeClass(className.match(scrollableNativeRegexp).join(\" \"));\n    }\n\n    _events_engine2.default.off(this._$element, \".\" + SCROLLABLE_NATIVE);\n\n    _events_engine2.default.off(this._$container, \".\" + SCROLLABLE_NATIVE);\n\n    this._removeScrollbars();\n\n    clearTimeout(this._hideScrollbarTimeout);\n  },\n  _removeScrollbars: function () {\n    this._eachScrollbar(function (scrollbar) {\n      scrollbar.$element().remove();\n    });\n  },\n  scrollBy: function (distance) {\n    var location = this.location();\n\n    this._$container.scrollTop(Math.round(-location.top - distance.top + this.option(\"pushBackValue\")));\n\n    this._$container.scrollLeft(Math.round(-location.left - distance.left));\n  },\n  validate: function (e) {\n    if (this.option(\"disabled\")) {\n      return false;\n    }\n\n    if (eventUtils.isDxMouseWheelEvent(e) && this._isScrolledInMaxDirection(e)) {\n      return false;\n    }\n\n    return !!this._allowedDirection();\n  },\n  _isScrolledInMaxDirection: function (e) {\n    var container = this._$container.get(0);\n\n    var result;\n\n    if (e.delta > 0) {\n      result = e.shiftKey ? !container.scrollLeft : !container.scrollTop;\n    } else {\n      if (e.shiftKey) {\n        result = container.clientWidth + container.scrollLeft >= container.scrollWidth;\n      } else {\n        result = container.clientHeight + container.scrollTop >= container.scrollHeight;\n      }\n    }\n\n    return result;\n  },\n  getDirection: function () {\n    return this._allowedDirection();\n  },\n  verticalOffset: function () {\n    return this.option(\"pushBackValue\");\n  }\n});\n\nmodule.exports = NativeStrategy;","map":null,"metadata":{},"sourceType":"script"}