{"ast":null,"code":"import { Droppable, isBlazor, addClass } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined, extend } from '@syncfusion/ej2-base';\nimport { setStyleAttribute, remove, updateBlazorTemplate, removeClass } from '@syncfusion/ej2-base';\nimport { getUpdateUsingRaf, appendChildren } from '../base/util';\nimport * as events from '../base/constant';\nimport { Row } from '../models/row';\nimport { RowRenderer } from './row-renderer';\nimport { CellMergeRender } from './cell-merge-renderer';\nimport { RowModelGenerator } from '../services/row-model-generator';\nimport { GroupModelGenerator } from '../services/group-model-generator';\nimport { getScrollBarWidth, isGroupAdaptive } from '../base/util';\n/**\n * Content module is used to render grid content\n * @hidden\n */\n\nvar ContentRender =\n/** @class */\nfunction () {\n  /**\n   * Constructor for content renderer module\n   */\n  function ContentRender(parent, serviceLocator) {\n    var _this = this;\n\n    this.rows = [];\n    this.freezeRows = [];\n    this.movableRows = [];\n    this.freezeRowElements = [];\n    /** @hidden */\n\n    this.currentInfo = {};\n    this.isLoaded = true;\n    this.viewColIndexes = [];\n\n    this.drop = function (e) {\n      _this.parent.notify(events.columnDrop, {\n        target: e.target,\n        droppedElement: e.droppedElement\n      });\n\n      remove(e.droppedElement);\n    };\n\n    this.infiniteCache = {};\n    this.isRemove = false;\n    this.visibleRows = [];\n    this.visibleFrozenRows = [];\n    this.isAddRows = false;\n    this.isInfiniteFreeze = false;\n\n    this.rafCallback = function (args) {\n      var arg = args;\n      return function () {\n        if (_this.parent.getFrozenColumns() && _this.parent.enableVirtualization) {\n          var mContentRows = [].slice.call(_this.parent.getMovableVirtualContent().querySelectorAll('.e-row'));\n          var fContentRows = [].slice.call(_this.parent.getFrozenVirtualContent().querySelectorAll('.e-row'));\n          _this.isLoaded = !mContentRows ? false : mContentRows.length === fContentRows.length;\n\n          if (_this.parent.enableColumnVirtualization && args.requestType === 'virtualscroll' && _this.isLoaded) {\n            var mHdr = [].slice.call(_this.parent.getMovableVirtualHeader().querySelectorAll('.e-row'));\n            var fHdr = [].slice.call(_this.parent.getFrozenVirtualHeader().querySelectorAll('.e-row'));\n            _this.isLoaded = mHdr.length === fHdr.length;\n          }\n        }\n\n        _this.ariaService.setBusy(_this.getPanel().querySelector('.e-content'), false);\n\n        if (_this.parent.isDestroyed) {\n          return;\n        }\n\n        var rows = _this.rows.slice(0);\n\n        if (_this.parent.getFrozenColumns() !== 0) {\n          rows = args.isFrozen ? _this.freezeRows : _this.movableRows;\n        }\n\n        _this.parent.notify(events.contentReady, {\n          rows: rows,\n          args: arg\n        });\n\n        if (_this.isLoaded) {\n          _this.parent.trigger(events.dataBound, {}, function () {\n            if (_this.parent.allowTextWrap) {\n              _this.parent.notify(events.freezeRender, {\n                case: 'textwrap'\n              });\n            }\n          });\n        }\n\n        if (arg) {\n          var action = (arg.requestType || '').toLowerCase() + '-complete';\n\n          _this.parent.notify(action, arg);\n\n          if (args.requestType === 'batchsave') {\n            args.cancel = false;\n\n            _this.parent.trigger(events.actionComplete, args);\n          }\n        }\n\n        if (_this.isLoaded) {\n          _this.parent.hideSpinner();\n        }\n      };\n    };\n\n    this.parent = parent;\n    this.serviceLocator = serviceLocator;\n    this.ariaService = this.serviceLocator.getService('ariaService');\n    this.generator = this.getModelGenerator();\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    if (!this.parent.enableColumnVirtualization && !this.parent.enableVirtualization) {\n      this.parent.on(events.columnVisibilityChanged, this.setVisible, this);\n    }\n\n    this.parent.on(events.colGroupRefresh, this.colGroupRefresh, this);\n    this.parent.on(events.uiUpdate, this.enableAfterRender, this);\n    this.parent.on(events.refreshInfiniteModeBlocks, this.refreshContentRows, this);\n    this.parent.on(events.beforeCellFocused, this.beforeCellFocused, this);\n  }\n\n  ContentRender.prototype.beforeCellFocused = function (e) {\n    if (e.byKey && (e.keyArgs.action === 'upArrow' || e.keyArgs.action === 'downArrow')) {\n      this.pressedKey = e.keyArgs.action;\n    } else {\n      this.pressedKey = undefined;\n    }\n  };\n  /**\n   * The function is used to render grid content div\n   */\n\n\n  ContentRender.prototype.renderPanel = function () {\n    var gObj = this.parent;\n    var div = this.parent.element.querySelector('.e-gridcontent');\n\n    if (div) {\n      this.ariaService.setOptions(this.parent.element.querySelector('.e-content'), {\n        busy: false\n      });\n      this.setPanel(div);\n      return;\n    }\n\n    div = this.parent.createElement('div', {\n      className: 'e-gridcontent'\n    });\n    var innerDiv = this.parent.createElement('div', {\n      className: 'e-content'\n    });\n    this.ariaService.setOptions(innerDiv, {\n      busy: false\n    });\n    div.appendChild(innerDiv);\n    this.setPanel(div);\n    gObj.element.appendChild(div);\n  };\n  /**\n   * The function is used to render grid content table\n   */\n\n\n  ContentRender.prototype.renderTable = function () {\n    var contentDiv = this.getPanel();\n    var virtualTable = contentDiv.querySelector('.e-virtualtable');\n    var virtualTrack = contentDiv.querySelector('.e-virtualtrack');\n\n    if (this.parent.enableVirtualization && !isNullOrUndefined(virtualTable) && !isNullOrUndefined(virtualTrack) && (!isBlazor() || isBlazor() && !this.parent.isServerRendered)) {\n      remove(virtualTable);\n      remove(virtualTrack);\n    }\n\n    contentDiv.appendChild(this.createContentTable('_content_table'));\n    this.setTable(contentDiv.querySelector('.e-table'));\n    this.ariaService.setOptions(this.getTable(), {\n      multiselectable: this.parent.selectionSettings.type === 'Multiple'\n    });\n    this.initializeContentDrop();\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().classList.add('e-frozenhdrcont');\n    }\n  };\n  /**\n   * The function is used to create content table elements\n   * @return {Element}\n   * @hidden\n   */\n\n\n  ContentRender.prototype.createContentTable = function (id) {\n    var innerDiv = this.getPanel().firstElementChild;\n\n    if (!isBlazor()) {\n      if (this.getTable()) {\n        remove(this.getTable());\n      }\n    }\n\n    var table = innerDiv.querySelector('.e-table') ? innerDiv.querySelector('.e-table') : this.parent.createElement('table', {\n      className: 'e-table',\n      attrs: {\n        cellspacing: '0.25px',\n        role: 'grid',\n        id: this.parent.element.id + id\n      }\n    });\n    this.setColGroup(this.parent.element.querySelector('.e-gridheader').querySelector('colgroup').cloneNode(true));\n    table.appendChild(this.getColGroup());\n    table.appendChild(this.parent.createElement('tbody'));\n    innerDiv.appendChild(table);\n    return innerDiv;\n  };\n\n  ContentRender.prototype.splitRows = function (idx) {\n    if (this.parent.getFrozenColumns()) {\n      if (idx === 0) {\n        this.freezeRows = this.rows;\n        this.freezeRowElements = this.rowElements;\n      } else {\n        this.movableRows = this.rows;\n      }\n    }\n  };\n  /**\n   * Refresh the content of the Grid.\n   * @return {void}\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  ContentRender.prototype.refreshContentRows = function (args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = {};\n    }\n\n    var gObj = this.parent;\n\n    if (gObj.currentViewData.length === 0) {\n      return;\n    }\n\n    var dataSource = this.currentMovableRows || gObj.currentViewData;\n    var frag = document.createDocumentFragment();\n\n    if (!this.initialPageRecords) {\n      this.initialPageRecords = extend([], dataSource);\n    }\n\n    var hdrfrag = document.createDocumentFragment();\n    var columns = gObj.getColumns();\n    var tr;\n    var hdrTbody;\n    var frzCols = gObj.getFrozenColumns();\n    var trElement;\n    var row = new RowRenderer(this.serviceLocator, null, this.parent);\n    var isInfiniteScroll = this.parent.enableInfiniteScrolling && args.requestType === 'infiniteScroll';\n    this.rowElements = [];\n    this.rows = [];\n    var fCont = this.getPanel().querySelector('.e-frozencontent');\n    var mCont = this.getPanel().querySelector('.e-movablecontent');\n    var cont = this.getPanel().querySelector('.e-content');\n\n    if (isGroupAdaptive(gObj)) {\n      if (['sorting', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder'].some(function (value) {\n        return args.requestType === value;\n      })) {\n        gObj.vcRows = [];\n        gObj.vRows = [];\n      }\n    }\n\n    var modelData;\n    var isServerRendered = 'isServerRendered';\n\n    if (isBlazor() && this.parent[isServerRendered]) {\n      modelData = this.generator.generateRows(dataSource, args);\n\n      if (this.parent.enableVirtualization) {\n        this.prevInfo = this.prevInfo ? this.prevInfo : args.virtualInfo;\n        this.prevInfo = args.virtualInfo.sentinelInfo && args.virtualInfo.sentinelInfo.axis === 'Y' && this.currentInfo.page && this.currentInfo.page !== args.virtualInfo.page ? this.currentInfo : args.virtualInfo;\n      }\n\n      this.rows = modelData;\n      this.freezeRows = modelData;\n      this.rowElements = [].slice.call(this.getTable().querySelectorAll('tr.e-row[data-uid]'));\n\n      if (frzCols) {\n        this.movableRows = modelData.map(function (mRow) {\n          var sRow = new Row(mRow);\n          sRow.cells = mRow.cells.slice(frzCols, mRow.cells.length);\n          mRow.cells = mRow.cells.slice(0, frzCols);\n          return sRow;\n        });\n        this.freezeRowElements = this.rowElements;\n      }\n\n      this.isLoaded = true;\n      this.parent.hideSpinner();\n      args.isFrozen = this.parent.getFrozenColumns() !== 0 && !args.isFrozen;\n      var arg = extend({\n        rows: this.rows\n      }, args);\n\n      if (this.getTable().querySelector('.e-emptyrow')) {\n        remove(this.getTable().querySelector('.e-emptyrow'));\n\n        if (!isNullOrUndefined(this.getTable().querySelectorAll('.e-table > tbody')[1])) {\n          remove(this.getTable().querySelectorAll('.e-table > tbody')[1]);\n        }\n      }\n\n      this.parent.notify('contentcolgroup', {});\n      this.rafCallback(arg)();\n\n      if (frzCols) {\n        cont.style.overflowY = 'hidden';\n        fCont.style.height = mCont.offsetHeight - getScrollBarWidth() + 'px';\n        mCont.style.overflowY = this.parent.height !== 'auto' ? 'scroll' : 'auto';\n        fCont.style.borderRightWidth = '1px';\n        this.parent.notify(events.contentReady, {\n          rows: this.movableRows,\n          args: extend({}, arg, {\n            isFrozen: false\n          })\n        });\n      }\n\n      if (!(this.parent.isCheckBoxSelection || this.parent.selectionSettings.type === 'Multiple') || !this.parent.isPersistSelection && !this.parent.enableVirtualization) {\n        var rowIndex = 'editRowIndex';\n\n        if (this.parent.editSettings.mode === 'Normal' && !isNullOrUndefined(args[rowIndex])) {\n          this.parent.selectRow(args[rowIndex]);\n        }\n      }\n\n      if (this.parent.enableVirtualization && !this.parent.getHeaderContent().querySelectorAll('.e-check').length) {\n        var removeClassByUid = this.parent.getRows().filter(function (x) {\n          return x.getAttribute('aria-selected');\n        }).map(function (y) {\n          return y.getAttribute('data-uid');\n        });\n        var addClassByUid = this.parent.getRows().filter(function (x) {\n          return x.getAttribute('aria-selected') === null;\n        }).map(function (y) {\n          return y.getAttribute('data-uid');\n        });\n\n        for (var i = 0; i < removeClassByUid.length; i++) {\n          if (!isNullOrUndefined(this.parent.getRowObjectFromUID(removeClassByUid[i])) && !this.parent.getRowObjectFromUID(removeClassByUid[i]).isSelected) {\n            this.parent.getRowElementByUID(removeClassByUid[i]).removeAttribute('aria-selected');\n\n            if (!isNullOrUndefined(this.parent.getRowElementByUID(removeClassByUid[i]).querySelector('.e-check'))) {\n              removeClass([this.parent.getRowElementByUID(removeClassByUid[i]).querySelector('.e-check')], ['e-check']);\n            }\n\n            for (var j = 0; j < this.parent.getRowElementByUID(removeClassByUid[i]).children.length; j++) {\n              this.parent.getRowElementByUID(removeClassByUid[i]).children[j].classList.remove('e-selectionbackground', 'e-active');\n            }\n          }\n        }\n\n        for (var i = 0; i < addClassByUid.length; i++) {\n          if (!isNullOrUndefined(this.parent.getRowObjectFromUID(addClassByUid[i])) && this.parent.getRowObjectFromUID(addClassByUid[i]).isSelected) {\n            this.parent.getRowElementByUID(addClassByUid[i]).setAttribute('aria-selected', 'true');\n\n            if (!isNullOrUndefined(this.parent.getRowElementByUID(addClassByUid[i]).querySelector('.e-frame'))) {\n              addClass([this.parent.getRowElementByUID(addClassByUid[i]).querySelector('.e-frame')], ['e-check']);\n            }\n\n            for (var j = 0; j < this.parent.getRowElementByUID(addClassByUid[i]).children.length; j++) {\n              this.parent.getRowElementByUID(addClassByUid[i]).children[j].classList.add('e-selectionbackground', 'e-active');\n            }\n          }\n        }\n      }\n\n      return;\n    }\n\n    if (this.parent.enableVirtualization && this.parent.getFrozenColumns()) {\n      if (this.parent.enableColumnVirtualization && args.requestType === 'virtualscroll') {\n        if (args.virtualInfo.sentinelInfo.axis === 'X') {\n          modelData = this.parent.contentModule.generateRows(dataSource, args);\n          args.renderMovableContent = true;\n        } else if (mCont.scrollLeft > 0 && !args.renderMovableContent) {\n          this.viewColIndexes = args.virtualInfo.columnIndexes;\n          var indexes = [];\n\n          for (var i = 0; i < this.parent.getFrozenColumns(); i++) {\n            indexes.push(i);\n          }\n\n          this.parent.setColumnIndexesInView(indexes);\n          args.virtualInfo.columnIndexes = indexes;\n        }\n      }\n\n      modelData = this.parent.contentModule.generateRows(dataSource, args);\n    } else {\n      modelData = this.checkInfiniteCache(modelData, args);\n\n      if (!this.isAddRows) {\n        modelData = this.generator.generateRows(dataSource, args);\n      }\n    }\n\n    this.parent.notify(events.setInfiniteCache, {\n      isInfiniteScroll: isInfiniteScroll,\n      modelData: modelData,\n      args: args\n    });\n\n    if (isNullOrUndefined(modelData[0].cells[0])) {\n      mCont.querySelector('tbody').innerHTML = '';\n    }\n\n    var idx = modelData[0].cells[0].index;\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && args.renderMovableContent && args.requestType === 'virtualscroll' && mCont.scrollLeft > 0 && args.virtualInfo.columnIndexes[0] !== 0) {\n      idx = this.parent.getFrozenColumns();\n    }\n    /* tslint:disable:no-any */\n\n\n    if (args.requestType !== 'infiniteScroll' && this.parent.registeredTemplate && this.parent.registeredTemplate.template && !args.isFrozen) {\n      var templatetoclear = [];\n\n      for (var i = 0; i < this.parent.registeredTemplate.template.length; i++) {\n        for (var j = 0; j < this.parent.registeredTemplate.template[i].rootNodes.length; j++) {\n          if (isNullOrUndefined(this.parent.registeredTemplate.template[i].rootNodes[j].parentNode)) {\n            templatetoclear.push(this.parent.registeredTemplate.template[i]);\n            /* tslint:enable:no-any */\n          }\n        }\n      }\n\n      this.parent.destroyTemplate(['template'], templatetoclear);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      var cellMerge = new CellMergeRender(this.serviceLocator, this.parent);\n      cellMerge.updateVirtualCells(modelData);\n    }\n\n    if (frzCols && idx >= frzCols) {\n      this.tbody = mCont.querySelector('tbody');\n    } else {\n      this.tbody = this.getTable().querySelector('tbody');\n    }\n\n    var startIndex = 0;\n    var blockLoad = true;\n\n    if (isGroupAdaptive(gObj) && gObj.vcRows.length) {\n      var top_1 = 'top';\n      var scrollTop = !isNullOrUndefined(args.virtualInfo.offsets) ? args.virtualInfo.offsets.top : !isNullOrUndefined(args.scrollTop) ? args.scrollTop[top_1] : 0;\n\n      if (scrollTop !== 0) {\n        var offsets_1 = gObj.vGroupOffsets;\n        var bSize = gObj.pageSettings.pageSize / 2;\n        var values = Object.keys(offsets_1).map(function (key) {\n          return offsets_1[key];\n        });\n\n        for (var m = 0; m < values.length; m++) {\n          if (scrollTop < values[m]) {\n            if (!isNullOrUndefined(args.virtualInfo) && args.virtualInfo.direction === 'up') {\n              args.virtualInfo.blockIndexes = m === 0 || m === 1 ? [1, 2] : [m, m + 1];\n              startIndex = m === 0 || m === 1 ? 0 : m * bSize;\n              break;\n            } else {\n              args.virtualInfo.blockIndexes = m === 0 || m === 1 ? [1, 2] : [m, m + 1];\n              startIndex = m === 0 || m === 1 ? 0 : m * bSize;\n              break;\n            }\n          }\n        }\n\n        if (scrollTop + this.contentPanel.firstElementChild.offsetHeight === this.contentPanel.firstElementChild.scrollHeight && !args.rowObject) {\n          blockLoad = false;\n        }\n      }\n    }\n\n    var isVFFrozenOnly = gObj.frozenRows && !gObj.getFrozenColumns() && this.parent.enableVirtualization && args.requestType === 'reorder';\n\n    if (gObj.frozenRows && args.requestType === 'virtualscroll' && args.virtualInfo.sentinelInfo.axis === 'X' || isVFFrozenOnly) {\n      var bIndex = args.virtualInfo.blockIndexes;\n      var page = args.virtualInfo.page;\n      args.virtualInfo.blockIndexes = [1, 2];\n\n      if (isVFFrozenOnly) {\n        args.virtualInfo.page = 1;\n      }\n\n      var data = isVFFrozenOnly ? this.initialPageRecords : dataSource;\n      var mhdrData = this.vgenerator.generateRows(data, args);\n      mhdrData.splice(this.parent.frozenRows);\n\n      for (var i = 0; i < this.parent.frozenRows; i++) {\n        mhdrData[i].cells.splice(0, this.parent.getFrozenColumns());\n        tr = row.render(mhdrData[i], columns);\n        hdrfrag.appendChild(tr);\n      }\n\n      args.virtualInfo.blockIndexes = bIndex;\n      args.virtualInfo.page = page;\n\n      if (isVFFrozenOnly && args.virtualInfo.page === 1) {\n        modelData.splice(0, this.parent.frozenRows);\n      }\n    }\n\n    this.virtualFrozenHdrRefresh(hdrfrag, modelData, row, args, dataSource, columns);\n\n    for (var i = startIndex, len = modelData.length; i < len; i++) {\n      this.rows.push(modelData[i]);\n      this.setInfiniteVisibleRows(args, modelData[i]);\n\n      if (isGroupAdaptive(gObj) && this.rows.length >= gObj.pageSettings.pageSize && blockLoad) {\n        break;\n      }\n\n      if (!gObj.rowTemplate) {\n        tr = row.render(modelData[i], columns);\n        var isVFreorder = this.ensureFrozenHeaderRender(args);\n\n        if (gObj.frozenRows && i < gObj.frozenRows && !isInfiniteScroll && args.requestType !== 'virtualscroll' && isVFreorder) {\n          hdrfrag.appendChild(tr);\n        } else {\n          frag.appendChild(tr);\n        }\n\n        if (modelData[i].isExpand) {\n          gObj.notify(events.expandChildGrid, tr.cells[gObj.groupSettings.columns.length]);\n        }\n      } else {\n        var rowTemplateID = gObj.element.id + 'rowTemplate';\n        var elements = gObj.getRowTemplate()(extend({\n          index: i\n        }, dataSource[i]), gObj, 'rowTemplate', rowTemplateID);\n\n        if (elements[0].tagName === 'TBODY') {\n          for (var j = 0; j < elements.length; j++) {\n            var isTR = elements[j].nodeName.toLowerCase() === 'tr';\n\n            if (isTR || elements[j].querySelectorAll && elements[j].querySelectorAll('tr').length) {\n              tr = isTR ? elements[j] : elements[j].querySelector('tr');\n            }\n          }\n\n          if (gObj.frozenRows && i < gObj.frozenRows) {\n            hdrfrag.appendChild(tr);\n          } else {\n            frag.appendChild(tr);\n          }\n        } else {\n          if (gObj.frozenRows && i < gObj.frozenRows) {\n            tr = appendChildren(hdrfrag, elements);\n          } else {\n            // frag.appendChild(tr);\n            tr = appendChildren(frag, elements);\n            trElement = tr.lastElementChild;\n          }\n        }\n\n        var arg = {\n          data: modelData[i].data,\n          row: trElement ? trElement : tr\n        };\n        this.parent.trigger(events.rowDataBound, arg);\n      }\n\n      if (modelData[i].isDataRow) {\n        this.rowElements.push(tr);\n      }\n\n      this.ariaService.setOptions(this.getTable(), {\n        colcount: gObj.getColumns().length.toString()\n      });\n    }\n\n    this.splitRows(idx);\n\n    if (gObj.frozenRows && args.requestType !== 'virtualscroll' && !isInfiniteScroll || args.requestType === 'virtualscroll' && args.virtualInfo.sentinelInfo && args.virtualInfo.sentinelInfo.axis === 'X') {\n      hdrTbody = frzCols ? gObj.getHeaderContent().querySelector(idx === 0 ? '.e-frozenheader' : '.e-movableheader').querySelector('tbody') : gObj.getHeaderTable().querySelector('tbody');\n      hdrTbody.innerHTML = '';\n      hdrTbody.appendChild(hdrfrag);\n    }\n\n    if (!gObj.enableVirtualization && gObj.frozenRows && idx === 0 && cont.offsetHeight === Number(gObj.height)) {\n      cont.style.height = cont.offsetHeight - hdrTbody.offsetHeight + 'px';\n    }\n\n    if (frzCols && idx === 0) {\n      this.getPanel().firstChild.style.overflowY = 'hidden';\n    }\n\n    if (!isBlazor() || this.parent.isJsComponent) {\n      args.rows = this.rows.slice(0);\n    }\n\n    args.isFrozen = this.parent.getFrozenColumns() !== 0 && !args.isFrozen;\n    this.index = idx;\n    getUpdateUsingRaf(function () {\n      _this.parent.notify(events.beforeFragAppend, args);\n\n      var isVFTable = _this.parent.enableVirtualization && _this.parent.getFrozenColumns() !== 0;\n\n      if (!_this.parent.enableVirtualization && !isInfiniteScroll) {\n        remove(_this.tbody);\n        _this.tbody = _this.parent.createElement('tbody');\n      }\n\n      if (frzCols && !isVFTable && !_this.parent.enableInfiniteScrolling) {\n        _this.tbody.appendChild(frag);\n\n        if (_this.index === 0) {\n          _this.isLoaded = false;\n          fCont.querySelector('table').appendChild(_this.tbody);\n        } else {\n          if (_this.tbody.childElementCount < 1) {\n            _this.tbody.appendChild(_this.parent.createElement('tr').appendChild(_this.parent.createElement('td')));\n          }\n\n          _this.isLoaded = true;\n          mCont.querySelector('table').appendChild(_this.tbody);\n\n          if (_this.parent.getFrozenColumns() !== 0 && !_this.parent.allowTextWrap) {\n            _this.parent.notify(events.freezeRender, {\n              case: 'refreshHeight'\n            });\n          }\n\n          fCont.style.height = mCont.offsetHeight - getScrollBarWidth() + 'px';\n          mCont.style.overflowY = _this.parent.height !== 'auto' ? 'scroll' : 'auto';\n          fCont.style.borderRightWidth = '1px';\n        }\n      } else {\n        if (gObj.rowTemplate) {\n          updateBlazorTemplate(gObj.element.id + 'rowTemplate', 'RowTemplate', gObj);\n        }\n\n        if (isVFTable) {\n          if (!args.renderMovableContent) {\n            _this.appendContent(fCont.querySelector('tbody'), frag, args);\n\n            if (_this.parent.enableColumnVirtualization && args.requestType === 'virtualscroll' && mCont.scrollLeft > 0) {\n              _this.parent.setColumnIndexesInView(_this.viewColIndexes);\n\n              args.virtualInfo.columnIndexes = _this.viewColIndexes;\n            }\n          } else {\n            _this.appendContent(mCont.querySelector('tbody'), frag, args);\n\n            if (args.virtualInfo && args.virtualInfo.direction !== 'right' && args.virtualInfo.direction !== 'left') {\n              fCont.style.height = mCont.offsetHeight - getScrollBarWidth() + 'px';\n            }\n\n            args.renderMovableContent = false;\n          }\n        } else {\n          if (!isNullOrUndefined(_this.parent.infiniteScrollModule) && _this.parent.enableInfiniteScrolling) {\n            _this.isAddRows = false;\n\n            _this.parent.notify(events.removeInfiniteRows, {\n              args: args\n            });\n\n            _this.parent.notify(events.appendInfiniteContent, {\n              tbody: _this.tbody,\n              frag: frag,\n              args: args,\n              rows: _this.rows,\n              rowElements: _this.rowElements,\n              visibleRows: _this.visibleRows\n            });\n\n            if (frzCols && idx !== 0) {\n              fCont.style.height = mCont.offsetHeight - getScrollBarWidth() + 'px';\n              mCont.style.overflowY = _this.parent.height !== 'auto' ? 'scroll' : 'auto';\n              fCont.style.borderRightWidth = '1px';\n            }\n          } else {\n            _this.appendContent(_this.tbody, frag, args);\n          }\n        }\n      }\n\n      if (frzCols && idx === 0) {\n        if (isVFTable) {\n          args.renderMovableContent = true;\n        }\n\n        _this.refreshContentRows(extend({}, args));\n      }\n\n      frag = null;\n    }, this.rafCallback(extend({}, args)));\n  };\n\n  ContentRender.prototype.appendContent = function (tbody, frag, args) {\n    tbody.appendChild(frag);\n    this.getTable().appendChild(tbody);\n  };\n\n  ContentRender.prototype.ensureFrozenHeaderRender = function (args) {\n    return !(this.parent.enableVirtualization && (args.requestType === 'reorder' || args.requestType === 'refresh') || this.parent.infiniteScrollSettings.enableCache && this.parent.frozenRows && this.parent.infiniteScrollModule.requestType === 'delete' && this.parent.pageSettings.currentPage !== 1);\n  };\n\n  ContentRender.prototype.checkInfiniteCache = function (modelData, args) {\n    if (this.parent.infiniteScrollSettings.enableCache && args.requestType === 'infiniteScroll') {\n      var index = args.isFrozen ? 1 : 0;\n      var frozenCols = this.parent.getFrozenColumns();\n      this.isAddRows = !isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage]);\n\n      if (frozenCols && !isNullOrUndefined(this.infiniteCache[this.parent.pageSettings.currentPage])) {\n        this.isAddRows = this.infiniteCache[this.parent.pageSettings.currentPage][index].length !== 0;\n      }\n\n      if (this.isAddRows) {\n        var data = !frozenCols ? this.infiniteCache[this.parent.pageSettings.currentPage] : this.infiniteCache[this.parent.pageSettings.currentPage][index];\n        modelData = this.parent.pageSettings.currentPage === 1 ? data.slice(this.parent.frozenRows) : data;\n      }\n\n      return modelData;\n    }\n\n    return null;\n  };\n\n  ContentRender.prototype.setInfiniteVisibleRows = function (args, data) {\n    var frozenCols = this.parent.getFrozenColumns();\n\n    if (this.parent.enableInfiniteScrolling && !this.parent.infiniteScrollSettings.enableCache) {\n      if (frozenCols) {\n        !args.isFrozen ? this.visibleFrozenRows.push(data) : this.visibleRows.push(data);\n      } else if (!this.parent.infiniteScrollSettings.enableCache) {\n        this.visibleRows.push(data);\n      }\n    }\n  };\n\n  ContentRender.prototype.getCurrentBlockInfiniteRecords = function (isFreeze) {\n    var data = [];\n\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      if (!Object.keys(this.infiniteCache).length) {\n        return [];\n      }\n\n      var frozenCols = this.parent.getFrozenColumns();\n      var rows = this.parent.getRows();\n      var index = parseInt(rows[this.parent.frozenRows].getAttribute('aria-rowindex'), 10);\n      var first = Math.ceil((index + 1) / this.parent.pageSettings.pageSize);\n      index = parseInt(rows[rows.length - 1].getAttribute('aria-rowindex'), 10);\n      var last = Math.ceil(index / this.parent.pageSettings.pageSize);\n\n      if (frozenCols) {\n        var idx = isFreeze ? 0 : 1;\n\n        for (var i = first; i <= last; i++) {\n          data = !data.length ? this.infiniteCache[i][idx] : data.concat(this.infiniteCache[i][idx]);\n        }\n\n        if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n          data = this.infiniteCache[1][idx].slice(0, this.parent.frozenRows).concat(data);\n        }\n      } else {\n        for (var i = first; i <= last; i++) {\n          data = !data.length ? this.infiniteCache[i] : data.concat(this.infiniteCache[i]);\n        }\n\n        if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n          data = this.infiniteCache[1].slice(0, this.parent.frozenRows).concat(data);\n        }\n      }\n    }\n\n    return data;\n  };\n\n  ContentRender.prototype.getReorderedVFRows = function (args) {\n    return this.parent.contentModule.getReorderedFrozenRows(args);\n  };\n\n  ContentRender.prototype.virtualFrozenHdrRefresh = function (hdrfrag, modelData, row, args, dataSource, columns) {\n    if (this.parent.frozenRows && this.parent.getFrozenColumns() && this.parent.enableVirtualization && (args.requestType === 'reorder' || args.requestType === 'refresh')) {\n      var tr = void 0;\n      this.currentMovableRows = dataSource;\n      var fhdrData = this.getReorderedVFRows(args);\n\n      for (var i = 0; i < fhdrData.length; i++) {\n        tr = row.render(fhdrData[i], columns);\n        hdrfrag.appendChild(tr);\n      }\n\n      if (args.virtualInfo.page === 1) {\n        modelData.splice(0, this.parent.frozenRows);\n      }\n\n      if (args.renderMovableContent) {\n        this.parent.currentViewData = this.currentMovableRows;\n        this.currentMovableRows = null;\n      }\n    }\n  };\n\n  ContentRender.prototype.getInfiniteRows = function () {\n    var rows = [];\n    var frozenCols = this.parent.getFrozenColumns();\n\n    if (this.parent.enableInfiniteScrolling) {\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        var keys = Object.keys(this.infiniteCache);\n\n        for (var i = 0; i < keys.length; i++) {\n          rows = !frozenCols ? rows.concat(this.infiniteCache[keys[i]]) : rows.concat(this.infiniteCache[keys[i]][0]);\n        }\n      } else {\n        rows = frozenCols ? this.visibleFrozenRows : this.visibleRows;\n      }\n    }\n\n    return rows;\n  };\n\n  ContentRender.prototype.getInfiniteMovableRows = function () {\n    var infiniteCacheRows = this.getCurrentBlockInfiniteRecords();\n    var infiniteRows = this.parent.enableInfiniteScrolling ? infiniteCacheRows.length ? infiniteCacheRows : this.visibleRows : [];\n    return infiniteRows;\n  };\n  /**\n   * Get the content div element of grid\n   * @return {Element}\n   */\n\n\n  ContentRender.prototype.getPanel = function () {\n    return this.contentPanel;\n  };\n  /**\n   * Set the content div element of grid\n   * @param  {Element} panel\n   */\n\n\n  ContentRender.prototype.setPanel = function (panel) {\n    this.contentPanel = panel;\n  };\n  /**\n   * Get the content table element of grid\n   * @return {Element}\n   */\n\n\n  ContentRender.prototype.getTable = function () {\n    return this.contentTable;\n  };\n  /**\n   * Set the content table element of grid\n   * @param  {Element} table\n   */\n\n\n  ContentRender.prototype.setTable = function (table) {\n    this.contentTable = table;\n  };\n  /**\n   * Get the Row collection in the Grid.\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>}\n   */\n\n\n  ContentRender.prototype.getRows = function () {\n    var infiniteRows = this.getInfiniteRows();\n    return infiniteRows.length ? infiniteRows : this.parent.getFrozenColumns() ? this.freezeRows : this.rows;\n  };\n  /**\n   * Get the Movable Row collection in the Freeze pane Grid.\n   * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>}\n   */\n\n\n  ContentRender.prototype.getMovableRows = function () {\n    var infiniteRows = this.getInfiniteMovableRows();\n    return infiniteRows.length ? infiniteRows : this.movableRows;\n  };\n  /**\n   * Get the content table data row elements\n   * @return {Element}\n   */\n\n\n  ContentRender.prototype.getRowElements = function () {\n    return this.parent.getFrozenColumns() ? this.freezeRowElements : this.rowElements;\n  };\n  /**\n   * Get the Freeze pane movable content table data row elements\n   * @return {Element}\n   */\n\n\n  ContentRender.prototype.getMovableRowElements = function () {\n    return this.rowElements;\n  };\n  /**\n   * Get the content table data row elements\n   * @return {Element}\n   */\n\n\n  ContentRender.prototype.setRowElements = function (elements) {\n    this.rowElements = elements;\n  };\n  /**\n   * Get the header colgroup element\n   * @returns {Element}\n   */\n\n\n  ContentRender.prototype.getColGroup = function () {\n    return this.colgroup;\n  };\n  /**\n   * Set the header colgroup element\n   * @param {Element} colgroup\n   * @returns {Element}\n   */\n\n\n  ContentRender.prototype.setColGroup = function (colGroup) {\n    if (!isNullOrUndefined(colGroup)) {\n      colGroup.id = 'content-' + colGroup.id;\n    }\n\n    return this.colgroup = colGroup;\n  };\n  /**\n   * Function to hide content table column based on visible property\n   * @param  {Column[]} columns?\n   */\n\n\n  ContentRender.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n\n    if (isBlazor() && gObj.isServerRendered) {\n      this.parent.notify('setvisibility', columns);\n    }\n\n    var frzCols = gObj.getFrozenColumns();\n    var rows = [];\n\n    if (frzCols) {\n      var fRows = this.freezeRows;\n      var mRows = this.movableRows;\n      var rowLen = fRows.length;\n      var cellLen = void 0;\n\n      for (var i = 0, row = void 0; i < rowLen; i++) {\n        cellLen = mRows[i].cells.length;\n        row = fRows[i].clone();\n\n        for (var j = 0; j < cellLen; j++) {\n          row.cells.push(mRows[i].cells[j]);\n        }\n\n        rows.push(row);\n      }\n    } else {\n      rows = this.getRows();\n    }\n\n    var element;\n    var testRow;\n    rows.some(function (r) {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    var tasks = [];\n    var needFullRefresh = true;\n\n    if (!gObj.groupSettings.columns.length && testRow) {\n      needFullRefresh = false;\n    }\n\n    var tr = gObj.getDataRows();\n    var args = {};\n    var infiniteData = this.infiniteRowVisibility();\n    var contentrows = infiniteData ? infiniteData : this.rows.filter(function (row) {\n      return !row.isDetailRow;\n    });\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      var idx = this.parent.getNormalizedColumnIndex(column.uid);\n      var colIdx = this.parent.getColumnIndexByUid(column.uid);\n      var displayVal = column.visible === true ? '' : 'none';\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        if (frzCols) {\n          if (idx < frzCols) {\n            setStyleAttribute(this.getColGroup().childNodes[idx], {\n              'display': displayVal\n            });\n            var infiniteFreezeData = this.infiniteRowVisibility(true);\n            contentrows = infiniteFreezeData ? infiniteFreezeData : this.freezeRows;\n            tr = gObj.getDataRows();\n          } else {\n            var mTable = gObj.getContent().querySelector('.e-movablecontent').querySelector('colgroup');\n            colIdx = idx = idx - frzCols;\n            setStyleAttribute(mTable.childNodes[idx], {\n              'display': displayVal\n            });\n            tr = gObj.getMovableDataRows();\n            var infiniteMovableData = this.infiniteRowVisibility();\n            contentrows = infiniteMovableData ? infiniteMovableData : this.movableRows;\n          }\n        } else {\n          setStyleAttribute(this.getColGroup().childNodes[idx], {\n            'display': displayVal\n          });\n        }\n      }\n\n      if (!needFullRefresh) {\n        this.setDisplayNone(tr, colIdx, displayVal, contentrows);\n      }\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n\n    if (needFullRefresh) {\n      this.refreshContentRows({\n        requestType: 'refresh'\n      });\n    } else {\n      if (!this.parent.getFrozenColumns()) {\n        this.parent.notify(events.partialRefresh, {\n          rows: contentrows,\n          args: args\n        });\n      } else {\n        this.parent.notify(events.partialRefresh, {\n          rows: this.freezeRows,\n          args: {\n            isFrozen: true,\n            rows: this.freezeRows\n          }\n        });\n        this.parent.notify(events.partialRefresh, {\n          rows: this.movableRows,\n          args: {\n            isFrozen: false,\n            rows: this.movableRows\n          }\n        });\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  ContentRender.prototype.setDisplayNone = function (tr, idx, displayVal, rows) {\n    var trs = Object.keys(tr);\n\n    for (var i = 0; i < trs.length; i++) {\n      var td = tr[trs[i]].querySelectorAll('td.e-rowcell')[idx];\n\n      if (tr[trs[i]].querySelectorAll('td.e-rowcell').length && td) {\n        setStyleAttribute(tr[trs[i]].querySelectorAll('td.e-rowcell')[idx], {\n          'display': displayVal\n        });\n\n        if (tr[trs[i]].querySelectorAll('td.e-rowcell')[idx].classList.contains('e-hide')) {\n          removeClass([tr[trs[i]].querySelectorAll('td.e-rowcell')[idx]], ['e-hide']);\n        }\n\n        if (this.parent.isRowDragable()) {\n          rows[trs[i]].cells[idx + 1].visible = displayVal === '' ? true : false;\n        } else {\n          rows[trs[i]].cells[idx].visible = displayVal === '' ? true : false;\n        }\n      }\n    }\n\n    this.parent.notify(events.infiniteShowHide, {\n      visible: displayVal,\n      index: idx,\n      isFreeze: this.isInfiniteFreeze\n    });\n  };\n\n  ContentRender.prototype.infiniteRowVisibility = function (isFreeze) {\n    var infiniteData;\n\n    if (this.parent.enableInfiniteScrolling) {\n      this.isInfiniteFreeze = isFreeze;\n\n      if (this.parent.infiniteScrollSettings.enableCache) {\n        infiniteData = isFreeze ? this.getCurrentBlockInfiniteRecords(true) : this.getCurrentBlockInfiniteRecords();\n      } else {\n        infiniteData = isFreeze ? this.visibleFrozenRows : this.visibleRows;\n      }\n    }\n\n    return infiniteData;\n  };\n\n  ContentRender.prototype.colGroupRefresh = function () {\n    if (this.getColGroup()) {\n      var colGroup = void 0;\n\n      if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && this.parent.contentModule.isXaxis()) {\n        colGroup = this.parent.getMovableVirtualHeader().querySelector('colgroup').cloneNode(true);\n      } else {\n        colGroup = isBlazor() ? this.parent.getHeaderTable().querySelector('colgroup').cloneNode(true) : this.parent.element.querySelector('.e-gridheader').querySelector('colgroup').cloneNode(true);\n      }\n\n      this.getTable().replaceChild(colGroup, this.getColGroup());\n      this.setColGroup(colGroup);\n    }\n  };\n\n  ContentRender.prototype.initializeContentDrop = function () {\n    var gObj = this.parent;\n    var drop = new Droppable(gObj.getContent(), {\n      accept: '.e-dragclone',\n      drop: this.drop\n    });\n  };\n\n  ContentRender.prototype.canSkip = function (column, row, index) {\n    /**\n     * Skip the toggle visiblity operation when one of the following success\n     * 1. Grid has empty records\n     * 2. column visible property is unchanged\n     * 3. cell`s isVisible property is same as column`s visible property.\n     */\n    return isNullOrUndefined(row) || //(1)\n    isNullOrUndefined(column.visible) || //(2)    \n    row.cells[index].visible === column.visible; //(3)\n  };\n\n  ContentRender.prototype.getModelGenerator = function () {\n    return this.generator = this.parent.allowGrouping ? new GroupModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  };\n\n  ContentRender.prototype.renderEmpty = function (tbody) {\n    if (isBlazor() && !this.parent.isJsComponent && this.parent.frozenRows) {\n      return;\n    }\n\n    this.getTable().appendChild(tbody);\n\n    if (this.parent.frozenRows) {\n      this.parent.getHeaderContent().querySelector('tbody').innerHTML = '';\n    }\n  };\n\n  ContentRender.prototype.setSelection = function (uid, set, clearAll) {\n    if (this.parent.getFrozenColumns()) {\n      var rows = this.getMovableRows().filter(function (row) {\n        return clearAll || uid === row.uid;\n      });\n\n      for (var i = 0; i < rows.length; i++) {\n        rows[i].isSelected = set;\n      }\n    }\n\n    var row = this.getRows().filter(function (row) {\n      return clearAll || uid === row.uid;\n    });\n\n    for (var j = 0; j < row.length; j++) {\n      row[j].isSelected = set;\n      var cells = row[j].cells;\n\n      for (var k = 0; k < cells.length; k++) {\n        cells[k].isSelected = set;\n      }\n    }\n  };\n\n  ContentRender.prototype.getRowByIndex = function (index) {\n    index = this.getInfiniteRowIndex(index);\n    return this.parent.getDataRows()[index];\n  };\n\n  ContentRender.prototype.getInfiniteRowIndex = function (index) {\n    if (this.parent.infiniteScrollSettings.enableCache) {\n      var fRows = this.parent.frozenRows;\n      var idx = fRows > index ? 0 : fRows;\n      var firstRowIndex = parseInt(this.parent.getRows()[idx].getAttribute('aria-rowindex'), 10);\n      index = fRows > index ? index : index - firstRowIndex + fRows;\n    }\n\n    return index;\n  };\n\n  ContentRender.prototype.getVirtualRowIndex = function (index) {\n    return index;\n  };\n\n  ContentRender.prototype.getMovableRowByIndex = function (index) {\n    index = this.getInfiniteRowIndex(index);\n    return this.parent.getMovableDataRows()[index];\n  };\n\n  ContentRender.prototype.enableAfterRender = function (e) {\n    if (e.module === 'group' && e.enable) {\n      this.generator = this.getModelGenerator();\n    }\n  };\n\n  ContentRender.prototype.setRowObjects = function (rows) {\n    this.rows = rows;\n  };\n\n  return ContentRender;\n}();\n\nexport { ContentRender };","map":null,"metadata":{},"sourceType":"module"}