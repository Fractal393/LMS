{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * PdfGrid.ts class for EJ2-PDF\n */\n\n\nimport { PdfGridColumnCollection } from './pdf-grid-column';\nimport { PdfGridRowCollection, PdfGridHeaderCollection } from './pdf-grid-row';\nimport { RectangleF, SizeF, PointF } from './../../drawing/pdf-drawing';\nimport { PdfLayoutElement } from './../../graphics/figures/layout-element';\nimport { PdfLayoutFormat } from './../../graphics/figures/base/element-layouter';\nimport { PdfGridStyle } from './styles/style';\nimport { PdfBorders } from './styles/pdf-borders';\nimport { PdfGridLayouter } from './../../structured-elements/grid/layout/grid-layouter';\n\nvar PdfGrid =\n/** @class */\nfunction (_super) {\n  __extends(PdfGrid, _super); //constructor\n\n  /**\n   * Initialize a new instance for `PdfGrid` class.\n   * @private\n   */\n\n\n  function PdfGrid() {\n    var _this = _super.call(this) || this;\n    /**\n     * @hidden\n     * @private\n     */\n\n\n    _this.gridSize = new SizeF(0, 0);\n    /**\n     * Check the child grid is ' split or not'\n     */\n\n    _this.isGridSplit = false;\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.isRearranged = false;\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.pageBounds = new RectangleF();\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.listOfNavigatePages = [];\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.parentCellIndex = 0;\n    _this.tempWidth = 0;\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.breakRow = true;\n    _this.splitChildRowIndex = -1;\n    /**\n     * The event raised on `begin cell lay outing`.\n     * @event\n     * @private\n     */\n    //public beginPageLayout : Function;\n\n    /**\n     * The event raised on `end cell lay outing`.\n     * @event\n     * @private\n     */\n    //public endPageLayout : Function;\n\n    _this.hasRowSpanSpan = false;\n    _this.hasColumnSpan = false;\n    _this.isSingleGrid = true;\n    return _this;\n  }\n\n  Object.defineProperty(PdfGrid.prototype, \"raiseBeginCellDraw\", {\n    //Properties\n\n    /**\n     * Gets a value indicating whether the `start cell layout event` should be raised.\n     * @private\n     */\n    get: function () {\n      return typeof this.beginCellDraw !== 'undefined' && typeof this.beginCellDraw !== null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"raiseEndCellDraw\", {\n    /**\n     * Gets a value indicating whether the `end cell layout event` should be raised.\n     * @private\n     */\n    get: function () {\n      return typeof this.endCellDraw !== 'undefined' && typeof this.endCellDraw !== null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"repeatHeader\", {\n    /**\n     * Gets or sets a value indicating whether to `repeat header`.\n     * @private\n     */\n    get: function () {\n      if (this.bRepeatHeader == null || typeof this.bRepeatHeader === 'undefined') {\n        this.bRepeatHeader = false;\n      }\n\n      return this.bRepeatHeader;\n    },\n    set: function (value) {\n      this.bRepeatHeader = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"allowRowBreakAcrossPages\", {\n    /**\n     * Gets or sets a value indicating whether to split or cut rows that `overflow a page`.\n     * @private\n     */\n    get: function () {\n      return this.breakRow;\n    },\n    set: function (value) {\n      this.breakRow = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"columns\", {\n    /**\n     * Gets the `column` collection of the PdfGrid.[Read-Only]\n     * @private\n     */\n    get: function () {\n      if (this.gridColumns == null || typeof this.gridColumns === 'undefined') {\n        this.gridColumns = new PdfGridColumnCollection(this);\n      }\n\n      return this.gridColumns;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"rows\", {\n    /**\n     * Gets the `row` collection from the PdfGrid.[Read-Only]\n     * @private\n     */\n    get: function () {\n      if (this.gridRows == null) {\n        this.gridRows = new PdfGridRowCollection(this);\n      }\n\n      return this.gridRows;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"headers\", {\n    /**\n     * Gets the `headers` collection from the PdfGrid.[Read-Only]\n     * @private\n     */\n    get: function () {\n      if (this.gridHeaders == null || typeof this.gridHeaders === 'undefined') {\n        this.gridHeaders = new PdfGridHeaderCollection(this);\n      }\n\n      return this.gridHeaders;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"initialWidth\", {\n    /**\n     * Indicating `initial width` of the page.\n     * @private\n     */\n    get: function () {\n      return this.gridInitialWidth;\n    },\n    set: function (value) {\n      this.gridInitialWidth = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"style\", {\n    /**\n     * Gets or sets the `grid style`.\n     * @private\n     */\n    get: function () {\n      if (this.gridStyle == null) {\n        this.gridStyle = new PdfGridStyle();\n      }\n\n      return this.gridStyle;\n    },\n    set: function (value) {\n      if (this.gridStyle == null) {\n        this.gridStyle = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"isPageWidth\", {\n    /**\n     * Gets a value indicating whether the grid column width is considered to be `page width`.\n     * @private\n     */\n    get: function () {\n      return this.ispageWidth;\n    },\n    set: function (value) {\n      this.ispageWidth = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"isChildGrid\", {\n    /**\n     * Gets or set if grid `is nested grid`.\n     * @private\n     */\n    get: function () {\n      return this.ischildGrid;\n    },\n    set: function (value) {\n      this.ischildGrid = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"size\", {\n    /**\n     * Gets or set if grid ' is split or not'\n     * @public\n     */\n    // public get isGridSplit() : boolean {\n    //     return this.isgridSplit;\n    // }\n    // public set isGridSplit(value : boolean) {\n    //     this.isgridSplit = value;\n    // }public get isGridSplit() : boolean {\n    //     return this.isgridSplit;\n    // }\n    // public set isGridSplit(value : boolean) {\n    //     this.isgridSplit = value;\n    // }\n\n    /**\n     * Gets the `size`.\n     * @private\n     */\n    get: function () {\n      if ((this.gridSize.width === 0 || typeof this.gridSize.width === 'undefined') && this.gridSize.height === 0) {\n        this.gridSize = this.measure();\n      }\n\n      return this.gridSize; // } else {\n      //     return this.gridSize;\n      // }\n    },\n    set: function (value) {\n      this.gridSize = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"ParentCell\", {\n    get: function () {\n      return this.parentCell;\n    },\n    set: function (value) {\n      this.parentCell = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGrid.prototype, \"LayoutFormat\", {\n    get: function () {\n      return this.layoutFormat;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  PdfGrid.prototype.draw = function (arg1, arg2, arg3, arg4) {\n    if (arg2 instanceof PointF && typeof arg2.width === 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(arg1, arg2.x, arg2.y);\n    } else if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {\n      return this.drawHelper(arg1, arg2, arg3, null);\n    } else if (arg2 instanceof RectangleF && typeof arg2.width !== 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(arg1, arg2, null);\n    } else if (arg2 instanceof PointF && typeof arg2.width === 'undefined' && arg3 instanceof PdfLayoutFormat) {\n      return this.drawHelper(arg1, arg2.x, arg2.y, arg3);\n    } else if (typeof arg2 === 'number' && typeof arg3 === 'number' && (arg4 instanceof PdfLayoutFormat || arg4 == null)) {\n      var width = arg1.graphics.clientSize.width - arg2;\n      var layoutRectangle = new RectangleF(arg2, arg3, width, 0);\n      return this.drawHelper(arg1, layoutRectangle, arg4);\n    } else if (arg2 instanceof RectangleF && typeof arg2.width !== 'undefined' && typeof arg3 === 'boolean') {\n      return this.drawHelper(arg1, arg2, null);\n    } else {\n      return this.drawHelper(arg1, arg2, arg3);\n    }\n  };\n  /**\n   * `measures` this instance.\n   * @private\n   */\n\n\n  PdfGrid.prototype.measure = function () {\n    var height = 0;\n    var width = this.columns.width;\n\n    for (var i = 0; i < this.headers.count; i++) {\n      var row = this.headers.getHeader(i);\n      height += row.height;\n    }\n\n    for (var i = 0; i < this.rows.count; i++) {\n      var row = this.rows.getRow(i);\n      height += row.height;\n    }\n\n    return new SizeF(width, height);\n  };\n\n  PdfGrid.prototype.onBeginCellDraw = function (args) {\n    if (this.raiseBeginCellDraw) {\n      this.beginCellDraw(this, args);\n    }\n  };\n\n  PdfGrid.prototype.onEndCellDraw = function (args) {\n    if (this.raiseEndCellDraw) {\n      this.endCellDraw(this, args);\n    }\n  };\n  /**\n   * `Layouts` the specified graphics.\n   * @private\n   */\n\n\n  PdfGrid.prototype.layout = function (param) {\n    if (this.rows.count !== 0) {\n      var currentRow = this.rows.getRow(0).cells.getCell(0).style;\n\n      if (currentRow.borders != null && (currentRow.borders.left != null && currentRow.borders.left.width !== 1 || currentRow.borders.top != null && currentRow.borders.top.width !== 1)) {\n        var x = currentRow.borders.left.width / 2;\n        var y = currentRow.borders.top.width / 2;\n\n        if (param.bounds.x === PdfBorders.default.right.width / 2 && param.bounds.y === PdfBorders.default.right.width / 2) {\n          var newBound = new RectangleF(x, y, this.gridSize.width, this.gridSize.height);\n          param.bounds = newBound;\n        }\n      }\n    }\n\n    this.setSpan();\n    this.checkSpan();\n    this.layoutFormat = param.format;\n    this.gridLocation = param.bounds;\n    var layouter = new PdfGridLayouter(this);\n    var result = layouter.Layouter(param);\n    return result;\n  };\n\n  PdfGrid.prototype.setSpan = function () {\n    var colSpan = 1;\n    var rowSpan = 1;\n    var currentCellIndex = 0;\n    var currentRowIndex = 0;\n    var maxSpan = 0;\n    var rowCount = this.headers.count;\n\n    for (var i = 0; i < rowCount; i++) {\n      var row = this.headers.getHeader(i);\n      maxSpan = 0;\n      var colCount = row.cells.count;\n\n      for (var j = 0; j < colCount; j++) {\n        var cell = row.cells.getCell(j);\n        maxSpan = Math.max(maxSpan, cell.rowSpan); //Skip setting span map for already coverted rows/columns.\n\n        if (!cell.isCellMergeContinue && !cell.isRowMergeContinue && (cell.columnSpan > 1 || cell.rowSpan > 1)) {\n          if (cell.columnSpan + j > row.cells.count) {\n            throw new Error('Invalid span specified at row ' + j.toString() + ' column ' + i.toString());\n          }\n\n          if (cell.rowSpan + i > this.headers.count) {\n            throw new Error('Invalid span specified at Header ' + j.toString() + ' column ' + i.toString());\n          } // if (this.rows.count !== 0 && cell.rowSpan + i > this.rows.count) {\n          //     throw new Error('Invalid span specified at row ' + j.toString() + ' column ' + i.toString());\n          // }\n\n\n          if (cell.columnSpan > 1 && cell.rowSpan > 1) {\n            colSpan = cell.columnSpan;\n            rowSpan = cell.rowSpan;\n            currentCellIndex = j;\n            currentRowIndex = i;\n            cell.isCellMergeStart = true;\n            cell.isRowMergeStart = true; //Set Column merges for first row\n\n            while (colSpan > 1) {\n              currentCellIndex++;\n              row.cells.getCell(currentCellIndex).isCellMergeContinue = true;\n              row.cells.getCell(currentCellIndex).isRowMergeContinue = true;\n              row.cells.getCell(currentCellIndex).rowSpan = rowSpan;\n              colSpan--;\n            }\n\n            currentCellIndex = j;\n            colSpan = cell.columnSpan; //Set Row Merges and column merges foreach subsequent rows.\n\n            while (rowSpan > 1) {\n              currentRowIndex++;\n              this.headers.getHeader(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;\n              this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;\n              rowSpan--;\n\n              while (colSpan > 1) {\n                currentCellIndex++;\n                this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isCellMergeContinue = true;\n                this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;\n                colSpan--;\n              }\n\n              colSpan = cell.columnSpan;\n              currentCellIndex = j;\n            }\n          } else if (cell.columnSpan > 1 && cell.rowSpan === 1) {\n            colSpan = cell.columnSpan;\n            currentCellIndex = j;\n            cell.isCellMergeStart = true; //Set Column merges.\n\n            while (colSpan > 1) {\n              currentCellIndex++;\n              row.cells.getCell(currentCellIndex).isCellMergeContinue = true;\n              colSpan--;\n            }\n          } else if (cell.columnSpan === 1 && cell.rowSpan > 1) {\n            rowSpan = cell.rowSpan;\n            currentRowIndex = i; //Set row Merges.\n\n            while (rowSpan > 1) {\n              currentRowIndex++;\n              this.headers.getHeader(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;\n              rowSpan--;\n            }\n          }\n        }\n      }\n\n      row.maximumRowSpan = maxSpan;\n    }\n  };\n\n  PdfGrid.prototype.checkSpan = function () {\n    var cellcolSpan;\n    var cellrowSpan = 1;\n    var cellmaxSpan = 0;\n    var currentCellIndex;\n    var currentRowIndex = 0;\n    cellcolSpan = cellrowSpan = 1;\n    currentCellIndex = currentRowIndex = 0;\n\n    if (this.hasRowSpanSpan || this.hasColumnSpan) {\n      var rowCount = this.rows.count;\n\n      for (var i = 0; i < rowCount; i++) {\n        var row = this.rows.getRow(i);\n        cellmaxSpan = 0;\n        var colCount = row.cells.count;\n\n        for (var j = 0; j < colCount; j++) {\n          var cell = row.cells.getCell(j);\n          cellmaxSpan = Math.max(cellmaxSpan, cell.rowSpan); //Skip setting span map for already coverted rows/columns.\n\n          if (!cell.isCellMergeContinue && !cell.isRowMergeContinue && (cell.columnSpan > 1 || cell.rowSpan > 1)) {\n            if (cell.columnSpan + j > row.cells.count) {\n              throw new Error('Invalid span specified at row  ' + j.toString() + ' column ' + i.toString());\n            }\n\n            if (cell.rowSpan + i > this.rows.count) {\n              throw new Error('Invalid span specified at row  ' + j.toString() + ' column ' + i.toString());\n            }\n\n            if (cell.columnSpan > 1 && cell.rowSpan > 1) {\n              cellcolSpan = cell.columnSpan;\n              cellrowSpan = cell.rowSpan;\n              currentCellIndex = j;\n              currentRowIndex = i;\n              cell.isCellMergeStart = true;\n              cell.isRowMergeStart = true; //Set Column merges for first row\n\n              while (cellcolSpan > 1) {\n                currentCellIndex++;\n                row.cells.getCell(currentCellIndex).isCellMergeContinue = true;\n                row.cells.getCell(currentCellIndex).isRowMergeContinue = true;\n                cellcolSpan--;\n              }\n\n              currentCellIndex = j;\n              cellcolSpan = cell.columnSpan; //Set Row Merges and column merges foreach subsequent rows.\n\n              while (cellrowSpan > 1) {\n                currentRowIndex++;\n                this.rows.getRow(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;\n                this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;\n                cellrowSpan--;\n\n                while (cellcolSpan > 1) {\n                  currentCellIndex++;\n                  this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isCellMergeContinue = true;\n                  this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;\n                  cellcolSpan--;\n                }\n\n                cellcolSpan = cell.columnSpan;\n                currentCellIndex = j;\n              }\n            } else if (cell.columnSpan > 1 && cell.rowSpan === 1) {\n              cellcolSpan = cell.columnSpan;\n              currentCellIndex = j;\n              cell.isCellMergeStart = true; //Set Column merges.\n\n              while (cellcolSpan > 1) {\n                currentCellIndex++;\n                row.cells.getCell(currentCellIndex).isCellMergeContinue = true;\n                cellcolSpan--;\n              }\n            } else if (cell.columnSpan === 1 && cell.rowSpan > 1) {\n              cellrowSpan = cell.rowSpan;\n              currentRowIndex = i; //Set row Merges.\n\n              while (cellrowSpan > 1) {\n                currentRowIndex++;\n                this.rows.getRow(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;\n                cellrowSpan--;\n              }\n            }\n          }\n        }\n\n        row.maximumRowSpan = cellmaxSpan;\n      }\n    }\n  };\n\n  PdfGrid.prototype.measureColumnsWidth = function (bounds) {\n    if (typeof bounds !== 'undefined') {\n      this.isPageWidth = false;\n      var widths = this.columns.getDefaultWidths(bounds.width - bounds.x); //let tempWidth : number = this.columns.getColumn(0).width;\n\n      for (var i = 0, count = this.columns.count; i < count; i++) {\n        // if (this.columns.getColumn(i).width < 0)\n        //     this.columns.getColumn(i).columnWidth = widths[i];\n        // else if (this.columns.getColumn(i).width > 0 && !this.columns.getColumn(i).isCustomWidth && widths[i]>0 && this.isComplete)\n        this.columns.getColumn(i).columnWidth = widths[i];\n        this.tempWidth = widths[i];\n      }\n\n      if (this.ParentCell != null && this.style.allowHorizontalOverflow == false && this.ParentCell.row.grid.style.allowHorizontalOverflow == false) {\n        var padding = 0;\n        var columnWidth = 0;\n        var columnCount = this.columns.count;\n        var childGridColumnWidth = 0;\n\n        if (this.ParentCell.style.cellPadding != null || typeof this.ParentCell.style.cellPadding !== 'undefined') {\n          if (typeof this.ParentCell.style.cellPadding.left != 'undefined' && this.ParentCell.style.cellPadding.hasLeftPad) {\n            padding += this.ParentCell.style.cellPadding.left;\n          }\n\n          if (typeof this.ParentCell.style.cellPadding.right != 'undefined' && this.ParentCell.style.cellPadding.hasRightPad) {\n            padding += this.ParentCell.style.cellPadding.right;\n          }\n        }\n\n        for (var i = 0; i < this.ParentCell.columnSpan; i++) {\n          columnWidth += this.ParentCell.row.grid.columns.getColumn(this.parentCellIndex + i).width;\n        }\n\n        for (var j = 0; j < this.columns.count; j++) {\n          if (this.gridColumns.getColumn(j).width > 0 && this.gridColumns.getColumn(j).isCustomWidth) {\n            columnWidth -= this.gridColumns.getColumn(j).width;\n            columnCount--;\n          }\n        }\n\n        if (this.ParentCell.row.grid.style.cellPadding != null || typeof this.ParentCell.row.grid.style.cellPadding != 'undefined') {\n          if (typeof this.ParentCell.row.grid.style.cellPadding.top != 'undefined' && this.ParentCell.row.grid.style.cellPadding.hasTopPad) {\n            padding += this.ParentCell.row.grid.style.cellPadding.top;\n          }\n\n          if (typeof this.ParentCell.row.grid.style.cellPadding.bottom != 'undefined' && this.ParentCell.row.grid.style.cellPadding.hasBottomPad) {\n            padding += this.ParentCell.row.grid.style.cellPadding.bottom;\n          }\n        }\n\n        if (this.ParentCell.row.grid.style.cellSpacing != 0) {\n          columnWidth -= this.ParentCell.row.grid.style.cellSpacing * 2;\n        }\n\n        if (columnWidth > padding) {\n          childGridColumnWidth = (columnWidth - padding) / columnCount;\n          this.tempWidth = childGridColumnWidth;\n\n          if (this.ParentCell != null) {\n            for (var j = 0; j < this.columns.count; j++) {\n              if (!this.columns.getColumn(j).isCustomWidth) this.columns.getColumn(j).columnWidth = childGridColumnWidth;\n            }\n          }\n        }\n      } // if (this.ParentCell != null && this.ParentCell.row.width > 0)\n      // {\n      //     if (this.isChildGrid && this.gridSize.width > this.ParentCell.row.width)\n      //     {\n      //         widths = this.columns.getDefaultWidths(bounds.width);\n      //         for (let i : number = 0; i < this.columns.count; i++)\n      //         {\n      //             this.columns.getColumn(i).width = widths[i];\n      //         }\n      //     }\n      // }\n\n    } else {\n      var widths = [this.columns.count];\n\n      for (var n = 0; n < this.columns.count; n++) {\n        widths[n] = 0;\n      }\n\n      var cellWidth = 0;\n      var cellWidths = 0;\n\n      if (typeof this.isChildGrid === 'undefined' && typeof this.gridLocation !== 'undefined' || this.isChildGrid === null && typeof this.gridLocation !== 'undefined') {\n        this.initialWidth = this.gridLocation.width;\n      }\n\n      if (this.headers.count > 0) {\n        var colCount_1 = this.headers.getHeader(0).cells.count;\n        var rowCount = this.headers.count;\n\n        for (var i = 0; i < colCount_1; i++) {\n          cellWidth = 0;\n\n          for (var j = 0; j < rowCount; j++) {\n            var rowWidth = Math.min(this.initialWidth, this.headers.getHeader(j).cells.getCell(i).width);\n            cellWidth = Math.max(cellWidth, rowWidth);\n          }\n\n          widths[i] = cellWidth;\n        }\n      } // else {\n      //     let colCount : number = this.rows.getRow(0).cells.count;\n      //     let rowCount : number = this.rows.count;\n      //     for (let i : number = 0; i < colCount; i++) {\n      //         cellWidth = 0;\n      //         for (let j : number = 0; j < rowCount; j++) {\n      //             let rowWidth : number = Math.min(this.initialWidth, this.rows.getRow(j).cells.getCell(i).width);\n      //             cellWidth = Math.max(cellWidth, rowWidth);\n      //         }\n      //         widths[i] = cellWidth;\n      //     }\n      // }\n\n\n      cellWidth = 0;\n\n      for (var i = 0, colCount_2 = this.columns.count; i < colCount_2; i++) {\n        for (var j = 0, rowCount = this.rows.count; j < rowCount; j++) {\n          if (this.rows.getRow(j).cells.getCell(i).columnSpan == 1 && !this.rows.getRow(j).cells.getCell(i).isCellMergeContinue || this.rows.getRow(j).cells.getCell(i).value != null) {\n            if (this.rows.getRow(j).cells.getCell(i).value != null && !this.rows.getRow(j).grid.style.allowHorizontalOverflow) {\n              var value = this.rows.getRow(j).grid.style.cellPadding.right + this.rows.getRow(j).grid.style.cellPadding.left + this.rows.getRow(j).cells.getCell(i).style.borders.left.width / 2; //  if (this.initialWidth != 0 )\n              //         (this.rows.getRow(j).cells.getCell(i).value as PdfGrid).initialWidth = this.initialWidth - value;\n            }\n\n            var rowWidth = 0;\n            rowWidth = this.initialWidth > 0.0 ? Math.min(this.initialWidth, this.rows.getRow(j).cells.getCell(i).width) : this.rows.getRow(j).cells.getCell(i).width; // let internalWidth : number = this.rows.getRow(j).cells.getCell(i).width;\n            // internalWidth += this.rows.getRow(j).cells.getCell(i).style.borders.left.width;\n            // internalWidth += this.rows.getRow(j).cells.getCell(i).style.borders.right.width;\n            // let internalHeight : number = this.rows.getRow(j).cells.getCell(i).height;\n            // internalHeight += (this.rows.getRow(j).cells.getCell(i).style.borders.top.width);\n            // internalHeight += (this.rows.getRow(j).cells.getCell(i).style.borders.bottom.width);\n            // let isCorrectWidth : boolean = (internalWidth + this.gridLocation.x) > this.currentGraphics.clientSize.width;\n            // let isCorrectHeight : boolean = (internalHeight + this.gridLocation.y) > this.currentGraphics.clientSize.height;\n            // if (isCorrectWidth || isCorrectHeight) {\n            //     throw Error('Image size exceeds client size of the page. Can not insert this image');\n            // }\n            // rowWidth = Math.min(this.initialWidth, this.rows.getRow(j).cells.getCell(i).width);\n\n            cellWidth = Math.max(widths[i], Math.max(cellWidth, rowWidth));\n            cellWidth = Math.max(this.columns.getColumn(i).width, cellWidth);\n          }\n        }\n\n        if (this.rows.count != 0) widths[i] = cellWidth;\n        cellWidth = 0;\n      }\n\n      for (var i = 0, RowCount = this.rows.count; i < RowCount; i++) {\n        for (var j = 0, ColCount = this.columns.count; j < ColCount; j++) {\n          if (this.rows.getRow(i).cells.getCell(j).columnSpan > 1) {\n            var total = widths[j];\n\n            for (var k = 1; k < this.rows.getRow(i).cells.getCell(j).columnSpan; k++) {\n              total += widths[j + k];\n            } // if (this.rows.getRow(i).cells.getCell(j).width > total)\n            // {\n            //     let extendedWidth : number = this.rows.getRow(i).cells.getCell(j).width - total;\n            //     extendedWidth = extendedWidth / this.rows.getRow(i).cells.getCell(j).columnSpan;\n            //     for (let k : number = j; k < j + this.rows.getRow(i).cells.getCell(j).columnSpan; k++)\n            //         widths[k] += extendedWidth;\n            // }\n\n          }\n        }\n      } // if (this.isChildGrid && this.initialWidth != 0)\n      // {\n      //     widths = this.columns.getDefaultWidths(this.initialWidth);\n      // }\n\n\n      for (var i = 0, count = this.columns.count; i < count; i++) {\n        if (this.columns.getColumn(i).width <= 0) this.columns.getColumn(i).columnWidth = widths[i];else if (this.columns.getColumn(i).width > 0 && !this.columns.getColumn(i).isCustomWidth) this.columns.getColumn(i).columnWidth = widths[i];\n      }\n\n      var padding = 0;\n      var colWidth = 0;\n      var colCount = this.columns.count;\n      var childGridColWidth = 0;\n      colWidth = this.tempWidth;\n\n      for (var j = 0; j < this.columns.count; j++) {\n        if (this.gridColumns.getColumn(j).width > 0 && this.gridColumns.getColumn(j).isCustomWidth) {\n          colWidth -= this.gridColumns.getColumn(j).width;\n          colCount--;\n        }\n      } // if (this.style.cellSpacing != 0){\n      //     colWidth -= this.style.cellSpacing * 2;\n      // }\n\n\n      if (colWidth > 0) {\n        if (this.ParentCell.row.grid.style.cellSpacing != 0) {\n          colWidth -= this.ParentCell.row.grid.style.cellSpacing * 2;\n        }\n      }\n\n      if (colWidth > padding) {\n        childGridColWidth = colWidth / colCount;\n\n        if (this.ParentCell != null) {\n          for (var j = 0; j < this.columns.count; j++) {\n            if (!this.columns.getColumn(j).isCustomWidth) this.columns.getColumn(j).columnWidth = childGridColWidth;\n          }\n        }\n      }\n    }\n  };\n\n  return PdfGrid;\n}(PdfLayoutElement);\n\nexport { PdfGrid };","map":null,"metadata":{},"sourceType":"module"}