{"ast":null,"code":"import { extend, isNullOrUndefined, isBlazor } from '@syncfusion/ej2-base';\nimport { closest as closestElement, removeClass, classList, remove } from '@syncfusion/ej2-base';\nimport { getElementIndex, inArray, parentsUntil, getPosition, isActionPrevent } from '../base/util';\nimport * as events from '../base/constant';\n/**\n *\n * The `Reorder` module is used for reordering columns.\n */\n\nvar Reorder =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the Grid reorder module\n   * @hidden\n   */\n  function Reorder(parent) {\n    this.parent = parent;\n\n    if (this.parent.isDestroyed) {\n      return;\n    }\n\n    this.parent.on(events.headerDrop, this.headerDrop, this);\n    this.parent.on(events.uiUpdate, this.enableAfterRender, this);\n    this.parent.on(events.reorderComplete, this.onActionComplete, this);\n    this.parent.on(events.columnDrag, this.drag, this);\n    this.parent.on(events.columnDragStart, this.dragStart, this);\n    this.parent.on(events.columnDragStop, this.dragStop, this);\n    this.parent.on(events.headerDrop, this.headerDrop, this);\n    this.parent.on(events.headerRefreshed, this.createReorderElement, this);\n    this.parent.on(events.keyPressed, this.keyPressHandler, this);\n  }\n\n  Reorder.prototype.chkDropPosition = function (srcElem, destElem) {\n    var col = this.parent.getColumnByUid(destElem.firstElementChild.getAttribute('e-mappinguid'));\n    var bool = col ? !col.lockColumn : true;\n    return (srcElem.parentElement.isEqualNode(destElem.parentElement) || this.parent.enableColumnVirtualization || this.parent.getFrozenColumns() && Array.prototype.indexOf.call(closestElement(srcElem, 'thead').children, srcElem.parentElement) === Array.prototype.indexOf.call(closestElement(destElem, 'thead').children, destElem.parentElement)) && this.targetParentContainerIndex(srcElem, destElem) > -1 && bool;\n  };\n\n  Reorder.prototype.chkDropAllCols = function (srcElem, destElem) {\n    var isFound;\n    var headers = this.getHeaderCells();\n    var header;\n\n    while (!isFound && headers.length > 0) {\n      header = headers.pop();\n      isFound = srcElem !== header && this.targetParentContainerIndex(srcElem, destElem) > -1;\n    }\n\n    return isFound;\n  };\n\n  Reorder.prototype.findColParent = function (col, cols, parent) {\n    parent = parent;\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      if (col === cols[i]) {\n        return true;\n      } else if (cols[i].columns) {\n        var cnt = parent.length;\n        parent.push(cols[i]);\n\n        if (!this.findColParent(col, cols[i].columns, parent)) {\n          parent.splice(cnt, parent.length - cnt);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Reorder.prototype.getColumnsModel = function (cols) {\n    var columnModel = [];\n    var subCols = [];\n\n    for (var i = 0, len = cols.length; i < len; i++) {\n      columnModel.push(cols[i]);\n\n      if (cols[i].columns) {\n        subCols = subCols.concat(cols[i].columns);\n      }\n    }\n\n    if (subCols.length) {\n      columnModel = columnModel.concat(this.getColumnsModel(subCols));\n    }\n\n    return columnModel;\n  };\n\n  Reorder.prototype.headerDrop = function (e) {\n    var gObj = this.parent;\n    var dropElement = this.element.querySelector('.e-headercelldiv') || this.element.querySelector('.e-stackedheadercelldiv');\n    var uId = dropElement.getAttribute('e-mappinguid');\n    var column = gObj.getColumnByUid(uId);\n\n    if (!closestElement(e.target, 'th') || !isNullOrUndefined(column) && (!column.allowReordering || column.lockColumn)) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        column: column\n      });\n      return;\n    }\n\n    var destElem = closestElement(e.target, '.e-headercell');\n    var destElemDiv = destElem.querySelector('.e-headercelldiv') || destElem.querySelector('.e-stackedheadercelldiv');\n    var destElemUid = destElemDiv.getAttribute('e-mappinguid');\n\n    if (!isNullOrUndefined(destElemUid)) {\n      var destColumn = gObj.getColumnByUid(destElemUid);\n\n      if (isNullOrUndefined(destColumn) || !destColumn.allowReordering || destColumn.lockColumn) {\n        this.parent.log('action_disabled_column', {\n          moduleName: this.getModuleName(),\n          column: column,\n          destColumn: destColumn\n        });\n        return;\n      }\n    }\n\n    if (destElem && !(!this.chkDropPosition(this.element, destElem) || !this.chkDropAllCols(this.element, destElem))) {\n      if (this.parent.enableColumnVirtualization) {\n        var columns = this.parent.columns;\n        var sourceUid_1 = this.element.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n        var col = this.parent.columns.filter(function (col) {\n          return col.uid === sourceUid_1;\n        });\n        var colMatchIndex_1 = null;\n        var column_1 = col[0];\n        var destUid_1 = destElem.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');\n        var bool = columns.some(function (col, index) {\n          if (col.uid === destUid_1) {\n            colMatchIndex_1 = index;\n            return col.uid === destUid_1;\n          }\n\n          return false;\n        });\n\n        if (!isNullOrUndefined(colMatchIndex_1)) {\n          this.moveColumns(colMatchIndex_1, column_1);\n        }\n      } else {\n        var newIndex = this.targetParentContainerIndex(this.element, destElem);\n        var uid = this.element.firstElementChild.getAttribute('e-mappinguid');\n        this.destElement = destElem;\n\n        if (uid) {\n          this.moveColumns(newIndex, this.parent.getColumnByUid(uid));\n        } else {\n          var headers = this.getHeaderCells();\n          var oldIdx = getElementIndex(this.element, headers);\n          var columns = this.getColumnsModel(this.parent.columns);\n          var column_2 = columns[oldIdx];\n          this.moveColumns(newIndex, column_2);\n        }\n      }\n    }\n  };\n\n  Reorder.prototype.isActionPrevent = function (gObj) {\n    return isActionPrevent(gObj);\n  };\n\n  Reorder.prototype.moveColumns = function (destIndex, column, reorderByColumn, preventRefresh) {\n    var gObj = this.parent;\n\n    if (this.isActionPrevent(gObj)) {\n      gObj.notify(events.preventBatch, {\n        instance: this,\n        handler: this.moveColumns,\n        arg1: destIndex,\n        arg2: column\n      });\n      return;\n    }\n\n    var parent = this.getColParent(column, this.parent.columns);\n    var cols = parent ? parent.columns : this.parent.columns;\n    var srcIdx = inArray(column, cols);\n\n    if ((this.parent.getFrozenColumns() && parent || this.parent.lockcolPositionCount) && !reorderByColumn) {\n      for (var i = 0; i < cols.length; i++) {\n        if (cols[i].field === column.field) {\n          srcIdx = i;\n          break;\n        }\n      }\n\n      var col = this.parent.getColumnByUid(this.destElement.firstElementChild.getAttribute('e-mappinguid'));\n\n      if (col) {\n        for (var i = 0; i < cols.length; i++) {\n          if (cols[i].field === col.field) {\n            destIndex = i;\n            break;\n          }\n        }\n      } else {\n        for (var i = 0; i < cols.length; i++) {\n          if (cols[i].headerText === this.destElement.innerText.trim()) {\n            destIndex = i;\n          }\n        }\n      }\n    }\n\n    if (!gObj.allowReordering || srcIdx === destIndex || srcIdx === -1 || destIndex === -1) {\n      return;\n    }\n\n    cols.splice(destIndex, 0, cols.splice(srcIdx, 1)[0]);\n    gObj.getColumns(true);\n    gObj.notify(events.columnPositionChanged, {\n      fromIndex: destIndex,\n      toIndex: srcIdx\n    });\n\n    if (preventRefresh !== false) {\n      gObj.notify(events.modelChanged, {\n        type: events.actionBegin,\n        requestType: 'reorder',\n        fromIndex: destIndex,\n        toIndex: srcIdx,\n        toColumnUid: column.uid\n      });\n    }\n  };\n\n  Reorder.prototype.targetParentContainerIndex = function (srcElem, destElem) {\n    var headers = this.getHeaderCells();\n    var cols = this.parent.columns;\n    var flatColumns = this.getColumnsModel(cols);\n    var parent = this.getColParent(flatColumns[getElementIndex(srcElem, headers)], cols);\n    cols = parent ? parent.columns : cols;\n    return inArray(flatColumns[getElementIndex(destElem, headers)], cols);\n  };\n\n  Reorder.prototype.getHeaderCells = function () {\n    var frozenColumns = this.parent.getFrozenColumns();\n\n    if (frozenColumns || this.parent.lockcolPositionCount) {\n      var fTh = void 0;\n      var mTh = void 0;\n      var fHeaders = [];\n      var fRows = [].slice.call(this.parent.getHeaderTable().querySelectorAll('.e-columnheader'));\n\n      if (frozenColumns) {\n        var mRows = [].slice.call(this.parent.getHeaderContent().querySelector('.e-movableheader').querySelectorAll('.e-columnheader'));\n\n        for (var i = 0; i < fRows.length; i++) {\n          fTh = [].slice.call(fRows[i].getElementsByClassName('e-headercell'));\n          mTh = [].slice.call(mRows[i].getElementsByClassName('e-headercell'));\n          var isAvail = void 0;\n\n          for (var k = 0; k < fTh.length; k++) {\n            for (var j = 0; j < mTh.length; j++) {\n              if (mTh[j].innerText === fTh[k].innerText) {\n                isAvail = true;\n                break;\n              }\n            }\n\n            if (!isAvail) {\n              fHeaders = fHeaders.concat([fTh[k]]);\n            }\n          }\n\n          for (var j = 0; j < mTh.length; j++) {\n            fHeaders.push(mTh[j]);\n          }\n        }\n      } else {\n        for (var i = 0; i < fRows.length; i++) {\n          mTh = [].slice.call(fRows[i].getElementsByClassName('e-headercell'));\n\n          for (var k = 0; k < mTh.length; k++) {\n            var isAvail = void 0;\n\n            for (var j = k + 1; j < mTh.length; j++) {\n              if (mTh[j].innerText === mTh[k].innerText) {\n                isAvail = true;\n                break;\n              }\n            }\n\n            if (!isAvail) {\n              fHeaders = fHeaders.concat([mTh[k]]);\n            }\n          }\n        }\n      }\n\n      return fHeaders;\n    } else {\n      return [].slice.call(this.parent.element.getElementsByClassName('e-headercell'));\n    }\n  };\n\n  Reorder.prototype.getColParent = function (column, columns) {\n    var parents = [];\n    this.findColParent(column, columns, parents);\n    return parents[parents.length - 1];\n  };\n\n  Reorder.prototype.reorderSingleColumn = function (fromFName, toFName) {\n    var fColumn = this.parent.enableColumnVirtualization ? this.parent.columns.filter(function (col) {\n      return col.field === fromFName;\n    })[0] : this.parent.getColumnByField(fromFName);\n    var toColumn = this.parent.enableColumnVirtualization ? this.parent.columns.filter(function (col) {\n      return col.field === toFName;\n    })[0] : this.parent.getColumnByField(toFName);\n\n    if (!isNullOrUndefined(fColumn) && (!fColumn.allowReordering || fColumn.lockColumn) || !isNullOrUndefined(toColumn) && (!toColumn.allowReordering || fColumn.lockColumn)) {\n      this.parent.log('action_disabled_column', {\n        moduleName: this.getModuleName(),\n        column: fColumn,\n        destColumn: toColumn\n      });\n      return;\n    }\n\n    var column = toColumn;\n    var parent = this.getColParent(column, this.parent.columns);\n    var columns = parent ? parent.columns : this.parent.columns;\n    var destIndex = inArray(column, columns);\n\n    if (destIndex > -1) {\n      this.moveColumns(destIndex, fColumn, true);\n    }\n  };\n\n  Reorder.prototype.reorderMultipleColumns = function (fromFNames, toFName) {\n    var toIndex = this.parent.getColumnIndexByField(toFName);\n    var toColumn = this.parent.getColumnByField(toFName);\n\n    if (toIndex < 0 || !isNullOrUndefined(toColumn) && (!toColumn.allowReordering || toColumn.lockColumn)) {\n      return;\n    }\n\n    for (var i = 0; i < fromFNames.length; i++) {\n      var column = this.parent.getColumnByField(fromFNames[i]);\n\n      if (!isNullOrUndefined(column) && (!column.allowReordering || column.lockColumn)) {\n        return;\n      }\n    }\n\n    for (var i = 0; i < fromFNames.length; i++) {\n      var column = this.parent.getColumnByIndex(toIndex);\n      var parent_1 = this.getColParent(column, this.parent.columns);\n      var columns = parent_1 ? parent_1.columns : this.parent.columns;\n      var destIndex = inArray(column, columns);\n\n      if (destIndex > -1) {\n        this.moveColumns(destIndex, this.parent.getColumnByField(fromFNames[i]), true, !(isBlazor() && !this.parent.isJsComponent));\n      }\n\n      if (this.parent.getColumnIndexByField(fromFNames[i + 1]) >= destIndex) {\n        toIndex++; //R to L\n      }\n    }\n\n    if (isBlazor() && !this.parent.isJsComponent) {\n      var cols_1 = this.parent.getColumns();\n      this.parent.notify(events.modelChanged, {\n        fromColumnUid: fromFNames.map(function (name) {\n          return cols_1.filter(function (col) {\n            return col.field === name;\n          })[0].uid;\n        }),\n        toColumnUid: toColumn.uid,\n        isMultipleReorder: true,\n        requestType: 'reorder',\n        type: 'actionBegin'\n      });\n    }\n  };\n\n  Reorder.prototype.moveTargetColumn = function (column, toIndex) {\n    if (toIndex > -1) {\n      this.moveColumns(toIndex, column, true);\n    }\n  };\n\n  Reorder.prototype.reorderSingleColumnByTarget = function (fieldName, toIndex) {\n    var column = this.parent.getColumnByField(fieldName);\n    this.moveTargetColumn(column, toIndex);\n  };\n\n  Reorder.prototype.reorderMultipleColumnByTarget = function (fieldName, toIndex) {\n    for (var i = 0; i < fieldName.length; i++) {\n      this.reorderSingleColumnByTarget(fieldName[i], toIndex);\n    }\n  };\n  /**\n   * Changes the position of the Grid columns by field names.\n   * @param  {string | string[]} fromFName - Defines the origin field names.\n   * @param  {string} toFName - Defines the destination field name.\n   * @return {void}\n   */\n\n\n  Reorder.prototype.reorderColumns = function (fromFName, toFName) {\n    if (typeof fromFName === 'string') {\n      this.reorderSingleColumn(fromFName, toFName);\n      this.fromCol = fromFName;\n    } else {\n      this.reorderMultipleColumns(fromFName, toFName);\n      this.fromCol = fromFName[0];\n    }\n  };\n  /**\n   * Changes the position of the Grid columns by field index.\n   * @param  {number} fromIndex - Defines the origin field index.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @return {void}\n   */\n\n\n  Reorder.prototype.reorderColumnByIndex = function (fromIndex, toIndex) {\n    var column = this.parent.getColumnByIndex(fromIndex);\n    this.moveTargetColumn(column, toIndex);\n  };\n  /**\n   * Changes the position of the Grid columns by field index.\n   * @param  {string | string[]} fieldName - Defines the field name.\n   * @param  {number} toIndex - Defines the destination field index.\n   * @return {void}\n   */\n\n\n  Reorder.prototype.reorderColumnByTargetIndex = function (fieldName, toIndex) {\n    typeof fieldName === 'string' ? this.reorderSingleColumnByTarget(fieldName, toIndex) : this.reorderMultipleColumnByTarget(fieldName, toIndex);\n  };\n\n  Reorder.prototype.enableAfterRender = function (e) {\n    if (e.module === this.getModuleName() && e.enable) {\n      this.createReorderElement();\n    }\n  };\n\n  Reorder.prototype.createReorderElement = function (e) {\n    if (e && e.args.isXaxis) {\n      this.setDisplay('none');\n    }\n\n    var header = this.parent.element.querySelector('.e-headercontent');\n    this.upArrow = header.appendChild(this.parent.createElement('div', {\n      className: 'e-icons e-icon-reorderuparrow e-reorderuparrow',\n      attrs: {\n        style: 'display:none'\n      }\n    }));\n    this.downArrow = header.appendChild(this.parent.createElement('div', {\n      className: 'e-icons e-icon-reorderdownarrow e-reorderdownarrow',\n      attrs: {\n        style: 'display:none'\n      }\n    }));\n  };\n  /**\n   * The function used to trigger onActionComplete\n   * @return {void}\n   * @hidden\n   */\n\n\n  Reorder.prototype.onActionComplete = function (e) {\n    if (isBlazor() && !this.parent.isJsComponent) {\n      e.rows = null;\n    }\n\n    this.parent.trigger(events.actionComplete, extend(e, {\n      type: events.actionComplete\n    }));\n    var target = this.fromCol && this.parent.getColumnHeaderByField(this.fromCol);\n\n    if (target) {\n      this.parent.focusModule.onClick({\n        target: target\n      }, true);\n    }\n  };\n  /**\n   * To destroy the reorder\n   * @return {void}\n   * @hidden\n   */\n\n\n  Reorder.prototype.destroy = function () {\n    var gridElement = this.parent.element;\n\n    if (this.parent.isDestroyed || !gridElement || !gridElement.querySelector('.e-gridheader') && !gridElement.querySelector('.e-gridcontent')) {\n      return;\n    }\n\n    remove(this.upArrow);\n    remove(this.downArrow);\n    this.parent.off(events.headerDrop, this.headerDrop);\n    this.parent.off(events.uiUpdate, this.enableAfterRender);\n    this.parent.off(events.reorderComplete, this.onActionComplete);\n    this.parent.off(events.columnDrag, this.drag);\n    this.parent.off(events.columnDragStart, this.dragStart);\n    this.parent.off(events.columnDragStop, this.dragStop);\n    this.parent.off(events.headerRefreshed, this.createReorderElement);\n    this.parent.off(events.keyPressed, this.keyPressHandler); //call ejdrag and drop destroy\n  };\n\n  Reorder.prototype.keyPressHandler = function (e) {\n    var gObj = this.parent;\n\n    switch (e.action) {\n      case 'ctrlLeftArrow':\n      case 'ctrlRightArrow':\n        var element = gObj.focusModule.currentInfo.element;\n\n        if (element && element.classList.contains('e-headercell')) {\n          var column = gObj.getColumnByUid(element.firstElementChild.getAttribute('e-mappinguid'));\n          var visibleCols = gObj.getVisibleColumns();\n          var index = visibleCols.indexOf(column);\n          var toCol = e.action === 'ctrlLeftArrow' ? visibleCols[index - 1] : visibleCols[index + 1];\n\n          if (toCol && toCol.field && column.field) {\n            this.reorderColumns(column.field, toCol.field);\n          }\n        }\n\n        break;\n    }\n  };\n\n  Reorder.prototype.drag = function (e) {\n    var gObj = this.parent;\n    var target = e.target;\n\n    if (!e.column.allowReordering || e.column.lockColumn) {\n      return;\n    }\n\n    var closest = closestElement(target, '.e-headercell:not(.e-stackedHeaderCell)');\n    var cloneElement = gObj.element.querySelector('.e-cloneproperties');\n    var content = gObj.getFrozenColumns() ? gObj.getMovableVirtualContent() : gObj.getContent().firstElementChild;\n    var isLeft = this.x > getPosition(e.event).x + content.scrollLeft;\n    removeClass(gObj.getHeaderTable().querySelectorAll('.e-reorderindicate'), ['e-reorderindicate']);\n    this.setDisplay('none');\n    this.stopTimer();\n    classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);\n    this.updateScrollPostion(e.event);\n\n    if (closest && !closest.isEqualNode(this.element)) {\n      target = closest; //consider stacked, detail header cell \n\n      if (!(!this.chkDropPosition(this.element, target) || !this.chkDropAllCols(this.element, target))) {\n        this.updateArrowPosition(target, isLeft);\n        classList(target, ['e-allowDrop', 'e-reorderindicate'], []);\n      } else if (!(gObj.allowGrouping && parentsUntil(e.target, 'e-groupdroparea'))) {\n        classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);\n      }\n    }\n\n    gObj.trigger(events.columnDrag, {\n      target: target,\n      draggableType: 'headercell',\n      column: e.column\n    });\n  };\n\n  Reorder.prototype.updateScrollPostion = function (e) {\n    var _this = this;\n\n    var frzCols = this.parent.getFrozenColumns();\n    var x = getPosition(e).x;\n    var cliRect = this.parent.element.getBoundingClientRect();\n    var cliRectBaseLeft = frzCols ? this.parent.element.querySelector('.e-movableheader').getBoundingClientRect().left : cliRect.left;\n    var cliRectBaseRight = cliRect.right;\n    var scrollElem = frzCols ? this.parent.getContent().querySelector('.e-movablecontent') : this.parent.getContent().firstElementChild;\n\n    if (x > cliRectBaseLeft && x < cliRectBaseLeft + 35) {\n      this.timer = window.setInterval(function () {\n        _this.setScrollLeft(scrollElem, true);\n      }, 50);\n    } else if (x < cliRectBaseRight && x > cliRectBaseRight - 35) {\n      this.timer = window.setInterval(function () {\n        _this.setScrollLeft(scrollElem, false);\n      }, 50);\n    }\n  };\n\n  Reorder.prototype.setScrollLeft = function (scrollElem, isLeft) {\n    var scrollLeft = scrollElem.scrollLeft;\n    scrollElem.scrollLeft = scrollElem.scrollLeft + (isLeft ? -5 : 5);\n\n    if (scrollLeft !== scrollElem.scrollLeft) {\n      this.setDisplay('none');\n    }\n  };\n\n  Reorder.prototype.stopTimer = function () {\n    window.clearInterval(this.timer);\n  };\n\n  Reorder.prototype.updateArrowPosition = function (target, isLeft) {\n    var cliRect = target.getBoundingClientRect();\n    var cliRectBase = this.parent.element.getBoundingClientRect();\n\n    if (isLeft && cliRect.left < cliRectBase.left || !isLeft && cliRect.right > cliRectBase.right) {\n      return;\n    }\n\n    if (this.parent.getFrozenColumns() && target.classList.contains('e-headercell')) {\n      var col = this.parent.getColumnByUid(target.firstElementChild.getAttribute('e-mappinguid'));\n      var fhdrWidth = Math.round(this.parent.getFrozenVirtualHeader().getBoundingClientRect().right);\n      var mhdrRight = Math.round(this.parent.getMovableVirtualHeader().getBoundingClientRect().right);\n\n      if (col && this.parent.getNormalizedColumnIndex(col.uid) >= this.parent.getFrozenColumns() && (isLeft && Math.round(cliRect.left) < fhdrWidth || !isLeft && mhdrRight < cliRect.right)) {\n        return;\n      }\n    }\n\n    this.upArrow.style.top = cliRect.top + cliRect.height - cliRectBase.top + 'px';\n    this.downArrow.style.top = cliRect.top - cliRectBase.top - 4 + 'px';\n    this.upArrow.style.left = this.downArrow.style.left = (isLeft ? cliRect.left : cliRect.right) - cliRectBase.left - 4 + 'px';\n    this.setDisplay('');\n  };\n\n  Reorder.prototype.dragStart = function (e) {\n    var gObj = this.parent;\n    var target = e.target;\n    this.element = target.classList.contains('e-headercell') ? target : parentsUntil(target, 'e-headercell');\n\n    if (!e.column.allowReordering || e.column.lockColumn) {\n      return;\n    }\n\n    var content = gObj.getFrozenColumns() ? gObj.getMovableVirtualContent() : gObj.getContent().firstElementChild;\n    this.x = getPosition(e.event).x + content.scrollLeft;\n    gObj.trigger(events.columnDragStart, {\n      target: target,\n      draggableType: 'headercell',\n      column: e.column\n    });\n  };\n\n  Reorder.prototype.dragStop = function (e) {\n    var gObj = this.parent;\n    this.setDisplay('none');\n    this.stopTimer();\n\n    if (!e.cancel) {\n      gObj.trigger(events.columnDrop, {\n        target: e.target,\n        draggableType: 'headercell',\n        column: e.column\n      });\n    }\n\n    removeClass(gObj.getHeaderTable().querySelectorAll('.e-reorderindicate'), ['e-reorderindicate']);\n  };\n\n  Reorder.prototype.setDisplay = function (display) {\n    this.upArrow.style.display = display;\n    this.downArrow.style.display = display;\n  };\n  /**\n   * For internal use only - Get the module name.\n   * @private\n   */\n\n\n  Reorder.prototype.getModuleName = function () {\n    return 'reorder';\n  };\n\n  return Reorder;\n}();\n\nexport { Reorder };","map":null,"metadata":{},"sourceType":"module"}