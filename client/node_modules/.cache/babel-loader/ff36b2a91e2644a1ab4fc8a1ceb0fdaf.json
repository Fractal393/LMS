{"ast":null,"code":"/**\n * TtfReader.ts class for EJ2-PDF\n */\nimport { TtfTableInfo } from './ttf-table-info';\nimport { Dictionary } from './../../collections/dictionary';\nimport { TtfNameTable } from './ttf-name-table';\nimport { TtfNameRecord } from './ttf-name-record';\nimport { TtfHeadTable } from './ttf-head-table';\nimport { TtfMetrics } from './ttf-metrics';\nimport { TtfHorizontalHeaderTable } from './ttf-horizontal-header-table';\nimport { TtfOS2Table } from './ttf-OS2-Table';\nimport { TtfPostTable } from './ttf-post-table';\nimport { TtfLongHorMetric } from './ttf-long-hor-metric';\nimport { TtfCmapSubTable } from './ttf-cmap-sub-table';\nimport { TtfCmapTable } from './ttf-cmap-table';\nimport { TtfGlyphInfo } from './ttf-glyph-info';\nimport { TtfLocaTable } from './ttf-loca-table';\nimport { TtfAppleCmapSubTable } from './ttf-apple-cmap-sub-table';\nimport { TtfMicrosoftCmapSubTable } from './ttf-microsoft-cmap-sub-table';\nimport { TtfTrimmedCmapSubTable } from './ttf-trimmed-cmap-sub-table';\nimport { TtfGlyphHeader } from './ttf-glyph-header';\nimport { Rectangle } from './../../drawing/pdf-drawing';\nimport { StringTokenizer } from './string-tokenizer';\nimport { TtfCmapFormat, TtfCmapEncoding, TtfPlatformID } from './enum';\nimport { TtfMicrosoftEncodingID, TtfMacintoshEncodingID, TtfCompositeGlyphFlags } from './enum';\nimport { BigEndianWriter } from './../../input-output/big-endian-writer';\n\nvar TtfReader =\n/** @class */\nfunction () {\n  //Constructors\n  function TtfReader(fontData) {\n    this.int32Size = 4;\n    this.isTtcFont = false;\n    this.isMacTtf = false;\n    this.metricsName = '';\n    this.isMacTTF = false;\n    this.missedGlyphs = 0;\n    this.tableNames = ['cvt ', 'fpgm', 'glyf', 'head', 'hhea', 'hmtx', 'loca', 'maxp', 'prep'];\n    this.entrySelectors = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4];\n    this.fontData = fontData;\n    this.initialize();\n  }\n\n  Object.defineProperty(TtfReader.prototype, \"macintosh\", {\n    //Properties\n\n    /**\n     * Gets glyphs for Macintosh or Symbol fonts (char - key, glyph - value).\n     */\n    get: function () {\n      if (this.macintoshDictionary === null || this.macintoshDictionary === undefined) {\n        this.macintoshDictionary = new Dictionary();\n      }\n\n      return this.macintoshDictionary;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TtfReader.prototype, \"microsoft\", {\n    /**\n     * Gets glyphs for Microsoft or Symbol fonts (char - key, glyph - value).\n     */\n    get: function () {\n      if (this.microsoftDictionary === null || this.microsoftDictionary === undefined) {\n        this.microsoftDictionary = new Dictionary();\n      }\n\n      return this.microsoftDictionary;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TtfReader.prototype, \"macintoshGlyphs\", {\n    /**\n     * Gets glyphs for Macintosh or Symbol fonts (glyph index - key, glyph - value).\n     */\n    get: function () {\n      if (this.internalMacintoshGlyphs === null || this.internalMacintoshGlyphs === undefined) {\n        this.internalMacintoshGlyphs = new Dictionary();\n      }\n\n      return this.internalMacintoshGlyphs;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TtfReader.prototype, \"microsoftGlyphs\", {\n    /**\n     * Gets glyphs for Microsoft Unicode fonts (glyph index - key, glyph - value).\n     */\n    get: function () {\n      if (this.internalMicrosoftGlyphs === null || this.internalMicrosoftGlyphs === undefined) {\n        this.internalMicrosoftGlyphs = new Dictionary();\n      }\n\n      return this.internalMicrosoftGlyphs;\n    },\n    enumerable: true,\n    configurable: true\n  }); //Implementation\n\n  TtfReader.prototype.initialize = function () {\n    if (this.metrics === undefined) {\n      this.metrics = new TtfMetrics();\n    }\n\n    this.readFontDictionary();\n    var nameTable = this.readNameTable();\n    var headTable = this.readHeadTable();\n    this.initializeFontName(nameTable);\n    this.metrics.macStyle = headTable.macStyle;\n  };\n\n  TtfReader.prototype.readFontDictionary = function () {\n    this.offset = 0;\n    var version = this.checkPreambula(); //this.offset += 4;\n\n    var numTables = this.readInt16(this.offset);\n    var searchRange = this.readInt16(this.offset);\n    var entrySelector = this.readInt16(this.offset);\n    var rangeShift = this.readInt16(this.offset);\n\n    if (this.tableDirectory === undefined) {\n      this.tableDirectory = new Dictionary();\n    }\n\n    for (var i = 0; i < numTables; ++i) {\n      var table = new TtfTableInfo();\n      var tableKey = this.readString(this.int32Size);\n      table.checksum = this.readInt32(this.offset);\n      table.offset = this.readInt32(this.offset);\n      table.length = this.readInt32(this.offset);\n      this.tableDirectory.setValue(tableKey, table);\n    }\n\n    this.lowestPosition = this.offset;\n\n    if (!this.isTtcFont) {\n      this.fixOffsets();\n    }\n  };\n\n  TtfReader.prototype.fixOffsets = function () {\n    var minOffset = Number.MAX_VALUE; // Search for a smallest offset and compare it with the lowest position found.\n\n    var tableKeys = this.tableDirectory.keys();\n\n    for (var i = 0; i < tableKeys.length; i++) {\n      var value = this.tableDirectory.getValue(tableKeys[i]);\n      var offset = value.offset;\n\n      if (minOffset > offset) {\n        minOffset = offset;\n\n        if (minOffset <= this.lowestPosition) {\n          break;\n        }\n      }\n    }\n\n    var shift = minOffset - this.lowestPosition;\n\n    if (shift !== 0) {\n      var table = new Dictionary();\n\n      for (var i = 0; i < tableKeys.length; i++) {\n        var value = this.tableDirectory.getValue(tableKeys[i]);\n        value.offset -= shift;\n        table.setValue(tableKeys[i], value);\n      }\n\n      this.tableDirectory = table;\n    }\n  };\n\n  TtfReader.prototype.checkPreambula = function () {\n    var version = this.readInt32(this.offset);\n    this.isMacTtf = version === 0x74727565 ? true : false;\n\n    if (version !== 0x10000 && version !== 0x74727565 && version !== 0x4f54544f) {\n      this.isTtcFont = true;\n      this.offset = 0;\n      var fontTag = this.readString(4);\n\n      if (fontTag !== 'ttcf') {\n        throw new Error('Can not read TTF font data');\n      } //skip 4\n\n\n      this.offset += 4;\n      var ttcIdentificationNumber = this.readInt32(this.offset);\n\n      if (ttcIdentificationNumber < 0) {\n        throw new Error('Can not read TTF font data');\n      }\n\n      this.offset = this.readInt32(this.offset);\n      version = this.readInt32(this.offset);\n    }\n\n    return version;\n  };\n\n  TtfReader.prototype.readNameTable = function () {\n    var tableInfo = this.getTable('name');\n    this.offset = tableInfo.offset;\n    var table = new TtfNameTable();\n    table.formatSelector = this.readUInt16(this.offset);\n    table.recordsCount = this.readUInt16(this.offset);\n    table.offset = this.readUInt16(this.offset);\n    table.nameRecords = [];\n    var recordSize = 12;\n    var position = this.offset;\n\n    for (var i = 0; i < table.recordsCount; i++) {\n      this.offset = position;\n      var record = new TtfNameRecord();\n      record.platformID = this.readUInt16(this.offset);\n      record.encodingID = this.readUInt16(this.offset);\n      record.languageID = this.readUInt16(this.offset);\n      record.nameID = this.readUInt16(this.offset);\n      record.length = this.readUInt16(this.offset);\n      record.offset = this.readUInt16(this.offset);\n      this.offset = tableInfo.offset + table.offset + record.offset;\n      var unicode = record.platformID === 0 || record.platformID === 3;\n      record.name = this.readString(record.length, unicode);\n      table.nameRecords[i] = record;\n      position += recordSize;\n    }\n\n    return table;\n  };\n\n  TtfReader.prototype.readHeadTable = function () {\n    var tableInfo = this.getTable('head');\n    this.offset = tableInfo.offset;\n    var table = new TtfHeadTable();\n    table.version = this.readFixed(this.offset);\n    table.fontRevision = this.readFixed(this.offset);\n    table.checkSumAdjustment = this.readUInt32(this.offset);\n    table.magicNumber = this.readUInt32(this.offset);\n    table.flags = this.readUInt16(this.offset);\n    table.unitsPerEm = this.readUInt16(this.offset);\n    table.created = this.readInt64(this.offset);\n    table.modified = this.readInt64(this.offset);\n    table.xMin = this.readInt16(this.offset);\n    table.yMin = this.readInt16(this.offset);\n    table.xMax = this.readInt16(this.offset);\n    table.yMax = this.readInt16(this.offset);\n    table.macStyle = this.readUInt16(this.offset);\n    table.lowestReadableSize = this.readUInt16(this.offset);\n    table.fontDirectionHint = this.readInt16(this.offset);\n    table.indexToLocalFormat = this.readInt16(this.offset);\n    table.glyphDataFormat = this.readInt16(this.offset);\n    return table;\n  };\n\n  TtfReader.prototype.readHorizontalHeaderTable = function () {\n    var tableInfo = this.getTable('hhea');\n    this.offset = tableInfo.offset;\n    var table = new TtfHorizontalHeaderTable();\n    table.version = this.readFixed(this.offset);\n    table.ascender = this.readInt16(this.offset);\n    table.descender = this.readInt16(this.offset);\n    table.lineGap = this.readInt16(this.offset);\n    table.advanceWidthMax = this.readUInt16(this.offset);\n    table.minLeftSideBearing = this.readInt16(this.offset);\n    table.minRightSideBearing = this.readInt16(this.offset);\n    table.xMaxExtent = this.readInt16(this.offset);\n    table.caretSlopeRise = this.readInt16(this.offset);\n    table.caretSlopeRun = this.readInt16(this.offset); //skip 2 * 5\n\n    this.offset += 10;\n    table.metricDataFormat = this.readInt16(this.offset);\n    table.numberOfHMetrics = this.readUInt16(this.offset);\n    return table;\n  };\n\n  TtfReader.prototype.readOS2Table = function () {\n    var tableInfo = this.getTable('OS/2');\n    this.offset = tableInfo.offset;\n    var table = new TtfOS2Table();\n    table.version = this.readUInt16(this.offset);\n    table.xAvgCharWidth = this.readInt16(this.offset);\n    table.usWeightClass = this.readUInt16(this.offset);\n    table.usWidthClass = this.readUInt16(this.offset);\n    table.fsType = this.readInt16(this.offset);\n    table.ySubscriptXSize = this.readInt16(this.offset);\n    table.ySubscriptYSize = this.readInt16(this.offset);\n    table.ySubscriptXOffset = this.readInt16(this.offset);\n    table.ySubscriptYOffset = this.readInt16(this.offset);\n    table.ySuperscriptXSize = this.readInt16(this.offset);\n    table.ySuperscriptYSize = this.readInt16(this.offset);\n    table.ySuperscriptXOffset = this.readInt16(this.offset);\n    table.ySuperscriptYOffset = this.readInt16(this.offset);\n    table.yStrikeoutSize = this.readInt16(this.offset);\n    table.yStrikeoutPosition = this.readInt16(this.offset);\n    table.sFamilyClass = this.readInt16(this.offset);\n    table.panose = this.readBytes(10);\n    table.ulUnicodeRange1 = this.readUInt32(this.offset);\n    table.ulUnicodeRange2 = this.readUInt32(this.offset);\n    table.ulUnicodeRange3 = this.readUInt32(this.offset);\n    table.ulUnicodeRange4 = this.readUInt32(this.offset);\n    table.vendorIdentifier = this.readBytes(4);\n    table.fsSelection = this.readUInt16(this.offset);\n    table.usFirstCharIndex = this.readUInt16(this.offset);\n    table.usLastCharIndex = this.readUInt16(this.offset);\n    table.sTypoAscender = this.readInt16(this.offset);\n    table.sTypoDescender = this.readInt16(this.offset);\n    table.sTypoLineGap = this.readInt16(this.offset);\n    table.usWinAscent = this.readUInt16(this.offset);\n    table.usWinDescent = this.readUInt16(this.offset);\n    table.ulCodePageRange1 = this.readUInt32(this.offset);\n    table.ulCodePageRange2 = this.readUInt32(this.offset);\n\n    if (table.version > 1) {\n      table.sxHeight = this.readInt16(this.offset);\n      table.sCapHeight = this.readInt16(this.offset);\n      table.usDefaultChar = this.readUInt16(this.offset);\n      table.usBreakChar = this.readUInt16(this.offset);\n      table.usMaxContext = this.readUInt16(this.offset);\n    } else {\n      table.sxHeight = 0;\n      table.sCapHeight = 0;\n      table.usDefaultChar = 0;\n      table.usBreakChar = 0;\n      table.usMaxContext = 0;\n    }\n\n    return table;\n  };\n\n  TtfReader.prototype.readPostTable = function () {\n    var tableInfo = this.getTable('post');\n    this.offset = tableInfo.offset;\n    var table = new TtfPostTable();\n    table.formatType = this.readFixed(this.offset);\n    table.italicAngle = this.readFixed(this.offset);\n    table.underlinePosition = this.readInt16(this.offset);\n    table.underlineThickness = this.readInt16(this.offset);\n    table.isFixedPitch = this.readUInt32(this.offset);\n    table.minType42 = this.readUInt32(this.offset);\n    table.maxType42 = this.readUInt32(this.offset);\n    table.minType1 = this.readUInt32(this.offset);\n    table.maxType1 = this.readUInt32(this.offset);\n    return table;\n  };\n  /**\n   * Reads Width of the glyphs.\n   */\n\n\n  TtfReader.prototype.readWidthTable = function (glyphCount, unitsPerEm) {\n    var tableInfo = this.getTable('hmtx');\n    this.offset = tableInfo.offset;\n    var width = [];\n\n    for (var i = 0; i < glyphCount; i++) {\n      var glyph = new TtfLongHorMetric();\n      glyph.advanceWidth = this.readUInt16(this.offset);\n      glyph.lsb = this.readInt16(this.offset);\n      var glyphWidth = glyph.advanceWidth * 1000 / unitsPerEm;\n      width.push(Math.floor(glyphWidth));\n    }\n\n    return width;\n  };\n  /**\n   * Reads the cmap table.\n   */\n\n\n  TtfReader.prototype.readCmapTable = function () {\n    var tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset;\n    var table = new TtfCmapTable();\n    table.version = this.readUInt16(this.offset);\n    table.tablesCount = this.readUInt16(this.offset);\n    var position = this.offset;\n    var subTables = [];\n\n    for (var i = 0; i < table.tablesCount; i++) {\n      this.offset = position;\n      var subTable = new TtfCmapSubTable();\n      subTable.platformID = this.readUInt16(this.offset);\n      subTable.encodingID = this.readUInt16(this.offset);\n      subTable.offset = this.readUInt32(this.offset);\n      position = this.offset;\n      this.readCmapSubTable(subTable);\n      subTables[i] = subTable;\n    }\n\n    return subTables;\n  };\n  /**\n   * Reads the cmap sub table.\n   */\n\n\n  TtfReader.prototype.readCmapSubTable = function (subTable) {\n    var tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset + subTable.offset;\n    var format = this.readUInt16(this.offset);\n    var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);\n    var platform = encoding === TtfCmapEncoding.Macintosh ? TtfPlatformID.Macintosh : TtfPlatformID.Microsoft;\n\n    if (encoding !== TtfCmapEncoding.Unknown) {\n      switch (format) {\n        case TtfCmapFormat.Apple:\n          this.readAppleCmapTable(subTable, encoding);\n          break;\n\n        case TtfCmapFormat.Microsoft:\n          this.readMicrosoftCmapTable(subTable, encoding);\n          break;\n\n        case TtfCmapFormat.Trimmed:\n          this.readTrimmedCmapTable(subTable, encoding);\n          break;\n      }\n    }\n  };\n  /**\n   * Reads Symbol cmap table.\n   */\n\n\n  TtfReader.prototype.readAppleCmapTable = function (subTable, encoding) {\n    var tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset + subTable.offset;\n    var table = new TtfAppleCmapSubTable();\n    table.format = this.readUInt16(this.offset);\n    table.length = this.readUInt16(this.offset);\n    table.version = this.readUInt16(this.offset);\n\n    if (this.maxMacIndex === null || this.maxMacIndex === undefined) {\n      this.maxMacIndex = 0;\n    }\n\n    for (var i = 0; i < 256; ++i) {\n      var glyphInfo = new TtfGlyphInfo();\n      glyphInfo.index = this.readByte(this.offset);\n      glyphInfo.width = this.getWidth(glyphInfo.index);\n      glyphInfo.charCode = i;\n      this.macintosh.setValue(i, glyphInfo);\n      this.addGlyph(glyphInfo, encoding); // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.\n\n      this.maxMacIndex = Math.max(i, this.maxMacIndex);\n    }\n  };\n  /**\n   * Reads Symbol cmap table.\n   */\n\n\n  TtfReader.prototype.readMicrosoftCmapTable = function (subTable, encoding) {\n    var tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset + subTable.offset;\n    var collection = encoding === TtfCmapEncoding.Unicode ? this.microsoft : this.macintosh;\n    var table = new TtfMicrosoftCmapSubTable();\n    table.format = this.readUInt16(this.offset);\n    table.length = this.readUInt16(this.offset);\n    table.version = this.readUInt16(this.offset);\n    table.segCountX2 = this.readUInt16(this.offset);\n    table.searchRange = this.readUInt16(this.offset);\n    table.entrySelector = this.readUInt16(this.offset);\n    table.rangeShift = this.readUInt16(this.offset);\n    var segCount = table.segCountX2 / 2;\n    table.endCount = this.readUshortArray(segCount);\n    table.reservedPad = this.readUInt16(this.offset);\n    table.startCount = this.readUshortArray(segCount);\n    table.idDelta = this.readUshortArray(segCount);\n    table.idRangeOffset = this.readUshortArray(segCount);\n    var length = table.length / 2 - 8 - segCount * 4;\n    table.glyphID = this.readUshortArray(length); // Process glyphIdArray array.\n\n    var codeOffset = 0;\n    var index = 0;\n\n    for (var j = 0; j < segCount; j++) {\n      for (var k = table.startCount[j]; k <= table.endCount[j] && k !== 65535; k++) {\n        if (table.idRangeOffset[j] === 0) {\n          codeOffset = k + table.idDelta[j] & 65535;\n        } else {\n          index = j + table.idRangeOffset[j] / 2 - segCount + k - table.startCount[j];\n\n          if (index >= table.glyphID.length) {\n            continue;\n          }\n\n          codeOffset = table.glyphID[index] + table.idDelta[j] & 65535;\n        }\n\n        var glyph = new TtfGlyphInfo();\n        glyph.index = codeOffset;\n        glyph.width = this.getWidth(glyph.index);\n        var id = encoding === TtfCmapEncoding.Symbol ? (k & 0xff00) === 0xf000 ? k & 0xff : k : k;\n        glyph.charCode = id;\n        collection.setValue(id, glyph);\n        this.addGlyph(glyph, encoding);\n      }\n    }\n  };\n  /**\n   * Reads Trimed cmap table.\n   */\n\n\n  TtfReader.prototype.readTrimmedCmapTable = function (subTable, encoding) {\n    var tableInfo = this.getTable('cmap');\n    this.offset = tableInfo.offset + subTable.offset;\n    var table = new TtfTrimmedCmapSubTable();\n    table.format = this.readUInt16(this.offset);\n    table.length = this.readUInt16(this.offset);\n    table.version = this.readUInt16(this.offset);\n    table.firstCode = this.readUInt16(this.offset);\n    table.entryCount = this.readUInt16(this.offset);\n\n    for (var i = 0; i < table.entryCount; ++i) {\n      var glyphInfo = new TtfGlyphInfo();\n      glyphInfo.index = this.readUInt16(this.offset);\n      glyphInfo.width = this.getWidth(glyphInfo.index);\n      glyphInfo.charCode = i + table.firstCode;\n      this.macintosh.setValue(i, glyphInfo);\n      this.addGlyph(glyphInfo, encoding); // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.\n\n      this.maxMacIndex = Math.max(i, this.maxMacIndex);\n    }\n  };\n\n  TtfReader.prototype.initializeFontName = function (nameTable) {\n    for (var i = 0; i < nameTable.recordsCount; i++) {\n      var record = nameTable.nameRecords[i];\n\n      if (record.nameID === 1) {\n        //font family\n        this.metrics.fontFamily = record.name;\n      } else if (record.nameID === 6) {\n        //post script name\n        this.metrics.postScriptName = record.name;\n      }\n      /* tslint:disable */\n\n\n      if (this.metrics.fontFamily !== null && this.metrics.fontFamily !== undefined && this.metrics.postScriptName !== null && this.metrics.postScriptName !== undefined) {\n        break;\n      }\n      /* tslint:disable */\n\n    }\n  };\n\n  TtfReader.prototype.getTable = function (name) {\n    // if (name === null) {\n    //     throw new Error('Argument Null Exception : name');\n    // }\n    var table = new TtfTableInfo();\n    var obj;\n\n    if (this.tableDirectory.containsKey(name)) {\n      obj = this.tableDirectory.getValue(name);\n    }\n\n    if (obj !== null && obj !== undefined) {\n      table = obj;\n    }\n\n    return table;\n  };\n  /**\n   * Returns width of the glyph.\n   */\n\n\n  TtfReader.prototype.getWidth = function (glyphCode) {\n    glyphCode = glyphCode < this.width.length ? glyphCode : this.width.length - 1;\n    return this.width[glyphCode];\n  };\n  /**\n   * Gets CMAP encoding based on platform ID and encoding ID.\n   */\n\n  /* tslint:disable */\n\n\n  TtfReader.prototype.getCmapEncoding = function (platformID, encodingID) {\n    var format = TtfCmapEncoding.Unknown;\n\n    if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Undefined) {\n      // When building a symbol font for Windows,\n      // the platform ID should be 3 and the encoding ID should be 0.\n      format = TtfCmapEncoding.Symbol;\n    } else if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Unicode) {\n      // When building a Unicode font for Windows,\n      // the platform ID should be 3 and the encoding ID should be 1.\n      format = TtfCmapEncoding.Unicode;\n    } else if (platformID == TtfPlatformID.Macintosh && encodingID == TtfMacintoshEncodingID.Roman) {\n      // When building a font that will be used on the Macintosh,\n      // the platform ID should be 1 and the encoding ID should be 0.\n      format = TtfCmapEncoding.Macintosh;\n    }\n\n    return format;\n  };\n  /* tslint:enable */\n\n  /**\n   * Adds glyph to the collection.\n   */\n\n\n  TtfReader.prototype.addGlyph = function (glyph, encoding) {\n    var collection = null;\n\n    switch (encoding) {\n      case TtfCmapEncoding.Unicode:\n        collection = this.microsoftGlyphs;\n        break;\n\n      case TtfCmapEncoding.Macintosh:\n      case TtfCmapEncoding.Symbol:\n        collection = this.macintoshGlyphs;\n        break;\n    }\n\n    collection.setValue(glyph.index, glyph);\n  };\n  /**\n   * Initializes metrics.\n   */\n\n  /* tslint:disable */\n\n\n  TtfReader.prototype.initializeMetrics = function (nameTable, headTable, horizontalHeadTable, os2Table, postTable, cmapTables) {\n    /* tslint:enable */\n    // if (cmapTables === null) {\n    //     throw new Error('ArgumentNullException : cmapTables');\n    // }\n    this.initializeFontName(nameTable); // Get font encoding.\n\n    var bSymbol = false;\n\n    for (var i = 0; i < cmapTables.length; i++) {\n      var subTable = cmapTables[i];\n      var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);\n\n      if (encoding === TtfCmapEncoding.Symbol) {\n        bSymbol = true;\n        break;\n      }\n    }\n\n    this.metrics.isSymbol = bSymbol;\n    this.metrics.macStyle = headTable.macStyle;\n    this.metrics.isFixedPitch = postTable.isFixedPitch !== 0;\n    this.metrics.italicAngle = postTable.italicAngle;\n    var factor = 1000 / headTable.unitsPerEm;\n    this.metrics.winAscent = os2Table.sTypoAscender * factor;\n    this.metrics.macAscent = horizontalHeadTable.ascender * factor; //m_metrics.MacAscent = os2Table.UsWinAscent * factor;\n    // NOTE: This is stange workaround. The value is good if os2Table.SCapHeight != 0, otherwise it should be properly computed.\n\n    this.metrics.capHeight = os2Table.sCapHeight !== 0 ? os2Table.sCapHeight : 0.7 * headTable.unitsPerEm * factor;\n    this.metrics.winDescent = os2Table.sTypoDescender * factor;\n    this.metrics.macDescent = horizontalHeadTable.descender * factor; //m_metrics.MacDescent = -os2Table.UsWinDescent * factor;\n\n    this.metrics.leading = (os2Table.sTypoAscender - os2Table.sTypoDescender + os2Table.sTypoLineGap) * factor;\n    this.metrics.lineGap = Math.ceil(horizontalHeadTable.lineGap * factor);\n    var left = headTable.xMin * factor;\n    var top = Math.ceil(this.metrics.macAscent + this.metrics.lineGap);\n    var right = headTable.xMax * factor;\n    var bottom = this.metrics.macDescent;\n    this.metrics.fontBox = new Rectangle(left, top, right, bottom); // NOTE: Strange!\n\n    this.metrics.stemV = 80;\n    this.metrics.widthTable = this.updateWidth();\n    this.metrics.contains = this.tableDirectory.containsKey('CFF');\n    this.metrics.subScriptSizeFactor = headTable.unitsPerEm / os2Table.ySubscriptYSize;\n    this.metrics.superscriptSizeFactor = headTable.unitsPerEm / os2Table.ySuperscriptYSize;\n  };\n  /**\n   * Updates chars structure which is used in the case of ansi encoding (256 bytes).\n   */\n\n\n  TtfReader.prototype.updateWidth = function () {\n    var count = 256;\n    var bytes = [];\n\n    if (this.metrics.isSymbol) {\n      for (var i = 0; i < count; i++) {\n        var glyphInfo = this.getGlyph(String.fromCharCode(i));\n        bytes[i] = glyphInfo.empty ? 0 : glyphInfo.width;\n      }\n    } else {\n      var byteToProcess = [];\n      var unknown = '?';\n      var space = String.fromCharCode(32);\n\n      for (var i = 0; i < count; i++) {\n        byteToProcess[0] = i;\n        var text = this.getString(byteToProcess, 0, byteToProcess.length);\n        var ch = text.length > 0 ? text[0] : unknown;\n        var glyphInfo = this.getGlyph(ch);\n\n        if (!glyphInfo.empty) {\n          bytes[i] = glyphInfo.width;\n        } else {\n          glyphInfo = this.getGlyph(space);\n          bytes[i] = glyphInfo.empty ? 0 : glyphInfo.width;\n        }\n      }\n    }\n\n    return bytes;\n  };\n  /**\n   * Returns default glyph.\n   */\n\n\n  TtfReader.prototype.getDefaultGlyph = function () {\n    var glyph = this.getGlyph(StringTokenizer.whiteSpace);\n    return glyph;\n  };\n  /**\n   * Reads unicode string from byte array.\n   */\n\n\n  TtfReader.prototype.getString = function (byteToProcess, start, length) {\n    var result = '';\n\n    for (var index = 0; index < length; index++) {\n      result += String.fromCharCode(byteToProcess[index + start]);\n    }\n\n    return result;\n  };\n  /**\n   * Reads loca table.\n   */\n\n\n  TtfReader.prototype.readLocaTable = function (bShort) {\n    var tableInfo = this.getTable('loca');\n    this.offset = tableInfo.offset;\n    var table = new TtfLocaTable();\n    var buffer = null;\n\n    if (bShort) {\n      var len = tableInfo.length / 2;\n      buffer = [];\n\n      for (var i = 0; i < len; i++) {\n        buffer[i] = this.readUInt16(this.offset) * 2;\n      }\n    } else {\n      var len = tableInfo.length / 4;\n      buffer = [];\n\n      for (var i = 0; i < len; i++) {\n        buffer[i] = this.readUInt32(this.offset);\n      }\n    }\n\n    table.offsets = buffer;\n    return table;\n  };\n  /**\n   * Updates hash table of used glyphs.\n   */\n\n\n  TtfReader.prototype.updateGlyphChars = function (glyphChars, locaTable) {\n    // if (glyphChars === null) {\n    //     throw new Error('Argument Null Exception : glyphChars');\n    // }\n    // Add zero key.\n    if (!glyphChars.containsKey(0)) {\n      glyphChars.setValue(0, 0);\n    }\n\n    var clone = new Dictionary();\n    var glyphCharKeys = glyphChars.keys();\n\n    for (var i = 0; i < glyphCharKeys.length; i++) {\n      clone.setValue(glyphCharKeys[i], glyphChars.getValue(glyphCharKeys[i]));\n    }\n\n    for (var i = 0; i < glyphCharKeys.length; i++) {\n      var nextKey = glyphCharKeys[i];\n      this.processCompositeGlyph(glyphChars, nextKey, locaTable);\n    }\n  };\n  /**\n   * Checks if glyph is composite or not.\n   */\n\n\n  TtfReader.prototype.processCompositeGlyph = function (glyphChars, glyph, locaTable) {\n    // if (glyphChars === null) {\n    //     throw new Error('Argument Null Exception : glyphChars');\n    // }\n    // Is in range.\n    if (glyph < locaTable.offsets.length - 1) {\n      var glyphOffset = locaTable.offsets[glyph];\n\n      if (glyphOffset !== locaTable.offsets[glyph + 1]) {\n        var tableInfo = this.getTable('glyf');\n        this.offset = tableInfo.offset + glyphOffset;\n        var glyphHeader = new TtfGlyphHeader();\n        glyphHeader.numberOfContours = this.readInt16(this.offset);\n        glyphHeader.xMin = this.readInt16(this.offset);\n        glyphHeader.yMin = this.readInt16(this.offset);\n        glyphHeader.xMax = this.readInt16(this.offset);\n        glyphHeader.yMax = this.readInt16(this.offset); // Glyph is composite.\n\n        if (glyphHeader.numberOfContours < 0) {\n          var skipBytes = 0;\n          var entry = true;\n\n          while (entry) {\n            var flags = this.readUInt16(this.offset);\n            var glyphIndex = this.readUInt16(this.offset);\n\n            if (!glyphChars.containsKey(glyphIndex)) {\n              glyphChars.setValue(glyphIndex, 0);\n            }\n\n            if ((flags & TtfCompositeGlyphFlags.MoreComponents) === 0) {\n              break;\n            }\n\n            skipBytes = (flags & TtfCompositeGlyphFlags.Arg1And2AreWords) !== 0 ? 4 : 2;\n\n            if ((flags & TtfCompositeGlyphFlags.WeHaveScale) !== 0) {\n              skipBytes += 2;\n            } else if ((flags & TtfCompositeGlyphFlags.WeHaveAnXyScale) !== 0) {\n              skipBytes += 4;\n            } else if ((flags & TtfCompositeGlyphFlags.WeHaveTwoByTwo) !== 0) {\n              skipBytes += 2 * 4;\n            }\n\n            this.offset += skipBytes;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Creates new glyph tables based on chars that are used for output.\n   */\n\n  /* tslint:disable */\n\n\n  TtfReader.prototype.generateGlyphTable = function (glyphChars, locaTable, newLocaTable, newGlyphTable) {\n    /* tslint:enable */\n    // if (glyphChars === null) {\n    //     throw new Error('Argument Null Exception : glyphChars');\n    // }\n    newLocaTable = []; // Sorting used glyphs keys.\n\n    var activeGlyphs = glyphChars.keys();\n    activeGlyphs.sort(function (a, b) {\n      return a - b;\n    });\n    var glyphSize = 0;\n\n    for (var i = 0; i < activeGlyphs.length; i++) {\n      var glyphIndex = activeGlyphs[i];\n\n      if (locaTable.offsets.length > 0) {\n        glyphSize += locaTable.offsets[glyphIndex + 1] - locaTable.offsets[glyphIndex];\n      }\n    }\n\n    var glyphSizeAligned = this.align(glyphSize);\n    newGlyphTable = [];\n\n    for (var i = 0; i < glyphSizeAligned; i++) {\n      newGlyphTable.push(0);\n    }\n\n    var nextGlyphOffset = 0;\n    var nextGlyphIndex = 0;\n    var table = this.getTable('glyf'); // Creating NewLocaTable - that would hold offsets for filtered glyphs.\n\n    for (var i = 0; i < locaTable.offsets.length; i++) {\n      newLocaTable.push(nextGlyphOffset);\n\n      if (nextGlyphIndex < activeGlyphs.length && activeGlyphs[nextGlyphIndex] === i) {\n        ++nextGlyphIndex;\n        newLocaTable[i] = nextGlyphOffset;\n        var oldGlyphOffset = locaTable.offsets[i];\n        var oldNextGlyphOffset = locaTable.offsets[i + 1] - oldGlyphOffset;\n\n        if (oldNextGlyphOffset > 0) {\n          this.offset = table.offset + oldGlyphOffset;\n          var result = this.read(newGlyphTable, nextGlyphOffset, oldNextGlyphOffset);\n          newGlyphTable = result.buffer;\n          nextGlyphOffset += oldNextGlyphOffset;\n        }\n      }\n    }\n\n    return {\n      glyphTableSize: glyphSize,\n      newLocaTable: newLocaTable,\n      newGlyphTable: newGlyphTable\n    };\n  };\n  /**\n   * Updates new Loca table.\n   */\n\n  /* tslint:disable */\n\n\n  TtfReader.prototype.updateLocaTable = function (newLocaTable, bLocaIsShort, newLocaTableOut) {\n    /* tslint:enable */\n    if (newLocaTable === null) {\n      throw new Error('Argument Null Exception : newLocaTable');\n    }\n\n    var size = bLocaIsShort ? newLocaTable.length * 2 : newLocaTable.length * 4;\n    var count = this.align(size); //BigEndianWiter\n\n    var writer = new BigEndianWriter(count);\n\n    for (var i = 0; i < newLocaTable.length; i++) {\n      var value = newLocaTable[i];\n\n      if (bLocaIsShort) {\n        value /= 2;\n        writer.writeShort(value);\n      } else {\n        writer.writeInt(value);\n      }\n    }\n\n    return {\n      newLocaUpdated: writer.data,\n      newLocaSize: size\n    };\n  };\n  /**\n   * Aligns number to be divisible on 4.\n   */\n\n\n  TtfReader.prototype.align = function (value) {\n    return value + 3 & ~3;\n  };\n  /**\n   * Returns font program data.\n   */\n\n  /* tslint:disable */\n\n\n  TtfReader.prototype.getFontProgram = function (newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {\n    /* tslint:enable */\n    if (newLocaTableOut === null) {\n      throw new Error('Argument Null Exception : newLocaTableOut');\n    }\n\n    if (newGlyphTable === null) {\n      throw new Error('Argument Null Exception : newGlyphTable');\n    }\n\n    var tableNames = this.tableNames;\n    var result = this.getFontProgramLength(newLocaTableOut, newGlyphTable, 0);\n    var fontProgramLength = result.fontProgramLength;\n    var numTables = result.numTables;\n    var writer = new BigEndianWriter(fontProgramLength);\n    writer.writeInt(0x10000);\n    writer.writeShort(numTables);\n    var entrySelector = this.entrySelectors[numTables];\n    writer.writeShort((1 << (entrySelector & 31)) * 16);\n    writer.writeShort(entrySelector);\n    writer.writeShort((numTables - (1 << (entrySelector & 31))) * 16); // Writing to destination buffer - checksums && sizes of used tables.\n\n    this.writeCheckSums(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize); // // Writing to destination buffer - used glyphs.\n\n    this.writeGlyphs(writer, newLocaTableOut, newGlyphTable);\n    return writer.data;\n  };\n  /* tslint:disable */\n\n\n  TtfReader.prototype.getFontProgramLength = function (newLocaTableOut, newGlyphTable, numTables) {\n    /* tslint:enable */\n    if (newLocaTableOut === null) {\n      throw new Error('Argument Null Exception : newLocaTableOut');\n    }\n\n    if (newGlyphTable === null) {\n      throw new Error('Argument Null Exception : newGlyphTable');\n    } // glyf and loca are used by default;\n\n\n    numTables = 2;\n    var tableNames = this.tableNames;\n    var fontProgramLength = 0;\n\n    for (var i = 0; i < tableNames.length; i++) {\n      var tableName = tableNames[i];\n\n      if (tableName !== 'glyf' && tableName !== 'loca') {\n        var table = this.getTable(tableName);\n\n        if (!table.empty) {\n          ++numTables;\n          fontProgramLength += this.align(table.length);\n        }\n      }\n    }\n\n    fontProgramLength += newLocaTableOut.length;\n    fontProgramLength += newGlyphTable.length;\n    var usedTablesSize = numTables * 16 + 3 * 4;\n    fontProgramLength += usedTablesSize;\n    return {\n      fontProgramLength: fontProgramLength,\n      numTables: numTables\n    };\n  };\n  /**\n   * Writing to destination buffer - checksums and sizes of used tables.\n   */\n\n  /* tslint:disable */\n\n\n  TtfReader.prototype.writeCheckSums = function (writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {\n    /* tslint:enable */\n    if (writer === null) {\n      throw new Error('Argument Null Exception : writer');\n    }\n\n    if (newLocaTableOut === null) {\n      throw new Error('Argument Null Exception : newLocaTableOut');\n    }\n\n    if (newGlyphTable === null) {\n      throw new Error('Argument Null Exception : newGlyphTable');\n    }\n\n    var tableNames = this.tableNames;\n    var usedTablesSize = numTables * 16 + 3 * 4;\n    var nextTableSize = 0;\n\n    for (var i = 0; i < tableNames.length; i++) {\n      var tableName = tableNames[i];\n      var tableInfo = this.getTable(tableName);\n\n      if (tableInfo.empty) {\n        continue;\n      }\n\n      writer.writeString(tableName);\n\n      if (tableName === 'glyf') {\n        var checksum = this.calculateCheckSum(newGlyphTable);\n        writer.writeInt(checksum);\n        nextTableSize = glyphTableSize;\n      } else if (tableName === 'loca') {\n        var checksum = this.calculateCheckSum(newLocaTableOut);\n        writer.writeInt(checksum);\n        nextTableSize = locaTableSize;\n      } else {\n        writer.writeInt(tableInfo.checksum);\n        nextTableSize = tableInfo.length;\n      }\n\n      writer.writeUInt(usedTablesSize);\n      writer.writeUInt(nextTableSize);\n      usedTablesSize += this.align(nextTableSize);\n    }\n  };\n  /**\n   * Gets checksum from source buffer.\n   */\n\n\n  TtfReader.prototype.calculateCheckSum = function (bytes) {\n    if (bytes === null) {\n      throw new Error('Argument Null Exception : bytes');\n    }\n\n    var pos = 0;\n    var byte1 = 0;\n    var byte2 = 0;\n    var byte3 = 0;\n    var byte4 = 0;\n\n    for (var i = 0; i < (bytes.length + 1) / 4; i++) {\n      byte4 += bytes[pos++] & 255;\n      byte3 += bytes[pos++] & 255;\n      byte2 += bytes[pos++] & 255;\n      byte1 += bytes[pos++] & 255;\n    }\n\n    var result = byte1;\n    result += byte2 << 8;\n    result += byte3 << 16;\n    result += byte4 << 24;\n    return result;\n  };\n  /**\n   * Writing to destination buffer - used glyphs.\n   */\n\n\n  TtfReader.prototype.writeGlyphs = function (writer, newLocaTable, newGlyphTable) {\n    if (writer === null) {\n      throw new Error('Argument Null Exception : writer');\n    }\n\n    if (newLocaTable === null) {\n      throw new Error('Argument Null Exception : newLocaTableOut');\n    }\n\n    if (newGlyphTable === null) {\n      throw new Error('Argument Null Exception : newGlyphTable');\n    }\n\n    var tableNames = this.tableNames;\n\n    for (var i = 0; i < tableNames.length; i++) {\n      var tableName = tableNames[i];\n      var tableInfo = this.getTable(tableName);\n\n      if (tableInfo.empty) {\n        continue;\n      }\n\n      if (tableName === 'glyf') {\n        writer.writeBytes(newGlyphTable);\n      } else if (tableName === 'loca') {\n        writer.writeBytes(newLocaTable);\n      } else {\n        var count = this.align(tableInfo.length);\n        var buff = [];\n\n        for (var i_1 = 0; i_1 < count; i_1++) {\n          buff.push(0);\n        }\n\n        this.offset = tableInfo.offset;\n        var result = this.read(buff, 0, tableInfo.length);\n        writer.writeBytes(result.buffer);\n      }\n    }\n  }; //public methods\n\n  /**\n   * Sets position value of font data.\n   */\n\n\n  TtfReader.prototype.setOffset = function (offset) {\n    this.offset = offset;\n  };\n  /**\n   * Creates font Internals\n   * @private\n   */\n\n\n  TtfReader.prototype.createInternals = function () {\n    this.metrics = new TtfMetrics();\n    var nameTable = this.readNameTable();\n    var headTable = this.readHeadTable();\n    this.bIsLocaShort = headTable.indexToLocalFormat === 0;\n    var horizontalHeadTable = this.readHorizontalHeaderTable();\n    var os2Table = this.readOS2Table();\n    var postTable = this.readPostTable();\n    this.width = this.readWidthTable(horizontalHeadTable.numberOfHMetrics, headTable.unitsPerEm);\n    var subTables = this.readCmapTable();\n    this.initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, subTables);\n  };\n\n  TtfReader.prototype.getGlyph = function (charCode) {\n    if (typeof charCode === 'number') {\n      var obj1 = null;\n\n      if (!this.metrics.isSymbol && this.microsoftGlyphs != null) {\n        if (this.microsoftGlyphs.containsKey(charCode)) {\n          obj1 = this.microsoftGlyphs.getValue(charCode);\n        }\n      } else if (this.metrics.isSymbol && this.macintoshGlyphs != null) {\n        if (this.macintoshGlyphs.containsKey(charCode)) {\n          obj1 = this.macintoshGlyphs.getValue(charCode);\n        }\n      }\n\n      var glyph = obj1 != null ? obj1 : this.getDefaultGlyph();\n      return glyph;\n    } else {\n      var obj = null;\n      var code = charCode.charCodeAt(0);\n\n      if (!this.metrics.isSymbol && this.microsoft !== null) {\n        if (this.microsoft.containsKey(code)) {\n          obj = this.microsoft.getValue(code);\n\n          if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {\n            this.isFontPresent = true;\n          }\n        } else if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {\n          this.isFontPresent = false;\n        }\n      } else if (this.metrics.isSymbol && this.macintosh !== null || this.isMacTTF) {\n        // NOTE: this code fixes char codes that extends 0x100. However, it might corrupt something.\n        if (this.maxMacIndex !== 0) {\n          code %= this.maxMacIndex + 1;\n        } else {\n          code = (code & 0xff00) === 0xf000 ? code & 0xff : code;\n        }\n\n        if (this.macintosh.containsKey(code)) {\n          obj = this.macintosh.getValue(code);\n          this.isFontPresent = true;\n        }\n      } // Fix for StackOverFlow exception in XPS to PDF converter\n\n\n      if (charCode === StringTokenizer.whiteSpace && obj === null) {\n        obj = new TtfGlyphInfo();\n      }\n\n      var glyph = obj !== null ? obj : this.getDefaultGlyph();\n      return glyph;\n    }\n  };\n  /**\n   * Gets hash table with chars indexed by glyph index.\n   */\n\n\n  TtfReader.prototype.getGlyphChars = function (chars) {\n    if (chars === null || chars === undefined) {\n      throw new Error('Argument Null Exception : chars');\n    }\n\n    var dictionary = new Dictionary();\n    var charKeys = chars.keys();\n\n    for (var i = 0; i < charKeys.length; i++) {\n      var ch = charKeys[i];\n      var glyph = this.getGlyph(ch);\n\n      if (!glyph.empty) {\n        dictionary.setValue(glyph.index, ch.charCodeAt(0));\n      }\n    }\n\n    return dictionary;\n  };\n  /**\n   * Gets all glyphs.\n   */\n\n\n  TtfReader.prototype.getAllGlyphs = function () {\n    var allGlyphInfo = [];\n    var info = new TtfGlyphInfo();\n    var index = 0;\n\n    for (var i = 0; i < this.width.length; i++) {\n      var width = this.width[i];\n      info.index = index;\n      info.width = width;\n      allGlyphInfo.push(info);\n      index++;\n    }\n\n    return allGlyphInfo;\n  };\n  /**\n   * Reads a font's program.\n   * @private\n   */\n\n\n  TtfReader.prototype.readFontProgram = function (chars) {\n    var glyphChars = this.getGlyphChars(chars);\n    var locaTable = this.readLocaTable(this.bIsLocaShort);\n\n    if (glyphChars.size() < chars.size()) {\n      this.missedGlyphs = chars.size() - glyphChars.size();\n    }\n\n    this.updateGlyphChars(glyphChars, locaTable);\n    /* tslint:disable */\n\n    var result1 = this.generateGlyphTable(glyphChars, locaTable, null, null);\n    /* tslint:enable */\n\n    var glyphTableSize = result1.glyphTableSize;\n    var newLocaTable = result1.newLocaTable;\n    var newGlyphTable = result1.newGlyphTable;\n    var result2 = this.updateLocaTable(newLocaTable, this.bIsLocaShort, null);\n    var newLocaSize = result2.newLocaSize;\n    var newLocaUpdated = result2.newLocaUpdated;\n    var fontProgram = this.getFontProgram(newLocaUpdated, newGlyphTable, glyphTableSize, newLocaSize);\n    return fontProgram;\n  };\n  /**\n   * Reconverts string to be in proper format saved into PDF file.\n   */\n\n\n  TtfReader.prototype.convertString = function (text) {\n    if (text === null) {\n      throw new Error('Argument Null Exception : text');\n    }\n\n    var glyph = '';\n    var i = 0;\n\n    for (var k = 0; k < text.length; k++) {\n      var ch = text[k];\n      var glyphInfo = this.getGlyph(ch);\n\n      if (!glyphInfo.empty) {\n        glyph += String.fromCharCode(glyphInfo.index);\n        i++;\n      }\n    }\n\n    return glyph;\n  };\n  /**\n   * Gets char width.\n   */\n\n\n  TtfReader.prototype.getCharWidth = function (code) {\n    var glyphInfo = this.getGlyph(code);\n    glyphInfo = !glyphInfo.empty ? glyphInfo : this.getDefaultGlyph();\n    var codeWidth = !glyphInfo.empty ? glyphInfo.width : 0;\n    return codeWidth;\n  };\n\n  TtfReader.prototype.readString = function (length, isUnicode) {\n    if (isUnicode === undefined) {\n      return this.readString(length, false);\n    } else {\n      //let buffer : number[] = this.readBytes(length);\n      var result = '';\n\n      if (isUnicode) {\n        for (var i = 0; i < length; i++) {\n          if (i % 2 !== 0) {\n            result += String.fromCharCode(this.fontData[this.offset]);\n          }\n\n          this.offset += 1;\n        }\n      } else {\n        for (var i = 0; i < length; i++) {\n          result += String.fromCharCode(this.fontData[this.offset]);\n          this.offset += 1;\n        }\n      }\n\n      return result;\n    }\n  };\n\n  TtfReader.prototype.readFixed = function (offset) {\n    var integer = this.readInt16(offset);\n    var sFraction = this.readInt16(offset + 2);\n    var fraction = sFraction / 16384;\n    return integer + fraction;\n  };\n\n  TtfReader.prototype.readInt32 = function (offset) {\n    var i1 = this.fontData[offset + 3];\n    var i2 = this.fontData[offset + 2];\n    var i3 = this.fontData[offset + 1];\n    var i4 = this.fontData[offset];\n    this.offset += 4;\n    return i1 + (i2 << 8) + (i3 << 16) + (i4 << 24);\n  };\n\n  TtfReader.prototype.readUInt32 = function (offset) {\n    var i1 = this.fontData[offset + 3];\n    var i2 = this.fontData[offset + 2];\n    var i3 = this.fontData[offset + 1];\n    var i4 = this.fontData[offset];\n    this.offset += 4;\n    return i1 | i2 << 8 | i3 << 16 | i4 << 24;\n  }; // private readInt16(offset : number) : number {\n  //     let result : number = (this.fontData[offset] << 8) + this.fontData[offset + 1];\n  //     this.offset += 2;\n  //     return result;\n  // }\n\n\n  TtfReader.prototype.readInt16 = function (offset) {\n    var result = (this.fontData[offset] << 8) + this.fontData[offset + 1];\n    result = result & 1 << 15 ? result - 0x10000 : result;\n    this.offset += 2;\n    return result;\n  };\n\n  TtfReader.prototype.readInt64 = function (offset) {\n    var low = this.readInt32(offset + 4);\n    var n = this.readInt32(offset) * 4294967296.0 + low;\n\n    if (low < 0) {\n      n += 4294967296;\n    }\n\n    return n;\n  };\n\n  TtfReader.prototype.readUInt16 = function (offset) {\n    var result = this.fontData[offset] << 8 | this.fontData[offset + 1];\n    this.offset += 2;\n    return result;\n  };\n  /**\n   * Reads ushort array.\n   */\n\n\n  TtfReader.prototype.readUshortArray = function (length) {\n    var buffer = [];\n\n    for (var i = 0; i < length; i++) {\n      buffer[i] = this.readUInt16(this.offset);\n    }\n\n    return buffer;\n  };\n\n  TtfReader.prototype.readBytes = function (length) {\n    var result = [];\n\n    for (var i = 0; i < length; i++) {\n      result.push(this.fontData[this.offset]);\n      this.offset += 1;\n    }\n\n    return result;\n  };\n\n  TtfReader.prototype.readByte = function (offset) {\n    var result = this.fontData[offset];\n    this.offset += 1;\n    return result;\n  };\n  /**\n   * Reads bytes to array in BigEndian order.\n   * @private\n   */\n\n\n  TtfReader.prototype.read = function (buffer, index, count) {\n    if (buffer === null) {\n      throw new Error('Argument Null Exception : buffer');\n    }\n\n    var written = 0;\n    var read = 0;\n\n    do {\n      for (var i = 0; i < count - written && this.offset + i < this.fontData.length; i++) {\n        buffer[index + i] = this.fontData[this.offset + i];\n      }\n\n      read = count - written;\n      this.offset += read;\n      written += read;\n    } while (written < count);\n\n    return {\n      buffer: buffer,\n      written: written\n    };\n  };\n\n  return TtfReader;\n}();\n\nexport { TtfReader };","map":null,"metadata":{},"sourceType":"module"}