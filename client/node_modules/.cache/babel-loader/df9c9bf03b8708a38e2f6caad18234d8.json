{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * PdfLinearGradientBrush.ts class for EJ2-PDF\n */\n\n\nimport { PdfColorSpace } from './../enum';\nimport { PdfColor } from './../pdf-color';\nimport { PointF, Rectangle } from './../../drawing/pdf-drawing';\nimport { PdfDictionary } from '../../primitives/pdf-dictionary';\nimport { DictionaryProperties } from './../../input-output/pdf-dictionary-properties';\nimport { PdfBoolean } from '../../primitives/pdf-boolean';\nimport { PdfArray } from './../../primitives/pdf-array';\nimport { PdfNumber } from './../../primitives/pdf-number';\nimport { PdfColorBlend } from './pdf-color-blend';\nimport { PdfGradientBrush } from './pdf-gradient-brush';\nimport { PdfExtend, PdfLinearGradientMode, ShadingType } from './enum';\n/**\n * `PdfLinearGradientBrush` Implements linear gradient brush by using PDF axial shading pattern.\n * @private\n */\n\nvar PdfLinearGradientBrush =\n/** @class */\nfunction (_super) {\n  __extends(PdfLinearGradientBrush, _super);\n  /**\n   * Initializes a new instance of the `PdfLinearGradientBrush` class.\n   * @public\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  function PdfLinearGradientBrush(arg1, arg2, arg3, arg4) {\n    var _this = _super.call(this, new PdfDictionary()) || this;\n    /**\n     * Local variable to store the dictionary properties.\n     * @private\n     */\n\n\n    _this.mDictionaryProperties = new DictionaryProperties();\n\n    if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PdfColor && arg4 instanceof PdfColor) {\n      _this.initialize(arg3, arg4);\n\n      _this.mPointStart = arg1;\n      _this.mPointEnd = arg2;\n\n      _this.setPoints(_this.mPointStart, _this.mPointEnd);\n    } else if (arg1 instanceof Rectangle) {\n      _this.initialize(arg2, arg3);\n      /* tslint:disable-next-line:max-line-length */\n\n\n      if (arg4 === PdfLinearGradientMode.BackwardDiagonal || arg4 === PdfLinearGradientMode.ForwardDiagonal || arg4 === PdfLinearGradientMode.Horizontal || arg4 === PdfLinearGradientMode.Vertical) {\n        _this.mBoundaries = arg1;\n\n        switch (arg4) {\n          case PdfLinearGradientMode.BackwardDiagonal:\n            _this.mPointStart = new PointF(arg1.right, arg1.top);\n            _this.mPointEnd = new PointF(arg1.left, arg1.bottom);\n            break;\n\n          case PdfLinearGradientMode.ForwardDiagonal:\n            _this.mPointStart = new PointF(arg1.left, arg1.top);\n            _this.mPointEnd = new PointF(arg1.right, arg1.bottom);\n            break;\n\n          case PdfLinearGradientMode.Horizontal:\n            _this.mPointStart = new PointF(arg1.left, arg1.top);\n            _this.mPointEnd = new PointF(arg1.right, arg1.top);\n            break;\n\n          case PdfLinearGradientMode.Vertical:\n            _this.mPointStart = new PointF(arg1.left, arg1.top);\n            _this.mPointEnd = new PointF(arg1.left, arg1.bottom);\n            break;\n\n          default:\n            throw new Error('ArgumentException -- Unsupported linear gradient mode: ' + arg4 + ' mode');\n        }\n\n        _this.setPoints(_this.mPointStart, _this.mPointEnd);\n      } else if (typeof arg4 === 'number' && typeof arg4 !== 'undefined') {\n        _this.mBoundaries = arg1;\n        arg4 = arg4 % 360;\n\n        if (arg4 === 0) {\n          _this.mPointStart = new PointF(arg1.left, arg1.top);\n          _this.mPointEnd = new PointF(arg1.right, arg1.top);\n        } else if (arg4 === 90) {\n          _this.mPointStart = new PointF(arg1.left, arg1.top);\n          _this.mPointEnd = new PointF(arg1.left, arg1.bottom);\n        } else if (arg4 === 180) {\n          _this.mPointEnd = new PointF(arg1.left, arg1.top);\n          _this.mPointStart = new PointF(arg1.right, arg1.top);\n        } else if (arg4 === 270) {\n          _this.mPointEnd = new PointF(arg1.left, arg1.top);\n          _this.mPointStart = new PointF(arg1.left, arg1.bottom);\n        } else {\n          var d2r = Math.PI / 180;\n          var radAngle = arg4 * d2r;\n          var k = Math.tan(radAngle);\n          var x = _this.mBoundaries.left + (_this.mBoundaries.right - _this.mBoundaries.left) / 2;\n          var y = _this.mBoundaries.top + (_this.mBoundaries.bottom - _this.mBoundaries.top) / 2;\n          var centre = new PointF(x, y);\n          x = _this.mBoundaries.width / (2 * Math.cos(radAngle));\n          y = k * x;\n          x = x + centre.x;\n          y = y + centre.y;\n          var p1 = new PointF(x, y);\n\n          var cp1 = _this.subPoints(p1, centre); //  P1 - P0\n\n\n          var p = _this.choosePoint(arg4);\n\n          var coef = _this.mulPoints(_this.subPoints(p, centre), cp1) / _this.mulPoints(cp1, cp1);\n\n          _this.mPointEnd = _this.addPoints(centre, _this.mulPoint(cp1, coef)); //  Parametric line equation.\n\n          _this.mPointStart = _this.addPoints(centre, _this.mulPoint(cp1, coef * -1));\n        }\n\n        _this.setPoints(_this.mPointEnd, _this.mPointStart);\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Initializes a new instance of the `PdfLinearGradientBrush` class.\n   * @param color1 The starting color of the gradient.\n   * @param color2 The end color of the gradient.\n   */\n\n\n  PdfLinearGradientBrush.prototype.initialize = function (color1, color2) {\n    this.mColours = [color1, color2];\n    this.mColourBlend = new PdfColorBlend(2);\n    this.mColourBlend.positions = [0, 1];\n    this.mColourBlend.colors = this.mColours;\n    this.initShading();\n  };\n\n  Object.defineProperty(PdfLinearGradientBrush.prototype, \"blend\", {\n    //Properties\n\n    /**\n     * Gets or sets a PdfBlend that specifies positions\n     * and factors that define a custom falloff for the gradient.\n     * @public\n     */\n    get: function () {\n      return this.mBlend;\n    },\n    set: function (value) {\n      if (value == null) {\n        throw new Error('ArgumentNullException : Blend');\n      }\n\n      if (this.mColours == null) {\n        throw new Error('NotSupportedException : There is no starting and ending colours specified.');\n      }\n\n      this.mBlend = value; //  TODO: generate correct colour blend.\n\n      this.mColourBlend = this.mBlend.generateColorBlend(this.mColours, this.colorSpace);\n      this.resetFunction();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfLinearGradientBrush.prototype, \"interpolationColors\", {\n    /**\n     * Gets or sets a ColorBlend that defines a multicolor linear gradient.\n     * @public\n     */\n    get: function () {\n      return this.mColourBlend;\n    },\n    set: function (value) {\n      if (value == null) {\n        throw new Error('ArgumentNullException : InterpolationColors');\n      }\n\n      this.mBlend = null;\n      this.mColours = null;\n      this.mColourBlend = value;\n      this.resetFunction();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfLinearGradientBrush.prototype, \"linearColors\", {\n    /**\n     * Gets or sets the starting and ending colors of the gradient.\n     * @public\n     */\n    get: function () {\n      return this.mColours;\n    },\n    set: function (value) {\n      if (value == null) {\n        throw new Error('ArgumentNullException : LinearColors');\n      }\n\n      if (value.length < 2) {\n        throw new Error('ArgumentException : The array is too small - LinearColors');\n      }\n\n      if (this.mColours == null && typeof this.mColours === 'undefined') {\n        this.mColours = [value[0], value[1]];\n      } else {\n        this.mColours[0] = value[0];\n        this.mColours[1] = value[1];\n      }\n\n      if (this.mBlend == null && typeof this.mBlend === 'undefined') {\n        //  Set correct colour blend.\n        this.mColourBlend = new PdfColorBlend(2);\n        this.mColourBlend.colors = this.mColours;\n        this.mColourBlend.positions = [0, 1];\n      } else {\n        this.mColourBlend = this.mBlend.generateColorBlend(this.mColours, this.colorSpace);\n      }\n\n      this.resetFunction();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfLinearGradientBrush.prototype, \"rectangle\", {\n    /**\n     * Gets a rectangular region that defines the boundaries of the gradient.\n     * @public\n     */\n    get: function () {\n      return this.mBoundaries;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfLinearGradientBrush.prototype, \"extend\", {\n    /**\n     * Gets or sets the value indicating whether the gradient should extend starting and ending points.\n     * @public\n     */\n    get: function () {\n      var result = PdfExtend.None;\n      var extend = this.shading.items.getValue(this.mDictionaryProperties.extend);\n\n      if (extend != null) {\n        var extStart = extend.items(0);\n        var extEnd = extend.items(1);\n\n        if (extStart.value) {\n          result = result | PdfExtend.Start;\n        }\n\n        if (extEnd.value) {\n          result = result | PdfExtend.End;\n        }\n      }\n\n      return result;\n    },\n    set: function (value) {\n      var extend = this.shading.items.getValue(this.mDictionaryProperties.extend);\n      var extStart;\n      var extEnd;\n\n      if (extend == null) {\n        extStart = new PdfBoolean(false);\n        extEnd = new PdfBoolean(false);\n        extend = new PdfArray();\n        extend.add(extStart);\n        extend.add(extEnd);\n        this.shading.items.setValue(this.mDictionaryProperties.extend, extend);\n      } else {\n        extStart = extend.items(0);\n        extEnd = extend.items(1);\n      } // extStart.value = ((value && PdfExtend.Start) > 0);\n      // extEnd.value = ((value && PdfExtend.End) > 0);\n\n    },\n    enumerable: true,\n    configurable: true\n  }); //Implementation\n\n  /**\n   * Adds two points to each other.\n   * @param point1 The point1.\n   * @param point2 The point2.\n   */\n\n  PdfLinearGradientBrush.prototype.addPoints = function (point1, point2) {\n    var x = point1.x + point2.x;\n    var y = point1.y + point2.y;\n    var result = new PointF(x, y);\n    return result;\n  };\n  /**\n   * Subs the second point from the first one.\n   * @param point1 The point1.\n   * @param point2 The point2.\n   */\n\n\n  PdfLinearGradientBrush.prototype.subPoints = function (point1, point2) {\n    var x = point1.x - point2.x;\n    var y = point1.y - point2.y;\n    var result = new PointF(x, y);\n    return result;\n  };\n  /**\n   * Makes scalar multiplication of two points.\n   * @param point1 The point1.\n   * @param point2 The point2.\n   */\n\n\n  PdfLinearGradientBrush.prototype.mulPoints = function (point1, point2) {\n    var result = point1.x * point2.x + point1.y * point2.y;\n    return result;\n  };\n  /**\n   * Multiplies the point by the value specified.\n   * @param point The point1.\n   * @param value The value.\n   */\n\n\n  PdfLinearGradientBrush.prototype.mulPoint = function (point, value) {\n    point.x = point.x * value;\n    point.y = point.y * value;\n    return point;\n  };\n  /**\n   * Choose the point according to the angle.\n   * @param angle The angle.\n   */\n\n\n  PdfLinearGradientBrush.prototype.choosePoint = function (angle) {\n    var point = new PointF(0, 0); //  Choose the correct point.\n\n    if (angle < 90 && angle > 0) {\n      point = new PointF(this.mBoundaries.right, this.mBoundaries.bottom);\n    } else if (angle < 180 && angle > 90) {\n      point = new PointF(this.mBoundaries.left, this.mBoundaries.bottom);\n    } else if (angle < 270 && angle > 180) {\n      point = new PointF(this.mBoundaries.left, this.mBoundaries.top);\n    } else if (angle > 270) {\n      point = new PointF(this.mBoundaries.right, this.mBoundaries.top);\n    } else {\n      throw new Error('PdfException - Internal error.');\n    }\n\n    return point;\n  };\n  /**\n   * Sets the start and end points.\n   * @param point1 The point1.\n   * @param point2 The point2.\n   */\n\n\n  PdfLinearGradientBrush.prototype.setPoints = function (point1, point2) {\n    var points = new PdfArray();\n    points.add(new PdfNumber(point1.x));\n    points.add(new PdfNumber(this.updateY(point1.y)));\n    points.add(new PdfNumber(point2.x));\n    points.add(new PdfNumber(this.updateY(point2.y)));\n    this.shading.items.setValue(this.mDictionaryProperties.coords, points);\n  };\n  /**\n   * Updates y co-ordinate.\n   * @param y Y co-ordinate..\n   */\n\n\n  PdfLinearGradientBrush.prototype.updateY = function (y) {\n    if (y !== 0) {\n      return -y;\n    } else {\n      return y;\n    }\n  }; //Overrides\n\n  /**\n   * Initializes the shading dictionary.\n   * @private\n   */\n\n\n  PdfLinearGradientBrush.prototype.initShading = function () {\n    this.colorSpace = PdfColorSpace.Rgb;\n    this.function = this.mColourBlend.getFunction(this.colorSpace);\n    this.shading.items.setValue(this.mDictionaryProperties.shadingType, new PdfNumber(ShadingType.Axial));\n  }; //Overrides\n\n  /**\n   * Creates a new copy of a brush.\n   * @public\n   */\n\n\n  PdfLinearGradientBrush.prototype.clone = function () {\n    var brush = this;\n    brush.resetPatternDictionary(new PdfDictionary(this.patternDictionary));\n    brush.shading = new PdfDictionary();\n    brush.initShading();\n    brush.setPoints(brush.mPointStart, brush.mPointEnd);\n\n    if (brush !== null && brush instanceof PdfLinearGradientBrush) {\n      if (this.matrix != null && typeof this.matrix !== 'undefined') {\n        brush.matrix = this.matrix.clone();\n      }\n    }\n\n    if (this.mColours != null && typeof this.mColours !== 'undefined') {\n      brush.mColours = this.mColours;\n    }\n\n    if (this.blend != null && typeof this.blend !== 'undefined') {\n      brush.blend = this.blend.clonePdfBlend();\n    } else if (this.interpolationColors != null && typeof this.interpolationColors !== 'undefined') {\n      brush.interpolationColors = this.interpolationColors.cloneColorBlend();\n    }\n\n    brush.extend = this.extend;\n    this.cloneBackgroundValue(brush);\n    this.cloneAntiAliasingValue(brush);\n    return brush;\n  };\n  /**\n   * Resets the function.\n   * @public\n   */\n\n\n  PdfLinearGradientBrush.prototype.resetFunction = function () {\n    this.function = this.mColourBlend.getFunction(this.colorSpace);\n  };\n\n  return PdfLinearGradientBrush;\n}(PdfGradientBrush);\n\nexport { PdfLinearGradientBrush };","map":null,"metadata":{},"sourceType":"module"}