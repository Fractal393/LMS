{"ast":null,"code":"// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\"use strict\";\n\nvar d = require(\"d\"),\n    validateSymbol = require(\"./validate-symbol\"),\n    NativeSymbol = require(\"ext/global-this\").Symbol,\n    generateName = require(\"./lib/private/generate-name\"),\n    setupStandardSymbols = require(\"./lib/private/setup/standard-symbols\"),\n    setupSymbolRegistry = require(\"./lib/private/setup/symbol-registry\");\n\nvar create = Object.create,\n    defineProperties = Object.defineProperties,\n    defineProperty = Object.defineProperty;\nvar SymbolPolyfill, HiddenSymbol, isNativeSafe;\n\nif (typeof NativeSymbol === \"function\") {\n  try {\n    String(NativeSymbol());\n    isNativeSafe = true;\n  } catch (ignore) {}\n} else {\n  NativeSymbol = null;\n} // Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\n\n\nHiddenSymbol = function Symbol(description) {\n  if (this instanceof HiddenSymbol) throw new TypeError(\"Symbol is not a constructor\");\n  return SymbolPolyfill(description);\n}; // Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\n\n\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n  var symbol;\n  if (this instanceof Symbol) throw new TypeError(\"Symbol is not a constructor\");\n  if (isNativeSafe) return NativeSymbol(description);\n  symbol = create(HiddenSymbol.prototype);\n  description = description === undefined ? \"\" : String(description);\n  return defineProperties(symbol, {\n    __description__: d(\"\", description),\n    __name__: d(\"\", generateName(description))\n  });\n};\n\nsetupStandardSymbols(SymbolPolyfill);\nsetupSymbolRegistry(SymbolPolyfill); // Internal tweaks for real symbol producer\n\ndefineProperties(HiddenSymbol.prototype, {\n  constructor: d(SymbolPolyfill),\n  toString: d(\"\", function () {\n    return this.__name__;\n  })\n}); // Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\n\ndefineProperties(SymbolPolyfill.prototype, {\n  toString: d(function () {\n    return \"Symbol (\" + validateSymbol(this).__description__ + \")\";\n  }),\n  valueOf: d(function () {\n    return validateSymbol(this);\n  })\n});\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d(\"\", function () {\n  var symbol = validateSymbol(this);\n  if (typeof symbol === \"symbol\") return symbol;\n  return symbol.toString();\n}));\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d(\"c\", \"Symbol\")); // Proper implementaton of toPrimitive and toStringTag for returned symbol instances\n\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])); // Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\n\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));","map":null,"metadata":{},"sourceType":"script"}