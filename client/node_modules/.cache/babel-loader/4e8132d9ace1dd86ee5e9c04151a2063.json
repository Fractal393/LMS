{"ast":null,"code":"/**\r\n * DevExtreme (ui/grid_core/ui.grid_core.adaptivity.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _events_engine = require(\"../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _utils = require(\"../../events/utils\");\n\nvar eventUtils = _interopRequireWildcard(_utils);\n\nvar _click = require(\"../../events/click\");\n\nvar _click2 = _interopRequireDefault(_click);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _browser = require(\"../../core/utils/browser\");\n\nvar _browser2 = _interopRequireDefault(_browser);\n\nvar _guid = require(\"../../core/guid\");\n\nvar _guid2 = _interopRequireDefault(_guid);\n\nvar _uiGrid_core = require(\"./ui.grid_core.modules\");\n\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\n\nvar _form = require(\"../form\");\n\nvar _form2 = _interopRequireDefault(_form);\n\nvar _uiGrid_core3 = require(\"./ui.grid_core.utils\");\n\nvar _uiGrid_core4 = _interopRequireDefault(_uiGrid_core3);\n\nvar _themes = require(\"../themes\");\n\nvar _themes2 = _interopRequireDefault(_themes);\n\nvar _window = require(\"../../core/utils/window\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _getRequireWildcardCache() {\n  if (\"function\" !== typeof WeakMap) {\n    return null;\n  }\n\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (null === obj || \"object\" !== _typeof(obj) && \"function\" !== typeof obj) {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar COLUMN_HEADERS_VIEW = \"columnHeadersView\";\nvar ROWS_VIEW = \"rowsView\";\nvar FOOTER_VIEW = \"footerView\";\nvar COLUMN_VIEWS = [COLUMN_HEADERS_VIEW, ROWS_VIEW, FOOTER_VIEW];\nvar ADAPTIVE_NAMESPACE = \"dxDataGridAdaptivity\";\nvar HIDDEN_COLUMNS_WIDTH = \"adaptiveHidden\";\nvar ADAPTIVE_ROW_TYPE = \"detailAdaptive\";\nvar FORM_ITEM_CONTENT_CLASS = \"dx-field-item-content\";\nvar FORM_ITEM_MODIFIED = \"dx-item-modified\";\nvar HIDDEN_COLUMN_CLASS = \"hidden-column\";\nvar ADAPTIVE_COLUMN_BUTTON_CLASS = \"adaptive-more\";\nvar ADAPTIVE_COLUMN_NAME_CLASS = \"dx-command-adaptive\";\nvar COMMAND_ADAPTIVE_HIDDEN_CLASS = \"dx-command-adaptive-hidden\";\nvar ADAPTIVE_DETAIL_ROW_CLASS = \"dx-adaptive-detail-row\";\nvar ADAPTIVE_ITEM_TEXT_CLASS = \"dx-adaptive-item-text\";\nvar MASTER_DETAIL_CELL_CLASS = \"dx-master-detail-cell\";\nvar LAST_DATA_CELL_CLASS = \"dx-last-data-cell\";\nvar ADAPTIVE_COLUMN_NAME = \"adaptive\";\nvar EDIT_MODE_BATCH = \"batch\";\nvar EDIT_MODE_ROW = \"row\";\nvar EDIT_MODE_FORM = \"form\";\nvar EDIT_MODE_POPUP = \"popup\";\nvar REVERT_TOOLTIP_CLASS = \"revert-tooltip\";\nvar GROUP_CELL_CLASS = \"dx-group-cell\";\n\nfunction getColumnId(that, column) {\n  return that._columnsController.getColumnId(column);\n}\n\nfunction getDataCellElements($row) {\n  return $row.find(\"td:not(.dx-datagrid-hidden-column):not([class*='dx-command-'])\");\n}\n\nfunction adaptiveCellTemplate(container, options) {\n  var $adaptiveColumnButton;\n  var $container = (0, _renderer2.default)(container);\n  var adaptiveColumnsController = options.component.getController(\"adaptiveColumns\");\n\n  if (\"data\" === options.rowType) {\n    $adaptiveColumnButton = (0, _renderer2.default)(\"<span>\").addClass(adaptiveColumnsController.addWidgetPrefix(ADAPTIVE_COLUMN_BUTTON_CLASS));\n\n    _events_engine2.default.on($adaptiveColumnButton, eventUtils.addNamespace(_click2.default.name, ADAPTIVE_NAMESPACE), adaptiveColumnsController.createAction(function () {\n      adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options.key);\n    }));\n\n    $adaptiveColumnButton.appendTo($container);\n  } else {\n    _uiGrid_core4.default.setEmptyText($container);\n  }\n}\n\nvar AdaptiveColumnsController = _uiGrid_core2.default.ViewController.inherit({\n  _isRowEditMode: function () {\n    var editMode = this._getEditMode();\n\n    return editMode === EDIT_MODE_ROW;\n  },\n  _isItemModified: function (item, cellOptions) {\n    var columnIndex = this._columnsController.getVisibleIndex(item.column.index);\n\n    var rowIndex = this._dataController.getRowIndexByKey(cellOptions.key);\n\n    var row = this._dataController.items()[rowIndex + 1];\n\n    return row && row.modifiedValues && _type2.default.isDefined(row.modifiedValues[columnIndex]);\n  },\n  _renderFormViewTemplate: function (item, cellOptions, $container) {\n    var that = this;\n    var column = item.column;\n    var focusAction = that.createAction(function () {\n      _events_engine2.default.trigger($container, _click2.default.name);\n    });\n    var value = column.calculateCellValue(cellOptions.data);\n\n    var displayValue = _uiGrid_core4.default.getDisplayValue(column, value, cellOptions.data, cellOptions.rowType);\n\n    var text = _uiGrid_core4.default.formatValue(displayValue, column);\n\n    var isCellOrBatchEditMode = this._editingController.isCellOrBatchEditMode();\n\n    var rowsView = that._rowsView;\n\n    if (column.allowEditing && that.getController(\"keyboardNavigation\").isKeyboardEnabled()) {\n      $container.attr(\"tabIndex\", that.option(\"tabIndex\"));\n\n      if (isCellOrBatchEditMode) {\n        _events_engine2.default.off($container, \"focus\", focusAction);\n\n        _events_engine2.default.on($container, \"focus\", focusAction);\n      }\n    }\n\n    if (column.cellTemplate) {\n      var templateOptions = (0, _extend.extend)({}, cellOptions, {\n        value: value,\n        displayValue: displayValue,\n        text: text,\n        column: column\n      });\n      var isDomElement = !!$container.closest((0, _window.getWindow)().document).length;\n      rowsView.renderTemplate($container, column.cellTemplate, templateOptions, isDomElement).done(function () {\n        rowsView._cellPrepared($container, cellOptions);\n      });\n    } else {\n      var container = $container.get(0);\n\n      if (column.encodeHtml) {\n        container.textContent = text;\n      } else {\n        container.innerHTML = text;\n      }\n\n      $container.addClass(ADAPTIVE_ITEM_TEXT_CLASS);\n\n      if (!_type2.default.isDefined(text) || \"\" === text) {\n        $container.html(\"&nbsp;\");\n      }\n\n      if (!that._isRowEditMode()) {\n        if (that._isItemModified(item, cellOptions)) {\n          $container.addClass(FORM_ITEM_MODIFIED);\n        }\n      }\n\n      rowsView._cellPrepared($container, cellOptions);\n    }\n  },\n  _getTemplate: function (item, cellOptions) {\n    var that = this;\n    var column = item.column;\n    var editingController = this.getController(\"editing\");\n    return function (options, container) {\n      var $container = (0, _renderer2.default)(container);\n\n      var columnIndex = that._columnsController.getVisibleIndex(column.visibleIndex);\n\n      var templateOptions = (0, _extend.extend)({}, cellOptions);\n\n      var renderFormTemplate = function () {\n        var isItemEdited = that._isItemEdited(item);\n\n        templateOptions.value = cellOptions.row.values[columnIndex];\n\n        if (isItemEdited || column.showEditorAlways) {\n          editingController.renderFormEditTemplate(templateOptions, item, options.component, $container, !isItemEdited);\n        } else {\n          templateOptions.column = column;\n          templateOptions.columnIndex = columnIndex;\n\n          that._renderFormViewTemplate(item, templateOptions, $container);\n        }\n      };\n\n      renderFormTemplate();\n      templateOptions.watch && templateOptions.watch(function () {\n        return {\n          isItemEdited: that._isItemEdited(item),\n          value: cellOptions.row.values[columnIndex]\n        };\n      }, function () {\n        $container.contents().remove();\n        $container.removeClass(ADAPTIVE_ITEM_TEXT_CLASS);\n        renderFormTemplate();\n      });\n    };\n  },\n  _isVisibleColumnsValid: function (visibleColumns) {\n    var getCommandColumnsCount = function () {\n      var result = 0;\n\n      for (var j = 0; j < visibleColumns.length; j++) {\n        var visibleColumn = visibleColumns[j];\n\n        if (visibleColumn.command) {\n          result++;\n        }\n      }\n\n      return result;\n    };\n\n    if (visibleColumns < 2) {\n      return false;\n    }\n\n    if (visibleColumns.length - getCommandColumnsCount() <= 1) {\n      return false;\n    }\n\n    return true;\n  },\n  _calculatePercentWidths: function (widths, visibleColumns) {\n    var that = this;\n    var percentWidths = 0;\n    visibleColumns.forEach(function (item, index) {\n      if (widths[index] !== HIDDEN_COLUMNS_WIDTH) {\n        percentWidths += that._getItemPercentWidth(item);\n      }\n    });\n    return percentWidths;\n  },\n  _isPercentWidth: function (width) {\n    return _type2.default.isString(width) && \"%\" === width.slice(-1);\n  },\n  _isColumnHidden: function (column) {\n    return this._hiddenColumns.filter(function (hiddenColumn) {\n      return hiddenColumn.index === column.index;\n    }).length > 0;\n  },\n  _getAverageColumnsWidth: function (containerWidth, columns, columnsCanFit) {\n    var that = this;\n    var fixedColumnsWidth = 0;\n    var columnsWithoutFixedWidthCount = 0;\n    columns.forEach(function (column) {\n      if (!that._isColumnHidden(column)) {\n        var width = column.width;\n\n        if (_type2.default.isDefined(width) && !isNaN(parseFloat(width))) {\n          fixedColumnsWidth += that._isPercentWidth(width) ? that._calculatePercentWidth({\n            visibleIndex: column.visibleIndex,\n            columnsCount: columns.length,\n            columnsCanFit: columnsCanFit,\n            bestFitWidth: column.bestFitWidth,\n            columnWidth: width,\n            containerWidth: containerWidth\n          }) : parseFloat(width);\n        } else {\n          columnsWithoutFixedWidthCount++;\n        }\n      }\n    });\n    return (containerWidth - fixedColumnsWidth) / columnsWithoutFixedWidthCount;\n  },\n  _calculateColumnWidth: function (column, containerWidth, contentColumns, columnsCanFit) {\n    var columnId = getColumnId(this, column);\n\n    var widthOption = this._columnsController.columnOption(columnId, \"width\");\n\n    var bestFitWidth = this._columnsController.columnOption(columnId, \"bestFitWidth\");\n\n    var columnsCount = contentColumns.length;\n    var colWidth;\n\n    if (widthOption && \"auto\" !== widthOption) {\n      if (this._isPercentWidth(widthOption)) {\n        colWidth = this._calculatePercentWidth({\n          visibleIndex: column.visibleIndex,\n          columnsCount: columnsCount,\n          columnsCanFit: columnsCanFit,\n          bestFitWidth: bestFitWidth,\n          columnWidth: widthOption,\n          containerWidth: containerWidth\n        });\n      } else {\n        return widthOption;\n      }\n    } else {\n      var columnAutoWidth = this.option(\"columnAutoWidth\");\n      colWidth = columnAutoWidth || !!column.command ? bestFitWidth : this._getAverageColumnsWidth(containerWidth, contentColumns, columnsCanFit);\n    }\n\n    return colWidth;\n  },\n  _calculatePercentWidth: function (options) {\n    var columnFitted = options.visibleIndex < options.columnsCount - 1 && options.columnsCanFit;\n    var partialWidth = options.containerWidth * parseFloat(options.columnWidth) / 100;\n    var resultWidth = options.columnsCanFit && partialWidth < options.bestFitWidth ? options.bestFitWidth : partialWidth;\n    return columnFitted ? options.containerWidth * parseFloat(options.columnWidth) / 100 : resultWidth;\n  },\n  _getNotTruncatedColumnWidth: function (column, containerWidth, contentColumns, columnsCanFit) {\n    var columnId = getColumnId(this, column);\n\n    var widthOption = this._columnsController.columnOption(columnId, \"width\");\n\n    var bestFitWidth = this._columnsController.columnOption(columnId, \"bestFitWidth\");\n\n    if (widthOption && \"auto\" !== widthOption && !this._isPercentWidth(widthOption)) {\n      return parseFloat(widthOption);\n    }\n\n    var colWidth = this._calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit);\n\n    return colWidth < bestFitWidth ? null : colWidth;\n  },\n  _getItemPercentWidth: function (item) {\n    var result = 0;\n\n    if (item.width && this._isPercentWidth(item.width)) {\n      result = parseFloat(item.width);\n    }\n\n    return result;\n  },\n  _getCommandColumnsWidth: function () {\n    var that = this;\n\n    var columns = that._columnsController.getVisibleColumns();\n\n    var colWidth = 0;\n    (0, _iterator.each)(columns, function (index, column) {\n      if (column.index < 0 || column.command) {\n        colWidth += that._columnsController.columnOption(getColumnId(that, column), \"bestFitWidth\") || 0;\n      }\n    });\n    return colWidth;\n  },\n  _isItemEdited: function (item) {\n    if (this.isFormEditMode()) {\n      return false;\n    }\n\n    if (this._isRowEditMode()) {\n      var editRowKey = this._editingController.getEditRowKey();\n\n      if ((0, _common.equalByValue)(editRowKey, this._dataController.adaptiveExpandedKey())) {\n        return true;\n      }\n    } else {\n      var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;\n\n      var columnIndex = this._columnsController.getVisibleIndex(item.column.index);\n\n      return this._editingController.isEditCell(rowIndex, columnIndex);\n    }\n  },\n  _getFormItemsByHiddenColumns: function (hiddenColumns) {\n    var items = [];\n    (0, _iterator.each)(hiddenColumns, function (_, column) {\n      items.push({\n        column: column,\n        name: column.name,\n        dataField: column.dataField,\n        visibleIndex: column.visibleIndex\n      });\n    });\n    return items;\n  },\n  _getAdaptiveColumnVisibleIndex: function (visibleColumns) {\n    for (var i = 0; i < visibleColumns.length; i++) {\n      var column = visibleColumns[i];\n\n      if (column.command === ADAPTIVE_COLUMN_NAME) {\n        return i;\n      }\n    }\n  },\n  _hideAdaptiveColumn: function (resultWidths, visibleColumns) {\n    var visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);\n\n    if (_type2.default.isDefined(visibleIndex)) {\n      resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH;\n\n      this._hideVisibleColumn({\n        isCommandColumn: true,\n        visibleIndex: visibleIndex\n      });\n    }\n  },\n  _showHiddenCellsInView: function (_ref) {\n    var $cells = _ref.$cells,\n        isCommandColumn = _ref.isCommandColumn;\n    var cssClassNameToRemove = isCommandColumn ? COMMAND_ADAPTIVE_HIDDEN_CLASS : this.addWidgetPrefix(HIDDEN_COLUMN_CLASS);\n    $cells.removeClass(cssClassNameToRemove);\n  },\n  _showHiddenColumns: function () {\n    for (var i = 0; i < COLUMN_VIEWS.length; i++) {\n      var view = this.getView(COLUMN_VIEWS[i]);\n\n      if (view && view.isVisible() && view.element()) {\n        var viewName = view.name;\n        var $hiddenCommandCells = view.element().find(\".\" + COMMAND_ADAPTIVE_HIDDEN_CLASS);\n\n        this._showHiddenCellsInView({\n          viewName: viewName,\n          $cells: $hiddenCommandCells,\n          isCommandColumn: true\n        });\n\n        var $hiddenCells = view.element().find(\".\" + this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));\n\n        this._showHiddenCellsInView({\n          viewName: viewName,\n          $cells: $hiddenCells\n        });\n      }\n    }\n  },\n  _isCellValid: function ($cell) {\n    return $cell && $cell.length && !$cell.hasClass(MASTER_DETAIL_CELL_CLASS) && !$cell.hasClass(GROUP_CELL_CLASS);\n  },\n  _hideVisibleColumn: function (_ref2) {\n    var isCommandColumn = _ref2.isCommandColumn,\n        visibleIndex = _ref2.visibleIndex;\n    var that = this;\n    COLUMN_VIEWS.forEach(function (viewName) {\n      var view = that.getView(viewName);\n      view && that._hideVisibleColumnInView({\n        view: view,\n        isCommandColumn: isCommandColumn,\n        visibleIndex: visibleIndex\n      });\n    });\n  },\n  _hideVisibleColumnInView: function (_ref3) {\n    var view = _ref3.view,\n        isCommandColumn = _ref3.isCommandColumn,\n        visibleIndex = _ref3.visibleIndex;\n    var viewName = view.name;\n    var $cellElement;\n\n    var column = this._columnsController.getVisibleColumns()[visibleIndex];\n\n    var editFormRowIndex = this._editingController && this._editingController.getEditFormRowIndex();\n\n    if (view && view.isVisible() && column) {\n      var rowsCount = view.getRowsCount();\n\n      var $rowElements = view._getRowElements();\n\n      for (var rowIndex = 0; rowIndex < rowsCount; rowIndex++) {\n        var cancelClassAdding = rowIndex === editFormRowIndex && viewName === ROWS_VIEW && \"popup\" !== this.option(\"editing.mode\");\n\n        if (!cancelClassAdding) {\n          var currentVisibleIndex = viewName === COLUMN_HEADERS_VIEW ? this._columnsController.getVisibleIndex(column.index, rowIndex) : visibleIndex;\n\n          if (currentVisibleIndex >= 0) {\n            $cellElement = $rowElements.eq(rowIndex).children().eq(currentVisibleIndex);\n            this._isCellValid($cellElement) && this._hideVisibleCellInView({\n              viewName: viewName,\n              isCommandColumn: isCommandColumn,\n              $cell: $cellElement\n            });\n          }\n        }\n      }\n    }\n  },\n  _hideVisibleCellInView: function (_ref4) {\n    var $cell = _ref4.$cell,\n        isCommandColumn = _ref4.isCommandColumn;\n    var cssClassNameToAdd = isCommandColumn ? COMMAND_ADAPTIVE_HIDDEN_CLASS : this.addWidgetPrefix(HIDDEN_COLUMN_CLASS);\n    $cell.addClass(cssClassNameToAdd);\n  },\n  _getEditMode: function () {\n    return this._editingController.getEditMode();\n  },\n  isFormEditMode: function () {\n    var editMode = this._getEditMode();\n\n    return editMode === EDIT_MODE_FORM || editMode === EDIT_MODE_POPUP;\n  },\n  hideRedundantColumns: function (resultWidths, visibleColumns, hiddenQueue) {\n    var that = this;\n    this._hiddenColumns = [];\n\n    if (that._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {\n      var totalWidth = 0;\n      var $rootElement = that.component.$element();\n\n      var rootElementWidth = $rootElement.width() - that._getCommandColumnsWidth();\n\n      var getVisibleContentColumns = function () {\n        var _this = this;\n\n        return visibleColumns.filter(function (item) {\n          return !item.command && 0 === _this._hiddenColumns.filter(function (i) {\n            return i.index === item.index;\n          }).length;\n        });\n      }.bind(this);\n\n      var visibleContentColumns = getVisibleContentColumns();\n      var contentColumnsCount = visibleContentColumns.length;\n      var i;\n      var hasHiddenColumns;\n      var needHideColumn;\n\n      do {\n        needHideColumn = false;\n        totalWidth = 0;\n\n        var percentWidths = that._calculatePercentWidths(resultWidths, visibleColumns);\n\n        var columnsCanFit = percentWidths < 100 && 0 !== percentWidths;\n\n        for (i = 0; i < visibleColumns.length; i++) {\n          var visibleColumn = visibleColumns[i];\n\n          var columnWidth = that._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, visibleContentColumns, columnsCanFit);\n\n          var columnId = getColumnId(that, visibleColumn);\n\n          var widthOption = that._columnsController.columnOption(columnId, \"width\");\n\n          var minWidth = that._columnsController.columnOption(columnId, \"minWidth\");\n\n          var columnBestFitWidth = that._columnsController.columnOption(columnId, \"bestFitWidth\");\n\n          if (resultWidths[i] === HIDDEN_COLUMNS_WIDTH) {\n            hasHiddenColumns = true;\n            continue;\n          }\n\n          if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {\n            needHideColumn = true;\n            break;\n          }\n\n          if (!widthOption || \"auto\" === widthOption) {\n            columnWidth = Math.max(columnBestFitWidth || 0, minWidth || 0);\n          }\n\n          if (visibleColumn.command !== ADAPTIVE_COLUMN_NAME || hasHiddenColumns) {\n            totalWidth += columnWidth;\n          }\n        }\n\n        needHideColumn = needHideColumn || totalWidth > $rootElement.width();\n\n        if (needHideColumn) {\n          var column = hiddenQueue.pop();\n\n          var visibleIndex = that._columnsController.getVisibleIndex(column.index);\n\n          rootElementWidth += that._calculateColumnWidth(column, rootElementWidth, visibleContentColumns, columnsCanFit);\n\n          that._hideVisibleColumn({\n            visibleIndex: visibleIndex\n          });\n\n          resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH;\n\n          this._hiddenColumns.push(column);\n\n          visibleContentColumns = getVisibleContentColumns();\n        }\n      } while (needHideColumn && visibleContentColumns.length > 1 && hiddenQueue.length);\n\n      if (contentColumnsCount === visibleContentColumns.length) {\n        that._hideAdaptiveColumn(resultWidths, visibleColumns);\n      }\n    } else {\n      that._hideAdaptiveColumn(resultWidths, visibleColumns);\n    }\n  },\n  getItemContentByColumnIndex: function (visibleColumnIndex) {\n    var $itemContent;\n\n    for (var i = 0; i < this._$itemContents.length; i++) {\n      $itemContent = this._$itemContents.eq(i);\n      var item = $itemContent.data(\"dx-form-item\");\n\n      if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {\n        return $itemContent;\n      }\n    }\n  },\n  toggleExpandAdaptiveDetailRow: function (key, alwaysExpanded) {\n    if (!(this.isFormEditMode() && this._editingController.isEditing())) {\n      this.getController(\"data\").toggleExpandAdaptiveDetailRow(key, alwaysExpanded);\n    }\n  },\n  createFormByHiddenColumns: function (container, options) {\n    var that = this;\n    var $container = (0, _renderer2.default)(container);\n    var userFormOptions = {\n      items: that._getFormItemsByHiddenColumns(that._hiddenColumns),\n      formID: \"dx-\" + new _guid2.default()\n    };\n    var defaultFormOptions = _themes2.default.isMaterial() ? {\n      colCount: 2\n    } : {};\n    this.executeAction(\"onAdaptiveDetailRowPreparing\", {\n      formOptions: userFormOptions\n    });\n    that._$itemContents = null;\n    that._form = that._createComponent((0, _renderer2.default)(\"<div>\").appendTo($container), _form2.default, (0, _extend.extend)(defaultFormOptions, userFormOptions, {\n      customizeItem: function (item) {\n        var column = item.column || that._columnsController.columnOption(item.name || item.dataField);\n\n        if (column) {\n          item.label = item.label || {};\n          item.label.text = item.label.text || column.caption;\n          item.column = column;\n          item.template = that._getTemplate(item, options, that.updateForm.bind(that));\n        }\n\n        userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item);\n      },\n      onContentReady: function (e) {\n        userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);\n        that._$itemContents = $container.find(\".\" + FORM_ITEM_CONTENT_CLASS);\n      }\n    }));\n  },\n  hasAdaptiveDetailRowExpanded: function () {\n    return _type2.default.isDefined(this._dataController.adaptiveExpandedKey());\n  },\n  updateForm: function (hiddenColumns) {\n    if (this.hasAdaptiveDetailRowExpanded()) {\n      if (this._form && _type2.default.isDefined(this._form._contentReadyAction)) {\n        if (hiddenColumns && hiddenColumns.length) {\n          this._form.option(\"items\", this._getFormItemsByHiddenColumns(hiddenColumns));\n        } else {\n          this._form.repaint();\n        }\n      }\n    }\n  },\n  updateHidingQueue: function (columns) {\n    var that = this;\n    var hideableColumns = columns.filter(function (column) {\n      return column.visible && !column.type && !column.fixed && !(_type2.default.isDefined(column.groupIndex) && column.groupIndex >= 0);\n    });\n    var columnsHasHidingPriority;\n    var i;\n    that._hidingColumnsQueue = [];\n\n    if (that.option(\"allowColumnResizing\") && \"widget\" === that.option(\"columnResizingMode\")) {\n      return that._hidingColumnsQueue;\n    }\n\n    for (i = 0; i < hideableColumns.length; i++) {\n      if (_type2.default.isDefined(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {\n        columnsHasHidingPriority = true;\n        that._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i];\n      }\n    }\n\n    if (columnsHasHidingPriority) {\n      that._hidingColumnsQueue.reverse();\n    } else {\n      if (that.option(\"columnHidingEnabled\")) {\n        for (i = 0; i < hideableColumns.length; i++) {\n          var visibleIndex = that._columnsController.getVisibleIndex(hideableColumns[i].index);\n\n          that._hidingColumnsQueue[visibleIndex] = hideableColumns[i];\n        }\n      }\n    }\n\n    that._hidingColumnsQueue = that._hidingColumnsQueue.filter(Object);\n    return that._hidingColumnsQueue;\n  },\n  getHiddenColumns: function () {\n    return this._hiddenColumns;\n  },\n  hasHiddenColumns: function () {\n    return this._hiddenColumns.length > 0;\n  },\n  getHidingColumnsQueue: function () {\n    return this._hidingColumnsQueue;\n  },\n  init: function () {\n    var that = this;\n    that._columnsController = that.getController(\"columns\");\n    that._dataController = that.getController(\"data\");\n    that._rowsView = that.getView(\"rowsView\");\n\n    that._columnsController.addCommandColumn({\n      type: ADAPTIVE_COLUMN_NAME,\n      command: ADAPTIVE_COLUMN_NAME,\n      visible: true,\n      adaptiveHidden: true,\n      cssClass: ADAPTIVE_COLUMN_NAME_CLASS,\n      alignment: \"center\",\n      width: \"auto\",\n      cellTemplate: adaptiveCellTemplate,\n      fixedPosition: \"right\"\n    });\n\n    that._columnsController.columnsChanged.add(function () {\n      var isAdaptiveVisible = !!that.updateHidingQueue(that._columnsController.getColumns()).length;\n\n      that._columnsController.columnOption(\"command:adaptive\", \"adaptiveHidden\", !isAdaptiveVisible, true);\n    });\n\n    that._editingController = that.getController(\"editing\");\n    that._hidingColumnsQueue = [];\n    that._hiddenColumns = [];\n    that.createAction(\"onAdaptiveDetailRowPreparing\");\n    that.callBase();\n  },\n  optionChanged: function (args) {\n    if (\"columnHidingEnabled\" === args.name) {\n      this._columnsController.columnOption(\"command:adaptive\", \"adaptiveHidden\", !args.value);\n    }\n\n    this.callBase(args);\n  },\n  publicMethods: function () {\n    return [\"isAdaptiveDetailRowExpanded\", \"expandAdaptiveDetailRow\", \"collapseAdaptiveDetailRow\"];\n  },\n  isAdaptiveDetailRowExpanded: function (key) {\n    return this._dataController.adaptiveExpandedKey() && (0, _common.equalByValue)(this._dataController.adaptiveExpandedKey(), key);\n  },\n  expandAdaptiveDetailRow: function (key) {\n    if (!this.hasAdaptiveDetailRowExpanded()) {\n      this.toggleExpandAdaptiveDetailRow(key);\n    }\n  },\n  collapseAdaptiveDetailRow: function () {\n    if (this.hasAdaptiveDetailRowExpanded()) {\n      this.toggleExpandAdaptiveDetailRow();\n    }\n  }\n});\n\nmodule.exports = {\n  defaultOptions: function () {\n    return {\n      columnHidingEnabled: false,\n      onAdaptiveDetailRowPreparing: null\n    };\n  },\n  controllers: {\n    adaptiveColumns: AdaptiveColumnsController\n  },\n  extenders: {\n    views: {\n      rowsView: {\n        _getCellTemplate: function (options) {\n          var that = this;\n          var column = options.column;\n\n          if (options.rowType === ADAPTIVE_ROW_TYPE && \"detail\" === column.command) {\n            return function (container, options) {\n              that._adaptiveColumnsController.createFormByHiddenColumns((0, _renderer2.default)(container), options);\n            };\n          }\n\n          return that.callBase(options);\n        },\n        _createRow: function (row) {\n          var $row = this.callBase(row);\n\n          if (row && row.rowType === ADAPTIVE_ROW_TYPE && row.key === this._dataController.adaptiveExpandedKey()) {\n            $row.addClass(ADAPTIVE_DETAIL_ROW_CLASS);\n          }\n\n          return $row;\n        },\n        _renderCells: function ($row, options) {\n          this.callBase($row, options);\n\n          var hidingColumnsQueueLength = this._adaptiveColumnsController.getHidingColumnsQueue().length;\n\n          var hiddenColumnsLength = this._adaptiveColumnsController.getHiddenColumns().length;\n\n          if (hidingColumnsQueueLength && !hiddenColumnsLength) {\n            getDataCellElements($row).last().addClass(LAST_DATA_CELL_CLASS);\n          }\n        },\n        _getColumnIndexByElementCore: function ($element) {\n          var $itemContent = $element.closest(\".\" + FORM_ITEM_CONTENT_CLASS);\n\n          if ($itemContent.length && $itemContent.closest(this.component.$element()).length) {\n            var formItem = $itemContent.length ? $itemContent.first().data(\"dx-form-item\") : null;\n            return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);\n          } else {\n            return this.callBase($element);\n          }\n        },\n        _cellPrepared: function ($cell, options) {\n          this.callBase.apply(this, arguments);\n\n          if (options.row.rowType !== ADAPTIVE_ROW_TYPE && options.column.visibleWidth === HIDDEN_COLUMNS_WIDTH) {\n            $cell.addClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));\n          }\n        },\n        _getCellElement: function (rowIndex, columnIdentifier) {\n          var item = this._dataController.items()[rowIndex];\n\n          if (item && item.rowType === ADAPTIVE_ROW_TYPE) {\n            return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier);\n          } else {\n            return this.callBase(rowIndex, columnIdentifier);\n          }\n        },\n        getContextMenuItems: function (options) {\n          if (options.row && \"detailAdaptive\" === options.row.rowType) {\n            var view = this.component.getView(\"columnHeadersView\");\n            var formItem = (0, _renderer2.default)(options.targetElement).closest(\".dx-field-item-label\").next().data(\"dx-form-item\");\n            options.column = formItem ? formItem.column : options.column;\n            return view.getContextMenuItems && view.getContextMenuItems(options);\n          }\n\n          return this.callBase && this.callBase(options);\n        },\n        isClickableElement: function ($target) {\n          var isClickable = this.callBase ? this.callBase($target) : false;\n          return isClickable || !!$target.closest(\".\" + ADAPTIVE_COLUMN_NAME_CLASS).length;\n        },\n        init: function () {\n          this.callBase();\n          this._adaptiveColumnsController = this.getController(\"adaptiveColumns\");\n        }\n      }\n    },\n    controllers: {\n      \"export\": {\n        _updateColumnWidth: function (column, width) {\n          this.callBase(column, column.visibleWidth === HIDDEN_COLUMNS_WIDTH ? column.bestFitWidth : width);\n        }\n      },\n      columnsResizer: {\n        _pointCreated: function (point, cellsLength, columns) {\n          var result = this.callBase(point, cellsLength, columns);\n          var currentColumn = columns[point.columnIndex] || {};\n\n          var nextColumnIndex = this._getNextColumnIndex(point.columnIndex);\n\n          var nextColumn = columns[nextColumnIndex] || {};\n          var hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command;\n          var hasAdaptiveHiddenWidth = currentColumn.visibleWidth === HIDDEN_COLUMNS_WIDTH || hasHiddenColumnsOnly;\n          return result || hasAdaptiveHiddenWidth;\n        },\n        _getNextColumnIndex: function (currentColumnIndex) {\n          var visibleColumns = this._columnsController.getVisibleColumns();\n\n          var index = this.callBase(currentColumnIndex);\n\n          while (visibleColumns[index] && visibleColumns[index].visibleWidth === HIDDEN_COLUMNS_WIDTH) {\n            index++;\n          }\n\n          return index;\n        }\n      },\n      draggingHeader: {\n        _pointCreated: function (point, columns, location, sourceColumn) {\n          var result = this.callBase(point, columns, location, sourceColumn);\n          var column = columns[point.columnIndex - 1] || {};\n          var hasAdaptiveHiddenWidth = column.visibleWidth === HIDDEN_COLUMNS_WIDTH;\n          return result || hasAdaptiveHiddenWidth;\n        }\n      },\n      editing: {\n        _isRowEditMode: function () {\n          return this.getEditMode() === EDIT_MODE_ROW;\n        },\n        _getFormEditItemTemplate: function (cellOptions, column) {\n          if (this.getEditMode() !== EDIT_MODE_ROW && \"detailAdaptive\" === cellOptions.rowType) {\n            cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.index);\n            return this.getColumnTemplate(cellOptions);\n          }\n\n          return this.callBase(cellOptions, column);\n        },\n        _closeEditItem: function ($targetElement) {\n          var $itemContents = $targetElement.closest(\".\" + FORM_ITEM_CONTENT_CLASS);\n          var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;\n          var formItem = $itemContents.length ? $itemContents.first().data(\"dx-form-item\") : null;\n\n          var columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);\n\n          if (!this.isEditCell(rowIndex, columnIndex)) {\n            this.callBase($targetElement);\n          }\n        },\n        _beforeUpdateItems: function (rowIndices, rowIndex) {\n          if (!this._adaptiveController.isFormEditMode() && this._adaptiveController.hasHiddenColumns()) {\n            var items = this._dataController.items();\n\n            var item = items[rowIndex];\n\n            var oldExpandRowIndex = _uiGrid_core4.default.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);\n\n            this._isForceRowAdaptiveExpand = !this._adaptiveController.hasAdaptiveDetailRowExpanded();\n\n            if (oldExpandRowIndex >= 0 && rowIndex > oldExpandRowIndex) {\n              this._editRowIndex--;\n            }\n\n            if (oldExpandRowIndex >= 0) {\n              rowIndices.push(oldExpandRowIndex + 1);\n            }\n\n            rowIndices.push(rowIndex + 1);\n\n            this._dataController.adaptiveExpandedKey(item.key);\n          }\n        },\n        _afterInsertRow: function (options) {\n          this.callBase(options);\n\n          if (this._adaptiveController.hasHiddenColumns()) {\n            this._adaptiveController.toggleExpandAdaptiveDetailRow(options.key, this.isRowEditMode());\n\n            this._isForceRowAdaptiveExpand = true;\n          }\n        },\n        _collapseAdaptiveDetailRow: function () {\n          if (this._isRowEditMode() && this._isForceRowAdaptiveExpand) {\n            this._adaptiveController.collapseAdaptiveDetailRow();\n\n            this._isForceRowAdaptiveExpand = false;\n          }\n        },\n        _cancelEditAdaptiveDetailRow: function () {\n          if (this._adaptiveController.hasHiddenColumns()) {\n            this._collapseAdaptiveDetailRow();\n          }\n        },\n        _afterSaveEditData: function () {\n          var _this2 = this;\n\n          this.callBase.apply(this, arguments);\n          var deferred = new _deferred.Deferred();\n\n          if (this._isRowEditMode() && this._adaptiveController.hasHiddenColumns()) {\n            (0, _deferred.when)(this.getController(\"validating\").validate(true)).done(function (isValid) {\n              if (isValid) {\n                _this2._cancelEditAdaptiveDetailRow();\n              }\n\n              deferred.resolve();\n            });\n          } else {\n            deferred.resolve();\n          }\n\n          return deferred.promise();\n        },\n        _beforeCancelEditData: function () {\n          this.callBase();\n\n          this._cancelEditAdaptiveDetailRow();\n        },\n        _getRowIndicesForCascadeUpdating: function (row) {\n          var rowIndices = this.callBase.apply(this, arguments);\n\n          if (this._adaptiveController.isAdaptiveDetailRowExpanded(row.key)) {\n            rowIndices.push(row.rowType === ADAPTIVE_ROW_TYPE ? row.rowIndex - 1 : row.rowIndex + 1);\n          }\n\n          return rowIndices;\n        },\n        _beforeCloseEditCellInBatchMode: function (rowIndices) {\n          var expandedKey = this._dataController._adaptiveExpandedKey;\n\n          if (expandedKey) {\n            var rowIndex = _uiGrid_core4.default.getIndexByKey(expandedKey, this._dataController.items());\n\n            if (rowIndex > -1) {\n              rowIndices.unshift(rowIndex);\n            }\n          }\n        },\n        editRow: function (rowIndex) {\n          if (this._adaptiveController.isFormEditMode()) {\n            this._adaptiveController.collapseAdaptiveDetailRow();\n          }\n\n          this.callBase(rowIndex);\n        },\n        deleteRow: function (rowIndex) {\n          var rowKey = this._dataController.getKeyByRowIndex(rowIndex);\n\n          if (this.getEditMode() === EDIT_MODE_BATCH && this._adaptiveController.isAdaptiveDetailRowExpanded(rowKey)) {\n            this._adaptiveController.collapseAdaptiveDetailRow();\n          }\n\n          this.callBase(rowIndex);\n        },\n        init: function () {\n          this.callBase();\n          this._adaptiveController = this.getController(\"adaptiveColumns\");\n        }\n      },\n      resizing: {\n        _needBestFit: function () {\n          return this.callBase() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length;\n        },\n        _updateScrollableForIE: function () {\n          var that = this;\n\n          if (_browser2.default.msie && parseInt(_browser2.default.version) <= 11) {\n            this._updateScrollableTimeoutID = setTimeout(function () {\n              that.getView(\"rowsView\")._updateScrollable();\n            });\n          }\n        },\n        _correctColumnWidths: function (resultWidths, visibleColumns) {\n          var adaptiveController = this._adaptiveColumnsController;\n          var columnAutoWidth = this.option(\"columnAutoWidth\");\n          var oldHiddenColumns = adaptiveController.getHiddenColumns();\n          var hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());\n          adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);\n          var hiddenColumns = adaptiveController.getHiddenColumns();\n\n          if (adaptiveController.hasAdaptiveDetailRowExpanded()) {\n            if (oldHiddenColumns.length !== hiddenColumns.length) {\n              adaptiveController.updateForm(hiddenColumns);\n            }\n          }\n\n          !hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();\n\n          if (columnAutoWidth && hidingColumnsQueue.length && !hiddenColumns.length) {\n            this._updateScrollableForIE();\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _toggleBestFitMode: function (isBestFit) {\n          isBestFit && this._adaptiveColumnsController._showHiddenColumns();\n          this.callBase(isBestFit);\n        },\n        _needStretch: function () {\n          var adaptiveColumnsController = this._adaptiveColumnsController;\n          return this.callBase.apply(this, arguments) || adaptiveColumnsController.getHidingColumnsQueue().length || adaptiveColumnsController.hasHiddenColumns();\n        },\n        init: function () {\n          this._adaptiveColumnsController = this.getController(\"adaptiveColumns\");\n          this.callBase();\n        },\n        dispose: function () {\n          this.callBase.apply(this, arguments);\n          clearTimeout(this._updateScrollableTimeoutID);\n        }\n      },\n      data: {\n        _processItems: function (items, change) {\n          var that = this;\n          var changeType = change.changeType;\n          items = that.callBase.apply(that, arguments);\n\n          if (\"loadingAll\" === changeType || !_type2.default.isDefined(that._adaptiveExpandedKey)) {\n            return items;\n          }\n\n          var expandRowIndex = _uiGrid_core4.default.getIndexByKey(that._adaptiveExpandedKey, items);\n\n          if (expandRowIndex >= 0) {\n            var item = items[expandRowIndex];\n            items.splice(expandRowIndex + 1, 0, {\n              visible: true,\n              rowType: ADAPTIVE_ROW_TYPE,\n              key: item.key,\n              data: item.data,\n              node: item.node,\n              modifiedValues: item.modifiedValues,\n              isNewRow: item.isNewRow,\n              values: item.values\n            });\n          } else {\n            if (\"refresh\" === changeType) {\n              that._adaptiveExpandedKey = void 0;\n            }\n          }\n\n          return items;\n        },\n        _getRowIndicesForExpand: function (key) {\n          var rowIndices = this.callBase.apply(this, arguments);\n\n          if (this.getController(\"adaptiveColumns\").isAdaptiveDetailRowExpanded(key)) {\n            var lastRowIndex = rowIndices[rowIndices.length - 1];\n            rowIndices.push(lastRowIndex + 1);\n          }\n\n          return rowIndices;\n        },\n        adaptiveExpandedKey: function (value) {\n          if (_type2.default.isDefined(value)) {\n            this._adaptiveExpandedKey = value;\n          } else {\n            return this._adaptiveExpandedKey;\n          }\n        },\n        toggleExpandAdaptiveDetailRow: function (key, alwaysExpanded) {\n          var that = this;\n\n          var oldExpandLoadedRowIndex = _uiGrid_core4.default.getIndexByKey(that._adaptiveExpandedKey, that._items);\n\n          var newExpandLoadedRowIndex = _uiGrid_core4.default.getIndexByKey(key, that._items);\n\n          if (oldExpandLoadedRowIndex >= 0 && oldExpandLoadedRowIndex === newExpandLoadedRowIndex && !alwaysExpanded) {\n            key = void 0;\n            newExpandLoadedRowIndex = -1;\n          }\n\n          that._adaptiveExpandedKey = key;\n\n          if (oldExpandLoadedRowIndex >= 0) {\n            oldExpandLoadedRowIndex++;\n          }\n\n          if (newExpandLoadedRowIndex >= 0) {\n            newExpandLoadedRowIndex++;\n          }\n\n          var rowIndexDelta = that.getRowIndexDelta();\n          that.updateItems({\n            allowInvisibleRowIndices: true,\n            changeType: \"update\",\n            rowIndices: [oldExpandLoadedRowIndex - rowIndexDelta, newExpandLoadedRowIndex - rowIndexDelta]\n          });\n        },\n        init: function () {\n          this.callBase();\n          this._adaptiveExpandedKey = void 0;\n        }\n      },\n      editorFactory: {\n        _getFocusCellSelector: function () {\n          return this.callBase() + \", .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content\";\n        },\n        _getTooltipsSelector: function () {\n          return this.callBase() + \", .dx-field-item-content .\" + this.addWidgetPrefix(REVERT_TOOLTIP_CLASS);\n        }\n      },\n      columns: {\n        _isColumnVisible: function (column) {\n          return this.callBase(column) && !column.adaptiveHidden;\n        }\n      },\n      keyboardNavigation: {\n        _isCellValid: function ($cell) {\n          return this.callBase.apply(this, arguments) && !$cell.hasClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));\n        },\n        _processNextCellInMasterDetail: function ($nextCell) {\n          this.callBase($nextCell);\n\n          var isCellOrBatchMode = this._editingController.isCellOrBatchEditMode();\n\n          if (!this._isInsideEditForm($nextCell) && $nextCell && isCellOrBatchMode) {\n            var focusHandler = function focusHandler() {\n              _events_engine2.default.off($nextCell, \"focus\", focusHandler);\n\n              _events_engine2.default.trigger($nextCell, \"dxclick\");\n            };\n\n            _events_engine2.default.on($nextCell, \"focus\", focusHandler);\n          }\n        },\n        _handleTabKeyOnMasterDetailCell: function (eventTarget, direction) {\n          var result = this.callBase(eventTarget, direction);\n\n          var $currentCell = this._getFocusedCell();\n\n          var $row = $currentCell && $currentCell.parent();\n\n          if (!result && $row && $row.length) {\n            var $dataCells = getDataCellElements($row);\n            var $targetCell = \"next\" === direction ? $dataCells.last() : $dataCells.first();\n            var rowIndex = $row.get(0).rowIndex;\n            var adaptiveController = this._adaptiveController;\n\n            var key = this._dataController.getKeyByRowIndex(\"next\" === direction ? rowIndex : rowIndex - 1);\n\n            var isCellElementsEquals = $currentCell && $targetCell && $currentCell.get(0) === $targetCell.get(0);\n            return adaptiveController.isAdaptiveDetailRowExpanded(key) && isCellElementsEquals;\n          }\n\n          return result;\n        },\n        init: function () {\n          this.callBase();\n          this._adaptiveController = this.getController(\"adaptiveColumns\");\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}