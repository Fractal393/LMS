{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { PdfGrid } from '../pdf-grid';\nimport { PdfStringFormat } from './../../../graphics/fonts/pdf-string-format';\nimport { SizeF, RectangleF, PointF } from './../../../drawing/pdf-drawing';\nimport { PdfBorders } from '../styles/pdf-borders';\nimport { PdfLayoutType, PdfLayoutBreakType } from './../../../graphics/figures/enum';\nimport { PdfLayoutResult, PdfLayoutFormat, ElementLayouter } from './../../../graphics/figures/base/element-layouter';\nimport { PdfHorizontalOverflowType } from '../styles/style';\nimport { TemporaryDictionary } from './../../../collections/object-object-pair/dictionary';\n/**\n * Class `lay outing the text`.\n *\n */\n\nvar PdfGridLayouter =\n/** @class */\nfunction (_super) {\n  __extends(PdfGridLayouter, _super); //constructor\n\n  /**\n   * Initialize a new instance for `PdfGrid` class.\n   * @private\n   */\n\n\n  function PdfGridLayouter(baseFormat) {\n    var _this = _super.call(this, baseFormat) || this;\n    /**\n     * @hidden\n     * @private\n     */\n\n\n    _this.gridInitialWidth = 0;\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.gridSize = new SizeF(0, 0);\n    _this.parentCellIndex = 0;\n    _this.tempWidth = 0;\n    _this.childheight = 0;\n    /**\n     * Check weather it is `child grid or not`.\n     * @private\n     */\n\n    _this.isChildGrid = false;\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.hasRowSpanSpan = false;\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.isRearranged = false;\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.pageBounds = new RectangleF();\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.listOfNavigatePages = [];\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.flag = true;\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.columnRanges = [];\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.currentLocation = new PointF(0, 0);\n    /**\n     * @hidden\n     * @private\n     */\n\n    _this.breakRow = true;\n    /**\n     * Checks whether the x co-ordinate is need to set as client size or not.\n     * @hidden\n     * @private\n     */\n\n    _this.isOverloadWithPosition = false;\n    return _this;\n  }\n\n  Object.defineProperty(PdfGridLayouter.prototype, \"Grid\", {\n    //Properties\n    get: function () {\n      return this.elements;\n    },\n    enumerable: true,\n    configurable: true\n  }); // Constructors\n\n  /**\n   * Initializes a new instance of the `StringLayouter` class.\n   * @private\n   */\n  //Public methods\n\n  /**\n   * `Layouts` the text.\n   * @private\n   */\n\n  /**\n   * `Layouts` the specified graphics.\n   * @private\n   */\n\n  /**\n   * `Layouts` the specified graphics.\n   * @private\n   */\n\n  /*public layout(graphics : PdfLayoutParams) : PdfLayoutResult\n  public layout(graphics : PdfGraphics, bounds : RectangleF) : void\n  public layout(graphics : PdfGraphics, bounds : PointF) : void\n  public layout(graphics ?: PdfGraphics | PdfLayoutParams, bounds ?: PointF | RectangleF) : void | PdfLayoutResult  {\n      if (graphics instanceof PdfGraphics) {\n      if (bounds instanceof PointF) {\n          if (bounds.x === 0) {\n              bounds.x = PdfBorders.default.right.width / 2;\n          }\n          if (bounds.y === 0) {\n              bounds.y = PdfBorders.default.top.width / 2;\n          }\n          let boundaries : RectangleF = new RectangleF(bounds, new SizeF(0, 0));\n          this.layout(graphics, boundaries);\n      } else {\n          let width : number = graphics.clientSize.width;\n          let parameter : PdfLayoutParams = new PdfLayoutParams();\n          parameter.bounds = bounds;\n          this.currentGraphics = graphics;\n          if (graphics.layer != null) {\n              let index : number = 0;\n              if (this.currentGraphics.page instanceof PdfPage) {\n                  index = (this.currentGraphics.page as PdfPage).section.indexOf(this.currentGraphics.page as PdfPage);\n              } else {\n                  index = (this.currentGraphics.page as PdfPageBase).defaultLayerIndex;\n              }\n          } else {\n              this.layoutInternal(parameter);\n          }\n      }\n  }\n  }*/\n\n  /**\n   * Gets the `format`.\n   * @private\n   */\n\n  PdfGridLayouter.prototype.getFormat = function (format) {\n    var f = format;\n    return f;\n  };\n  /**\n   * `Layouts` the element.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.layoutInternal = function (param) {\n    var format = this.getFormat(param.format);\n    this.gridLayoutFormat = this.getFormat(param.format);\n    this.currentPage = param.page;\n\n    if (this.currentPage !== null) {\n      var pageHeight = this.currentPage.getClientSize().height;\n      var pageWidth = this.currentPage.getClientSize().width;\n      this.currentPageBounds = this.currentPage.getClientSize();\n    } else {\n      throw Error('Can not set page as null'); //this.currentPageBounds = this.currentGraphics.clientSize;\n    }\n\n    this.currentGraphics = this.currentPage.graphics; //this.currentGraphics = (this.currentPage != null ) ? this.currentPage.graphics : this.currentGraphics;\n    // if (this.currentGraphics.layer !== null) {\n    //     let index : number = 0;\n    //     if (this.currentGraphics.page instanceof PdfPage) {\n    //         index = (this.currentGraphics.page as PdfPage).section.indexOf(this.currentGraphics.page as PdfPage);\n    //     } else {\n    //         index = (this.currentGraphics.page as PdfPageBase).defaultLayerIndex;\n    //     }\n    //     this.listOfNavigatePages.push(index);\n    // }\n\n    var index = 0;\n    index = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);\n    this.listOfNavigatePages.push(index);\n\n    if (format != null && format.break === PdfLayoutBreakType.FitColumnsToPage) {\n      this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), new SizeF(this.Grid.columns.width, this.currentGraphics.clientSize.height));\n    } else {\n      this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), this.currentGraphics.clientSize);\n    } //this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), this.currentGraphics.clientSize);\n\n\n    if (this.Grid.rows.count !== 0) {\n      this.currentBounds.width = param.bounds.width > 0 ? param.bounds.width : this.currentBounds.width - this.Grid.rows.getRow(0).cells.getCell(0).style.borders.left.width / 2;\n    } else if (this.Grid.headers.count !== 0) {\n      // this.currentBounds.width = (param.bounds.width > 0) ? param.bounds.width : (this.currentBounds.width -\n      //                                 this.Grid.headers.getHeader(0).cells.getCell(0).style.borders.left.width / 2);\n      this.currentBounds.width = param.bounds.width;\n    } else {\n      throw Error('Please add row or header into grid');\n    }\n\n    this.startLocation = new PointF(param.bounds.x, param.bounds.y); // if (this.Grid.style.allowHorizontalOverflow && this.currentBounds.width > this.currentGraphics.clientSize.width) {\n    //     this.currentBounds.width = this.currentGraphics.clientSize.width;\n    //     this.currentBounds.width -= this.currentBounds.x;\n    // }\n    // if (this.Grid.isChildGrid) {\n    //     this.childheight = param.bounds.height;\n    // }\n    // if (param.format !== null && param.format.usePaginateBounds) {\n    //     if (param.format.paginateBounds.height > 0) {\n    //         this.currentBounds.height = param.format.paginateBounds.height;\n    //     }\n    //} else \n\n    if (param.bounds.height > 0 && !this.Grid.isChildGrid) {\n      this.currentBounds.height = param.bounds.height;\n    }\n\n    if (!this.Grid.isChildGrid) {\n      this.hType = this.Grid.style.horizontalOverflowType;\n    }\n\n    if (!this.Grid.style.allowHorizontalOverflow) {\n      this.columnRanges = [];\n      this.Grid.measureColumnsWidth(this.currentBounds);\n      this.columnRanges.push([0, this.Grid.columns.count - 1]);\n    } else {\n      this.Grid.measureColumnsWidth();\n      this.determineColumnDrawRanges();\n    }\n\n    if (this.Grid.hasRowSpanSpan) {\n      for (var i = 0; i < this.Grid.rows.count; i++) {\n        if (this.Grid.rows.getRow(i).height !== -1 && !this.Grid.rows.getRow(i).isRowHeightSet) {\n          this.Grid.rows.getRow(i).isRowHeightSet = true;\n        }\n      }\n    }\n\n    var result = this.layoutOnPage(param);\n    return result;\n  }; // /* tslint:enable */\n\n  /**\n   * `Determines the column draw ranges`.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.determineColumnDrawRanges = function () {\n    var startColumn = 0;\n    var endColumn = 0;\n    var cellWidths = 0;\n    var availableWidth = this.currentGraphics.clientSize.width - this.currentBounds.x;\n\n    for (var i = 0; i < this.Grid.columns.count; i++) {\n      cellWidths += this.Grid.columns.getColumn(i).width;\n\n      if (cellWidths >= availableWidth) {\n        var subWidths = 0;\n\n        for (var j = startColumn; j <= i; j++) {\n          subWidths += this.Grid.columns.getColumn(j).width;\n\n          if (subWidths > availableWidth) {\n            break;\n          }\n\n          endColumn = j;\n        }\n\n        this.columnRanges.push([startColumn, endColumn]);\n        startColumn = endColumn + 1;\n        endColumn = startColumn;\n        cellWidths = endColumn <= i ? this.Grid.columns.getColumn(i).width : 0;\n      }\n    } // if (startColumn !== this.columns.Count) {\n\n\n    this.columnRanges.push([startColumn, this.Grid.columns.count - 1]); // }\n  };\n  /**\n   * `Layouts the on page`.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.layoutOnPage = function (param) {\n    /* tslint:disable */\n    this.pageBounds.x = param.bounds.x;\n    this.pageBounds.y = param.bounds.y;\n    this.pageBounds.height = param.bounds.height;\n    var format = this.getFormat(param.format);\n    var endArgs = null;\n    var result = null;\n    var layoutedPages = new TemporaryDictionary();\n    var startPage = param.page;\n    var isParentCell = false;\n    var cellBounds = [];\n\n    for (var index = 0; index < this.columnRanges.length; index++) {\n      var range = this.columnRanges[index];\n      this.cellStartIndex = range[0];\n      this.cellEndIndex = range[1];\n      var returnObject = this.raiseBeforePageLayout(this.currentPage, this.currentBounds, this.currentRowIndex);\n      this.currentBounds = returnObject.currentBounds;\n      this.currentRowIndex = returnObject.currentRowIndex; // if (returnObject.returnValue) {\n      //     result = new PdfGridLayoutResult(this.currentPage, this.currentBounds);\n      //     break;\n      // }\n      //Draw Headers.\n\n      var drawHeader = void 0;\n\n      for (var i_1 = 0; i_1 < this.Grid.headers.count; i_1++) {\n        var row = this.Grid.headers.getHeader(i_1);\n        var headerHeight = this.currentBounds.y; // RowLayoutResult\n\n        var headerResult = this.drawRow(row); // if (headerHeight === this.currentBounds.y) {\n        //     drawHeader = true;\n        //     if (PdfGrid.repeatRowIndex === -1) {\n        //         PdfGrid.repeatRowIndex = this.rows.getRow.indexOf(row);\n        //     }\n        // } else {\n\n        drawHeader = false; // }\n      }\n\n      var i = 0;\n      var length_1 = this.Grid.rows.count;\n      var repeatRow = void 0;\n      var startingHeight = 0;\n      var flag = true; //Here is to draw parent Grid and Cells\n\n      cellBounds = []; //Draw row by row with the specified cell range.\n\n      for (var j = 0; j < this.Grid.rows.count; j++) {\n        var row = this.Grid.rows.getRow(j);\n        i++;\n        this.currentRowIndex = i - 1;\n        var originalHeight = this.currentBounds.y;\n        startPage = this.currentPage;\n        PdfGridLayouter.repeatRowIndex = -1;\n\n        if (flag && row.grid.isChildGrid) {\n          startingHeight = originalHeight;\n          flag = false;\n        }\n\n        var rowResult = null; ///rowResult = this.drawRow(row);\n\n        /*if(!row.isrowFinish) {\n            if(!row.grid.isgridSplit){\n                rowResult = this.drawRow(row);\n                row.isrowFinish = true;\n                row.isrowDraw = true;\n            } else {\n                if(!row.isrowDraw){\n                    rowResult = this.drawRow(row);\n                    row.isrowFinish = true;\n                    row.isrowDraw = true;\n                    row.grid.isgridSplit = false;\n                } else {\n                    rowResult =  null;\n                    break;\n                }\n            }\n        }\n        else {\n            //row.isrowFinish = false;\n            //rowResult = this.drawRow(row);\n            rowResult = null;\n            break;\n            \n        }             */\n\n        if (this.Grid.splitChildRowIndex == -1) {\n          rowResult = this.drawRow(row);\n          row.isrowFinish = true;\n        } else {\n          if (row.grid.ParentCell.row.grid.isGridSplit && this.Grid.splitChildRowIndex <= row.rowIndex) {\n            rowResult = this.drawRow(row);\n            row.isrowFinish = true;\n          } else if (row.isrowFinish) {\n            continue;\n          } else {\n            break;\n          }\n        } //rowResult = this.drawRow(row);\n\n\n        cellBounds.push(rowResult.bounds.width);\n        /*if (row.isRowBreaksNextPage)\n            {\n                let x : number  = 0;\n                for (let l : number = 0; l < row.cells.count; l++)\n                {\n                    let isNestedRowBreak : boolean = false;\n                    if (row.height == row.cells.getCell(l).height)\n                    {\n                        let n : number;\n                        let grid : PdfGrid = row.cells.getCell(l).value as PdfGrid;\n                        for (let m : number = grid.rows.count; 0 < m; m--)\n                        {\n                            if ((grid.rows.getRow(m - 1).rowBreakHeight > 0))\n                            {\n                                isNestedRowBreak = true;\n                                break;\n                            }\n                            if (grid.rows.getRow(m - 1).isRowBreaksNextPage)\n                            {\n                                row.rowBreakHeightValue = grid.rows.getRow(m - 1).rowBreakHeightValue;\n                                break;\n                            }\n                            row.rowBreakHeightValue += grid.rows.getRow(m - 1).height;\n                        }\n                    }\n                    if (isNestedRowBreak)\n                        break;\n                }\n                for (let j : number = 0; j < row.cells.count; j++)\n                {\n                     if (row.height > row.cells.getCell(j).height)\n                    {\n                        row.cells.getCell(j).value = \" \";\n                        let rect : RectangleF ;\n                        let page : PdfPage = this.getNextPage(this.currentPage);\n                        let section : PdfSection = this.currentPage.section;\n                        let index : number = section.indexOf(page);\n                        for (let k : number = 0; k < (section.count - 1) - index; k++)\n                        {\n                            rect = new RectangleF(x, 0, row.grid.columns.getColumn(j).width, page.getClientSize().height);\n                            PdfGridLayouter.repeatRowIndex = -1;\n                            row.cells.getCell(j).draw(page.graphics, rect, false);\n                            page = this.getNextPage(page);\n                        }\n                        rect = new RectangleF(x, 0, row.grid.columns.getColumn(j).width, row.rowBreakHeightValue);\n                         row.cells.getCell(j).draw(page.graphics, rect, false);\n                    }\n                    x += row.grid.columns.getColumn(j).width;\n                }\n            }*/\n        //if height remains same, it is understood that row is not drawn in the page\n\n        if (originalHeight === this.currentBounds.y) {\n          repeatRow = true;\n          PdfGridLayouter.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n        } else {\n          repeatRow = false;\n          PdfGridLayouter.repeatRowIndex = -1;\n        }\n\n        while (!rowResult.isFinish && startPage != null) {\n          var tempResult = this.getLayoutResult();\n          /*if (startPage != this.currentPage)\n              {\n                  if (row.grid.isChildGrid && row.grid.ParentCell != null)\n                  {\n                      let bounds : RectangleF= new RectangleF(new PointF(format.paginateBounds.x,format.paginateBounds.y), new SizeF(param.bounds.width, tempResult.bounds.height));\n                      bounds.x += param.bounds.x;\n                      if (row.grid.ParentCell.row.grid.style.cellPadding != null)\n                      {\n                          bounds.y += row.grid.ParentCell.row.grid.style.cellPadding.top;\n                          if (bounds.height > this.currentPageBounds.height)\n                          {\n                              bounds.height = this.currentPageBounds.height - bounds.y;\n                              bounds.height -= (row.grid.ParentCell.row.grid.style.cellPadding.bottom);\n                          }\n                      }\n                      // Draw border for cells in the nested grid cell's row.\n                      for (let c : number = 0; c < row.cells.count; c++)\n                      {\n                          let cell : PdfGridCell = row.cells.getCell(c);\n                          let cellWidth :  number= 0;\n                          if (cell.columnSpan > 1)\n                          {\n                              for (; c < cell.columnSpan; c++)\n                                  cellWidth += row.grid.columns.getColumn(c).width;\n                          }\n                          else\n                              cellWidth = Math.max(cell.width, row.grid.columns.getColumn(c).width);\n                          cell.drawCellBorders(this.currentGraphics, new RectangleF(new PointF(bounds.x,bounds.y), new SizeF(cellWidth, bounds.height)));\n                          bounds.x += cellWidth;\n                          c += (cell.columnSpan - 1);\n                      }\n                  }\n              }\n              */\n\n          endArgs = this.raisePageLayouted(tempResult);\n          if (endArgs.cancel || repeatRow) break;else if (this.Grid.allowRowBreakAcrossPages) {\n            //If there is no space in the current page, add new page and then draw the remaining row.\n            this.currentPage = this.getNextPageformat(format);\n            originalHeight = this.currentBounds.y;\n            var location_1 = new PointF(PdfBorders.default.right.width / 2, PdfBorders.default.top.width / 2);\n\n            if (format.paginateBounds.x === 0 && format.paginateBounds.y === 0 && format.paginateBounds.width === 0 && format.paginateBounds.height === 0 && this.startLocation.x === location_1.x && this.startLocation.y === location_1.y) {\n              this.currentBounds.x += this.startLocation.x;\n              this.currentBounds.y += this.startLocation.y;\n            }\n\n            if (this.Grid.isChildGrid && row.grid.ParentCell != null) {\n              if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {\n                if (row.rowBreakHeight + this.Grid.ParentCell.row.grid.style.cellPadding.top < this.currentBounds.height) {\n                  this.currentBounds.y = this.Grid.ParentCell.row.grid.style.cellPadding.top;\n                }\n              }\n            }\n\n            if (row.grid.ParentCell != null) {\n              row.grid.ParentCell.row.isRowBreaksNextPage = true;\n              row.grid.ParentCell.row.rowBreakHeightValue = row.rowBreakHeight + this.Grid.ParentCell.row.grid.style.cellPadding.top + this.Grid.ParentCell.row.grid.style.cellPadding.bottom;\n\n              for (var i_2 = row.rowIndex + 1; i_2 < row.grid.rows.count; i_2++) {\n                row.grid.ParentCell.row.rowBreakHeightValue += row.grid.rows.getRow(i_2).height;\n              } //row.rowBreakHeight = row.grid.ParentCell.row.rowBreakHeightValue;\n\n            }\n            /*if (row.noOfPageCount > 1)\n            {\n                let temp : number = row.rowBreakHeightValue;\n                for (let j : number = 1; j < row.noOfPageCount; j++)\n                {\n                    row.rowBreakHeightValue = 0;\n                    row.height = ((row.noOfPageCount - 1) * this.currentPage.getClientSize().height);\n                    this.drawRow(row);\n                    this.currentPage = this.getNextPageformat(format);\n                    startPage = this.currentPage;\n                }\n                row.rowBreakHeightValue = temp;\n                row.noOfPageCount = 1;\n                rowResult = this.drawRow(row);\n            } else {\n                rowResult = this.drawRow(row);\n            }\n            /*if(row.grid.isChildGrid){\n                row.isrowFinish = false;\n                row.isrowDraw = false;\n                row.grid.isgridSplit = true;\n                row.grid.ParentCell.row.grid.isgridSplit = true;\n                //rowResult.isFinish = false;\n                break;\n            }*/\n\n\n            if (row.grid.isChildGrid) {\n              //row.grid.isgridSplit = true;\n              row.isrowFinish = false; //row.grid.ParentCell.row.grid.isgridSplit = true;\n\n              row.grid.splitChildRowIndex = row.rowIndex;\n              row.grid.ParentCell.row.grid.splitChildRowIndex = row.grid.ParentCell.row.rowIndex;\n\n              if (row.grid.ParentCell.row.grid.isGridSplit) {\n                row.grid.ParentCell.row.noOfPageCount += 1;\n                row.grid.ParentCell.row.grid.isGridSplit = false;\n              }\n\n              break;\n            }\n\n            if (row.noOfPageCount < 1) {\n              if (row.grid.splitChildRowIndex != -1) {\n                row.grid.isGridSplit = true;\n              }\n\n              if (row.style.border != null && (row.style.border.left != null && row.style.border.left.width !== 1 || row.style.border.top != null && row.style.border.top.width !== 1)) {\n                var x = row.style.border.left.width / 2;\n                var y = row.style.border.top.width / 2;\n\n                if (this.currentBounds.x === PdfBorders.default.right.width / 2 && this.currentBounds.y === PdfBorders.default.right.width / 2) {\n                  var newBound = new RectangleF(x, y, this.currentBounds.width, this.currentBounds.height);\n                  this.currentBounds = newBound;\n                }\n              }\n\n              if (this.Grid.repeatHeader) {\n                for (var j_1 = 0; j_1 < this.Grid.headers.count; j_1++) {\n                  var headerRepeat = this.Grid.headers.getHeader(j_1);\n                  this.drawRow(headerRepeat);\n                }\n              }\n\n              rowResult = this.drawRow(row);\n\n              if (row.noOfPageCount >= 1) {\n                var temp = row.rowBreakHeightValue;\n\n                for (var j_2 = 0; j_2 < row.noOfPageCount; j_2++) {\n                  //this.currentPage.section.add();\n                  var tempResult1 = this.getLayoutResult();\n                  endArgs = this.raisePageLayouted(tempResult1);\n                  this.currentPage = this.getNextPageformat(format);\n                  originalHeight = this.currentBounds.y; //row.rowBreakHeightValue = 0;\n\n                  if (row.grid.splitChildRowIndex != -1) {\n                    row.grid.isGridSplit = true;\n                  }\n\n                  this.currentBounds.y = 0.5;\n\n                  if (this.Grid.repeatHeader) {\n                    for (var i_3 = 0; i_3 < this.Grid.headers.count; i_3++) {\n                      var header = this.Grid.headers.getHeader(i_3);\n                      this.drawRow(header);\n                    }\n                  } //row.height = ((row.noOfPageCount - 1) * this.currentPage.getClientSize().height);\n\n\n                  this.drawRow(row);\n                } // row.rowBreakHeight = temp;\n                // row.noOfPageCount = 1;\n                // rowResult = this.drawRow(row);\n\n              }\n\n              row.grid.splitChildRowIndex = -1;\n              row.grid.isGridSplit = false;\n              rowResult.isFinish = true; //row.NestedGridLayoutResult.bounds.height = row.rowBreakHeightValue;\n              //this.currentBounds.y = rowResult.bounds.y;\n\n              for (var i_4 = 0; i_4 < row.cells.count; i_4++) {\n                if (row.cells.getCell(i_4).value instanceof PdfGrid) {\n                  row.cells.getCell(i_4).value.splitChildRowIndex = -1;\n                }\n              }\n            }\n          } // else if (!this.Grid.allowRowBreakAcrossPages && i < length)\n          // {\n          //     this.currentPage = this.getNextPageformat(format);\n          //     break;\n          // }\n          // else if (i >= length)\n          //     break;\n        }\n\n        if (!rowResult.isFinish && startPage !== null && format.layout !== PdfLayoutType.OnePage && repeatRow) {\n          // During pagination, cell position is maintained here.\n          this.startLocation.x = this.currentBounds.x;\n          var isAddNextPage = false;\n          this.currentPage = this.getNextPageformat(format);\n          /*if (!this.Grid.isSingleGrid)\n          {\n              for ( let j : number= 0; j < this.Grid.rows.count; j++)\n              {\n                  let isWidthGreaterthanParent : boolean = false;\n                  for (let k : number = 0; k < this.Grid.rows.getRow(j).cells.count; k++)\n                  {\n                      if (this.Grid.rows.getRow(j).cells.getCell(k).width > this.currentPageBounds.width)\n                          isWidthGreaterthanParent = true;\n                  }\n                  if (isWidthGreaterthanParent && this.Grid.rows.getRow(j).cells.getCell(this.rowBreakPageHeightCellIndex).pageCount > 0)\n                  {\n                      isAddNextPage = true;\n                  }\n              }\n          }\n          if (!this.Grid.isRearranged && isAddNextPage)\n               {\n                   let section : PdfSection = this.currentPage.section;\n                   \n                   //this.currentPage = section.add();\n               \n                   this.currentGraphics = this.currentPage.graphics;\n                   this.currentBounds = new RectangleF(new PointF(0,0), this.currentPage.getClientSize());\n                \n                   let pageindex  : number = (this.currentGraphics.page as PdfPage).section.indexOf(this.currentGraphics.page as PdfPage);\n               }\n               else\n               {\n                   this.currentPage = this.getNextPageformat(format);\n               }\n               if (format.paginateBounds.y == 0)\n                   this.currentBounds.y = PdfBorders.default.top.width/2;\n               else\n               {\n                   this.currentBounds.y = format == null ? 0 : format.paginateBounds.y;\n                   \n               }\n               if (this.raiseBeforePageLayout(this.currentPage, this.currentBounds, this.currentRowIndex))\n                   break;*/\n\n          if (param.format !== null && !param.format.usePaginateBounds && param.bounds !== null && param.bounds.height > 0 && !this.Grid.isChildGrid) {\n            this.currentBounds.height = param.bounds.height;\n          }\n\n          if (param.format !== null && !param.format.usePaginateBounds && param.bounds !== null && param.bounds.y > 0 && !this.Grid.isChildGrid) {\n            this.currentBounds.y = param.bounds.y;\n          }\n\n          this.startLocation.y = this.currentBounds.y;\n\n          if (format.paginateBounds.x === format.paginateBounds.y && format.paginateBounds.y === format.paginateBounds.height && format.paginateBounds.height === format.paginateBounds.width && format.paginateBounds.width === 0) {\n            this.currentBounds.x += this.startLocation.x;\n          }\n\n          if (this.currentBounds.x === PdfBorders.default.left.width / 2) {\n            this.currentBounds.y += this.startLocation.x;\n          }\n\n          if (this.Grid.repeatHeader) {\n            for (var i_5 = 0; i_5 < this.Grid.headers.count; i_5++) {\n              var header = this.Grid.headers.getHeader(i_5);\n              this.drawRow(header);\n            }\n          }\n\n          this.drawRow(row);\n\n          if (this.currentPage !== null && !layoutedPages.containsKey(this.currentPage)) {\n            layoutedPages.add(this.currentPage, range);\n          }\n        }\n\n        if (row.NestedGridLayoutResult != null) {\n          // Position for next row in the grid.\n          this.currentPage = row.NestedGridLayoutResult.page;\n          this.currentGraphics = this.currentPage.graphics; //If not, next row will not be drawn in the layouted page.\n\n          this.startLocation = new PointF(row.NestedGridLayoutResult.bounds.x, row.NestedGridLayoutResult.bounds.y);\n          var recalHeight = this.ReCalculateHeight(row, row.NestedGridLayoutResult.bounds.height);\n          this.currentBounds.y = recalHeight; //this.currentBounds.y = row.NestedGridLayoutResult.bounds.height;\n\n          if (startPage != this.currentPage) {\n            var secion = this.currentPage.section;\n            var startIndex = secion.indexOf(startPage) + 1;\n            var endIndex = secion.indexOf(this.currentPage);\n\n            for (var page = startIndex; page < endIndex + 1; page++) {\n              var pageGraphics = this.currentPage.graphics;\n              var location_2 = new PointF(format.paginateBounds.x, format.paginateBounds.y);\n              var height = page == endIndex ? row.NestedGridLayoutResult.bounds.height - param.bounds.y : this.currentBounds.height - location_2.y;\n              if (height <= pageGraphics.clientSize.height) height += param.bounds.y; // if (row.grid.isChildGrid && row.grid.ParentCell != null)\n              //     location.x += param.bounds.x;\n\n              location_2.y = format == null ? 0.5 : format.paginateBounds.y; // Draw border for last paginated row containing nested grid.\n\n              for (var c = 0; c < row.cells.count; c++) {\n                var cell = row.cells.getCell(c);\n                var cellWidth = 0;\n                var totalwidth = 0;\n\n                if (cell.value instanceof PdfGrid) {\n                  for (var i_6 = 0; i_6 < cell.value.columns.count; i_6++) {\n                    totalwidth += cell.value.columns.getColumn(i_6).columnWidth;\n                  }\n                } else {\n                  totalwidth = cell.width;\n                } // if (cell.columnSpan > 1)\n                // {\n                //     for (; c < cell.columnSpan; c++)\n                //         cellWidth += row.grid.columns.getColumn(c).width;\n                // }\n                // else\n\n\n                cellWidth = Math.max(totalwidth, row.grid.columns.getColumn(c).width);\n                cell.drawCellBorders(pageGraphics, new RectangleF(location_2, new SizeF(cellWidth, height)));\n                location_2.x += cellWidth;\n                c += cell.columnSpan - 1;\n              }\n            } // So, nested grid drawing is completed for the current row. Update page.\n            // Otherwise, the next nested grid of the parent will draw borders from start.\n\n\n            startPage = this.currentPage;\n          }\n        }\n      }\n\n      var isPdfGrid = false;\n      var maximumCellBoundsWidth = 0;\n\n      if (cellBounds.length > 0) {\n        maximumCellBoundsWidth = cellBounds[0];\n      }\n\n      var largeNavigatePage = [[1, 2]];\n\n      for (var c = 0; c < this.Grid.rows.count; c++) {\n        if (this.cellEndIndex != -1 && this.Grid.rows.getRow(c).cells.getCell(this.cellEndIndex).value instanceof PdfGrid) {\n          var grid = this.Grid.rows.getRow(c).cells.getCell(this.cellEndIndex).value;\n          this.rowLayoutBoundsWidth = grid.rowLayoutBoundsWidth;\n          isPdfGrid = true; // if (largeNavigatePage[0][0] < grid.listOfNavigatePages.length)\n          // {\n          //     largeNavigatePage[0][0] = grid.listOfNavigatePages.length;\n          //     largeNavigatePage[0][1] = cellBounds[c];\n          // }\n          // else if ((largeNavigatePage[0][0] == grid.listOfNavigatePages.length) && (largeNavigatePage[0][1] < cellBounds[c]))\n          // {\n          //     largeNavigatePage[0][1] = cellBounds[c];\n          // }\n        }\n      }\n\n      if (!isPdfGrid && cellBounds.length > 0) {\n        for (var c = 0; c < i - 1; c++) {\n          if (maximumCellBoundsWidth < cellBounds[c]) {\n            maximumCellBoundsWidth = cellBounds[c];\n          }\n        }\n\n        this.rowLayoutBoundsWidth = maximumCellBoundsWidth;\n      } else {\n        this.rowLayoutBoundsWidth = largeNavigatePage[0][1];\n      }\n\n      if (this.columnRanges.indexOf(range) < this.columnRanges.length - 1 && startPage != null && format.layout != PdfLayoutType.OnePage) {\n        isParentCell = this.Grid.isChildGrid;\n\n        if (largeNavigatePage[0][0] != 0) {\n          var section = this.currentPage.section;\n          var pageIndex = section.indexOf(this.currentPage);\n          this.currentGraphics = this.currentPage.graphics;\n          this.currentBounds = new RectangleF(new PointF(0, 0), this.currentPage.getClientSize());\n          var pageindex = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);\n        } else {\n          this.currentPage = this.getNextPageformat(format);\n        } // let locationGrid : PointF= new PointF(PdfBorders.default.right.width / 2, PdfBorders.default.top.width / 2);\n        // if (format.paginateBounds == new RectangleF(0,0,0,0) && this.startLocation == locationGrid)\n        // {\n        //     this.currentBounds.x += this.startLocation.x;\n        //     this.currentBounds.y += this.startLocation.y;\n        // }\n\n      }\n\n      if (this.columnRanges.length - 1 !== index && this.columnRanges.length > 1 && format.layout !== PdfLayoutType.OnePage) {\n        this.currentPage = this.getNextPageformat(format);\n\n        if (format.paginateBounds.x === format.paginateBounds.y && format.paginateBounds.y === format.paginateBounds.height && format.paginateBounds.height === format.paginateBounds.width && format.paginateBounds.width === 0) {\n          this.currentBounds.x += this.startLocation.x;\n          this.currentBounds.y += this.startLocation.y; //this.currentBounds.height = this.pageBounds.height;\n        }\n      }\n    }\n\n    result = this.getLayoutResult();\n\n    if (this.Grid.style.allowHorizontalOverflow && this.Grid.style.horizontalOverflowType == PdfHorizontalOverflowType.NextPage) {\n      this.reArrangePages(layoutedPages);\n    }\n\n    this.raisePageLayouted(result);\n    return result;\n  };\n  /* tslint:enable */\n\n  /**\n   * Gets the `next page`.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.getNextPageformat = function (format) {\n    var section = this.currentPage.section;\n    var nextPage = null;\n    var index = section.indexOf(this.currentPage);\n    this.flag = false;\n\n    if (index === section.count - 1) {\n      nextPage = section.add();\n    } else {\n      nextPage = section.getPages()[index + 1];\n    }\n\n    this.currentGraphics = nextPage.graphics;\n    var pageindex = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);\n\n    if (!(this.listOfNavigatePages.indexOf(pageindex) !== -1)) {\n      this.listOfNavigatePages.push(pageindex);\n    }\n\n    this.currentBounds = new RectangleF(new PointF(0, 0), nextPage.getClientSize()); // if ((format.paginateBounds.x !== format.paginateBounds.y) && (format.paginateBounds.y !== format.paginateBounds.height)\n    //     && (format.paginateBounds.height !== format.paginateBounds.width) && (format.paginateBounds.width !== 0)) {\n    //     this.currentBounds.x = format.paginateBounds.x;\n    //     this.currentBounds.y = format.paginateBounds.y;\n    //     this.currentBounds.height = format.paginateBounds.height;\n    // }\n\n    return nextPage;\n  };\n\n  PdfGridLayouter.prototype.CheckIfDefaultFormat = function (format) {\n    var defaultFormat = new PdfStringFormat();\n    return format.alignment === defaultFormat.alignment && format.characterSpacing === defaultFormat.characterSpacing && format.clipPath === defaultFormat.clipPath && format.firstLineIndent === defaultFormat.firstLineIndent && format.horizontalScalingFactor === defaultFormat.horizontalScalingFactor && format.lineAlignment === defaultFormat.lineAlignment && format.lineLimit === defaultFormat.lineLimit && format.lineSpacing === defaultFormat.lineSpacing && format.measureTrailingSpaces === defaultFormat.measureTrailingSpaces && format.noClip === defaultFormat.noClip && format.paragraphIndent === defaultFormat.paragraphIndent && format.rightToLeft === defaultFormat.rightToLeft && format.subSuperScript === defaultFormat.subSuperScript && format.wordSpacing === defaultFormat.wordSpacing && format.wordWrap === defaultFormat.wordWrap;\n  };\n  /**\n   * `Raises BeforeCellDraw event`.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.RaiseBeforeCellDraw = function (graphics, rowIndex, cellIndex, bounds, value, style) {\n    var args = null;\n\n    if (this.Grid.raiseBeginCellDraw) {\n      args = new PdfGridBeginCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, style);\n      this.Grid.onBeginCellDraw(args);\n      style = args.style;\n    }\n\n    return style;\n  };\n  /**\n   * `Raises AfterCellDraw event`.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.raiseAfterCellDraw = function (graphics, rowIndex, cellIndex, bounds, value, cellstyle) {\n    var args = null;\n\n    if (this.Grid.raiseEndCellDraw) {\n      args = new PdfGridEndCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, cellstyle);\n      this.Grid.onEndCellDraw(args);\n    }\n  };\n\n  PdfGridLayouter.prototype.reArrangePages = function (layoutedPages) {\n    var document = this.currentPage.document;\n    var pages = [];\n    var keys = layoutedPages.keys();\n    var values = layoutedPages.values();\n\n    for (var i = 0; i < keys.length; i++) {\n      var page = keys[i];\n      page.section = null;\n      pages.push(page);\n      document.pages.remove(page);\n    }\n    /* tslint:disable */\n\n\n    for (var i = 0; i < layoutedPages.size(); i++) {\n      var count = 0;\n\n      for (var j = i, count_1 = layoutedPages.size() / this.columnRanges.length; j < layoutedPages.size(); j += count_1) {\n        var page = pages[j];\n\n        if (document.pages.indexOf(page) === -1) {\n          document.pages.add(page);\n        }\n      }\n    }\n    /* tslint:enable */\n\n  };\n  /**\n   * Gets the `layout result`.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.getLayoutResult = function () {\n    if (this.Grid.isChildGrid && this.Grid.allowRowBreakAcrossPages) {\n      for (var i = 0; i < this.Grid.rows.count; i++) {\n        var row = this.Grid.rows.getRow(i);\n\n        if (row.rowBreakHeight > 0 && row.repeatFlag) {\n          this.startLocation.y = this.currentPage.origin.y;\n        }\n      }\n    }\n\n    var bounds;\n\n    if (!this.isChanged) {\n      bounds = new RectangleF(this.startLocation, new SizeF(this.currentBounds.width, this.currentBounds.y - this.startLocation.y));\n    } // else {\n    //     bounds = new RectangleF(this.currentLocation, new SizeF(this.currentBounds.width, this.currentBounds.y -\n    //                              this.currentLocation.y));\n    // }\n\n    /* tslint:enable */\n\n\n    return new PdfGridLayoutResult(this.currentPage, bounds);\n  };\n  /**\n   * `Recalculate row height` for the split cell to be drawn.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.ReCalculateHeight = function (row, height) {\n    var newHeight = 0.0;\n\n    for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {\n      if (!(row.cells.getCell(i).remainingString === null || row.cells.getCell(i).remainingString === '' || typeof row.cells.getCell(i).remainingString === 'undefined')) {\n        newHeight = Math.max(newHeight, row.cells.getCell(i).measureHeight());\n      }\n    }\n\n    return Math.max(height, newHeight);\n  };\n  /**\n   * `Raises BeforePageLayout event`.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.raiseBeforePageLayout = function (currentPage, currentBounds, currentRow) {\n    var cancel = false;\n\n    if (this.Grid.raiseBeginPageLayout) {\n      var args = new PdfGridBeginPageLayoutEventArgs(currentBounds, currentPage, currentRow);\n      this.Grid.onBeginPageLayout(args); // if (currentBounds !== args.Bounds) {\n      //     this.isChanged = true;\n      //     this.currentLocation = new PointF(args.Bounds.x, args.Bounds.y);\n      //     this.measureColumnsWidth(new RectangleF(new PointF(args.Bounds.x, args.Bounds.y) ,\n      //                                                  new SizeF(args.Bounds.width + args.Bounds.x ,\n      //                                                                 args.Bounds.height)));\n      // }\n\n      cancel = args.cancel;\n      currentBounds = args.bounds;\n      currentRow = args.startRowIndex;\n    }\n\n    return {\n      returnValue: cancel,\n      currentBounds: currentBounds,\n      currentRowIndex: currentRow\n    };\n  };\n  /**\n   * `Raises PageLayout event` if needed.\n   * @private\n   */\n\n\n  PdfGridLayouter.prototype.raisePageLayouted = function (result) {\n    var args = new PdfGridEndPageLayoutEventArgs(result);\n\n    if (this.Grid.raiseEndPageLayout) {\n      this.Grid.onEndPageLayout(args);\n    }\n\n    return args;\n  };\n\n  PdfGridLayouter.prototype.drawRow = function (row, result, height) {\n    if (typeof result === 'undefined') {\n      //.. Check if required space available.\n      //.....If the row conains spans which  falls through more than one page, then draw the row to next page.                        \n      var result_1 = new RowLayoutResult();\n      var rowHeightWithSpan = 0;\n      var location_3 = new PointF(0, 0);\n      var size = new SizeF(0, 0);\n      var isHeader = false;\n\n      if (row.rowSpanExists) {\n        var maxSpan = 0;\n        var currRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n\n        if (currRowIndex === -1) {\n          currRowIndex = this.Grid.headers.indexOf(row);\n\n          if (currRowIndex !== -1) {\n            isHeader = true;\n          }\n        }\n\n        for (var i = 0; i < row.cells.count; i++) {\n          var cell = row.cells.getCell(i);\n          maxSpan = Math.max(maxSpan, cell.rowSpan);\n        }\n\n        for (var i = currRowIndex; i < currRowIndex + maxSpan; i++) {\n          rowHeightWithSpan += isHeader ? this.Grid.headers.getHeader(i).height : this.Grid.rows.getRow(i).height;\n        } // let rowMaxHeight : number = rowHeightWithSpan;\n        // for (let i : number = 0; i < row.cells.count; i++ ) {\n        //     rowMaxHeight = rowMaxHeight > row.cells.getCell(i).height ? rowMaxHeight : row.cells.getCell(i).height;\n        // }\n        // let flag : boolean = true;\n        // let nextRow : PdfGridRow = this.Grid.headers.getHeader(this.Grid.headers.indexOf(row) + 1);\n        // for (let i : number = 0; i < nextRow.cells.count; i++ ) {\n        //     if (nextRow.cells.getCell(i).value !== '' && nextRow.cells.getCell(i).value !== undefined) {\n        //         flag = false;\n        //         break;\n        //     }\n        // }\n        // if ((rowMaxHeight > rowHeightWithSpan) && flag) {\n        //     row.height += (rowMaxHeight - rowHeightWithSpan);\n        // }                \n\n      }\n\n      var calculatedHeight = row.rowBreakHeight > 0.0 ? row.rowBreakHeight : row.height;\n\n      if (this.Grid.isChildGrid && this.Grid.ParentCell != null) {\n        //Split row only if row height exceeds page height and AllowRowBreakAcrossPages is true.\n        // if (calculatedHeight + this.Grid.ParentCell.row.grid.style.cellPadding.bottom +\n        //             this.Grid.ParentCell.row.grid.style.cellPadding.top > this.currentPageBounds.height) {\n        //     if (this.Grid.allowRowBreakAcrossPages) {\n        //         result.isFinish = true;\n        //         if ( this.Grid.isChildGrid && row.rowBreakHeight > 0 ) {\n        //             if (this.Grid.ParentCell.row.grid.style.cellPadding !== null) {\n        //                 this.currentBounds.y += this.Grid.ParentCell.row.grid.style.cellPadding.top;\n        //             }\n        //             this.currentBounds.x = this.startLocation.x;\n        //         }\n        //         result.bounds = this.currentBounds ;\n        //         this.drawRowWithBreak(result, row, calculatedHeight);\n        //     } else {\n        //         //If AllowRowBreakAcrossPages is not true, draw the row till it fits the page.                       \n        //         if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {\n        //             this.currentBounds.y += this.Grid.ParentCell.row.grid.style.cellPadding.top;\n        //             calculatedHeight = this.currentBounds.height - this.currentBounds.y -\n        //                     this.Grid.ParentCell.row.grid.style.cellPadding.bottom;\n        //         }\n        //         result.isFinish = false;\n        //         this.drawRow( row, result, calculatedHeight);\n        //     }\n        // } else\n        if (this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentPageBounds.height || this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentBounds.height || this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + rowHeightWithSpan > this.currentPageBounds.height) {\n          //If a row is repeated and still cannot fit in page, proceed draw.\n          if (this.Grid.ParentCell.row.grid.LayoutFormat.break === PdfLayoutBreakType.FitPage) {\n            PdfGridLayouter.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n            this.Grid.splitChildRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n          }\n\n          if (PdfGridLayouter.repeatRowIndex > -1 && PdfGridLayouter.repeatRowIndex === row.rowIndex) {\n            if (this.Grid.allowRowBreakAcrossPages) {\n              result_1.isFinish = true; // if (this.Grid.isChildGrid && row.rowBreakHeightValue > 0) {\n              //     // if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {\n              //     //     this.currentBounds.y += this.Grid.ParentCell.row.grid.style.cellPadding.top;\n              //     // }\n              //     this.currentBounds.x = this.startLocation.x;\n              // }\n\n              result_1.bounds = this.currentBounds;\n              this.drawRowWithBreak(result_1, row, calculatedHeight);\n              row.repeatFlag = true;\n              row.repeatRowNumber = PdfGridLayouter.repeatRowIndex;\n            } // else {\n            //     result.isFinish = false;\n            //     row.repeatFlag = false;\n            //     this.drawRow( row, result, calculatedHeight);\n            // }\n\n          } // else {\n          //     result.isFinish = false;\n          // }\n\n        } else {\n          result_1.isFinish = true;\n\n          if (row.grid.ParentCell.row.rowBreakHeightValue > 0) {\n            row.repeatFlag = true;\n          } else {\n            row.repeatFlag = false;\n            calculatedHeight = row.height;\n          }\n\n          if (this.Grid.isChildGrid && row.rowBreakHeight > 0) {\n            if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {\n              calculatedHeight += this.Grid.ParentCell.row.grid.style.cellPadding.bottom;\n            }\n          }\n\n          this.drawRow(row, result_1, calculatedHeight);\n        }\n      } else {\n        //Split row only if row height exceeds page height and AllowRowBreakAcrossPages is true.\n        if (calculatedHeight > this.currentPageBounds.height) {\n          if (this.Grid.allowRowBreakAcrossPages) {\n            result_1.isFinish = true; //result.bounds = this.currentBounds;\n\n            this.drawRowWithBreak(result_1, row, calculatedHeight);\n            row.isrowFinish = true;\n            row.repeatFlag = true;\n\n            if (row.grid.splitChildRowIndex !== -1) {\n              result_1.isFinish = false;\n            }\n          } // else {\n          //     //If AllowRowBreakAcrossPages is not true, draw the row till it fits the page.\n          //     result.isFinish = false;\n          //     this.drawRow( row, result, calculatedHeight);\n          // }\n\n        } else if (this.currentBounds.y + calculatedHeight > this.currentPageBounds.height || this.currentBounds.y + calculatedHeight > this.currentBounds.height + this.startLocation.y || this.currentBounds.y + rowHeightWithSpan > this.currentPageBounds.height) {\n          // If a row is repeated and still cannot fit in page, proceed draw.\n          if (this.Grid.LayoutFormat.break === PdfLayoutBreakType.FitPage) {\n            PdfGridLayouter.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);\n          }\n\n          if (PdfGridLayouter.repeatRowIndex > -1 && PdfGridLayouter.repeatRowIndex === row.rowIndex) {\n            if (this.Grid.allowRowBreakAcrossPages) {\n              result_1.isFinish = true;\n              this.drawRowWithBreak(result_1, row, calculatedHeight);\n              row.repeatFlag = true;\n              row.repeatRowNumber = PdfGridLayouter.repeatRowIndex;\n\n              if (row.grid.splitChildRowIndex !== -1) {\n                result_1.isFinish = false;\n              }\n            } // else {\n            //     result.isFinish = false;\n            //     this.drawRow(row, result, calculatedHeight);\n            // }\n\n          } else {\n            result_1.isFinish = false;\n          }\n        } else {\n          result_1.isFinish = true;\n          this.drawRow(row, result_1, calculatedHeight);\n          row.repeatFlag = false;\n        }\n      }\n\n      return result_1;\n    } else {\n      var skipcell = false;\n      var location_4 = new PointF(this.currentBounds.x, this.currentBounds.y); // if (row.grid.isChildGrid && row.grid.allowRowBreakAcrossPages && this.startLocation.x !== this.currentBounds.x && row.width <\n      //                 this.currentPage.getClientSize().width) {\n      //     location.x = this.startLocation.x;\n      // }\n\n      result.bounds = new RectangleF(location_4, new SizeF(0, 0));\n      height = this.ReCalculateHeight(row, height);\n\n      for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {\n        var cancelSpans = i > this.cellEndIndex + 1 && row.cells.getCell(i).columnSpan > 1; // let cancelSpans : boolean = false;\n\n        if (!cancelSpans) {\n          for (var j = 1; j < row.cells.getCell(i).columnSpan; j++) {\n            row.cells.getCell(i + j).isCellMergeContinue = true;\n          }\n        }\n\n        var size = new SizeF(this.Grid.columns.getColumn(i).width, height); // if (size.width > this.currentGraphics.clientSize.width) {\n        //     size.width = this.currentGraphics.clientSize.width;\n        // }\n        // if (this.Grid.isChildGrid && this.Grid.style.allowHorizontalOverflow) {\n        //     if (size.width >= this.currentGraphics.clientSize.width) {\n        //         size.width -= 2 * this.currentBounds.x;\n        //     }\n        // }\n\n        /* tslint:disable */\n\n        if (!this.CheckIfDefaultFormat(this.Grid.columns.getColumn(i).format) && this.CheckIfDefaultFormat(row.cells.getCell(i).stringFormat)) {\n          row.cells.getCell(i).stringFormat = this.Grid.columns.getColumn(i).format;\n        }\n\n        var cellstyle = row.cells.getCell(i).style;\n        var tempValue = typeof row.cells.getCell(i).value === 'string' && row.cells.getCell(i).value !== null ? row.cells.getCell(i).value : '';\n        row.cells.getCell(i).style = this.RaiseBeforeCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(location_4, size), tempValue, cellstyle); //row.cells.getCell(i).style = cellstyle;\n\n        if (!skipcell) {\n          if (row.cells.getCell(i).value instanceof PdfGrid) {\n            var grid = row.cells.getCell(i).value;\n            grid.parentCellIndex = i;\n          }\n\n          var stringResult = row.cells.getCell(i).draw(this.currentGraphics, new RectangleF(location_4, size), cancelSpans);\n\n          if (row.grid.style.allowHorizontalOverflow && (row.cells.getCell(i).columnSpan > this.cellEndIndex || i + row.cells.getCell(i).columnSpan > this.cellEndIndex + 1) && this.cellEndIndex < row.cells.count - 1) {\n            row.rowOverflowIndex = this.cellEndIndex;\n          }\n\n          if (row.grid.style.allowHorizontalOverflow && row.rowOverflowIndex > 0 && (row.cells.getCell(i).columnSpan > this.cellEndIndex || i + row.cells.getCell(i).columnSpan > this.cellEndIndex + 1) && row.cells.getCell(i).columnSpan - this.cellEndIndex + i - 1 > 0) {\n            row.cells.getCell(row.rowOverflowIndex + 1).value = stringResult !== null ? stringResult.remainder !== undefined ? stringResult.remainder : '' : '';\n            row.cells.getCell(row.rowOverflowIndex + 1).stringFormat = row.cells.getCell(i).stringFormat;\n            row.cells.getCell(row.rowOverflowIndex + 1).style = row.cells.getCell(i).style;\n            row.cells.getCell(row.rowOverflowIndex + 1).columnSpan = row.cells.getCell(i).columnSpan - this.cellEndIndex + i - 1;\n          }\n        }\n        /* tslint:enable */\n\n\n        tempValue = typeof row.cells.getCell(i).value === 'string' && row.cells.getCell(i).value !== null ? row.cells.getCell(i).value : '';\n\n        if (!cancelSpans) {\n          this.raiseAfterCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(location_4, size), tempValue, row.cells.getCell(i).style);\n        }\n\n        if (row.cells.getCell(i).value instanceof PdfGrid) {\n          var grid = row.cells.getCell(i).value;\n\n          if (this.Grid.columns.getColumn(i).width >= this.currentGraphics.clientSize.width) {\n            location_4.x = grid.rowLayoutBoundsWidth;\n            location_4.x += grid.style.cellSpacing;\n          } else {\n            location_4.x += this.Grid.columns.getColumn(i).width;\n          }\n        } else {\n          location_4.x += this.Grid.columns.getColumn(i).width;\n        }\n      }\n\n      if (!row.rowMergeComplete || row.isRowHeightSet) {\n        this.currentBounds.y += height;\n      }\n\n      result.bounds = new RectangleF(new PointF(result.bounds.x, result.bounds.y), new SizeF(location_4.x, location_4.y));\n    }\n  };\n\n  PdfGridLayouter.prototype.drawRowWithBreak = function (result, row, calculateHeight) {\n    var location = new PointF(this.currentBounds.x, this.currentBounds.y);\n\n    if (row.grid.isChildGrid && row.grid.allowRowBreakAcrossPages && this.startLocation.x !== this.currentBounds.x) {\n      location.x = this.startLocation.x;\n    }\n\n    result.bounds = new RectangleF(location, new SizeF(0, 0));\n    this.gridHeight = row.rowBreakHeight > 0 ? this.currentPageBounds.height : 0; // Calculate the remaining height.\n\n    if (row.grid.style.cellPadding.top + this.currentBounds.y + row.grid.style.cellPadding.bottom < this.currentPageBounds.height) {\n      row.rowBreakHeight = this.currentBounds.y + calculateHeight - this.currentPageBounds.height;\n    } // else {\n    //     row.rowBreakHeight = calculateHeight;\n    //     result.isFinish = false;\n    //     return;\n    // }\n    // No need to explicit break if the row height is equal to grid height.\n\n\n    for (var i = 0; i < row.cells.count; i++) {\n      var cell = row.cells.getCell(i);\n      var cellHeight = cell.measureHeight();\n\n      if (cellHeight === calculateHeight && cell.value instanceof PdfGrid) {\n        row.rowBreakHeight = 0;\n      } // else if (cellHeight === calculateHeight && (cell.value as PdfGrid) === null) {\n      //     row.rowBreakHeight = this.currentBounds.y + calculateHeight - this.currentPageBounds.height;\n      // }\n\n    }\n\n    for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {\n      var cancelSpans = row.cells.getCell(i).columnSpan + i > this.cellEndIndex + 1 && row.cells.getCell(i).columnSpan > 1; // if (!cancelSpans) {\n      //     for (let k : number = 1; k < row.cells.getCell(i).columnSpan; k++) {\n      //         row.cells.getCell(i + k).isCellMergeContinue = true;\n      //     }\n      //}\n\n      var size = new SizeF(this.Grid.columns.getColumn(i).width, this.gridHeight > 0.0 ? this.gridHeight : this.currentPageBounds.height); // if (size.width === 0) {\n      //     size = new SizeF(row.cells.getCell(i).width, size.height);\n      // }\n      // if (!this.CheckIfDefaultFormat(this.Grid.columns.getColumn(i).format) &&\n      //         this.CheckIfDefaultFormat((row.cells.getCell(i).stringFormat))) {\n      //     row.cells.getCell(i).stringFormat = this.Grid.columns.getColumn(i).format;\n      // }\n\n      var cellstyle1 = row.cells.getCell(i).style;\n      row.cells.getCell(i).style = cellstyle1;\n      var skipcell = false;\n      var stringResult = null;\n\n      if (!skipcell) {\n        stringResult = row.cells.getCell(i).draw(this.currentGraphics, new RectangleF(location, size), cancelSpans);\n      } //If still row is to be drawn, set cell finished drawing cell as false and update the text to be drawn.\n\n\n      if (row.rowBreakHeight > 0.0) {\n        if (stringResult != null) {\n          row.cells.getCell(i).FinishedDrawingCell = false;\n          row.cells.getCell(i).remainingString = stringResult.remainder == null ? ' ' : stringResult.remainder;\n\n          if (row.grid.isChildGrid) {\n            row.rowBreakHeight = calculateHeight - stringResult.actualSize.height;\n          }\n        }\n      }\n\n      result.isFinish = !result.isFinish ? result.isFinish : row.cells.getCell(i).FinishedDrawingCell; // let tempValue : string = ((typeof row.cells.getCell(i).value === 'string' &&\n      //row.cells.getCell(i).value !== null) ? row.cells.getCell(i).value : '') as string;\n      // if (!cancelSpans) {\n      //     // this.raiseAfterCellDraw(this.currentGraphics, this.currentRowIndex, i,\n      //     //           new RectangleF(location, size), tempValue, row.cells.getCell(i).style);            \n      //     this.raiseAfterCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(location, size),\n      //                             (row.cells.getCell(i).value as string) ? row.cells.getCell(i).value.toString() : ' ',\n      //                             row.cells.getCell(i).style);\n      //     }                \n\n      if (row.cells.getCell(i).value instanceof PdfGrid) {\n        var grid = row.cells.getCell(i).value;\n        this.rowBreakPageHeightCellIndex = i; // row.cells.getCell(i).pageCount = grid.listOfNavigatePages.length;\n        // for (let j : number = 0;j<grid.listOfNavigatePages.length;j++){\n        //     let pageIndex : number =grid.listOfNavigatePages.indexOf(j);\n        //             this.Grid.listOfNavigatePages.push(pageIndex);\n        //     }\n\n        if (this.Grid.columns.getColumn(i).width >= this.currentGraphics.clientSize.width) {\n          location.x = this.rowLayoutBoundsWidth;\n          location.x += grid.style.cellSpacing;\n        } else {\n          location.x += this.Grid.columns.getColumn(i).width;\n        }\n      } else {\n        location.x += this.Grid.columns.getColumn(i).width;\n      }\n    }\n\n    this.currentBounds.y += this.gridHeight > 0.0 ? this.gridHeight : calculateHeight;\n    result.bounds = new RectangleF(new PointF(result.bounds.x, result.bounds.y), new SizeF(location.x, location.y));\n  };\n  /**\n   * @hidden\n   * @private\n   */\n\n\n  PdfGridLayouter.repeatRowIndex = -1;\n  return PdfGridLayouter;\n}(ElementLayouter);\n\nexport { PdfGridLayouter }; // recalculateBounds : boolean, clientSize : SizeF\n//Implementation\n\n/**\n * `Initializes` internal data.\n * @private\n */\n//Internal declaration\n\nvar PdfGridLayoutResult =\n/** @class */\nfunction (_super) {\n  __extends(PdfGridLayoutResult, _super);\n  /**\n   * Constructor\n   * @private\n   */\n\n\n  function PdfGridLayoutResult(page, bounds) {\n    return _super.call(this, page, bounds) || this;\n  }\n\n  return PdfGridLayoutResult;\n}(PdfLayoutResult);\n\nexport { PdfGridLayoutResult };\n/**\n * `PdfGridLayoutFormat` class represents a flexible grid that consists of columns and rows.\n */\n\nvar PdfGridLayoutFormat =\n/** @class */\nfunction (_super) {\n  __extends(PdfGridLayoutFormat, _super);\n  /**\n   * Initializes a new instance of the `PdfGridLayoutFormat` class.\n   * @private\n   */\n\n\n  function PdfGridLayoutFormat(baseFormat) {\n    return _super.call(this, baseFormat) || this;\n  }\n\n  return PdfGridLayoutFormat;\n}(PdfLayoutFormat);\n\nexport { PdfGridLayoutFormat };\n\nvar GridCellEventArgs =\n/** @class */\nfunction () {\n  // Constructors\n\n  /**\n   * Initialize a new instance for `GridCellEventArgs` class.\n   * @private\n   */\n  function GridCellEventArgs(graphics, rowIndex, cellIndex, bounds, value) {\n    this.gridRowIndex = rowIndex;\n    this.gridCellIndex = cellIndex;\n    this.internalValue = value;\n    this.gridBounds = bounds;\n    this.pdfGraphics = graphics;\n  }\n\n  Object.defineProperty(GridCellEventArgs.prototype, \"rowIndex\", {\n    // Properties\n\n    /**\n     * Gets the value of current `row index`.\n     * @private\n     */\n    get: function () {\n      return this.gridRowIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GridCellEventArgs.prototype, \"cellIndex\", {\n    /**\n     * Gets the value of current `cell index`.\n     * @private\n     */\n    get: function () {\n      return this.gridCellIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GridCellEventArgs.prototype, \"value\", {\n    /**\n     * Gets the actual `value` of current cell.\n     * @private\n     */\n    get: function () {\n      return this.internalValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GridCellEventArgs.prototype, \"bounds\", {\n    /**\n     * Gets the `bounds` of current cell.\n     * @private\n     */\n    get: function () {\n      return this.gridBounds;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GridCellEventArgs.prototype, \"graphics\", {\n    /**\n     * Gets the instance of `current graphics`.\n     * @private\n     */\n    get: function () {\n      return this.pdfGraphics;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return GridCellEventArgs;\n}();\n\nexport { GridCellEventArgs };\n\nvar PdfGridBeginCellDrawEventArgs =\n/** @class */\nfunction (_super) {\n  __extends(PdfGridBeginCellDrawEventArgs, _super); // Constructors\n\n  /**\n   * Initializes a new instance of the `StartCellLayoutEventArgs` class.\n   * @private\n   */\n\n\n  function PdfGridBeginCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, style) {\n    var _this = _super.call(this, graphics, rowIndex, cellIndex, bounds, value) || this;\n\n    _this.style = style;\n    return _this;\n  }\n\n  Object.defineProperty(PdfGridBeginCellDrawEventArgs.prototype, \"skip\", {\n    // Properties\n\n    /**\n     * Gets or sets a value indicating whether the value of this cell should be `skipped`.\n     * @private\n     */\n    get: function () {\n      return this.bSkip;\n    },\n    set: function (value) {\n      this.bSkip = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfGridBeginCellDrawEventArgs.prototype, \"style\", {\n    /**\n     * Gets or sets a `style` value of the cell.\n     * @private\n     */\n    get: function () {\n      return this.cellStyle;\n    },\n    set: function (value) {\n      this.cellStyle = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PdfGridBeginCellDrawEventArgs;\n}(GridCellEventArgs);\n\nexport { PdfGridBeginCellDrawEventArgs };\n\nvar PdfGridEndCellDrawEventArgs =\n/** @class */\nfunction (_super) {\n  __extends(PdfGridEndCellDrawEventArgs, _super); // Constructors\n\n  /**\n   * Initializes a new instance of the `PdfGridEndCellLayoutEventArgs` class.\n   * @private\n   */\n\n\n  function PdfGridEndCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, style) {\n    var _this = _super.call(this, graphics, rowIndex, cellIndex, bounds, value) || this;\n\n    _this.cellStyle = style;\n    return _this;\n  }\n\n  Object.defineProperty(PdfGridEndCellDrawEventArgs.prototype, \"style\", {\n    // Propertise\n\n    /**\n     * Get the `PdfGridCellStyle`.\n     * @private\n     */\n    get: function () {\n      return this.cellStyle;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PdfGridEndCellDrawEventArgs;\n}(GridCellEventArgs);\n\nexport { PdfGridEndCellDrawEventArgs };\n\nvar PdfCancelEventArgs =\n/** @class */\nfunction () {\n  function PdfCancelEventArgs() {}\n\n  Object.defineProperty(PdfCancelEventArgs.prototype, \"cancel\", {\n    // Properties\n\n    /**\n     * Gets and Sets the value of `cancel`.\n     * @private\n     */\n    get: function () {\n      return this.isCancel;\n    },\n    set: function (value) {\n      this.isCancel = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PdfCancelEventArgs;\n}();\n\nexport { PdfCancelEventArgs };\n\nvar BeginPageLayoutEventArgs =\n/** @class */\nfunction (_super) {\n  __extends(BeginPageLayoutEventArgs, _super); // Constructors\n\n  /**\n   * Initializes a new instance of the `BeginPageLayoutEventArgs` class with the specified rectangle and page.\n   * @private\n   */\n\n\n  function BeginPageLayoutEventArgs(bounds, page) {\n    var _this = _super.call(this) || this;\n\n    _this.bounds = bounds;\n    _this.pdfPage = page;\n    return _this;\n  }\n\n  Object.defineProperty(BeginPageLayoutEventArgs.prototype, \"bounds\", {\n    // Properties\n\n    /**\n     * Gets or sets value that indicates the lay outing `bounds` on the page.\n     * @private\n     */\n    get: function () {\n      return this.cellBounds;\n    },\n    set: function (value) {\n      this.cellBounds = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BeginPageLayoutEventArgs.prototype, \"page\", {\n    /**\n     * Gets the `page` where the lay outing should start.\n     * @private\n     */\n    get: function () {\n      return this.pdfPage;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return BeginPageLayoutEventArgs;\n}(PdfCancelEventArgs);\n\nexport { BeginPageLayoutEventArgs };\n/**\n * `EndPageLayoutEventArgs` class is alternate for end page layout events.\n */\n\nvar EndPageLayoutEventArgs =\n/** @class */\nfunction (_super) {\n  __extends(EndPageLayoutEventArgs, _super); // Constructors\n\n  /**\n   * Initializes a new instance of the `EndPageLayoutEventArgs` class. with the specified 'PdfLayoutResult'.\n   * @private\n   */\n\n\n  function EndPageLayoutEventArgs(result) {\n    var _this = _super.call(this) || this;\n\n    _this.layoutResult = result;\n    return _this;\n  }\n\n  Object.defineProperty(EndPageLayoutEventArgs.prototype, \"result\", {\n    // Properties\n\n    /**\n     * Gets the lay outing `result` of the page.\n     * @private\n     */\n    get: function () {\n      return this.layoutResult;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(EndPageLayoutEventArgs.prototype, \"nextPage\", {\n    /**\n     * Gets or sets a value indicating the `next page` where the element should be layout.\n     * @private\n     */\n    get: function () {\n      return this.nextPdfPage;\n    },\n    set: function (value) {\n      this.nextPdfPage = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return EndPageLayoutEventArgs;\n}(PdfCancelEventArgs);\n\nexport { EndPageLayoutEventArgs };\n/**\n * `PdfGridBeginPageLayoutEventArgs` class is alternate for begin page layout events.\n */\n\nvar PdfGridBeginPageLayoutEventArgs =\n/** @class */\nfunction (_super) {\n  __extends(PdfGridBeginPageLayoutEventArgs, _super); // Constructors\n\n  /**\n   * Initialize a new instance of `PdfGridBeginPageLayoutEventArgs` class.\n   * @private\n   */\n\n\n  function PdfGridBeginPageLayoutEventArgs(bounds, page, startRow) {\n    var _this = _super.call(this, bounds, page) || this;\n\n    _this.startRow = startRow;\n    return _this;\n  }\n\n  Object.defineProperty(PdfGridBeginPageLayoutEventArgs.prototype, \"startRowIndex\", {\n    // Properties\n\n    /**\n     * Gets the `start row index`.\n     * @private\n     */\n    get: function () {\n      return this.startRow;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PdfGridBeginPageLayoutEventArgs;\n}(BeginPageLayoutEventArgs);\n\nexport { PdfGridBeginPageLayoutEventArgs };\n/**\n * `PdfGridEndPageLayoutEventArgs` class is alternate for begin page layout events.\n */\n\nvar PdfGridEndPageLayoutEventArgs =\n/** @class */\nfunction (_super) {\n  __extends(PdfGridEndPageLayoutEventArgs, _super); // Constructors\n\n  /**\n   * Initialize a new instance of `PdfGridEndPageLayoutEventArgs` class.\n   * @private\n   */\n\n\n  function PdfGridEndPageLayoutEventArgs(result) {\n    return _super.call(this, result) || this;\n  }\n\n  return PdfGridEndPageLayoutEventArgs;\n}(EndPageLayoutEventArgs);\n\nexport { PdfGridEndPageLayoutEventArgs };\n\nvar RowLayoutResult =\n/** @class */\nfunction () {\n  //Constructors\n\n  /**\n   * Initializes a new instance of the `RowLayoutResult` class.\n   * @private\n   */\n  function RowLayoutResult() {\n    this.layoutedBounds = new RectangleF(0, 0, 0, 0);\n  }\n\n  Object.defineProperty(RowLayoutResult.prototype, \"isFinish\", {\n    /**\n     * Gets or sets a value indicating whether this instance `is finish`.\n     * @private\n     */\n    get: function () {\n      return this.bIsFinished;\n    },\n    set: function (value) {\n      this.bIsFinished = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RowLayoutResult.prototype, \"bounds\", {\n    /**\n     * Gets or sets the `bounds`.\n     * @private\n     */\n    get: function () {\n      return this.layoutedBounds;\n    },\n    set: function (value) {\n      this.layoutedBounds = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return RowLayoutResult;\n}();\n\nexport { RowLayoutResult };","map":null,"metadata":{},"sourceType":"module"}