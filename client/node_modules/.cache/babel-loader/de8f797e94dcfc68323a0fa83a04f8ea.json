{"ast":null,"code":"import * as events from '../base/constant';\nimport { PdfDocument, PdfGrid, PdfBorders, PdfPen, PdfPaddings } from '@syncfusion/ej2-pdf-export';\nimport { PdfStandardFont, PdfFontFamily, PdfFontStyle, PdfBitmap } from '@syncfusion/ej2-pdf-export';\nimport { PdfStringFormat, PdfTextAlignment, PdfColor, PdfSolidBrush } from '@syncfusion/ej2-pdf-export';\nimport { PdfVerticalAlignment, RectangleF, PdfPageTemplateElement } from '@syncfusion/ej2-pdf-export';\nimport { PointF, PdfPageNumberField, PdfCompositeField } from '@syncfusion/ej2-pdf-export';\nimport { PdfPageCountField, SizeF, PdfPageSettings, PdfPageOrientation } from '@syncfusion/ej2-pdf-export';\nimport { PdfTrueTypeFont } from '@syncfusion/ej2-pdf-export';\nimport { ExportHelper, ExportValueFormatter } from './export-helper';\nimport { Data } from '../actions/data';\nimport { SummaryModelGenerator, GroupSummaryModelGenerator, CaptionSummaryModelGenerator } from '../services/summary-model-generator';\nimport { compile, getEnumValue, isNullOrUndefined, detach, isBlazor } from '@syncfusion/ej2-base';\nimport { CellType, AggregateTemplateType } from '../base/enum';\nimport { DataManager, Query } from '@syncfusion/ej2-data';\nimport { getValue } from '@syncfusion/ej2-base';\nimport { getUid, getPrintGridModel, measureColumnDepth, isExportColumns, updateColumnTypeForExportColumns, prepareColumns } from '../base/util';\n/**\n * `PDF Export` module is used to handle the exportToPDF action.\n * @hidden\n */\n\nvar PdfExport =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the Grid PDF Export module\n   * @hidden\n   */\n  function PdfExport(parent) {\n    this.hideColumnInclude = false;\n    this.currentViewData = false;\n    this.customDataSource = false;\n    this.isGrouping = false;\n    this.headerOnPages = [];\n    this.drawPosition = {\n      xPosition: 0,\n      yPosition: 0\n    };\n    this.parent = parent;\n    this.helper = new ExportHelper(parent);\n    this.gridPool = {};\n  }\n  /**\n   * For internal use only - Get the module name.\n   */\n\n\n  PdfExport.prototype.getModuleName = function () {\n    return 'PdfExport';\n  };\n\n  PdfExport.prototype.init = function (parent) {\n    this.exportValueFormatter = new ExportValueFormatter(parent.locale);\n    this.pdfDocument = undefined;\n    this.hideColumnInclude = false;\n    this.currentViewData = false;\n    this.parent = parent;\n    this.isGrouping = false;\n    this.isExporting = true;\n    parent.id = getUid('main-grid');\n    this.gridPool[parent.id] = false;\n    this.pdfPageSettings = new PdfPageSettings();\n  };\n\n  PdfExport.prototype.exportWithData = function (parent, pdfDoc, resolve, returnType, pdfExportProperties, isMultipleExport, reject) {\n    var _this = this;\n\n    this.init(parent);\n\n    if (!isNullOrUndefined(pdfDoc)) {\n      this.pdfDocument = pdfDoc;\n    } else {\n      this.pdfDocument = new PdfDocument();\n    }\n\n    this.processExport(parent, returnType, pdfExportProperties, isMultipleExport).then(function () {\n      _this.isExporting = false;\n      parent.trigger(events.pdfExportComplete, _this.isBlob ? {\n        promise: _this.blobPromise\n      } : {});\n\n      _this.parent.log('exporting_complete', _this.getModuleName());\n\n      resolve(_this.pdfDocument);\n    }).catch(function (e) {\n      reject(_this.pdfDocument);\n\n      _this.parent.trigger(events.actionFailure, e);\n    });\n  };\n  /**\n   * Used to map the input data\n   * @return {void}\n   */\n\n\n  PdfExport.prototype.Map = function (parent, pdfExportProperties, isMultipleExport, pdfDoc, isBlob) {\n    var _this = this;\n\n    this.data = new Data(this.parent);\n    this.isBlob = isBlob;\n    this.gridPool = {};\n\n    if (parent.childGrid && !(!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.hierarchyExportMode === 'None')) {\n      parent.expandedRows = getPrintGridModel(parent).expandedRows;\n    }\n\n    var args = {\n      requestType: 'beforePdfExport',\n      cancel: false,\n      headerPageNumbers: [],\n      gridDrawPosition: {\n        xPosition: 0,\n        yPosition: 0\n      }\n    };\n\n    if (!isBlazor()) {\n      var gridObject = 'gridObject';\n      args[gridObject] = parent;\n    }\n\n    var can = 'cancel';\n    var header = 'headerPageNumbers';\n    var drawPos = 'gridDrawPosition';\n    parent.trigger(events.beforePdfExport, args);\n\n    if (args[can] === true) {\n      return new Promise(function (resolve, reject) {\n        return resolve();\n      });\n    }\n\n    if (isExportColumns(pdfExportProperties)) {\n      updateColumnTypeForExportColumns(pdfExportProperties, parent);\n    }\n\n    this.headerOnPages = args[header];\n    this.drawPosition = args[drawPos];\n    this.parent.log('exporting_begin', this.getModuleName());\n\n    if (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.dataSource)) {\n      if (!(pdfExportProperties.dataSource instanceof DataManager)) {\n        pdfExportProperties.dataSource = new DataManager(pdfExportProperties.dataSource);\n      }\n\n      return new Promise(function (resolve, reject) {\n        pdfExportProperties.dataSource.executeQuery(new Query()).then(function (returnType) {\n          _this.exportWithData(parent, pdfDoc, resolve, returnType, pdfExportProperties, isMultipleExport, reject);\n        });\n      });\n    } else if (!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.exportType === 'CurrentPage') {\n      return new Promise(function (resolve, reject) {\n        _this.exportWithData(parent, pdfDoc, resolve, _this.parent.getCurrentViewRecords(), pdfExportProperties, isMultipleExport, reject);\n      });\n    } else {\n      var allPromise_1 = [];\n      allPromise_1.push(this.data.getData({}, ExportHelper.getQuery(parent, this.data)));\n      allPromise_1.push(this.helper.getColumnData(parent));\n      return new Promise(function (resolve, reject) {\n        Promise.all(allPromise_1).then(function (e) {\n          _this.init(parent);\n\n          if (!isNullOrUndefined(pdfDoc)) {\n            _this.pdfDocument = pdfDoc;\n          } else {\n            _this.pdfDocument = new PdfDocument();\n          }\n\n          _this.processExport(parent, e[0], pdfExportProperties, isMultipleExport).then(function () {\n            _this.isExporting = false;\n            parent.trigger(events.pdfExportComplete, _this.isBlob ? {\n              promise: _this.blobPromise\n            } : {});\n\n            _this.parent.log('exporting_complete', _this.getModuleName());\n\n            resolve(_this.pdfDocument);\n          }).catch(function (e) {\n            reject(_this.pdfDocument);\n\n            _this.parent.trigger(events.actionFailure, e);\n          });\n        });\n      });\n    }\n  };\n\n  PdfExport.prototype.processExport = function (gObj, returnType, pdfExportProperties, isMultipleExport) {\n    var _this = this;\n\n    var section = this.pdfDocument.sections.add();\n    var pdfGrid;\n    this.processSectionExportProperties(section, pdfExportProperties);\n    var pdfPage = section.pages.add();\n    return new Promise(function (resolve, reject) {\n      pdfGrid = _this.processGridExport(gObj, returnType, pdfExportProperties);\n      _this.globalResolve = resolve;\n      _this.gridPool[gObj.id] = true;\n\n      _this.helper.checkAndExport(_this.gridPool, _this.globalResolve);\n    }).then(function () {\n      // draw the grid\n      var xPosition = 'xPosition';\n      var yPosition = 'yPosition';\n      pdfGrid.draw(pdfPage, _this.drawPosition[xPosition], _this.drawPosition[yPosition]);\n\n      _this.drawHeader(pdfExportProperties);\n\n      if (!isMultipleExport) {\n        // save the PDF\n        if (!_this.isBlob) {\n          if (!isNullOrUndefined(pdfExportProperties) && pdfExportProperties.fileName) {\n            _this.pdfDocument.save(pdfExportProperties.fileName);\n          } else {\n            _this.pdfDocument.save('Export.pdf');\n          }\n        } else {\n          _this.blobPromise = _this.pdfDocument.save();\n        }\n\n        _this.pdfDocument.destroy();\n\n        delete gObj.expandedRows;\n      }\n\n      return _this.pdfDocument;\n    });\n  };\n\n  PdfExport.prototype.processSectionExportProperties = function (section, pdfExportProperties) {\n    if (!isNullOrUndefined(pdfExportProperties) && (!isNullOrUndefined(pdfExportProperties.pageOrientation) || !isNullOrUndefined(pdfExportProperties.pageSize))) {\n      this.pdfPageSettings.orientation = pdfExportProperties.pageOrientation === 'Landscape' ? PdfPageOrientation.Landscape : PdfPageOrientation.Portrait;\n      this.pdfPageSettings.size = this.getPageSize(pdfExportProperties.pageSize);\n      section.setPageSettings(this.pdfPageSettings);\n    }\n\n    return section;\n  };\n\n  PdfExport.prototype.processGridExport = function (gObj, returnType, pdfExportProperties) {\n    var allowHorizontalOverflow = true;\n\n    if (!isNullOrUndefined(pdfExportProperties)) {\n      this.gridTheme = pdfExportProperties.theme;\n\n      if (isBlazor() && !isNullOrUndefined(this.gridTheme)) {\n        this.getGridPdfFont(this.gridTheme);\n      }\n\n      allowHorizontalOverflow = isNullOrUndefined(pdfExportProperties.allowHorizontalOverflow) ? true : pdfExportProperties.allowHorizontalOverflow;\n    }\n\n    var helper = new ExportHelper(gObj);\n    var dataSource = this.processExportProperties(pdfExportProperties, returnType.result);\n    var columns = isExportColumns(pdfExportProperties) ? prepareColumns(pdfExportProperties.columns, gObj.enableColumnVirtualization) : helper.getGridExportColumns(gObj.columns);\n    columns = columns.filter(function (columns) {\n      return isNullOrUndefined(columns.commands);\n    });\n    var isGrouping = false;\n\n    if (gObj.groupSettings.columns.length) {\n      isGrouping = true;\n    }\n\n    if (gObj.childGrid && !isNullOrUndefined(pdfExportProperties)) {\n      gObj.hierarchyPrintMode = pdfExportProperties.hierarchyExportMode || 'Expanded';\n    } // create a grid\n\n\n    var pdfGrid = new PdfGrid(); // get header theme style\n\n    var headerThemeStyle = this.getHeaderThemeStyle();\n    var border = headerThemeStyle.border;\n    var headerFont = headerThemeStyle.font;\n    var headerBrush = headerThemeStyle.brush;\n    var returnValue = helper.getHeaders(columns, this.hideColumnInclude); // Column collection with respect to the records in the grid\n\n    var gridColumns = returnValue.columns; // process grid header content\n\n    pdfGrid = this.processGridHeaders(gObj.groupSettings.columns.length, pdfGrid, returnValue.rows, gridColumns, border, headerFont, headerBrush, gObj, allowHorizontalOverflow, columns); // set alignment, width and type of the values of the column\n\n    this.setColumnProperties(gridColumns, pdfGrid, helper, gObj, allowHorizontalOverflow);\n    var captionThemeStyle = this.getSummaryCaptionThemeStyle();\n\n    if (!isNullOrUndefined(dataSource) && dataSource.length) {\n      if (isGrouping) {\n        if (!isNullOrUndefined(captionThemeStyle.border)) {\n          border = captionThemeStyle.border;\n        }\n\n        this.processGroupedRecords(pdfGrid, dataSource, gridColumns, gObj, border, 0, captionThemeStyle.font, captionThemeStyle.brush, captionThemeStyle.backgroundBrush, returnType, pdfExportProperties, helper, 0);\n      } else {\n        this.processRecord(border, gridColumns, gObj, dataSource, pdfGrid, 0, pdfExportProperties, helper, 0);\n      }\n\n      if (!isNullOrUndefined(returnType.aggregates)) {\n        var summaryModel = new SummaryModelGenerator(gObj);\n        var sRows = void 0;\n\n        if (gObj.aggregates.length && this.parent !== gObj) {\n          gObj.aggregateModule.prepareSummaryInfo();\n        }\n\n        if (this.customDataSource) {\n          sRows = summaryModel.generateRows(dataSource, returnType.aggregates);\n        } else if (this.currentViewData) {\n          sRows = summaryModel.generateRows(this.parent.getCurrentViewRecords(), returnType.aggregates);\n        } else if (isGrouping) {\n          sRows = summaryModel.generateRows(dataSource.records, returnType.aggregates);\n        } else {\n          sRows = summaryModel.generateRows(returnType.result, returnType.aggregates, null, null, columns);\n        }\n\n        this.processAggregates(sRows, pdfGrid, border, captionThemeStyle.font, captionThemeStyle.brush, captionThemeStyle.backgroundBrush, false);\n      }\n    } else {\n      var row = pdfGrid.rows.addRow();\n      row.style.setBorder(border);\n    }\n\n    return pdfGrid;\n  };\n\n  PdfExport.prototype.getSummaryCaptionThemeStyle = function () {\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.caption)) {\n      var fontSize = !isNullOrUndefined(this.gridTheme.caption.fontSize) ? this.gridTheme.caption.fontSize : 9.75;\n      var fontFamily = !isNullOrUndefined(this.gridTheme.caption.fontName) ? this.getFontFamily(this.gridTheme.caption.fontName) : PdfFontFamily.Helvetica;\n      var fontStyle = this.getFontStyle(this.gridTheme.caption);\n      var pdfColor = new PdfColor(0, 0, 0);\n\n      if (!isNullOrUndefined(this.gridTheme.caption.fontColor)) {\n        var penBrushColor = this.hexToRgb(this.gridTheme.caption.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      var borderCaption = this.gridTheme.caption.border ? this.getBorderStyle(this.gridTheme.caption.border) : null;\n      var font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.caption.font)) {\n        font = this.gridTheme.caption.font;\n      }\n\n      return {\n        font: font,\n        brush: new PdfSolidBrush(pdfColor),\n        backgroundBrush: new PdfSolidBrush(new PdfColor(246, 246, 246)),\n        border: borderCaption\n      };\n    } else {\n      //Material theme\n      return {\n        font: new PdfStandardFont(PdfFontFamily.Helvetica, 9.75),\n        brush: new PdfSolidBrush(new PdfColor(0, 0, 0)),\n        backgroundBrush: new PdfSolidBrush(new PdfColor(246, 246, 246))\n      };\n    }\n  };\n\n  PdfExport.prototype.getGridPdfFont = function (args) {\n    var fontFamily = 'fontFamily';\n    var fontSize = 'fontSize';\n    var fontStyle = 'fontStyle';\n    var isTrueType = 'isTrueType';\n    var style = 0;\n\n    if (args.header && args.header.font) {\n      var headerFont = args.header.font[fontFamily];\n      var headerSize = args.header.font[fontSize];\n      var headerStyle = args.header.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[headerStyle]) ? 0 : PdfFontStyle[headerStyle];\n\n      if (args.header.font[isTrueType]) {\n        args.header.font = new PdfTrueTypeFont(headerFont, headerSize, style);\n      } else {\n        var fontFamily_1 = !isNullOrUndefined(headerFont) ? this.getFontFamily(headerFont) : PdfFontFamily.Helvetica;\n        args.header.font = new PdfStandardFont(fontFamily_1, headerSize, style);\n      }\n    }\n\n    if (args.caption && args.caption.font) {\n      var captionFont = args.caption.font[fontFamily];\n      var captionSize = args.caption.font[fontSize];\n      var captionStyle = args.caption.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[captionStyle]) ? 0 : PdfFontStyle[captionStyle];\n\n      if (args.caption.font[isTrueType]) {\n        args.caption.font = new PdfTrueTypeFont(captionFont, captionSize, style);\n      } else {\n        var fontFamily_2 = !isNullOrUndefined(captionFont) ? this.getFontFamily(captionFont) : PdfFontFamily.Helvetica;\n        args.caption.font = new PdfStandardFont(fontFamily_2, captionSize, style);\n      }\n    }\n\n    if (args.record && args.record.font) {\n      var recordFont = args.record.font[fontFamily];\n      var recordSize = args.record.font[fontSize];\n      var recordStyle = args.record.font[fontStyle];\n      style = isNullOrUndefined(PdfFontStyle[recordStyle]) ? 0 : PdfFontStyle[recordStyle];\n\n      if (args.record.font[isTrueType]) {\n        args.record.font = new PdfTrueTypeFont(recordFont, recordSize, style);\n      } else {\n        var fontFamily_3 = !isNullOrUndefined(recordFont) ? this.getFontFamily(recordFont) : PdfFontFamily.Helvetica;\n        args.record.font = new PdfStandardFont(fontFamily_3, recordSize, style);\n      }\n    }\n  };\n\n  PdfExport.prototype.getHeaderThemeStyle = function () {\n    var border = new PdfBorders();\n\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.header)) {\n      var fontFamily = !isNullOrUndefined(this.gridTheme.header.fontName) ? this.getFontFamily(this.gridTheme.header.fontName) : PdfFontFamily.Helvetica;\n      var fontStyle = this.getFontStyle(this.gridTheme.header);\n      var fontSize = !isNullOrUndefined(this.gridTheme.header.fontSize) ? this.gridTheme.header.fontSize : 10.5;\n      var pdfColor = new PdfColor();\n\n      if (!isNullOrUndefined(this.gridTheme.header.fontColor)) {\n        var penBrushColor = this.hexToRgb(this.gridTheme.header.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      var font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.header.font)) {\n        font = this.gridTheme.header.font;\n      }\n\n      return {\n        border: this.getBorderStyle(this.gridTheme.header.border),\n        font: font,\n        brush: new PdfSolidBrush(pdfColor)\n      };\n    } else {\n      //Material theme\n      border.all = new PdfPen(new PdfColor(234, 234, 234));\n      return {\n        border: border,\n        font: new PdfStandardFont(PdfFontFamily.Helvetica, 10.5),\n        brush: new PdfSolidBrush(new PdfColor(102, 102, 102))\n      };\n    }\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  PdfExport.prototype.processGroupedRecords = function (pdfGrid, dataSource, gridColumns, gObj, border, level, font, brush, backgroundBrush, returnType, pdfExportProperties, helper, index) {\n    var _this = this;\n\n    var groupIndex = level;\n\n    var _loop_1 = function (dataSourceItems) {\n      var row = pdfGrid.rows.addRow();\n      var col = gObj.getColumnByField(dataSourceItems.field);\n      /* tslint:disable-next-line:no-any */\n\n      var args = {\n        value: dataSourceItems.key,\n        column: col,\n        style: undefined,\n        isForeignKey: col.isForeignColumn()\n      };\n      /* tslint:disable-next-line:max-line-length */\n\n      var value = this_1.parent.getColumnByField(dataSourceItems.field).headerText + ': ' + (!col.enableGroupByFormat ? this_1.exportValueFormatter.formatCellValue(args) : dataSourceItems.key) + ' - ' + dataSourceItems.count + (dataSource.count > 1 ? ' items' : ' item');\n      var cArgs = {\n        captionText: value,\n        type: 'PDF'\n      };\n      this_1.parent.trigger(events.exportGroupCaption, cArgs, function (cArgs) {\n        row.cells.getCell(groupIndex).value = cArgs.captionText;\n        row.cells.getCell(groupIndex + 1).style.stringFormat = new PdfStringFormat(PdfTextAlignment.Left);\n        row.style.setBorder(border);\n        row.style.setFont(font);\n        row.style.setTextBrush(brush);\n        row.style.setBackgroundBrush(backgroundBrush);\n        var sRows;\n        var captionSummaryModel = new CaptionSummaryModelGenerator(gObj);\n\n        if (!isNullOrUndefined(dataSourceItems.items.records)) {\n          sRows = captionSummaryModel.generateRows(dataSourceItems.items.records, dataSourceItems);\n        } else {\n          sRows = captionSummaryModel.generateRows(dataSourceItems.items, dataSourceItems);\n        }\n\n        if (!isNullOrUndefined(sRows) && sRows.length === 0) {\n          row.cells.getCell(groupIndex + 1).columnSpan = pdfGrid.columns.count - (groupIndex + 1);\n        }\n\n        if (!isNullOrUndefined(dataSource.childLevels) && dataSource.childLevels > 0) {\n          _this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, true, row, groupIndex);\n\n          _this.processGroupedRecords(pdfGrid, dataSourceItems.items, gridColumns, gObj, border, groupIndex + 1, font, brush, backgroundBrush, returnType, pdfExportProperties, helper, index);\n\n          var groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n          sRows = groupSummaryModel.generateRows(dataSourceItems.items.records, dataSourceItems);\n\n          _this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, false);\n        } else {\n          _this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, true, row, groupIndex);\n\n          index = _this.processRecord(border, gridColumns, gObj, dataSourceItems.items, pdfGrid, groupIndex + 1, pdfExportProperties, helper, index);\n          var groupSummaryModel = new GroupSummaryModelGenerator(gObj);\n          sRows = groupSummaryModel.generateRows(dataSourceItems.items, dataSourceItems);\n          var isGroupedFooter = true;\n\n          _this.processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, false, null, null, isGroupedFooter);\n        }\n      });\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, dataSource_1 = dataSource; _i < dataSource_1.length; _i++) {\n      var dataSourceItems = dataSource_1[_i];\n\n      _loop_1(dataSourceItems);\n    }\n  };\n\n  PdfExport.prototype.processGridHeaders = function (childLevels, pdfGrid, rows, gridColumn, border, headerFont, headerBrush, grid, allowHorizontalOverflow, eCols) {\n    var _this = this;\n\n    var columnCount = gridColumn.length + childLevels;\n    var depth = measureColumnDepth(eCols);\n    var cols = eCols;\n    var index = 0;\n\n    if (this.parent.allowGrouping) {\n      index = this.parent.groupSettings.columns.length;\n    }\n\n    pdfGrid.columns.add(columnCount);\n    pdfGrid.headers.add(rows.length);\n\n    var applyTextAndSpan = function (rowIdx, colIdx, col, rowSpan, colSpan) {\n      var gridHeader = pdfGrid.headers.getHeader(rowIdx);\n      var pdfCell = gridHeader.cells.getCell(colIdx);\n      var cell = rows[rowIdx].cells[colIdx];\n\n      if (!isNullOrUndefined(col.headerTextAlign)) {\n        pdfCell.style.stringFormat = _this.getHorizontalAlignment(col.headerTextAlign);\n      }\n\n      if (rowSpan > 0) {\n        pdfCell.rowSpan = rowSpan;\n        pdfCell.style.stringFormat = _this.getVerticalAlignment('Bottom', pdfCell.style.stringFormat, col.textAlign);\n      }\n\n      if (colSpan > 0) {\n        pdfCell.columnSpan = colSpan;\n      }\n\n      gridHeader.style.setBorder(border);\n      gridHeader.style.setFont(headerFont);\n      gridHeader.style.setTextBrush(headerBrush);\n      pdfCell.value = col.headerText;\n\n      if (!isNullOrUndefined(cell) && (cell.cellType === CellType.HeaderIndent || cell.cellType === CellType.DetailHeader)) {\n        pdfCell.value = '';\n        pdfCell.width = 20;\n      }\n\n      var args = {\n        cell: pdfCell,\n        gridCell: cell,\n        style: pdfCell.style\n      };\n\n      _this.parent.trigger(events.pdfHeaderQueryCellInfo, args);\n    };\n\n    var recuHeader = function (cols, depth, spanCnt, colIndex, rowIndex, isRoot) {\n      var cidx = 0;\n\n      for (var i = 0; i < cols.length; i++) {\n        if (isRoot) {\n          cidx = cidx + spanCnt + (i === 0 ? 0 : -1);\n          colIndex = cidx;\n          spanCnt = 0;\n        }\n\n        if (cols[i].columns && cols[i].columns.length) {\n          var newSpanCnt = recuHeader(cols[i].columns, depth - 1, 0, i + colIndex, rowIndex + 1, false);\n          applyTextAndSpan(rowIndex, i + colIndex, cols[i], 0, newSpanCnt);\n          spanCnt = spanCnt + newSpanCnt;\n          colIndex = colIndex + newSpanCnt - 1;\n        } else if (cols[i].visible || _this.hideColumnInclude) {\n          spanCnt++;\n          applyTextAndSpan(rowIndex, i + colIndex + index, cols[i], depth, 0);\n        }\n      }\n\n      return spanCnt;\n    };\n\n    recuHeader(cols, depth, 0, 0, 0, true);\n\n    if (pdfGrid.columns.count >= 6 && allowHorizontalOverflow) {\n      pdfGrid.style.allowHorizontalOverflow = true;\n    }\n\n    return pdfGrid;\n  };\n\n  PdfExport.prototype.processExportProperties = function (pdfExportProperties, dataSource) {\n    if (!isNullOrUndefined(pdfExportProperties)) {\n      if (!isNullOrUndefined(pdfExportProperties.theme)) {\n        this.gridTheme = pdfExportProperties.theme;\n      }\n\n      var clientSize = this.pdfPageSettings.size;\n      this.drawHeader(pdfExportProperties);\n\n      if (!isNullOrUndefined(pdfExportProperties.footer)) {\n        /* tslint:disable-next-line:no-any */\n        var footer = pdfExportProperties.footer;\n        var position = new PointF(0, clientSize.width - 80 - footer.fromBottom * 0.75);\n        var size = new SizeF(clientSize.width - 80, footer.height * 0.75);\n        var bounds = new RectangleF(position, size);\n        this.pdfDocument.template.bottom = this.drawPageTemplate(new PdfPageTemplateElement(bounds), footer);\n      }\n\n      if (!isNullOrUndefined(pdfExportProperties.includeHiddenColumn) && !this.isGrouping) {\n        this.hideColumnInclude = pdfExportProperties.includeHiddenColumn;\n      }\n\n      if (!isNullOrUndefined(pdfExportProperties.dataSource)) {\n        if (!(pdfExportProperties.dataSource instanceof DataManager)) {\n          dataSource = pdfExportProperties.dataSource;\n        }\n\n        this.customDataSource = true;\n        this.currentViewData = false;\n      } else if (!isNullOrUndefined(pdfExportProperties.exportType)) {\n        if (pdfExportProperties.exportType === 'CurrentPage') {\n          dataSource = this.parent.currentViewData;\n          this.currentViewData = true;\n          this.customDataSource = false;\n        } else {\n          this.currentViewData = false;\n          this.customDataSource = false;\n        }\n      } else {\n        this.currentViewData = false;\n        this.customDataSource = false;\n      }\n    } else {\n      this.currentViewData = false;\n      this.customDataSource = false;\n    }\n\n    return dataSource;\n  };\n\n  PdfExport.prototype.drawHeader = function (pdfExportProperties) {\n    var _this = this;\n\n    var clientSize = this.pdfPageSettings.size;\n\n    if (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.header)) {\n      /* tslint:disable-next-line:no-any */\n      var header = pdfExportProperties.header;\n      var position = new PointF(0, header.fromTop);\n      var size = new SizeF(clientSize.width - 80, header.height * 0.75);\n      var bounds = new RectangleF(position, size);\n\n      if (!this.headerOnPages.length) {\n        this.pdfDocument.template.top = this.drawPageTemplate(new PdfPageTemplateElement(bounds), header);\n      } else {\n        var headerTemplate_1 = this.drawPageTemplate(new PdfPageTemplateElement(bounds), header);\n        this.headerOnPages.filter(function (index) {\n          if (index - 1 >= 0 && index - 1 < _this.pdfDocument.pages.count - 1) {\n            _this.pdfDocument.pages.getPageByIndex(index - 1).graphics.drawPdfTemplate(headerTemplate_1.template, new PointF(0, 0));\n          }\n        });\n      }\n    }\n  };\n\n  PdfExport.prototype.drawPageTemplate = function (template, element) {\n    for (var _i = 0, _a = element.contents; _i < _a.length; _i++) {\n      var content = _a[_i];\n      this.processContentValidation(content);\n\n      switch (content.type) {\n        case 'Text':\n          /* tslint:disable-next-line:max-line-length */\n          if (content.value === '' || content.value === undefined || content.value === null || typeof content.value !== 'string') {\n            throw new Error('please enter the valid input value in text content...');\n          }\n\n          this.drawText(template, content);\n          break;\n\n        case 'PageNumber':\n          this.drawPageNumber(template, content);\n          break;\n\n        case 'Image':\n          if (content.src === undefined || content.src === null || content.src === '') {\n            throw new Error('please enter the valid base64 string in image content...');\n          }\n\n          this.drawImage(template, content);\n          break;\n\n        case 'Line':\n          this.drawLine(template, content);\n          break;\n\n        default:\n          throw new Error('Please set valid content type...');\n      }\n    }\n\n    return template;\n  };\n\n  PdfExport.prototype.processContentValidation = function (content) {\n    if (content.type === undefined || content.type === null) {\n      throw new Error('please set valid content type...');\n    } else {\n      if (content.type === 'Line') {\n        if (content.points === undefined || content.points === null) {\n          throw new Error('please enter valid points in ' + content.type + ' content...');\n        } else {\n          if (content.points.x1 === undefined || content.points.x1 === null || typeof content.points.x1 !== 'number') {\n            throw new Error('please enter valid x1 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.y1 === undefined || content.points.y1 === null || typeof content.points.y1 !== 'number') {\n            throw new Error('please enter valid y1 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.x2 === undefined || content.points.x2 === null || typeof content.points.x2 !== 'number') {\n            throw new Error('please enter valid x2 co-ordinate in ' + content.type + ' points...');\n          }\n\n          if (content.points.y2 === undefined || content.points.y2 === null || typeof content.points.y2 !== 'number') {\n            throw new Error('please enter valid y2 co-ordinate in ' + content.type + ' points...');\n          }\n        }\n      } else {\n        if (content.position === undefined || content.position === null) {\n          throw new Error('please enter valid position in ' + content.type + ' content...');\n        } else {\n          if (content.position.x === undefined || content.position.x === null || typeof content.position.x !== 'number') {\n            throw new Error('please enter valid x co-ordinate in ' + content.type + ' position...');\n          }\n\n          if (content.position.y === undefined || content.position.y === null || typeof content.position.y !== 'number') {\n            throw new Error('please enter valid y co-ordinate in ' + content.type + ' position...');\n          }\n        }\n      }\n    }\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  PdfExport.prototype.drawText = function (pageTemplate, content) {\n    var font = this.getFont(content);\n    var brush = this.getBrushFromContent(content);\n    var pen = null;\n\n    if (!isNullOrUndefined(content.style.textPenColor)) {\n      var penColor = this.hexToRgb(content.style.textPenColor);\n      pen = new PdfPen(new PdfColor(penColor.r, penColor.g, penColor.b));\n    }\n\n    if (brush == null && pen == null) {\n      brush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    }\n\n    var value = content.value.toString();\n    var x = content.position.x * 0.75;\n    var y = content.position.y * 0.75;\n    var format = new PdfStringFormat();\n    var result = this.setContentFormat(content, format);\n\n    if (result !== null && !isNullOrUndefined(result.format) && !isNullOrUndefined(result.size)) {\n      pageTemplate.graphics.drawString(value, font, pen, brush, x, y, result.size.width, result.size.height, result.format);\n    } else {\n      pageTemplate.graphics.drawString(value, font, pen, brush, x, y, format);\n    }\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  PdfExport.prototype.drawPageNumber = function (documentHeader, content) {\n    var font = this.getFont(content);\n    var brush = null;\n\n    if (!isNullOrUndefined(content.style.textBrushColor)) {\n      /* tslint:disable-next-line:max-line-length */\n      var brushColor = this.hexToRgb(content.style.textBrushColor);\n      brush = new PdfSolidBrush(new PdfColor(brushColor.r, brushColor.g, brushColor.b));\n    } else {\n      brush = new PdfSolidBrush(new PdfColor(0, 0, 0));\n    }\n\n    var pageNumber = new PdfPageNumberField(font, brush);\n    pageNumber.numberStyle = this.getPageNumberStyle(content.pageNumberType);\n    var compositeField;\n    var format;\n\n    if (!isNullOrUndefined(content.format)) {\n      if (content.format.indexOf('$total') !== -1 && content.format.indexOf('$current') !== -1) {\n        var pageCount = new PdfPageCountField(font);\n        pageCount.numberStyle = this.getPageNumberStyle(content.pageNumberType);\n\n        if (content.format.indexOf('$total') > content.format.indexOf('$current')) {\n          format = content.format.replace('$current', '0');\n          format = format.replace('$total', '1');\n        } else {\n          format = content.format.replace('$current', '1');\n          format = format.replace('$total', '0');\n        }\n\n        compositeField = new PdfCompositeField(font, brush, format, pageNumber, pageCount);\n      } else if (content.format.indexOf('$current') !== -1 && content.format.indexOf('$total') === -1) {\n        format = content.format.replace('$current', '0');\n        compositeField = new PdfCompositeField(font, brush, format, pageNumber);\n      } else {\n        var pageCount = new PdfPageCountField(font);\n        format = content.format.replace('$total', '0');\n        compositeField = new PdfCompositeField(font, brush, format, pageCount);\n      }\n    } else {\n      format = '{0}';\n      compositeField = new PdfCompositeField(font, brush, format, pageNumber);\n    }\n\n    var x = content.position.x * 0.75;\n    var y = content.position.y * 0.75;\n    var result = this.setContentFormat(content, compositeField.stringFormat);\n\n    if (result !== null && !isNullOrUndefined(result.format) && !isNullOrUndefined(result.size)) {\n      compositeField.stringFormat = result.format;\n      compositeField.bounds = new RectangleF(x, y, result.size.width, result.size.height);\n    }\n\n    compositeField.draw(documentHeader.graphics, x, y);\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  PdfExport.prototype.drawImage = function (documentHeader, content) {\n    var x = content.position.x * 0.75;\n    var y = content.position.y * 0.75;\n    var width = !isNullOrUndefined(content.size) ? content.size.width * 0.75 : undefined;\n    var height = !isNullOrUndefined(content.size) ? content.size.height * 0.75 : undefined;\n    var image = new PdfBitmap(content.src);\n\n    if (!isNullOrUndefined(width)) {\n      documentHeader.graphics.drawImage(image, x, y, width, height);\n    } else {\n      documentHeader.graphics.drawImage(image, x, y);\n    }\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  PdfExport.prototype.drawLine = function (documentHeader, content) {\n    var x1 = content.points.x1 * 0.75;\n    var y1 = content.points.y1 * 0.75;\n    var x2 = content.points.x2 * 0.75;\n    var y2 = content.points.y2 * 0.75;\n    var pen = this.getPenFromContent(content);\n\n    if (!isNullOrUndefined(content.style) && content.style !== null) {\n      if (!isNullOrUndefined(content.style.penSize) && content.style.penSize !== null && typeof content.style.penSize === 'number') {\n        pen.width = content.style.penSize * 0.75;\n      }\n\n      pen.dashStyle = this.getDashStyle(content.style.dashStyle);\n    }\n\n    documentHeader.graphics.drawLine(pen, x1, y1, x2, y2);\n  };\n  /* tslint:disable-next-line:no-any */\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  PdfExport.prototype.processAggregates = function (sRows, pdfGrid, border, font, brush, backgroundBrush, isCaption, captionRow, groupIndex, isGroupedFooter) {\n    for (var _i = 0, sRows_1 = sRows; _i < sRows_1.length; _i++) {\n      var row = sRows_1[_i];\n      var startIndex = 0;\n      var leastCaptionSummaryIndex = -1;\n      var index = 0;\n      var isEmpty = true;\n      /* tslint:disable-next-line:no-any */\n\n      var value = [];\n\n      for (var i = 0; i < pdfGrid.columns.count; i++) {\n        var cell = row.cells[index];\n\n        if (cell.cellType === CellType.DetailFooterIntent) {\n          i--;\n          index++;\n          continue;\n        }\n\n        if (!this.hideColumnInclude) {\n          while (cell.visible === undefined) {\n            if (cell.cellType === CellType.DetailFooterIntent) {\n              continue;\n            }\n\n            if (!isNullOrUndefined(captionRow)) {\n              if (!isNullOrUndefined(captionRow.cells.getCell(i).value)) {\n                /* tslint:disable-next-line:max-line-length */\n                var args = {\n                  row: row,\n                  type: AggregateTemplateType.GroupCaption,\n                  style: captionRow.cells\n                };\n                this.parent.trigger(events.pdfAggregateQueryCellInfo, args);\n                value.push('');\n                value.push(captionRow.cells.getCell(i).value);\n                isEmpty = false;\n\n                if (!isCaption) {\n                  i += 1;\n                }\n              } else {\n                value.push('');\n              }\n            } else {\n              value.push('');\n            }\n\n            i += 1;\n            index = index + 1;\n            cell = row.cells[index];\n          }\n\n          while (!isNullOrUndefined(cell.visible) && !cell.visible) {\n            index = index + 1;\n            cell = row.cells[index];\n          }\n        }\n\n        if (cell.isDataCell) {\n          var templateFn = {};\n          /* tslint:disable-next-line:max-line-length */\n\n          if (!isNullOrUndefined(cell.column.footerTemplate) || !isNullOrUndefined(cell.column.groupCaptionTemplate) || !isNullOrUndefined(cell.column.groupFooterTemplate)) {\n            /* tslint:disable-next-line:no-any */\n            var result = this.getTemplateFunction(templateFn, i, leastCaptionSummaryIndex, cell);\n            templateFn = result.templateFunction;\n            leastCaptionSummaryIndex = result.leastCaptionSummaryIndex;\n            /* tslint:disable-next-line:max-line-length */\n\n            var txt = templateFn[getEnumValue(CellType, cell.cellType)](row.data[cell.column.field ? cell.column.field : cell.column.columnName]);\n            value.push(txt[0].textContent);\n            isEmpty = false;\n          } else {\n            /* tslint:disable-next-line:no-any */\n            var result = this.getSummaryWithoutTemplate(row.data[cell.column.field]);\n\n            if (!isNullOrUndefined(result)) {\n              value.push(result);\n            }\n          }\n        } else {\n          value.push('');\n        }\n\n        if (isEmpty && value[i] !== '' && !isNullOrUndefined(value[i]) && value[i] !== null) {\n          isEmpty = false;\n        }\n\n        index += 1;\n      }\n\n      if (isCaption) {\n        for (var i = this.parent.groupSettings.columns.length + 1; i < value.length - 1; i++) {\n          value[i] = value[i + 1];\n        }\n      }\n\n      if (!isEmpty) {\n        if (!isCaption) {\n          var gridRow = pdfGrid.rows.addRow();\n          gridRow.style.setBorder(border);\n          gridRow.style.setFont(font);\n          gridRow.style.setTextBrush(brush);\n          gridRow.style.setBackgroundBrush(backgroundBrush);\n          /* tslint:disable-next-line:max-line-length */\n\n          var args = {\n            row: row,\n            type: isGroupedFooter ? AggregateTemplateType.GroupFooter : AggregateTemplateType.Footer,\n            style: gridRow.cells\n          };\n          this.parent.trigger(events.pdfAggregateQueryCellInfo, args);\n\n          for (var i = 0; i < pdfGrid.columns.count; i++) {\n            gridRow.cells.getCell(i).value = value[i].toString();\n          }\n        } else {\n          for (var i = 0; i < pdfGrid.columns.count; i++) {\n            captionRow.cells.getCell(i).value = value[i].toString();\n\n            if (i === groupIndex + 1 && leastCaptionSummaryIndex !== -1 && leastCaptionSummaryIndex !== 1) {\n              captionRow.cells.getCell(i).columnSpan = leastCaptionSummaryIndex - (groupIndex + 1);\n            } else if (i === groupIndex + 1 && leastCaptionSummaryIndex === -1) {\n              captionRow.cells.getCell(i).columnSpan = pdfGrid.columns.count - (groupIndex + 1);\n            }\n          }\n        }\n      }\n    }\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  PdfExport.prototype.getTemplateFunction = function (templateFn, index, leastCaptionSummaryIndex, cell) {\n    if (!isNullOrUndefined(cell.column.footerTemplate) && cell.cellType === CellType.Summary) {\n      templateFn[getEnumValue(CellType, CellType.Summary)] = compile(cell.column.footerTemplate);\n    } else if (!isNullOrUndefined(cell.column.groupCaptionTemplate)) {\n      if (leastCaptionSummaryIndex === -1) {\n        leastCaptionSummaryIndex = index;\n      }\n\n      templateFn[getEnumValue(CellType, CellType.CaptionSummary)] = compile(cell.column.groupCaptionTemplate);\n    } else {\n      templateFn[getEnumValue(CellType, CellType.GroupSummary)] = compile(cell.column.groupFooterTemplate);\n    }\n\n    return {\n      templateFunction: templateFn,\n      leastCaptionSummaryIndex: leastCaptionSummaryIndex\n    };\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  PdfExport.prototype.getSummaryWithoutTemplate = function (data) {\n    if (!isNullOrUndefined(data.Sum)) {\n      return data.Sum;\n    } else if (!isNullOrUndefined(data.Average)) {\n      return data.Average;\n    } else if (!isNullOrUndefined(data.Max)) {\n      return data.Max;\n    } else if (!isNullOrUndefined(data.Min)) {\n      return data.Min;\n    } else if (!isNullOrUndefined(data.Count)) {\n      return data.Count;\n    } else if (!isNullOrUndefined(data.TrueCount)) {\n      return data.TrueCount;\n    } else if (!isNullOrUndefined(data.FalseCount)) {\n      return data.FalseCount;\n    } else if (!isNullOrUndefined(data.Custom)) {\n      return data.Custom;\n    }\n  };\n  /**\n   * Set alignment, width and type of the values of the column\n   */\n\n\n  PdfExport.prototype.setColumnProperties = function (gridColumns, pdfGrid, helper, gObj, allowHorizontalOverflow) {\n    var startIndex = gObj.groupSettings.columns.length;\n\n    for (var i = 0; i < startIndex; i++) {\n      pdfGrid.columns.getColumn(i).width = 20;\n    }\n\n    for (var i = 0; i < gridColumns.length; i++) {\n      if (!isNullOrUndefined(gridColumns[i].textAlign)) {\n        pdfGrid.columns.getColumn(i + startIndex).format = this.getHorizontalAlignment(gridColumns[i].textAlign);\n      } // Need to add width consideration with % value\n\n\n      if (pdfGrid.style.allowHorizontalOverflow && !isNullOrUndefined(gridColumns[i].width) && allowHorizontalOverflow) {\n        pdfGrid.columns.getColumn(i + startIndex).width = typeof gridColumns[i].width === 'number' ? gridColumns[i].width * 0.75 : helper.getConvertedWidth(gridColumns[i].width) * 0.75;\n      }\n    }\n  };\n  /**\n   * set default style properties of each rows in exporting grid\n   * @private\n   */\n\n\n  PdfExport.prototype.setRecordThemeStyle = function (row, border) {\n    if (!isNullOrUndefined(this.gridTheme) && !isNullOrUndefined(this.gridTheme.record)) {\n      var fontFamily = !isNullOrUndefined(this.gridTheme.record.fontName) ? this.getFontFamily(this.gridTheme.record.fontName) : PdfFontFamily.Helvetica;\n      var fontSize = !isNullOrUndefined(this.gridTheme.record.fontSize) ? this.gridTheme.record.fontSize : 9.75;\n      var fontStyle = this.getFontStyle(this.gridTheme.record);\n      var font = new PdfStandardFont(fontFamily, fontSize, fontStyle);\n\n      if (!isNullOrUndefined(this.gridTheme.record.font)) {\n        font = this.gridTheme.record.font;\n      }\n\n      row.style.setFont(font);\n      var pdfColor = new PdfColor();\n\n      if (!isNullOrUndefined(this.gridTheme.record.fontColor)) {\n        var penBrushColor = this.hexToRgb(this.gridTheme.record.fontColor);\n        pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);\n      }\n\n      row.style.setTextBrush(new PdfSolidBrush(pdfColor));\n    } else {\n      row.style.setTextBrush(new PdfSolidBrush(new PdfColor(0, 0, 0)));\n    }\n\n    var borderRecord = this.gridTheme && this.gridTheme.record && this.gridTheme.record.border ? this.getBorderStyle(this.gridTheme.record.border) : border;\n    row.style.setBorder(borderRecord);\n    return row;\n  };\n  /**\n   * generate the formatted cell values\n   * @private\n   */\n\n\n  PdfExport.prototype.processRecord = function (border, columns, gObj, dataSource, pdfGrid, startIndex, pdfExportProperties, helper, rowIndex) {\n    var rows = helper.getGridRowModel(columns, dataSource, gObj, rowIndex);\n\n    for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n      var row = rows_1[_i];\n      rowIndex++; // create a new row and set default style properties\n\n      var gridRow = this.setRecordThemeStyle(pdfGrid.rows.addRow(), border);\n      var cellLength = row.cells.length;\n\n      for (var j = 0; j < cellLength; j++) {\n        var gridCell = row.cells[j];\n\n        if (gridCell.cellType !== CellType.Data) {\n          continue;\n        }\n\n        var column = gridCell.column;\n        var field = column.field;\n        var cellValue = !isNullOrUndefined(field) ? column.valueAccessor(field, row.data, column) : '';\n        var value = !isNullOrUndefined(cellValue) ? cellValue : '';\n        var foreignKeyData = void 0;\n\n        if (column.isForeignColumn && column.isForeignColumn()) {\n          foreignKeyData = helper.getFData(value, column);\n          value = getValue(column.foreignKeyValue, foreignKeyData);\n        }\n\n        var data = row.data;\n        var cell = gridRow.cells.getCell(j);\n        var args = {\n          data: data,\n          value: value,\n          column: column,\n          style: undefined,\n          colSpan: 1,\n          cell: cell\n        };\n        args.value = this.exportValueFormatter.formatCellValue(args, gObj.isServerRendered);\n        this.parent.trigger(events.pdfQueryCellInfo, args);\n        cell.value = args.value;\n\n        if (!isNullOrUndefined(args.style)) {\n          this.processCellStyle(cell, args);\n        }\n\n        if (args.colSpan > 1) {\n          if (j + 1 + args.colSpan > gridRow.cells.count) {\n            args.colSpan = gridRow.cells.count - (j + 1);\n          }\n\n          cell.columnSpan = args.colSpan;\n\n          for (var i = 1; i < cell.columnSpan; i++) {\n            var spanCell = gridRow.cells.getCell(j + i);\n            spanCell.value = '';\n          }\n\n          j += args.colSpan - 1;\n        }\n      }\n\n      if (row.isExpand) {\n        var gridRow_1 = this.setRecordThemeStyle(pdfGrid.rows.addRow(), border);\n        var cell = gridRow_1.cells.getCell(startIndex);\n        cell.columnSpan = gridRow_1.cells.count - startIndex;\n        cell.style.cellPadding = new PdfPaddings(10, 10, 10, 10);\n        gObj.isPrinting = true;\n        var exportType = !isNullOrUndefined(pdfExportProperties) && pdfExportProperties.exportType ? pdfExportProperties.exportType : 'AllPages';\n        var returnValue = this.helper.createChildGrid(gObj, row, exportType, this.gridPool);\n        var childGridObj = returnValue.childGrid;\n        var element = returnValue.element;\n        childGridObj.actionFailure = helper.failureHandler(this.gridPool, childGridObj, this.globalResolve);\n        var args = {\n          childGrid: childGridObj,\n          row: row,\n          cell: cell,\n          exportProperties: pdfExportProperties\n        };\n        this.parent.trigger(events.exportDetailDataBound, args);\n        childGridObj.beforeDataBound = this.childGridCell(cell, childGridObj, pdfExportProperties);\n        childGridObj.appendTo(element);\n      }\n\n      this.parent.notify(events.exportRowDataBound, {\n        type: 'pdf',\n        rowObj: row\n      });\n    }\n\n    return rowIndex;\n  };\n\n  PdfExport.prototype.childGridCell = function (cell, childGridObj, pdfExportProperties) {\n    var _this = this;\n\n    return function (result) {\n      childGridObj.beforeDataBound = null;\n      result.cancel = true;\n      cell.value = _this.processGridExport(childGridObj, result, pdfExportProperties);\n      childGridObj.destroy();\n      detach(childGridObj.element);\n      _this.gridPool[childGridObj.id] = true;\n\n      _this.helper.checkAndExport(_this.gridPool, _this.globalResolve);\n\n      return cell;\n    };\n  };\n\n  PdfExport.prototype.processCellStyle = function (cell, args) {\n    if (!isNullOrUndefined(args.style.backgroundColor)) {\n      var backColor = this.hexToRgb(args.style.backgroundColor);\n      cell.style.backgroundBrush = new PdfSolidBrush(new PdfColor(backColor.r, backColor.g, backColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.textAlignment)) {\n      cell.style.stringFormat = this.getHorizontalAlignment(args.style.textAlignment);\n    }\n\n    if (!isNullOrUndefined(args.style.cellPadding)) {\n      cell.style.cellPadding = args.style.cellPadding;\n    }\n\n    if (!isNullOrUndefined(args.style.verticalAlignment)) {\n      cell.style.stringFormat = this.getVerticalAlignment(args.style.verticalAlignment, cell.style.stringFormat);\n    }\n\n    if (!isNullOrUndefined(args.style.textBrushColor)) {\n      var textBrushColor = this.hexToRgb(args.style.textBrushColor);\n      cell.style.textBrush = new PdfSolidBrush(new PdfColor(textBrushColor.r, textBrushColor.g, textBrushColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.textPenColor)) {\n      var textPenColor = this.hexToRgb(args.style.textPenColor);\n      cell.style.textPen = new PdfPen(new PdfColor(textPenColor.r, textPenColor.g, textPenColor.b));\n    }\n\n    if (!isNullOrUndefined(args.style.fontFamily) || !isNullOrUndefined(args.style.fontSize) || !isNullOrUndefined(args.style.bold) || !isNullOrUndefined(args.style.italic) || !isNullOrUndefined(args.style.underline) || !isNullOrUndefined(args.style.strikeout)) {\n      cell.style.font = this.getFont(args);\n    }\n\n    if (!isNullOrUndefined(args.style.border)) {\n      var border = new PdfBorders();\n      var borderWidth = args.style.border.width; // set border width\n\n      var width = !isNullOrUndefined(borderWidth) && typeof borderWidth === 'number' ? borderWidth * 0.75 : undefined; // set border color\n\n      var color = new PdfColor(196, 196, 196);\n\n      if (!isNullOrUndefined(args.style.border.color)) {\n        var borderColor = this.hexToRgb(args.style.border.color);\n        color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);\n      }\n\n      var pen = new PdfPen(color, width); // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'\n\n      if (!isNullOrUndefined(args.style.border.dashStyle)) {\n        pen.dashStyle = this.getDashStyle(args.style.border.dashStyle);\n      }\n\n      border.all = pen;\n      cell.style.borders = border;\n    }\n\n    if (!isNullOrUndefined(args.style.paragraphIndent)) {\n      cell.style.stringFormat = new PdfStringFormat();\n      cell.style.stringFormat.paragraphIndent = args.style.paragraphIndent;\n    }\n  };\n  /**\n   * set text alignment of each columns in exporting grid\n   * @private\n   */\n\n\n  PdfExport.prototype.getHorizontalAlignment = function (textAlign, format) {\n    if (format === undefined) {\n      format = new PdfStringFormat();\n    }\n\n    switch (textAlign) {\n      case 'Right':\n        format.alignment = PdfTextAlignment.Right;\n        break;\n\n      case 'Center':\n        format.alignment = PdfTextAlignment.Center;\n        break;\n\n      case 'Justify':\n        format.alignment = PdfTextAlignment.Justify;\n        break;\n\n      case 'Left':\n        format.alignment = PdfTextAlignment.Left;\n        break;\n    }\n\n    return format;\n  };\n  /**\n   * set vertical alignment of each columns in exporting grid\n   * @private\n   */\n\n\n  PdfExport.prototype.getVerticalAlignment = function (verticalAlign, format, textAlign) {\n    if (format === undefined) {\n      format = new PdfStringFormat();\n      format = this.getHorizontalAlignment(textAlign, format);\n    }\n\n    switch (verticalAlign) {\n      case 'Bottom':\n        format.lineAlignment = PdfVerticalAlignment.Bottom;\n        break;\n\n      case 'Middle':\n        format.lineAlignment = PdfVerticalAlignment.Middle;\n        break;\n\n      case 'Top':\n        format.lineAlignment = PdfVerticalAlignment.Top;\n        break;\n    }\n\n    return format;\n  };\n\n  PdfExport.prototype.getFontFamily = function (fontFamily) {\n    switch (fontFamily) {\n      case 'TimesRoman':\n        return 2;\n\n      case 'Courier':\n        return 1;\n\n      case 'Symbol':\n        return 3;\n\n      case 'ZapfDingbats':\n        return 4;\n\n      default:\n        return 0;\n    }\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  PdfExport.prototype.getFont = function (content) {\n    if (content.font) {\n      return content.font;\n    }\n\n    var fontSize = !isNullOrUndefined(content.style.fontSize) ? content.style.fontSize * 0.75 : 9.75;\n    var fontFamily = !isNullOrUndefined(content.style.fontFamily) ? this.getFontFamily(content.style.fontFamily) : PdfFontFamily.TimesRoman;\n    var fontStyle = PdfFontStyle.Regular;\n\n    if (!isNullOrUndefined(content.style.bold) && content.style.bold) {\n      fontStyle |= PdfFontStyle.Bold;\n    }\n\n    if (!isNullOrUndefined(content.style.italic) && content.style.italic) {\n      fontStyle |= PdfFontStyle.Italic;\n    }\n\n    if (!isNullOrUndefined(content.style.underline) && content.style.underline) {\n      fontStyle |= PdfFontStyle.Underline;\n    }\n\n    if (!isNullOrUndefined(content.style.strikeout) && content.style.strikeout) {\n      fontStyle |= PdfFontStyle.Strikeout;\n    }\n\n    return new PdfStandardFont(fontFamily, fontSize, fontStyle);\n  };\n\n  PdfExport.prototype.getPageNumberStyle = function (pageNumberType) {\n    switch (pageNumberType) {\n      case 'LowerLatin':\n        return 2;\n\n      case 'LowerRoman':\n        return 3;\n\n      case 'UpperLatin':\n        return 4;\n\n      case 'UpperRoman':\n        return 5;\n\n      default:\n        return 1;\n    }\n  };\n\n  PdfExport.prototype.setContentFormat = function (content, format) {\n    if (!isNullOrUndefined(content.size)) {\n      var width = content.size.width * 0.75;\n      var height = content.size.height * 0.75;\n      format = new PdfStringFormat(PdfTextAlignment.Left, PdfVerticalAlignment.Middle);\n\n      if (!isNullOrUndefined(content.style.hAlign)) {\n        switch (content.style.hAlign) {\n          case 'Right':\n            format.alignment = PdfTextAlignment.Right;\n            break;\n\n          case 'Center':\n            format.alignment = PdfTextAlignment.Center;\n            break;\n\n          case 'Justify':\n            format.alignment = PdfTextAlignment.Justify;\n            break;\n\n          default:\n            format.alignment = PdfTextAlignment.Left;\n        }\n      }\n\n      if (!isNullOrUndefined(content.style.vAlign)) {\n        format = this.getVerticalAlignment(content.style.vAlign, format);\n      }\n\n      return {\n        format: format,\n        size: new SizeF(width, height)\n      };\n    }\n\n    return null;\n  };\n\n  PdfExport.prototype.getPageSize = function (pageSize) {\n    switch (pageSize) {\n      case 'Letter':\n        return new SizeF(612, 792);\n\n      case 'Note':\n        return new SizeF(540, 720);\n\n      case 'Legal':\n        return new SizeF(612, 1008);\n\n      case 'A0':\n        return new SizeF(2380, 3368);\n\n      case 'A1':\n        return new SizeF(1684, 2380);\n\n      case 'A2':\n        return new SizeF(1190, 1684);\n\n      case 'A3':\n        return new SizeF(842, 1190);\n\n      case 'A5':\n        return new SizeF(421, 595);\n\n      case 'A6':\n        return new SizeF(297, 421);\n\n      case 'A7':\n        return new SizeF(210, 297);\n\n      case 'A8':\n        return new SizeF(148, 210);\n\n      case 'A9':\n        return new SizeF(105, 148);\n      // case 'A10':\n      //     return new SizeF(74, 105);\n\n      case 'B0':\n        return new SizeF(2836, 4008);\n\n      case 'B1':\n        return new SizeF(2004, 2836);\n\n      case 'B2':\n        return new SizeF(1418, 2004);\n\n      case 'B3':\n        return new SizeF(1002, 1418);\n\n      case 'B4':\n        return new SizeF(709, 1002);\n\n      case 'B5':\n        return new SizeF(501, 709);\n\n      case 'Archa':\n        return new SizeF(648, 864);\n\n      case 'Archb':\n        return new SizeF(864, 1296);\n\n      case 'Archc':\n        return new SizeF(1296, 1728);\n\n      case 'Archd':\n        return new SizeF(1728, 2592);\n\n      case 'Arche':\n        return new SizeF(2592, 3456);\n\n      case 'Flsa':\n        return new SizeF(612, 936);\n\n      case 'HalfLetter':\n        return new SizeF(396, 612);\n\n      case 'Letter11x17':\n        return new SizeF(792, 1224);\n\n      case 'Ledger':\n        return new SizeF(1224, 792);\n\n      default:\n        return new SizeF(595, 842);\n    }\n  };\n\n  PdfExport.prototype.getDashStyle = function (dashStyle) {\n    switch (dashStyle) {\n      case 'Dash':\n        return 1;\n\n      case 'Dot':\n        return 2;\n\n      case 'DashDot':\n        return 3;\n\n      case 'DashDotDot':\n        return 4;\n\n      default:\n        return 0;\n    }\n  };\n\n  PdfExport.prototype.getPenFromContent = function (content) {\n    var pen = new PdfPen(new PdfColor(0, 0, 0));\n\n    if (!isNullOrUndefined(content.style) && content.style !== null && !isNullOrUndefined(content.style.penColor)) {\n      var penColor = this.hexToRgb(content.style.penColor);\n      pen = new PdfPen(new PdfColor(penColor.r, penColor.g, penColor.b));\n    }\n\n    return pen;\n  };\n\n  PdfExport.prototype.getBrushFromContent = function (content) {\n    var brush = null;\n\n    if (!isNullOrUndefined(content.style.textBrushColor)) {\n      /* tslint:disable-next-line:max-line-length */\n      var brushColor = this.hexToRgb(content.style.textBrushColor);\n      brush = new PdfSolidBrush(new PdfColor(brushColor.r, brushColor.g, brushColor.b));\n    }\n\n    return brush;\n  };\n\n  PdfExport.prototype.hexToRgb = function (hex) {\n    if (hex === null || hex === '' || hex.length !== 7) {\n      throw new Error('please set valid hex value for color...');\n    }\n\n    hex = hex.substring(1);\n    var bigint = parseInt(hex, 16);\n    var r = bigint >> 16 & 255;\n    var g = bigint >> 8 & 255;\n    var b = bigint & 255;\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  };\n\n  PdfExport.prototype.getFontStyle = function (theme) {\n    var fontStyle = PdfFontStyle.Regular;\n\n    if (!isNullOrUndefined(theme) && theme.bold) {\n      fontStyle |= PdfFontStyle.Bold;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.italic) {\n      fontStyle |= PdfFontStyle.Italic;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.underline) {\n      fontStyle |= PdfFontStyle.Underline;\n    }\n\n    if (!isNullOrUndefined(theme) && theme.strikeout) {\n      fontStyle |= PdfFontStyle.Strikeout;\n    }\n\n    return fontStyle;\n  };\n\n  PdfExport.prototype.getBorderStyle = function (border) {\n    var borders = new PdfBorders();\n\n    if (!isNullOrUndefined(border)) {\n      var borderWidth = border.width; // set border width\n\n      var width = !isNullOrUndefined(borderWidth) && typeof borderWidth === 'number' ? borderWidth * 0.75 : undefined; // set border color\n\n      var color = new PdfColor(196, 196, 196);\n\n      if (!isNullOrUndefined(border.color)) {\n        var borderColor = this.hexToRgb(border.color);\n        color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);\n      }\n\n      var pen = new PdfPen(color, width); // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'\n\n      if (!isNullOrUndefined(border.dashStyle)) {\n        pen.dashStyle = this.getDashStyle(border.dashStyle);\n      }\n\n      borders.all = pen;\n    } else {\n      borders.all = new PdfPen(new PdfColor(234, 234, 234));\n    }\n\n    return borders;\n  };\n  /**\n   * To destroy the pdf export\n   * @return{void}\n   * @hidden\n   */\n\n\n  PdfExport.prototype.destroy = function () {//destroy for exporting\n  };\n\n  return PdfExport;\n}();\n\nexport { PdfExport };","map":null,"metadata":{},"sourceType":"module"}