{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * Path.ts class for EJ2-PDF\n */\n\n\nimport { PdfBrush } from './../brushes/pdf-brush';\nimport { PdfPen } from './../pdf-pen';\nimport { PdfLayoutFormat } from './../figures/base/element-layouter';\nimport { RectangleF, PointF } from './../../drawing/pdf-drawing';\nimport { PathPointType } from './enum';\nimport { PdfFillElement } from './../figures/base/fill-element';\nimport { PdfFillMode } from './../enum';\n/**\n * `PdfPath` class Implements graphics path, which is a sequence of primitive graphics elements.\n * @private\n */\n\nvar PdfPath =\n/** @class */\nfunction (_super) {\n  __extends(PdfPath, _super);\n  /**\n   * Initializes a new instance of the `PdfPath` class.\n   * @public\n   */\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  function PdfPath(arg1, arg2, arg3, arg4) {\n    var _this = _super.call(this) || this; // Fields\n\n    /**\n     * Local variable to store the points.\n     * @private\n     */\n\n\n    _this.mpoints = null;\n    /**\n     * Local variable to store the path Types.\n     * @private\n     */\n\n    _this.mpathTypes = null;\n    /**\n     * Local variable to store the Start Figure.\n     * @private\n     */\n\n    _this.mStartFigure = true;\n    /**\n     * Local variable to store the fill Mode.\n     * @private\n     */\n\n    _this.mfillMode = PdfFillMode.Alternate;\n    /**\n     * Local variable to store the Beziers.\n     * @private\n     */\n\n    _this.isBeziers3 = false;\n    /**\n     * Local variable to store the xps.\n     * @private\n     */\n\n    _this.isXps = false;\n\n    if (typeof arg1 === 'undefined') {//\n    } else if (arg1 instanceof PdfPen) {\n      _this = _super.call(this, arg1) || this;\n\n      if (arg2 instanceof PdfBrush) {\n        _this = _super.call(this, arg1, arg2) || this;\n        _this.fillMode = arg3;\n      } else if (arg2 !== null && typeof arg2 !== 'undefined' && arg3 !== null && typeof arg3 !== 'undefined') {\n        _this.addPath(arg2, arg3);\n      }\n    } else if (arg1 instanceof PdfBrush) {\n      _this = _super.call(this, arg1) || this;\n\n      if (arg2 !== null && typeof arg2 !== 'undefined') {\n        _this.fillMode = arg2;\n      }\n\n      if (arg3 !== null && typeof arg3 !== 'undefined' && arg4 !== null && typeof arg4 !== 'undefined') {\n        _this.addPath(arg3, arg4);\n      }\n    } else {\n      _this.addPath(arg1, arg2);\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(PdfPath.prototype, \"fillMode\", {\n    // Properties\n\n    /**\n     * Gets or sets the fill mode.\n     * @public\n     */\n    get: function () {\n      return this.mfillMode;\n    },\n    set: function (value) {\n      this.mfillMode = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfPath.prototype, \"pathPoints\", {\n    /**\n     * Gets the path points.\n     * @public\n     */\n    get: function () {\n      return this.points;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfPath.prototype, \"pathTypes\", {\n    /**\n     * Gets the path point types.\n     * @public\n     */\n    get: function () {\n      return this.types;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfPath.prototype, \"pointCount\", {\n    /**\n     * Gets the point count.\n     * @public\n     */\n    get: function () {\n      var count = 0;\n\n      if (this.mpoints != null) {\n        count = this.mpoints.length;\n      }\n\n      return count;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfPath.prototype, \"lastPoint\", {\n    /**\n     * Gets the last points.\n     * @public\n     */\n    get: function () {\n      return this.getLastPoint();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfPath.prototype, \"points\", {\n    /**\n     * Gets the points list.\n     * @private\n     */\n    get: function () {\n      if (this.mpoints == null) {\n        this.mpoints = [];\n      }\n\n      return this.mpoints;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfPath.prototype, \"types\", {\n    /**\n     * Gets the types.\n     * @private\n     */\n    get: function () {\n      if (this.mpathTypes == null) {\n        this.mpathTypes = [];\n      }\n\n      return this.mpathTypes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  PdfPath.prototype.draw = function (arg1, arg2, arg3, arg4) {\n    if (arg2 instanceof PointF && typeof arg2.width === 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(arg1, arg2.x, arg2.y);\n    } else if (arg2 instanceof RectangleF && typeof arg2.width !== 'undefined' && typeof arg3 === 'undefined') {\n      return this.drawHelper(arg1, arg2, null);\n    } else if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {\n      return this.drawHelper(arg1, arg2, arg3, null);\n    } else if (arg2 instanceof PointF && arg3 instanceof PdfLayoutFormat) {\n      return this.drawHelper(arg1, arg2.x, arg2.y, arg3);\n    } else if (typeof arg2 === 'number' && (arg4 instanceof PdfLayoutFormat || arg4 == null) && typeof arg3 === 'number') {\n      var widthValue = arg1.graphics.clientSize.width - arg2;\n      var layoutRect = new RectangleF(arg2, arg3, widthValue, 0);\n      return this.drawHelper(arg1, layoutRect, arg4);\n    } else if (arg2 instanceof RectangleF && arg3 instanceof PdfLayoutFormat) {\n      return this.drawHelper(arg1, arg2, arg3);\n    } else {\n      return this.drawHelper(arg1, arg2, arg3);\n    }\n  };\n\n  PdfPath.prototype.addArc = function (arg1, arg2, arg3, arg4, arg5, arg6) {\n    if (arg1 instanceof RectangleF) {\n      this.addArc(arg1.x, arg1.y, arg1.width, arg1.height, arg2, arg3);\n    } else {\n      var points = this.getBezierArcPoints(arg1, arg2, arg2 + arg3, arg2 + arg4, arg5, arg6);\n\n      for (var i = 0; i < points.length; i = i + 8) {\n        /* tslint:disable-next-line:max-line-length */\n        var point = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];\n        this.addPoints(point, PathPointType.Bezier3);\n      }\n    }\n  };\n  /* tslint:disable-next-line:max-line-length */\n\n\n  PdfPath.prototype.addBezier = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n    if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PointF && arg4 instanceof PointF) {\n      this.addBezier(arg1.x, arg1.y, arg2.x, arg2.y, arg3.x, arg3.y, arg4.x, arg4.y);\n    } else {\n      var points = [];\n      points.push(arg1);\n      points.push(arg2);\n      points.push(arg3);\n      points.push(arg4);\n      points.push(arg5);\n      points.push(arg6);\n      points.push(arg7);\n      points.push(arg8);\n      this.addPoints(points, PathPointType.Bezier3);\n    }\n  };\n\n  PdfPath.prototype.addEllipse = function (arg1, arg2, arg3, arg4) {\n    if (arg1 instanceof RectangleF) {\n      this.addEllipse(arg1.x, arg1.y, arg1.width, arg1.height);\n    } else {\n      this.startFigure();\n      this.addArc(arg1, arg2, arg3, arg4, 0, 360);\n      this.closeFigure();\n    }\n  };\n\n  PdfPath.prototype.addLine = function (arg1, arg2, arg3, arg4) {\n    if (arg1 instanceof PointF && arg2 instanceof PointF) {\n      this.addLine(arg1.x, arg1.y, arg2.x, arg2.y);\n    } else {\n      var points = [];\n      points.push(arg1);\n      points.push(arg2);\n      points.push(arg3);\n      points.push(arg4);\n      this.addPoints(points, PathPointType.Line);\n    }\n  };\n\n  PdfPath.prototype.addPath = function (arg1, arg2) {\n    if (arg1 instanceof PdfPath) {\n      this.addPath(arg1.pathPoints, arg1.pathTypes);\n    } else {\n      if (arg1 == null) {\n        throw new Error('ArgumentNullException:pathPoints');\n      }\n\n      if (arg2 == null) {\n        throw new Error('ArgumentNullException:pathTypes');\n      }\n\n      var count = arg1.length;\n\n      if (count !== arg2.length) {\n        throw new Error('The argument arrays should be of equal length.');\n      }\n    }\n  };\n\n  PdfPath.prototype.addPie = function (arg1, arg2, arg3, arg4, arg5, arg6) {\n    if (arg1 instanceof RectangleF) {\n      this.addPie(arg1.x, arg1.y, arg1.width, arg1.height, arg2, arg3);\n    } else {\n      this.startFigure();\n      this.addArc(arg1, arg2, arg3, arg4, arg5, arg6);\n      this.addPoint(new PointF(arg1 + arg3 / 2, arg2 + arg4 / 2), PathPointType.Line);\n      this.closeFigure();\n    }\n  };\n  /**\n   * `add a polygon` specified by points.\n   * @param points The points of the polygon\n   */\n\n\n  PdfPath.prototype.addPolygon = function (points) {\n    var count = points.length * 2;\n    var p = [];\n    this.startFigure();\n\n    for (var i = 0; i < points.length; i++) {\n      p.push(points[i].x);\n      p.push(points[i].y);\n    }\n\n    this.addPoints(p, PathPointType.Line);\n    this.closeFigure();\n  };\n\n  PdfPath.prototype.addRectangle = function (arg1, y, width, height) {\n    if (arg1 instanceof RectangleF) {\n      this.addRectangle(arg1.x, arg1.y, arg1.width, arg1.height);\n    } else {\n      var points = [];\n      this.startFigure();\n      points.push(arg1);\n      points.push(y);\n      points.push(arg1 + width);\n      points.push(y);\n      points.push(arg1 + width);\n      points.push(y + height);\n      points.push(arg1);\n      points.push(y + height);\n      this.addPoints(points, PathPointType.Line);\n      this.closeFigure();\n    }\n  };\n  /**\n   * Starts a new figure.\n   * @public\n   */\n\n\n  PdfPath.prototype.startFigure = function () {\n    this.mStartFigure = true;\n  };\n  /**\n   * Closed all non-closed figures.\n   * @public\n   */\n\n\n  PdfPath.prototype.closeAllFigures = function () {\n    var startPath = this.pathPoints[0];\n\n    for (var i = 0; i < this.mpathTypes.length; i++) {\n      var pt = this.types[i];\n      var flag = false;\n\n      if (i !== 0 && pt === PathPointType.Start) {\n        this.closeFigure(i - 1);\n        flag = true;\n      } else if (i === this.mpathTypes.length - 1 && !flag && this.isXps) {\n        if (startPath.x === this.pathPoints[i].y) {\n          this.closeFigure(i);\n        }\n      }\n    }\n  };\n  /**\n   * Gets the last point.\n   * @public\n   */\n\n\n  PdfPath.prototype.getLastPoint = function () {\n    var lastPoint = new PointF(0, 0);\n    var count = this.pointCount;\n\n    if (count > 0 && this.mpoints != null) {\n      lastPoint.x = this.mpoints[count - 1].x;\n      lastPoint.y = this.mpoints[count - 1].y;\n    }\n\n    return lastPoint;\n  };\n  /**\n   * Gets the bezier points for arc constructing.\n   * @public\n   */\n\n\n  PdfPath.prototype.getBezierArcPoints = function (x1, y1, x2, y2, s1, e1) {\n    if (x1 > x2) {\n      var tmp = void 0;\n      tmp = x1;\n      x1 = x2;\n      x2 = tmp;\n    }\n\n    if (y2 > y1) {\n      var tmp = void 0;\n      tmp = y1;\n      y1 = y2;\n      y2 = tmp;\n    }\n\n    var fragAngle;\n    var numFragments;\n\n    if (Math.abs(e1) <= 90) {\n      fragAngle = e1;\n      numFragments = 1;\n    } else {\n      numFragments = Math.ceil(Math.abs(e1) / 90);\n      fragAngle = e1 / numFragments;\n    }\n\n    var xcen = (x1 + x2) / 2;\n    var ycen = (y1 + y2) / 2;\n    var rx = (x2 - x1) / 2;\n    var ry = (y2 - y1) / 2;\n    var halfAng = fragAngle * (Math.PI / 360);\n    var kappa = Math.abs(4.0 / 3.0 * (1.0 - Math.cos(halfAng)) / Math.sin(halfAng));\n    var pointList = [];\n\n    for (var i = 0; i < numFragments; i++) {\n      var theta0 = (s1 + i * fragAngle) * (Math.PI / 180);\n      var theta1 = (s1 + (i + 1) * fragAngle) * (Math.PI / 180);\n      var cos0 = Math.cos(theta0);\n      var cos1 = Math.cos(theta1);\n      var sin0 = Math.sin(theta0);\n      var sin1 = Math.sin(theta1);\n\n      if (fragAngle > 0) {\n        /* tslint:disable-next-line:max-line-length */\n        pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 - kappa * sin0), ycen - ry * (sin0 + kappa * cos0), xcen + rx * (cos1 + kappa * sin1), ycen - ry * (sin1 - kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);\n      } else {\n        /* tslint:disable-next-line:max-line-length */\n        pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 + kappa * sin0), ycen - ry * (sin0 - kappa * cos0), xcen + rx * (cos1 - kappa * sin1), ycen - ry * (sin1 + kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);\n      }\n    }\n\n    return pointList;\n  };\n  /**\n   * `getBoundsInternal` Returns a rectangle that bounds this element.\n   * @public\n   */\n\n\n  PdfPath.prototype.getBoundsInternal = function () {\n    var points = this.pathPoints;\n    var bounds = new RectangleF(0, 0, 0, 0);\n\n    if (points.length > 0) {\n      var xmin = points[0].x;\n      var xmax = points[0].x;\n      var ymin = points[0].y;\n      var ymax = points[0].y;\n\n      for (var i = 1; i < points.length; i++) {\n        var point = points[i];\n        xmin = Math.min(point.x, xmin);\n        xmax = Math.max(point.x, xmax);\n        ymin = Math.min(point.y, ymin);\n        ymax = Math.max(point.y, ymax);\n      }\n\n      bounds = new RectangleF(xmin, ymin, xmax - xmin, ymax - ymin);\n    }\n\n    return bounds;\n  };\n  /**\n   * `drawInternal` Draws an element on the Graphics.\n   * @param graphics Graphics context where the element should be printed.\n   * @public\n   */\n\n\n  PdfPath.prototype.drawInternal = function (graphics) {\n    if (graphics == null) {\n      throw new Error('ArgumentNullException :graphics');\n    }\n\n    graphics.drawPath(this.obtainPen(), this.brush, this);\n  };\n\n  PdfPath.prototype.addPoints = function (points, pointType, startIndex, endIndex) {\n    if (typeof startIndex === 'undefined' && typeof endIndex === 'undefined') {\n      this.addPoints(points, pointType, 0, points.length);\n    } else {\n      for (var i = startIndex; i < endIndex; i++) {\n        var point = new PointF(points[i], points[i + 1]);\n\n        if (i === startIndex) {\n          if (this.pointCount <= 0 || this.mStartFigure) {\n            this.addPoint(point, PathPointType.Start);\n            this.mStartFigure = false;\n          } else if (point.x !== this.lastPoint.x && point.y !== this.lastPoint.y && !this.isBeziers3) {\n            this.addPoint(point, PathPointType.Line);\n          } else if (point.x !== this.lastPoint.x && point.y !== this.lastPoint.y) {\n            this.addPoint(point, PathPointType.Bezier3);\n          }\n        } else {\n          this.addPoint(point, pointType);\n        }\n\n        i++;\n      }\n    }\n  };\n  /**\n   * `add a point` Adds the point and its type\n   * @param points The points.\n   * @param pointType Type of the points.\n   * @private\n   */\n\n\n  PdfPath.prototype.addPoint = function (point, pointType) {\n    this.points.push(point);\n    this.types.push(pointType);\n  };\n\n  PdfPath.prototype.closeFigure = function (index) {\n    if (typeof index === 'undefined') {\n      if (this.pointCount > 0) {\n        this.closeFigure(this.pointCount - 1);\n      }\n\n      this.startFigure();\n    } else {\n      if (index < 0) {\n        throw new Error('IndexOutOfRangeException()');\n      }\n\n      var pt = this.types[index];\n      pt = pt | PathPointType.CloseSubpath;\n      this.types[index] = pt;\n    }\n  };\n\n  return PdfPath;\n}(PdfFillElement);\n\nexport { PdfPath };","map":null,"metadata":{},"sourceType":"module"}