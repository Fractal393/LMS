{"ast":null,"code":"/**\r\n * DevExtreme (ui/text_box/ui.text_editor.mask.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\");\n\nvar caret = require(\"./utils.caret\");\n\nvar devices = require(\"../../core/devices\");\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar eventUtils = require(\"../../events/utils\");\n\nvar eventsEngine = require(\"../../events/core/events_engine\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar focused = require(\"../widget/selectors\").focused;\n\nvar isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar messageLocalization = require(\"../../localization/message\");\n\nvar noop = require(\"../../core/utils/common\").noop;\n\nvar stringUtils = require(\"../../core/utils/string\");\n\nvar wheelEvent = require(\"../../events/core/wheel\");\n\nvar MaskRules = require(\"./ui.text_editor.mask.rule\");\n\nvar TextEditorBase = require(\"./ui.text_editor.base\");\n\nvar DefaultMaskStrategy = require(\"./ui.text_editor.mask.strategy.default\").default;\n\nvar AndroidMaskStrategy = require(\"./ui.text_editor.mask.strategy.android\").default;\n\nvar stubCaret = function () {\n  return {};\n};\n\nvar EMPTY_CHAR = \" \";\nvar ESCAPED_CHAR = \"\\\\\";\nvar TEXTEDITOR_MASKED_CLASS = \"dx-texteditor-masked\";\nvar FORWARD_DIRECTION = \"forward\";\nvar BACKWARD_DIRECTION = \"backward\";\nvar buildInMaskRules = {\n  0: /[0-9]/,\n  9: /[0-9\\s]/,\n  \"#\": /[-+0-9\\s]/,\n  L: function (char) {\n    return isLiteralChar(char);\n  },\n  l: function (char) {\n    return isLiteralChar(char) || isSpaceChar(char);\n  },\n  C: /\\S/,\n  c: /./,\n  A: function (char) {\n    return isLiteralChar(char) || isNumericChar(char);\n  },\n  a: function (char) {\n    return isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char);\n  }\n};\n\nfunction isNumericChar(char) {\n  return /[0-9]/.test(char);\n}\n\nfunction isLiteralChar(char) {\n  var code = char.charCodeAt();\n  return 64 < code && code < 91 || 96 < code && code < 123 || code > 127;\n}\n\nfunction isSpaceChar(char) {\n  return \" \" === char;\n}\n\nvar TextEditorMask = TextEditorBase.inherit({\n  _getDefaultOptions: function () {\n    return extend(this.callBase(), {\n      mask: \"\",\n      maskChar: \"_\",\n      maskRules: {},\n      maskInvalidMessage: messageLocalization.format(\"validation-mask\"),\n      useMaskedValue: false,\n      showMaskMode: \"always\"\n    });\n  },\n  _supportedKeys: function () {\n    var that = this;\n    var keyHandlerMap = {\n      backspace: that._maskStrategy.getHandler(\"backspace\"),\n      del: that._maskStrategy.getHandler(\"del\"),\n      enter: that._changeHandler\n    };\n    var result = that.callBase();\n    each(keyHandlerMap, function (key, callback) {\n      var parentHandler = result[key];\n\n      result[key] = function (e) {\n        that.option(\"mask\") && callback.call(that, e);\n        parentHandler && parentHandler(e);\n      };\n    });\n    return result;\n  },\n  _getSubmitElement: function () {\n    return !this.option(\"mask\") ? this.callBase() : this._$hiddenElement;\n  },\n  _init: function () {\n    this.callBase();\n\n    this._initMaskStrategy();\n  },\n  _initMaskStrategy: function () {\n    var device = devices.real();\n    this._maskStrategy = device.android && device.version[0] > 4 ? new AndroidMaskStrategy(this) : new DefaultMaskStrategy(this);\n  },\n  _initMarkup: function () {\n    this._renderHiddenElement();\n\n    this.callBase();\n  },\n  _attachMouseWheelEventHandlers: function () {\n    var hasMouseWheelHandler = this._onMouseWheel !== noop;\n\n    if (!hasMouseWheelHandler) {\n      return;\n    }\n\n    var input = this._input();\n\n    var eventName = eventUtils.addNamespace(wheelEvent.name, this.NAME);\n\n    var mouseWheelAction = this._createAction(function (e) {\n      if (focused(input)) {\n        var dxEvent = e.event;\n\n        this._onMouseWheel(dxEvent);\n\n        dxEvent.preventDefault();\n        dxEvent.stopPropagation();\n      }\n    }.bind(this));\n\n    eventsEngine.off(input, eventName);\n    eventsEngine.on(input, eventName, function (e) {\n      mouseWheelAction({\n        event: e\n      });\n    });\n  },\n  _onMouseWheel: noop,\n  _render: function () {\n    this.callBase();\n\n    this._renderMask();\n\n    this._attachMouseWheelEventHandlers();\n  },\n  _renderHiddenElement: function () {\n    if (this.option(\"mask\")) {\n      this._$hiddenElement = $(\"<input>\").attr(\"type\", \"hidden\").appendTo(this._inputWrapper());\n    }\n  },\n  _removeHiddenElement: function () {\n    this._$hiddenElement && this._$hiddenElement.remove();\n  },\n  _renderMask: function () {\n    this.$element().removeClass(TEXTEDITOR_MASKED_CLASS);\n    this._maskRulesChain = null;\n\n    this._maskStrategy.detachEvents();\n\n    if (!this.option(\"mask\")) {\n      return;\n    }\n\n    this.$element().addClass(TEXTEDITOR_MASKED_CLASS);\n\n    this._maskStrategy.attachEvents();\n\n    this._parseMask();\n\n    this._renderMaskedValue();\n  },\n  _suppressCaretChanging: function (callback, args) {\n    var originalCaret = caret;\n    caret = stubCaret;\n\n    try {\n      callback.apply(this, args);\n    } finally {\n      caret = originalCaret;\n    }\n  },\n  _changeHandler: function (e) {\n    var $input = this._input();\n\n    var inputValue = $input.val();\n\n    if (inputValue === this._changedValue) {\n      return;\n    }\n\n    this._changedValue = inputValue;\n    var changeEvent = eventUtils.createEvent(e, {\n      type: \"change\"\n    });\n    eventsEngine.trigger($input, changeEvent);\n  },\n  _parseMask: function () {\n    this._maskRules = extend({}, buildInMaskRules, this.option(\"maskRules\"));\n    this._maskRulesChain = this._parseMaskRule(0);\n  },\n  _parseMaskRule: function (index) {\n    var mask = this.option(\"mask\");\n\n    if (index >= mask.length) {\n      return new MaskRules.EmptyMaskRule();\n    }\n\n    var currentMaskChar = mask[index];\n    var isEscapedChar = currentMaskChar === ESCAPED_CHAR;\n    var result = isEscapedChar ? new MaskRules.StubMaskRule({\n      maskChar: mask[index + 1]\n    }) : this._getMaskRule(currentMaskChar);\n    result.next(this._parseMaskRule(index + 1 + isEscapedChar));\n    return result;\n  },\n  _getMaskRule: function (pattern) {\n    var ruleConfig;\n    each(this._maskRules, function (rulePattern, allowedChars) {\n      if (rulePattern === pattern) {\n        ruleConfig = {\n          pattern: rulePattern,\n          allowedChars: allowedChars\n        };\n        return false;\n      }\n    });\n    return isDefined(ruleConfig) ? new MaskRules.MaskRule(extend({\n      maskChar: this.option(\"maskChar\")\n    }, ruleConfig)) : new MaskRules.StubMaskRule({\n      maskChar: pattern\n    });\n  },\n  _renderMaskedValue: function () {\n    if (!this._maskRulesChain) {\n      return;\n    }\n\n    var value = this.option(\"value\") || \"\";\n\n    this._maskRulesChain.clear(this._normalizeChainArguments());\n\n    var chainArgs = {\n      length: value.length\n    };\n    chainArgs[this._isMaskedValueMode() ? \"text\" : \"value\"] = value;\n\n    this._handleChain(chainArgs);\n\n    this._displayMask();\n  },\n  _replaceSelectedText: function (text, selection, char) {\n    if (void 0 === char) {\n      return text;\n    }\n\n    var textBefore = text.slice(0, selection.start);\n    var textAfter = text.slice(selection.end);\n    var edited = textBefore + char + textAfter;\n    return edited;\n  },\n  _isMaskedValueMode: function () {\n    return this.option(\"useMaskedValue\");\n  },\n  _displayMask: function (caret) {\n    caret = caret || this._caret();\n\n    this._renderValue();\n\n    this._caret(caret);\n  },\n  _isValueEmpty: function () {\n    return stringUtils.isEmpty(this._value);\n  },\n  _shouldShowMask: function () {\n    var showMaskMode = this.option(\"showMaskMode\");\n\n    if (\"onFocus\" === showMaskMode) {\n      return focused(this._input()) || !this._isValueEmpty();\n    }\n\n    return true;\n  },\n  _showMaskPlaceholder: function () {\n    if (this._shouldShowMask()) {\n      var text = this._maskRulesChain.text();\n\n      this.option(\"text\", text);\n\n      if (\"onFocus\" === this.option(\"showMaskMode\")) {\n        this._renderDisplayText(text);\n      }\n    }\n  },\n  _renderValue: function () {\n    if (this._maskRulesChain) {\n      var text = this._maskRulesChain.text();\n\n      this._showMaskPlaceholder();\n\n      if (this._$hiddenElement) {\n        var value = this._maskRulesChain.value();\n\n        var hiddenElementValue = this._isMaskedValueMode() ? text : value;\n\n        this._$hiddenElement.val(!stringUtils.isEmpty(value) ? hiddenElementValue : \"\");\n      }\n    }\n\n    return this.callBase();\n  },\n  _valueChangeEventHandler: function (e) {\n    if (!this._maskRulesChain) {\n      this.callBase.apply(this, arguments);\n      return;\n    }\n\n    this._saveValueChangeEvent(e);\n\n    this.option(\"value\", this._convertToValue().replace(/\\s+$/, \"\"));\n  },\n  _isControlKeyFired: function (e) {\n    return this._isControlKey(eventUtils.normalizeKeyName(e)) || e.ctrlKey || e.metaKey;\n  },\n  _handleChain: function (args) {\n    var handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));\n\n    this._value = this._maskRulesChain.value();\n    this._textValue = this._maskRulesChain.text();\n    return handledCount;\n  },\n  _normalizeChainArguments: function (args) {\n    args = args || {};\n    args.index = 0;\n    args.fullText = this._maskRulesChain.text();\n    return args;\n  },\n  _convertToValue: function (text) {\n    if (this._isMaskedValueMode()) {\n      text = this._replaceMaskCharWithEmpty(text || this._textValue || \"\");\n    } else {\n      text = text || this._value || \"\";\n    }\n\n    return text;\n  },\n  _replaceMaskCharWithEmpty: function (text) {\n    return text.replace(new RegExp(this.option(\"maskChar\"), \"g\"), EMPTY_CHAR);\n  },\n  _maskKeyHandler: function (e, keyHandler) {\n    var _this = this;\n\n    if (this.option(\"readOnly\")) {\n      return;\n    }\n\n    this.setForwardDirection();\n    e.preventDefault();\n\n    this._handleSelection();\n\n    var previousText = this._input().val();\n\n    var raiseInputEvent = function () {\n      if (previousText !== _this._input().val()) {\n        _this._maskStrategy.runWithoutEventProcessing(function () {\n          return eventsEngine.trigger(_this._input(), \"input\");\n        });\n      }\n    };\n\n    var handled = keyHandler();\n\n    if (handled) {\n      handled.then(raiseInputEvent);\n    } else {\n      this.setForwardDirection();\n\n      this._adjustCaret();\n\n      this._displayMask();\n\n      this._maskRulesChain.reset();\n\n      raiseInputEvent();\n    }\n  },\n  _handleKey: function (key, direction) {\n    this._direction(direction || FORWARD_DIRECTION);\n\n    this._adjustCaret(key);\n\n    this._handleKeyChain(key);\n\n    this._moveCaret();\n  },\n  _handleSelection: function () {\n    if (!this._hasSelection()) {\n      return;\n    }\n\n    var caret = this._caret();\n\n    var emptyChars = new Array(caret.end - caret.start + 1).join(EMPTY_CHAR);\n\n    this._handleKeyChain(emptyChars);\n  },\n  _handleKeyChain: function (chars) {\n    var caret = this._caret();\n\n    var start = this.isForwardDirection() ? caret.start : caret.start - 1;\n    var end = this.isForwardDirection() ? caret.end : caret.end - 1;\n    var length = start === end ? 1 : end - start;\n\n    this._handleChain({\n      text: chars,\n      start: start,\n      length: length\n    });\n  },\n  _tryMoveCaretBackward: function () {\n    this.setBackwardDirection();\n\n    var currentCaret = this._caret().start;\n\n    this._adjustCaret();\n\n    return !currentCaret || currentCaret !== this._caret().start;\n  },\n  _adjustCaret: function (char) {\n    var caret = this._maskRulesChain.adjustedCaret(this._caret().start, this.isForwardDirection(), char);\n\n    this._caret({\n      start: caret,\n      end: caret\n    });\n  },\n  _moveCaret: function () {\n    var currentCaret = this._caret().start;\n\n    var maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);\n    var caret = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;\n\n    this._caret({\n      start: caret,\n      end: caret\n    });\n  },\n  _caret: function (position) {\n    var $input = this._input();\n\n    if (!$input.length) {\n      return;\n    }\n\n    if (!arguments.length) {\n      return caret($input);\n    }\n\n    caret($input, position);\n  },\n  _hasSelection: function () {\n    var caret = this._caret();\n\n    return caret.start !== caret.end;\n  },\n  _direction: function (direction) {\n    if (!arguments.length) {\n      return this._typingDirection;\n    }\n\n    this._typingDirection = direction;\n  },\n  setForwardDirection: function () {\n    this._direction(FORWARD_DIRECTION);\n  },\n  setBackwardDirection: function () {\n    this._direction(BACKWARD_DIRECTION);\n  },\n  isForwardDirection: function () {\n    return this._direction() === FORWARD_DIRECTION;\n  },\n  _clean: function () {\n    this._maskStrategy && this._maskStrategy.clean();\n    this.callBase();\n  },\n  _validateMask: function () {\n    if (!this._maskRulesChain) {\n      return;\n    }\n\n    var isValid = stringUtils.isEmpty(this.option(\"value\")) || this._maskRulesChain.isValid(this._normalizeChainArguments());\n\n    this.option({\n      isValid: isValid,\n      validationError: isValid ? null : {\n        editorSpecific: true,\n        message: this.option(\"maskInvalidMessage\")\n      }\n    });\n  },\n  _updateHiddenElement: function () {\n    this._removeHiddenElement();\n\n    if (this.option(\"mask\")) {\n      this._input().removeAttr(\"name\");\n\n      this._renderHiddenElement();\n    }\n\n    this._setSubmitElementName(this.option(\"name\"));\n  },\n  _updateMaskOption: function () {\n    this._updateHiddenElement();\n\n    this._renderMask();\n\n    this._validateMask();\n  },\n  _processEmptyMask: function (mask) {\n    if (mask) {\n      return;\n    }\n\n    var value = this.option(\"value\");\n    this.option({\n      text: value,\n      isValid: true\n    });\n    this.validationRequest.fire({\n      value: value,\n      editor: this\n    });\n\n    this._renderValue();\n  },\n  _optionChanged: function (args) {\n    switch (args.name) {\n      case \"mask\":\n        this._updateMaskOption();\n\n        this._processEmptyMask(args.value);\n\n        break;\n\n      case \"maskChar\":\n      case \"maskRules\":\n      case \"useMaskedValue\":\n        this._updateMaskOption();\n\n        break;\n\n      case \"value\":\n        this._renderMaskedValue();\n\n        this._validateMask();\n\n        this.callBase(args);\n        this._changedValue = this._input().val();\n        break;\n\n      case \"maskInvalidMessage\":\n        break;\n\n      case \"showMaskMode\":\n        this.option(\"text\", \"\");\n\n        this._renderValue();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  }\n});\nmodule.exports = TextEditorMask;","map":null,"metadata":{},"sourceType":"script"}