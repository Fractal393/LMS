{"ast":null,"code":"import { SizeF, RectangleF, PointF } from './../../drawing/pdf-drawing';\nimport { PdfWordWrapType } from './enum';\nimport { StringTokenizer } from './string-tokenizer';\n/**\n * Class `lay outing the text`.\n */\n\nvar PdfStringLayouter =\n/** @class */\nfunction () {\n  // Constructors\n\n  /**\n   * Initializes a new instance of the `StringLayouter` class.\n   * @private\n   */\n  function PdfStringLayouter() {\n    /**\n     * Checks whether the x co-ordinate is need to set as client size or not.\n     * @hidden\n     * @private\n     */\n    this.isOverloadWithPosition = false; //\n  }\n\n  PdfStringLayouter.prototype.layout = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n    if (arg4 instanceof RectangleF) {\n      this.initialize(arg1, arg2, arg3, arg4, arg5);\n      this.isOverloadWithPosition = arg6;\n      this.clientSize = arg7;\n      var result = this.doLayout();\n      this.clear();\n      return result;\n    } else {\n      this.initialize(arg1, arg2, arg3, arg4);\n      this.isOverloadWithPosition = arg5;\n      this.clientSize = arg6;\n      var result = this.doLayout();\n      this.clear();\n      return result;\n    }\n  };\n\n  PdfStringLayouter.prototype.initialize = function (text, font, format, rectSize, pageHeight) {\n    if (typeof pageHeight === 'number') {\n      if (text == null) {\n        throw new Error('ArgumentNullException:text');\n      }\n\n      if (font == null) {\n        throw new Error('ArgumentNullException:font');\n      }\n\n      this.text = text;\n      this.font = font;\n      this.format = format;\n      this.size = new SizeF(rectSize.width, rectSize.height);\n      this.rectangle = rectSize;\n      this.pageHeight = pageHeight;\n      this.reader = new StringTokenizer(text);\n    } else {\n      this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);\n    }\n  };\n  /**\n   * `Clear` all resources.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.clear = function () {\n    this.font = null;\n    this.format = null;\n    this.reader.close();\n    this.reader = null;\n    this.text = null;\n  };\n  /**\n   * `Layouts` the text.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.doLayout = function () {\n    var result = new PdfStringLayoutResult();\n    var lineResult = new PdfStringLayoutResult();\n    var lines = [];\n    var line = this.reader.peekLine();\n    var lineIndent = this.getLineIndent(true);\n\n    while (line != null) {\n      lineResult = this.layoutLine(line, lineIndent);\n\n      if (lineResult !== null || typeof lineResult !== 'undefined') {\n        var numSymbolsInserted = 0;\n        /* tslint:disable */\n\n        var returnedValue = this.copyToResult(result, lineResult, lines,\n        /*out*/\n        numSymbolsInserted);\n        /* tslint:enable */\n\n        var success = returnedValue.success;\n        numSymbolsInserted = returnedValue.numInserted;\n\n        if (!success) {\n          this.reader.read(numSymbolsInserted);\n          break;\n        }\n      } // if (lineResult.textRemainder != null && lineResult.textRemainder.length > 0 ) {\n      //     break;\n      // }\n\n\n      this.reader.readLine();\n      line = this.reader.peekLine();\n      lineIndent = this.getLineIndent(false);\n    }\n\n    this.finalizeResult(result, lines);\n    return result;\n  };\n  /**\n   * Returns `line indent` for the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineIndent = function (firstLine) {\n    var lineIndent = 0;\n\n    if (this.format != null) {\n      lineIndent = firstLine ? this.format.firstLineIndent : this.format.paragraphIndent;\n      lineIndent = this.size.width > 0 ? Math.min(this.size.width, lineIndent) : lineIndent;\n    }\n\n    return lineIndent;\n  };\n  /**\n   * Calculates `height` of the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineHeight = function () {\n    var height = this.font.height;\n\n    if (this.format != null && this.format.lineSpacing !== 0) {\n      height = this.format.lineSpacing + this.font.height;\n    }\n\n    return height;\n  };\n  /**\n   * Calculates `width` of the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getLineWidth = function (line) {\n    var width = this.font.getLineWidth(line, this.format);\n    return width;\n  }; // tslint:disable\n\n  /**\n   * `Layouts` line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.layoutLine = function (line, lineIndent) {\n    var lineResult = new PdfStringLayoutResult();\n    lineResult.layoutLineHeight = this.getLineHeight();\n    var lines = [];\n    var maxWidth = this.size.width;\n    var lineWidth = this.getLineWidth(line) + lineIndent;\n    var lineType = LineType.FirstParagraphLine;\n    var readWord = true; // line is in bounds.\n\n    if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {\n      this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);\n    } else {\n      var builder = '';\n      var curLine = '';\n      lineWidth = lineIndent;\n      var curIndent = lineIndent;\n      var reader = new StringTokenizer(line);\n      var word = reader.peekWord();\n      var isSingleWord = false;\n\n      if (word.length !== reader.length) {\n        if (word === ' ') {\n          curLine = curLine + word;\n          builder = builder + word;\n          reader.position += 1;\n          word = reader.peekWord();\n        }\n      }\n\n      while (word != null) {\n        curLine = curLine + word;\n        var curLineWidth = this.getLineWidth(curLine.toString()) + curIndent\n        /*)*/\n        ;\n\n        if (curLine.toString() === ' ') {\n          curLine = '';\n          curLineWidth = 0;\n        }\n\n        if (curLineWidth > maxWidth) {\n          if (this.getWrapType() === PdfWordWrapType.None) {\n            break;\n          }\n\n          if (curLine.length === word.length) {\n            //  Character wrap is disabled or one symbol is greater than bounds.\n            if (this.getWrapType() === PdfWordWrapType.WordOnly) {\n              lineResult.textRemainder = line.substring(reader.position);\n              break;\n            } else if (curLine.length === 1) {\n              builder = builder + word;\n              break;\n            } else {\n              readWord = false;\n              curLine = '';\n              word = reader.peek().toString();\n              continue;\n            }\n          } else {\n            if (this.getLineWidth(word.toString()) > maxWidth) {\n              this.format.wordWrap = PdfWordWrapType.Character;\n            } else {\n              if (typeof this.format !== 'undefined' && this.format !== null) {\n                this.format.wordWrap = PdfWordWrapType.Word;\n              }\n            }\n\n            if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {\n              var ln = builder.toString(); // if (ln.indexOf(' ') === -1) {\n              //     isSingleWord = true;\n              //     this.addToLineResult(lineResult, lines, curLine, lineWidth, LineType.LayoutBreak | lineType);\n              // } else {\n              //     this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n              // }                          \n\n              if (ln !== ' ') {\n                this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);\n              }\n\n              if (this.isOverloadWithPosition) {\n                maxWidth = this.clientSize.width;\n              }\n\n              curLine = '';\n              builder = '';\n              lineWidth = 0;\n              curIndent = 0;\n              curLineWidth = 0;\n              lineType = LineType.None; // if (isSingleWord) {\n              //     reader.readWord();\n              //     readWord = false;\n              // }\n\n              word = readWord ? word : reader.peekWord(); //isSingleWord = false;\n\n              readWord = true;\n            } else {\n              readWord = false;\n              curLine = '';\n              curLine = curLine + builder.toString();\n              word = reader.peek().toString();\n            }\n\n            continue;\n          }\n        }\n        /*tslint:disable:max-func-body-length */\n\n\n        builder = builder + word;\n        lineWidth = curLineWidth;\n\n        if (readWord) {\n          reader.readWord();\n          word = reader.peekWord(); //isSingleWord = false;\n        } else {\n          reader.read();\n          word = reader.peek().toString();\n        }\n      }\n\n      if (builder.length > 0) {\n        var ln = builder.toString();\n        this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);\n      }\n\n      reader.close();\n    }\n\n    lineResult.layoutLines = [];\n\n    for (var index = 0; index < lines.length; index++) {\n      lineResult.layoutLines.push(lines[index]);\n    }\n\n    lines = [];\n    return lineResult;\n  };\n  /**\n   * `Adds` line to line result.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.addToLineResult = function (lineResult, lines, line, lineWidth, breakType) {\n    var info = new LineInfo();\n    info.text = line;\n    info.width = lineWidth;\n    info.lineType = breakType;\n    lines.push(info);\n    var size = lineResult.actualSize;\n    size.height += this.getLineHeight();\n    size.width = Math.max(size.width, lineWidth);\n    lineResult.size = size;\n  };\n  /**\n   * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.copyToResult = function (result, lineResult, lines,\n  /*out*/\n  numInserted) {\n    var success = true;\n    var allowPartialLines = this.format != null && !this.format.lineLimit;\n    var height = result.actualSize.height;\n    var maxHeight = this.size.height;\n\n    if (this.pageHeight > 0 && maxHeight + this.rectangle.y > this.pageHeight) {\n      maxHeight = this.rectangle.y - this.pageHeight;\n      maxHeight = Math.max(maxHeight, -maxHeight);\n    }\n\n    numInserted = 0;\n\n    if (lineResult.lines != null) {\n      for (var i = 0, len = lineResult.lines.length; i < len; i++) {\n        var expHeight = height + lineResult.lineHeight;\n\n        if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {\n          var info = lineResult.lines[i];\n          numInserted += info.text.length;\n          info = this.trimLine(info, lines.length === 0);\n          lines.push(info); // Update width.\n\n          var size = result.actualSize;\n          size.width = Math.max(size.width, info.width);\n          result.size = size; // The part of the line fits only and it's allowed to use partial lines.\n          // if (expHeight >= maxHeight && maxHeight > 0 && allowPartialLines)\n          // {\n          //     let shouldClip : boolean = (this.format == null || !this.format.noClip);\n          //     if (shouldClip)\n          //     {\n          //         let exceededHeight : number = expHeight - maxHeight;\n          //         let fitHeight : number  = /*Utils.Round(*/ lineResult.lineHeight - exceededHeight /*)*/;\n          //         height = /*Utils.Round(*/ height + fitHeight /*)*/;\n          //     }\n          //     else\n          //     {\n          //         height = expHeight;\n          //     }\n          //     success = false;\n          //     break;\n          // } else {\n\n          height = expHeight; // }\n        } else {\n          success = false;\n          break;\n        }\n      }\n    }\n\n    if (height != result.size.height) {\n      var size1 = result.actualSize;\n      size1.height = height;\n      result.size = size1;\n    }\n\n    return {\n      success: success,\n      numInserted: numInserted\n    };\n  };\n  /**\n   * `Finalizes` final result.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.finalizeResult = function (result, lines) {\n    result.layoutLines = [];\n\n    for (var index = 0; index < lines.length; index++) {\n      result.layoutLines.push(lines[index]);\n    }\n\n    result.layoutLineHeight = this.getLineHeight();\n\n    if (!this.reader.end) {\n      result.textRemainder = this.reader.readToEnd();\n    }\n\n    lines = [];\n  };\n  /**\n   * `Trims` whitespaces at the line.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.trimLine = function (info, firstLine) {\n    var line = info.text;\n    var lineWidth = info.width; // Trim start whitespaces if the line is not a start of the paragraph only.\n\n    var trimStartSpaces = (info.lineType & LineType.FirstParagraphLine) === 0;\n    var start = this.format == null || !this.format.rightToLeft;\n    var spaces = StringTokenizer.spaces;\n    line = start ? line.trim() : line.trim(); // Recalculate line width.\n\n    if (line.length !== info.text.length) {\n      lineWidth = this.getLineWidth(line);\n\n      if ((info.lineType & LineType.FirstParagraphLine) > 0) {\n        lineWidth += this.getLineIndent(firstLine);\n      }\n    }\n\n    info.text = line;\n    info.width = lineWidth;\n    return info;\n  };\n  /**\n   * Returns `wrap` type.\n   * @private\n   */\n\n\n  PdfStringLayouter.prototype.getWrapType = function () {\n    var wrapType = this.format != null ? this.format.wordWrap : PdfWordWrapType.Word;\n    return wrapType;\n  };\n\n  return PdfStringLayouter;\n}();\n\nexport { PdfStringLayouter }; //Internal declaration\n\nvar PdfStringLayoutResult =\n/** @class */\nfunction () {\n  function PdfStringLayoutResult() {}\n\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"remainder\", {\n    // Properties\n\n    /**\n     * Gets the `text` which is not lay outed.\n     * @private\n     */\n    get: function () {\n      return this.textRemainder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"actualSize\", {\n    /**\n     * Gets the actual layout text `bounds`.\n     * @private\n     */\n    get: function () {\n      if (typeof this.size === 'undefined') {\n        this.size = new SizeF(0, 0);\n      }\n\n      return this.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lines\", {\n    /**\n     * Gets layout `lines` information.\n     * @private\n     */\n    get: function () {\n      return this.layoutLines;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lineHeight\", {\n    /**\n     * Gets the `height` of the line.\n     * @private\n     */\n    get: function () {\n      return this.layoutLineHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"empty\", {\n    /**\n     * Gets value that indicates whether any layout text [`empty`].\n     * @private\n     */\n    get: function () {\n      return this.layoutLines == null || this.layoutLines.length === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PdfStringLayoutResult.prototype, \"lineCount\", {\n    /**\n     * Gets `number of` the layout lines.\n     * @private\n     */\n    get: function () {\n      var count = !this.empty ? this.layoutLines.length : 0;\n      return count;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PdfStringLayoutResult;\n}();\n\nexport { PdfStringLayoutResult };\n\nvar LineInfo =\n/** @class */\nfunction () {\n  function LineInfo() {}\n\n  Object.defineProperty(LineInfo.prototype, \"lineType\", {\n    //Properties\n\n    /**\n     * Gets the `type` of the line text.\n     * @private\n     */\n    get: function () {\n      return this.type;\n    },\n    set: function (value) {\n      this.type = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineInfo.prototype, \"text\", {\n    /**\n     * Gets the line `text`.\n     * @private\n     */\n    get: function () {\n      return this.content;\n    },\n    set: function (value) {\n      this.content = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineInfo.prototype, \"width\", {\n    /**\n     * Gets `width` of the line text.\n     * @private\n     */\n    get: function () {\n      return this.lineWidth;\n    },\n    set: function (value) {\n      this.lineWidth = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LineInfo;\n}();\n\nexport { LineInfo };\n/**\n* Break type of the `line`.\n* @private\n*/\n\nexport var LineType;\n\n(function (LineType) {\n  /**\n   * Specifies the type of `None`.\n   * @private\n   */\n  LineType[LineType[\"None\"] = 0] = \"None\";\n  /**\n   * Specifies the type of `NewLineBreak`.\n   * @private\n   */\n\n  LineType[LineType[\"NewLineBreak\"] = 1] = \"NewLineBreak\";\n  /**\n   * Specifies the type of `LayoutBreak`.\n   * @private\n   */\n\n  LineType[LineType[\"LayoutBreak\"] = 2] = \"LayoutBreak\";\n  /**\n   * Specifies the type of `FirstParagraphLine`.\n   * @private\n   */\n\n  LineType[LineType[\"FirstParagraphLine\"] = 4] = \"FirstParagraphLine\";\n  /**\n   * Specifies the type of `LastParagraphLine`.\n   * @private\n   */\n\n  LineType[LineType[\"LastParagraphLine\"] = 8] = \"LastParagraphLine\";\n})(LineType || (LineType = {}));","map":null,"metadata":{},"sourceType":"module"}