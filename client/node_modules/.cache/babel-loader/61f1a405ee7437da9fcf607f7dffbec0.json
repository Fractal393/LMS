{"ast":null,"code":"import { Row } from './../models/row';\nimport { CellType } from '../base/enum';\nimport { isNullOrUndefined, Internationalization, getValue, createElement } from '@syncfusion/ej2-base';\nimport { Cell } from '../models/cell';\nimport { ValueFormatter } from './../services/value-formatter';\nimport { Query, DataManager } from '@syncfusion/ej2-data';\nimport { getForeignData, measureColumnDepth, getUid } from '../base/util';\nimport { Grid } from '../base/grid';\n/**\n * @hidden\n * `ExportHelper` for `PdfExport` & `ExcelExport`\n */\n\nvar ExportHelper =\n/** @class */\nfunction () {\n  function ExportHelper(parent) {\n    this.hideColumnInclude = false;\n    this.foreignKeyData = {};\n    this.parent = parent;\n  }\n\n  ExportHelper.getQuery = function (parent, data) {\n    return data.isRemote() ? data.generateQuery(true).requiresCount().take(parent.pageSettings.totalRecordsCount) : data.generateQuery(true).requiresCount();\n  };\n\n  ExportHelper.prototype.getFData = function (value, column) {\n    var foreignKeyData = getForeignData(column, {}, value, this.foreignKeyData[column.field])[0];\n    return foreignKeyData;\n  };\n\n  ExportHelper.prototype.getGridRowModel = function (columns, dataSource, gObj, startIndex) {\n    if (startIndex === void 0) {\n      startIndex = 0;\n    }\n\n    var rows = [];\n    var length = dataSource.length;\n\n    if (length) {\n      for (var i = 0; i < length; i++, startIndex++) {\n        var options = {\n          isExpand: false\n        };\n        options.data = dataSource[i];\n        options.index = startIndex;\n\n        if (gObj.childGrid) {\n          if (gObj.hierarchyPrintMode === 'All') {\n            options.isExpand = true;\n          } else if (gObj.hierarchyPrintMode === 'Expanded' && this.parent.expandedRows && this.parent.expandedRows[startIndex]) {\n            options.isExpand = gObj.expandedRows[startIndex].isExpand;\n          }\n        }\n\n        var row = new Row(options);\n        row.cells = this.generateCells(columns, gObj);\n        rows.push(row);\n      }\n\n      this.processColumns(rows);\n    }\n\n    return rows;\n  };\n\n  ExportHelper.prototype.generateCells = function (columns, gObj) {\n    var cells = [];\n\n    if (gObj.childGridLevel) {\n      var len = gObj.childGridLevel;\n\n      for (var i = 0; len > i; i++) {\n        cells.push(this.generateCell({}, CellType.Indent));\n      }\n    }\n\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n      var col = columns_1[_i];\n      cells.push(this.generateCell(col, CellType.Data));\n    }\n\n    return cells;\n  };\n\n  ExportHelper.prototype.getColumnData = function (gridObj) {\n    var _this = this;\n\n    var columnPromise = [];\n    var promise;\n    var fColumns = gridObj.getForeignKeyColumns();\n\n    if (fColumns.length) {\n      for (var i = 0; i < fColumns.length; i++) {\n        var colData = 'result' in fColumns[i].dataSource ? new DataManager(fColumns[i].dataSource.result) : fColumns[i].dataSource;\n        columnPromise.push(colData.executeQuery(new Query()));\n      }\n\n      promise = Promise.all(columnPromise).then(function (e) {\n        for (var j = 0; j < fColumns.length; j++) {\n          _this.foreignKeyData[fColumns[j].field] = e[j].result;\n        } // tslint:disable-next-line:no-any\n\n      });\n    }\n\n    return promise;\n  };\n\n  ExportHelper.prototype.getHeaders = function (columns, isHideColumnInclude) {\n    if (isHideColumnInclude) {\n      this.hideColumnInclude = true;\n    } else {\n      this.hideColumnInclude = false;\n    }\n\n    this.colDepth = measureColumnDepth(columns);\n    var rows = [];\n\n    for (var i = 0; i < this.colDepth; i++) {\n      rows[i] = new Row({});\n      rows[i].cells = [];\n    }\n\n    rows = this.processColumns(rows);\n    rows = this.processHeaderCells(rows, columns);\n    return {\n      rows: rows,\n      columns: this.generateActualColumns(columns)\n    };\n  };\n\n  ExportHelper.prototype.getConvertedWidth = function (input) {\n    var value = parseFloat(input);\n    return input.indexOf('%') !== -1 ? this.parent.element.getBoundingClientRect().width * value / 100 : value;\n  };\n\n  ExportHelper.prototype.generateActualColumns = function (columns, actualColumns) {\n    if (actualColumns === void 0) {\n      actualColumns = [];\n    }\n\n    for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n      var column = columns_2[_i];\n\n      if (column.commands) {\n        continue;\n      }\n\n      if (!column.columns) {\n        if (column.visible || this.hideColumnInclude) {\n          actualColumns.push(column);\n        }\n      } else {\n        if (column.visible || this.hideColumnInclude) {\n          var colSpan = this.getCellCount(column, 0);\n\n          if (colSpan !== 0) {\n            this.generateActualColumns(column.columns, actualColumns);\n          }\n        }\n      }\n    }\n\n    return actualColumns;\n  };\n\n  ExportHelper.prototype.processHeaderCells = function (rows, cols) {\n    var columns = cols;\n\n    for (var i = 0; i < columns.length; i++) {\n      if (!columns[i].commands) {\n        rows = this.appendGridCells(columns[i], rows, 0);\n      }\n    }\n\n    return rows;\n  };\n\n  ExportHelper.prototype.appendGridCells = function (cols, gridRows, index) {\n    if (!cols.columns && (cols.visible !== false || this.hideColumnInclude) && !cols.commands) {\n      gridRows[index].cells.push(this.generateCell(cols, CellType.Header, this.colDepth - index, index));\n    } else if (cols.columns) {\n      var colSpan = this.getCellCount(cols, 0);\n\n      if (colSpan) {\n        gridRows[index].cells.push(new Cell({\n          cellType: CellType.StackedHeader,\n          column: cols,\n          colSpan: colSpan\n        }));\n      }\n\n      var isIgnoreFirstCell = void 0;\n\n      for (var i = 0, len = cols.columns.length; i < len; i++) {\n        if (cols.columns[i].visible && !isIgnoreFirstCell) {\n          isIgnoreFirstCell = true;\n        }\n\n        gridRows = this.appendGridCells(cols.columns[i], gridRows, index + 1);\n      }\n    }\n\n    return gridRows;\n  };\n\n  ExportHelper.prototype.generateCell = function (gridColumn, cellType, rowSpan, rowIndex) {\n    var option = {\n      'visible': gridColumn.visible,\n      'isDataCell': cellType === CellType.Data,\n      'column': gridColumn,\n      'cellType': cellType,\n      'rowSpan': rowSpan,\n      'index': rowIndex\n    };\n\n    if (!option.rowSpan || option.rowSpan < 2) {\n      delete option.rowSpan;\n    }\n\n    return new Cell(option);\n  };\n\n  ExportHelper.prototype.processColumns = function (rows) {\n    //TODO: generate dummy column for group, detail, stacked row here; ensureColumns here\n    var gridObj = this.parent;\n    var columnIndexes = [];\n\n    if (gridObj.enableColumnVirtualization) {\n      columnIndexes = gridObj.getColumnIndexesInView();\n    }\n\n    for (var i = 0, len = rows.length; i < len; i++) {\n      if (gridObj.allowGrouping) {\n        for (var j = 0, len_1 = gridObj.groupSettings.columns.length; j < len_1; j++) {\n          if (gridObj.enableColumnVirtualization && columnIndexes.indexOf(j) === -1) {\n            continue;\n          }\n\n          rows[i].cells.splice(0, 0, this.generateCell({}, CellType.HeaderIndent));\n        }\n      }\n    }\n\n    return rows;\n  };\n\n  ExportHelper.prototype.getCellCount = function (column, count) {\n    if (column.columns) {\n      for (var i = 0; i < column.columns.length; i++) {\n        count = this.getCellCount(column.columns[i], count);\n      }\n    } else {\n      if (column.visible || this.hideColumnInclude) {\n        count++;\n      }\n    }\n\n    return count;\n  };\n\n  ExportHelper.prototype.checkAndExport = function (gridPool, globalResolve) {\n    var bool = Object.keys(gridPool).some(function (key) {\n      return !gridPool[key];\n    });\n\n    if (!bool) {\n      globalResolve();\n    }\n  };\n\n  ExportHelper.prototype.failureHandler = function (gridPool, childGridObj, resolve) {\n    var _this = this;\n\n    return function () {\n      gridPool[childGridObj.id] = true;\n\n      _this.checkAndExport(gridPool, resolve);\n    };\n  }; // tslint:disable-next-line:no-any\n\n\n  ExportHelper.prototype.createChildGrid = function (gObj, row, exportType, gridPool) {\n    var childGridObj = new Grid(this.parent.detailRowModule.getGridModel(gObj, row, exportType));\n    gObj.isPrinting = false;\n    var parent = 'parentDetails';\n    childGridObj[parent] = {\n      parentID: gObj.element.id,\n      parentPrimaryKeys: gObj.getPrimaryKeyFieldNames(),\n      parentKeyField: gObj.childGrid.queryString,\n      parentKeyFieldValue: getValue(childGridObj.queryString, row.data),\n      parentRowData: row.data\n    };\n    var exportId = getUid('child-grid');\n    var element = createElement('div', {\n      id: exportId,\n      styles: 'display: none'\n    });\n    document.body.appendChild(element);\n    childGridObj.id = exportId;\n    gridPool[exportId] = false;\n    return {\n      childGrid: childGridObj,\n      element: element\n    };\n  };\n\n  ExportHelper.prototype.getGridExportColumns = function (columns) {\n    var actualGridColumns = [];\n\n    for (var i = 0, gridColumns = columns; i < gridColumns.length; i++) {\n      if (gridColumns[i].type !== 'checkbox') {\n        actualGridColumns.push(gridColumns[i]);\n      }\n    }\n\n    return actualGridColumns;\n  };\n\n  return ExportHelper;\n}();\n\nexport { ExportHelper };\n/**\n * @hidden\n * `ExportValueFormatter` for `PdfExport` & `ExcelExport`\n */\n\nvar ExportValueFormatter =\n/** @class */\nfunction () {\n  function ExportValueFormatter(culture) {\n    this.valueFormatter = new ValueFormatter(culture);\n    this.internationalization = new Internationalization(culture);\n  }\n  /* tslint:disable-next-line:no-any */\n\n\n  ExportValueFormatter.prototype.returnFormattedValue = function (args, customFormat) {\n    if (!isNullOrUndefined(args.value) && args.value) {\n      return this.valueFormatter.getFormatFunction(customFormat)(args.value);\n    } else {\n      return '';\n    }\n  };\n  /* tslint:disable-next-line:no-any */\n\n\n  ExportValueFormatter.prototype.formatCellValue = function (args, isServerBlaz) {\n    if (args.isForeignKey) {\n      args.value = getValue(args.column.foreignKeyValue, getForeignData(args.column, {}, args.value)[0]);\n    }\n\n    if (args.column.type === 'number' && args.column.format !== undefined && args.column.format !== '') {\n      return args.value ? this.internationalization.getNumberFormat({\n        format: args.column.format\n      })(args.value) : '';\n    } else if (args.column.type === 'boolean') {\n      return args.value ? 'true' : 'false';\n      /* tslint:disable-next-line:max-line-length */\n    } else if ((args.column.type === 'date' || args.column.type === 'datetime' || args.column.type === 'time') && args.column.format !== undefined) {\n      if (typeof args.value === 'string') {\n        args.value = new Date(args.value);\n      }\n\n      if (typeof args.column.format === 'string') {\n        var format = void 0;\n        var cFormat = args.column.format;\n\n        if (args.column.type === 'date') {\n          format = isServerBlaz ? {\n            type: 'date',\n            format: cFormat\n          } : {\n            type: 'date',\n            skeleton: cFormat\n          };\n        } else if (args.column.type === 'time') {\n          format = isServerBlaz ? {\n            type: 'time',\n            format: cFormat\n          } : {\n            type: 'time',\n            skeleton: cFormat\n          };\n        } else {\n          format = isServerBlaz ? {\n            type: 'dateTime',\n            format: cFormat\n          } : {\n            type: 'dateTime',\n            skeleton: cFormat\n          };\n        }\n\n        return this.returnFormattedValue(args, format);\n      } else {\n        if (args.column.format instanceof Object && args.column.format.type === undefined) {\n          return args.value.toString();\n        } else {\n          /* tslint:disable-next-line:max-line-length */\n          var customFormat = void 0;\n\n          if (args.column.type === 'date') {\n            /* tslint:disable-next-line:max-line-length */\n            customFormat = {\n              type: args.column.format.type,\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          } else if (args.column.type === 'time') {\n            customFormat = {\n              type: 'time',\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          } else {\n            customFormat = {\n              type: 'dateTime',\n              format: args.column.format.format,\n              skeleton: args.column.format.skeleton\n            };\n          }\n\n          return this.returnFormattedValue(args, customFormat);\n        }\n      }\n    } else {\n      if (!isNullOrUndefined(args.column.type) && !isNullOrUndefined(args.value) || !isNullOrUndefined(args.value)) {\n        return args.value.toString();\n      } else {\n        return '';\n      }\n    }\n  };\n\n  return ExportValueFormatter;\n}();\n\nexport { ExportValueFormatter };","map":null,"metadata":{},"sourceType":"module"}