{"ast":null,"code":"/**\n * PdfTransformationMatrix.ts class for EJ2-PDF\n */\nimport { PointF } from './../drawing/pdf-drawing';\nimport { PdfNumber } from './../primitives/pdf-number';\n/**\n * Class for representing Root `transformation matrix`.\n */\n\nvar PdfTransformationMatrix =\n/** @class */\nfunction () {\n  function PdfTransformationMatrix(value) {\n    /**\n     * Value for `angle converting`.\n     * @default 180.0 / Math.PI\n     * @private\n     */\n    this.radDegFactor = 180.0 / Math.PI;\n\n    if (typeof value === 'undefined') {\n      this.transformationMatrix = new Matrix(1.00, 0.00, 0.00, 1.00, 0.00, 0.00);\n    } else {\n      this.transformationMatrix = new Matrix(1.00, 0.00, 0.00, -1.00, 0.00, 0.00);\n    }\n  }\n\n  Object.defineProperty(PdfTransformationMatrix.prototype, \"matrix\", {\n    // Properties\n\n    /**\n     * Gets or sets the `internal matrix object`.\n     * @private\n     */\n    get: function () {\n      return this.transformationMatrix;\n    },\n    set: function (value) {\n      this.transformationMatrix = value;\n    },\n    enumerable: true,\n    configurable: true\n  }); // Public methods\n\n  /**\n   * `Translates` coordinates by specified coordinates.\n   * @private\n   */\n\n  PdfTransformationMatrix.prototype.translate = function (offsetX, offsetY) {\n    this.transformationMatrix.translate(offsetX, offsetY);\n  };\n  /**\n   * `Scales` coordinates by specified coordinates.\n   * @private\n   */\n\n\n  PdfTransformationMatrix.prototype.scale = function (scaleX, scaleY) {\n    this.transformationMatrix.elements[0] = scaleX;\n    this.transformationMatrix.elements[3] = scaleY;\n  };\n  /**\n   * `Rotates` coordinate system in counterclockwise direction.\n   * @private\n   */\n\n\n  PdfTransformationMatrix.prototype.rotate = function (angle) {\n    //Convert from degree to radian \n    angle = angle * Math.PI / 180; //Rotation \n\n    this.transformationMatrix.elements[0] = Math.cos(angle);\n    this.transformationMatrix.elements[1] = Math.sin(angle);\n    this.transformationMatrix.elements[2] = -Math.sin(angle);\n    this.transformationMatrix.elements[3] = Math.cos(angle);\n  }; // Overrides\n\n  /**\n   * Gets `PDF representation`.\n   * @private\n   */\n\n\n  PdfTransformationMatrix.prototype.toString = function () {\n    var builder = '';\n    var whitespace = ' ';\n\n    for (var i = 0, len = this.transformationMatrix.elements.length; i < len; i++) {\n      var temp = this.matrix.elements[i];\n      builder += PdfNumber.floatToString(this.transformationMatrix.elements[i]);\n      builder += whitespace;\n    }\n\n    return builder;\n  }; // Implementation\n\n  /**\n   * `Multiplies` matrices (changes coordinate system.)\n   * @private\n   */\n\n\n  PdfTransformationMatrix.prototype.multiply = function (matrix) {\n    this.transformationMatrix.multiply(matrix.matrix);\n  };\n  /**\n   * Converts `degrees to radians`.\n   * @private\n   */\n\n\n  PdfTransformationMatrix.degreesToRadians = function (degreesX) {\n    return this.degRadFactor * degreesX;\n  };\n  /**\n   * Converts `radians to degrees`.\n   * @private\n   */\n\n\n  PdfTransformationMatrix.prototype.radiansToDegrees = function (radians) {\n    return this.radDegFactor * radians;\n  };\n  /**\n   * `Clones` this instance of PdfTransformationMatrix.\n   * @private\n   */\n\n\n  PdfTransformationMatrix.prototype.clone = function () {\n    return this;\n  }; // Constants\n\n  /**\n   * Value for `angle converting`.\n   * @default Math.PI / 180.0\n   * @private\n   */\n\n\n  PdfTransformationMatrix.degRadFactor = Math.PI / 180.0;\n  return PdfTransformationMatrix;\n}();\n\nexport { PdfTransformationMatrix };\n\nvar Matrix =\n/** @class */\nfunction () {\n  function Matrix(arg1, arg2, arg3, arg4, arg5, arg6) {\n    if (typeof arg1 === 'undefined') {\n      this.metrixElements = [];\n    } else if (typeof arg1 === 'number') {\n      this.metrixElements = [];\n      this.metrixElements.push(arg1);\n      this.metrixElements.push(arg2);\n      this.metrixElements.push(arg3);\n      this.metrixElements.push(arg4);\n      this.metrixElements.push(arg5);\n      this.metrixElements.push(arg6);\n    } else {\n      this.metrixElements = arg1;\n    }\n  }\n\n  Object.defineProperty(Matrix.prototype, \"elements\", {\n    // Properties\n\n    /**\n     * Gets the `elements`.\n     * @private\n     */\n    get: function () {\n      return this.metrixElements;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"offsetX\", {\n    /**\n     * Gets the off set `X`.\n     * @private\n     */\n    get: function () {\n      return this.metrixElements[4];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"offsetY\", {\n    /**\n     * Gets the off set `Y`.\n     * @private\n     */\n    get: function () {\n      return this.metrixElements[5];\n    },\n    enumerable: true,\n    configurable: true\n  }); // Implementation\n\n  /**\n   * `Translates` coordinates by specified coordinates.\n   * @private\n   */\n\n  Matrix.prototype.translate = function (offsetX, offsetY) {\n    this.metrixElements[4] = offsetX;\n    this.metrixElements[5] = offsetY;\n  };\n  /**\n   * `Translates` the specified offset X.\n   * @private\n   */\n\n\n  Matrix.prototype.transform = function (point) {\n    var x = point.x;\n    var y = point.y;\n    var x2 = x * this.elements[0] + y * this.elements[2] + this.offsetX;\n    var y2 = x * this.elements[1] + y * this.elements[3] + this.offsetY;\n    return new PointF(x2, y2);\n  };\n  /**\n   * `Multiplies matrices` (changes coordinate system.)\n   * @private\n   */\n\n\n  Matrix.prototype.multiply = function (matrix) {\n    var tempMatrix = [];\n    tempMatrix.push(this.elements[0] * matrix.elements[0] + this.elements[1] * matrix.elements[2]);\n    tempMatrix[1] = this.elements[0] * matrix.elements[1] + this.elements[1] * matrix.elements[3];\n    tempMatrix[2] = this.elements[2] * matrix.elements[0] + this.elements[3] * matrix.elements[2];\n    tempMatrix[3] = this.elements[2] * matrix.elements[1] + this.elements[3] * matrix.elements[3];\n    tempMatrix[4] = this.offsetX * matrix.elements[0] + this.offsetY * matrix.elements[2] + matrix.offsetX;\n    tempMatrix[5] = this.offsetX * matrix.elements[1] + this.offsetY * matrix.elements[3] + matrix.offsetY;\n\n    for (var i = 0; i < tempMatrix.length; i++) {\n      this.elements[i] = tempMatrix[i];\n    }\n  }; // IDisposable Members\n\n  /**\n   * `Dispose` this instance of PdfTransformationMatrix class.\n   * @private\n   */\n\n\n  Matrix.prototype.dispose = function () {\n    this.metrixElements = null;\n  }; // ICloneable Members\n\n  /**\n   * `Clones` this instance of PdfTransformationMatrix class.\n   * @private\n   */\n\n\n  Matrix.prototype.clone = function () {\n    var m = new Matrix(this.metrixElements);\n    return m;\n  };\n\n  return Matrix;\n}();\n\nexport { Matrix };","map":null,"metadata":{},"sourceType":"module"}