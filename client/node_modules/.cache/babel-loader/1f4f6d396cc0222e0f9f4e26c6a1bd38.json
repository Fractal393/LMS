{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { setStyleAttribute, addClass, removeClass, ChildProperty, Complex } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined, formatUnit } from '@syncfusion/ej2-base';\nimport { Browser } from '@syncfusion/ej2-base';\nimport { calculatePosition, calculateRelativeBasedPosition } from '../common/position';\nimport { Animation, Property, Event, Component } from '@syncfusion/ej2-base';\nimport { NotifyPropertyChanges } from '@syncfusion/ej2-base';\nimport { EventHandler } from '@syncfusion/ej2-base';\nimport { flip, fit, isCollide } from '../common/collision';\n/**\n * Specifies the offset position values.\n */\n\nvar PositionData =\n/** @class */\nfunction (_super) {\n  __extends(PositionData, _super);\n\n  function PositionData() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('left')], PositionData.prototype, \"X\", void 0);\n\n  __decorate([Property('top')], PositionData.prototype, \"Y\", void 0);\n\n  return PositionData;\n}(ChildProperty);\n\nexport { PositionData }; // don't use space in classNames\n\nvar CLASSNAMES = {\n  ROOT: 'e-popup',\n  RTL: 'e-rtl',\n  OPEN: 'e-popup-open',\n  CLOSE: 'e-popup-close'\n};\n/**\n * Represents the Popup Component\n * ```html\n * <div id=\"popup\" style=\"position:absolute;height:100px;width:100px;\">\n * <div style=\"margin:35px 25px;\">Popup Content</div></div>\n * ```\n * ```typescript\n * <script>\n *   var popupObj = new Popup();\n *   popupObj.appendTo(\"#popup\");\n * </script>\n * ```\n */\n\nvar Popup =\n/** @class */\nfunction (_super) {\n  __extends(Popup, _super);\n\n  function Popup(element, options) {\n    return _super.call(this, options, element) || this;\n  }\n  /**\n   * Called internally if any of the property value changed.\n   * @private\n   */\n\n\n  Popup.prototype.onPropertyChanged = function (newProp, oldProp) {\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'width':\n          setStyleAttribute(this.element, {\n            'width': formatUnit(newProp.width)\n          });\n          break;\n\n        case 'height':\n          setStyleAttribute(this.element, {\n            'height': formatUnit(newProp.height)\n          });\n          break;\n\n        case 'zIndex':\n          setStyleAttribute(this.element, {\n            'zIndex': newProp.zIndex\n          });\n          break;\n\n        case 'enableRtl':\n          this.setEnableRtl();\n          break;\n\n        case 'position':\n        case 'relateTo':\n          this.refreshPosition();\n          break;\n\n        case 'offsetX':\n          var x = newProp.offsetX - oldProp.offsetX;\n          this.element.style.left = (parseInt(this.element.style.left, 10) + x).toString() + 'px';\n          break;\n\n        case 'offsetY':\n          var y = newProp.offsetY - oldProp.offsetY;\n          this.element.style.top = (parseInt(this.element.style.top, 10) + y).toString() + 'px';\n          break;\n\n        case 'content':\n          this.setContent();\n          break;\n\n        case 'actionOnScroll':\n          if (newProp.actionOnScroll !== 'none') {\n            this.wireScrollEvents();\n          } else {\n            this.unwireScrollEvents();\n          }\n\n          break;\n      }\n    }\n  };\n  /**\n   * gets the Component module name.\n   * @private\n   */\n\n\n  Popup.prototype.getModuleName = function () {\n    return 'popup';\n  };\n  /**\n   * To resolve if any collision occurs.\n   */\n\n\n  Popup.prototype.resolveCollision = function () {\n    this.checkCollision();\n  };\n  /**\n   * gets the persisted state properties of the Component.\n   */\n\n\n  Popup.prototype.getPersistData = function () {\n    return this.addOnPersist([]);\n  };\n  /**\n   * To destroy the control.\n   */\n\n\n  Popup.prototype.destroy = function () {\n    this.element.classList.remove(CLASSNAMES.ROOT, CLASSNAMES.RTL, CLASSNAMES.OPEN, CLASSNAMES.CLOSE);\n    this.unwireEvents();\n\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * To Initialize the control rendering\n   * @private\n   */\n\n\n  Popup.prototype.render = function () {\n    this.element.classList.add(CLASSNAMES.ROOT);\n    var styles = {};\n\n    if (this.zIndex !== 1000) {\n      styles.zIndex = this.zIndex;\n    }\n\n    if (this.width !== 'auto') {\n      styles.width = formatUnit(this.width);\n    }\n\n    if (this.height !== 'auto') {\n      styles.height = formatUnit(this.height);\n    }\n\n    setStyleAttribute(this.element, styles);\n    this.fixedParent = false;\n    this.setEnableRtl();\n    this.setContent();\n  };\n\n  Popup.prototype.wireEvents = function () {\n    if (Browser.isDevice) {\n      EventHandler.add(window, 'orientationchange', this.orientationOnChange, this);\n    }\n\n    if (this.actionOnScroll !== 'none') {\n      this.wireScrollEvents();\n    }\n  };\n\n  Popup.prototype.wireScrollEvents = function () {\n    if (this.getRelateToElement()) {\n      for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {\n        var parent_1 = _a[_i];\n        EventHandler.add(parent_1, 'scroll', this.scrollRefresh, this);\n      }\n    }\n  };\n\n  Popup.prototype.unwireEvents = function () {\n    if (Browser.isDevice) {\n      EventHandler.remove(window, 'orientationchange', this.orientationOnChange);\n    }\n\n    if (this.actionOnScroll !== 'none') {\n      this.unwireScrollEvents();\n    }\n  };\n\n  Popup.prototype.unwireScrollEvents = function () {\n    if (this.getRelateToElement()) {\n      for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {\n        var parent_2 = _a[_i];\n        EventHandler.remove(parent_2, 'scroll', this.scrollRefresh);\n      }\n    }\n  };\n\n  Popup.prototype.getRelateToElement = function () {\n    var relateToElement = this.relateTo === '' || isNullOrUndefined(this.relateTo) ? document.body : this.relateTo;\n    this.setProperties({\n      relateTo: relateToElement\n    }, true);\n    return typeof this.relateTo === 'string' ? document.querySelector(this.relateTo) : this.relateTo;\n  };\n\n  Popup.prototype.scrollRefresh = function (e) {\n    if (this.actionOnScroll === 'reposition') {\n      if (!(this.element.offsetParent === e.target || this.element.offsetParent && this.element.offsetParent.tagName === 'BODY' && e.target.parentElement == null)) {\n        this.refreshPosition();\n      }\n    } else if (this.actionOnScroll === 'hide') {\n      this.hide();\n    }\n\n    if (this.actionOnScroll !== 'none') {\n      if (this.getRelateToElement()) {\n        var targetVisible = this.isElementOnViewport(this.getRelateToElement(), e.target);\n\n        if (!targetVisible && !this.targetInvisibleStatus) {\n          this.trigger('targetExitViewport');\n          this.targetInvisibleStatus = true;\n        } else if (targetVisible) {\n          this.targetInvisibleStatus = false;\n        }\n      }\n    }\n  };\n  /**\n   * This method is to get the element visibility on viewport when scroll\n   * the page. This method will returns true even though 1 px of element\n   * part is in visible.\n   */\n\n\n  Popup.prototype.isElementOnViewport = function (relateToElement, scrollElement) {\n    var scrollParents = this.getScrollableParent(relateToElement);\n\n    for (var parent_3 = 0; parent_3 < scrollParents.length; parent_3++) {\n      if (this.isElementVisible(relateToElement, scrollParents[parent_3])) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Popup.prototype.isElementVisible = function (relateToElement, scrollElement) {\n    var rect = this.checkGetBoundingClientRect(relateToElement);\n\n    if (!rect.height || !rect.width) {\n      return false;\n    }\n\n    if (!isNullOrUndefined(this.checkGetBoundingClientRect(scrollElement))) {\n      var parent_4 = scrollElement.getBoundingClientRect();\n      return !(rect.bottom < parent_4.top) && !(rect.bottom > parent_4.bottom) && !(rect.right > parent_4.right) && !(rect.left < parent_4.left);\n    } else {\n      var win = window;\n      var windowView = {\n        top: win.scrollY,\n        left: win.scrollX,\n        right: win.scrollX + win.outerWidth,\n        bottom: win.scrollY + win.outerHeight\n      };\n      var off = calculatePosition(relateToElement);\n      var ele = {\n        top: off.top,\n        left: off.left,\n        right: off.left + rect.width,\n        bottom: off.top + rect.height\n      };\n      var elementView = {\n        top: windowView.bottom - ele.top,\n        left: windowView.right - ele.left,\n        bottom: ele.bottom - windowView.top,\n        right: ele.right - windowView.left\n      };\n      return elementView.top > 0 && elementView.left > 0 && elementView.right > 0 && elementView.bottom > 0;\n    }\n  };\n  /**\n   * Initialize the event handler\n   * @private\n   */\n\n\n  Popup.prototype.preRender = function () {//There is no event handler\n  };\n\n  Popup.prototype.setEnableRtl = function () {\n    this.reposition();\n    this.enableRtl ? this.element.classList.add(CLASSNAMES.RTL) : this.element.classList.remove(CLASSNAMES.RTL);\n  };\n\n  Popup.prototype.setContent = function () {\n    if (!isNullOrUndefined(this.content)) {\n      this.element.innerHTML = '';\n\n      if (typeof this.content === 'string') {\n        this.element.textContent = this.content;\n      } else {\n        this.element.appendChild(this.content);\n      }\n    }\n  };\n\n  Popup.prototype.orientationOnChange = function () {\n    var _this = this;\n\n    setTimeout(function () {\n      _this.refreshPosition();\n    }, 200);\n  };\n  /**\n   * Based on the `relative` element and `offset` values, `Popup` element position will refreshed.\n   */\n\n\n  Popup.prototype.refreshPosition = function (target, collision) {\n    if (!isNullOrUndefined(target)) {\n      this.checkFixedParent(target);\n    }\n\n    this.reposition();\n\n    if (!collision) {\n      this.checkCollision();\n    }\n  };\n\n  Popup.prototype.reposition = function () {\n    var pos;\n    var position;\n    var relateToElement = this.getRelateToElement();\n\n    if (typeof this.position.X === 'number' && typeof this.position.Y === 'number') {\n      pos = {\n        left: this.position.X,\n        top: this.position.Y\n      };\n    } else if (typeof this.position.X === 'string' && typeof this.position.Y === 'number' || typeof this.position.X === 'number' && typeof this.position.Y === 'string') {\n      var display = this.element.style.display;\n      var parentDisplay = void 0;\n      this.element.style.display = 'block';\n\n      if (this.element.classList.contains('e-dlg-modal')) {\n        parentDisplay = this.element.parentElement.style.display;\n        this.element.parentElement.style.display = 'block';\n      }\n\n      position = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);\n\n      if (typeof this.position.X === 'string') {\n        pos = {\n          left: position.left,\n          top: this.position.Y\n        };\n      } else {\n        pos = {\n          left: this.position.X,\n          top: position.top\n        };\n      }\n\n      this.element.style.display = display;\n\n      if (this.element.classList.contains('e-dlg-modal')) {\n        this.element.parentElement.style.display = parentDisplay;\n      }\n    } else if (relateToElement) {\n      var display = this.element.style.display;\n      this.element.style.display = 'block';\n      pos = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);\n      this.element.style.display = display;\n    } else {\n      pos = {\n        left: 0,\n        top: 0\n      };\n    }\n\n    if (!isNullOrUndefined(pos)) {\n      this.element.style.left = pos.left + 'px';\n      this.element.style.top = pos.top + 'px';\n    }\n  };\n\n  Popup.prototype.checkGetBoundingClientRect = function (ele) {\n    var eleRect;\n\n    try {\n      eleRect = ele.getBoundingClientRect();\n      return eleRect;\n    } catch (error) {\n      return null;\n    }\n  };\n\n  Popup.prototype.getAnchorPosition = function (anchorEle, ele, position, offsetX, offsetY) {\n    var eleRect = this.checkGetBoundingClientRect(ele);\n    var anchorRect = this.checkGetBoundingClientRect(anchorEle);\n\n    if (isNullOrUndefined(eleRect) || isNullOrUndefined(anchorRect)) {\n      return null;\n    }\n\n    var anchor = anchorEle;\n    var anchorPos = {\n      left: 0,\n      top: 0\n    };\n\n    if (ele.offsetParent && ele.offsetParent.tagName === 'BODY' && anchorEle.tagName === 'BODY') {\n      anchorPos = calculatePosition(anchorEle);\n    } else {\n      if (ele.classList.contains('e-dlg-modal') && anchor.tagName !== 'BODY') {\n        ele = ele.parentElement;\n      }\n\n      anchorPos = calculateRelativeBasedPosition(anchor, ele);\n    }\n\n    switch (position.X) {\n      default:\n      case 'left':\n        break;\n\n      case 'center':\n        if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {\n          anchorPos.left += window.innerWidth / 2 - eleRect.width / 2;\n        } else if (this.targetType === 'container') {\n          anchorPos.left += anchorRect.width / 2 - eleRect.width / 2;\n        } else {\n          anchorPos.left += anchorRect.width / 2;\n        }\n\n        break;\n\n      case 'right':\n        if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {\n          anchorPos.left += window.innerWidth - eleRect.width;\n        } else if (this.targetType === 'container') {\n          anchorPos.left += anchorRect.width - eleRect.width;\n        } else {\n          anchorPos.left += anchorRect.width;\n        }\n\n        break;\n    }\n\n    switch (position.Y) {\n      default:\n      case 'top':\n        break;\n\n      case 'center':\n        if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {\n          anchorPos.top += window.innerHeight / 2 - eleRect.height / 2;\n        } else if (this.targetType === 'container') {\n          anchorPos.top += anchorRect.height / 2 - eleRect.height / 2;\n        } else {\n          anchorPos.top += anchorRect.height / 2;\n        }\n\n        break;\n\n      case 'bottom':\n        if (ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container') {\n          anchorPos.top += window.innerHeight - eleRect.height;\n        } else if (this.targetType === 'container') {\n          anchorPos.top += anchorRect.height - eleRect.height;\n        } else {\n          anchorPos.top += anchorRect.height;\n        }\n\n        break;\n    }\n\n    anchorPos.left += offsetX;\n    anchorPos.top += offsetY;\n    return anchorPos;\n  };\n\n  Popup.prototype.callFlip = function (param) {\n    var relateToElement = this.getRelateToElement();\n    flip(this.element, relateToElement, this.offsetX, this.offsetY, this.position.X, this.position.Y, this.viewPortElement, param, this.fixedParent);\n  };\n\n  Popup.prototype.callFit = function (param) {\n    if (isCollide(this.element, this.viewPortElement).length !== 0) {\n      if (isNullOrUndefined(this.viewPortElement)) {\n        var data = fit(this.element, this.viewPortElement, param);\n\n        if (param.X) {\n          this.element.style.left = data.left + 'px';\n        }\n\n        if (param.Y) {\n          this.element.style.top = data.top + 'px';\n        }\n      } else {\n        var elementRect = this.checkGetBoundingClientRect(this.element);\n        var viewPortRect = this.checkGetBoundingClientRect(this.viewPortElement);\n\n        if (isNullOrUndefined(elementRect) || isNullOrUndefined(viewPortRect)) {\n          return null;\n        }\n\n        if (param && param.Y === true) {\n          if (viewPortRect.top > elementRect.top) {\n            this.element.style.top = '0px';\n          } else if (viewPortRect.bottom < elementRect.bottom) {\n            this.element.style.top = parseInt(this.element.style.top, 10) - (elementRect.bottom - viewPortRect.bottom) + 'px';\n          }\n        }\n\n        if (param && param.X === true) {\n          if (viewPortRect.right < elementRect.right) {\n            this.element.style.left = parseInt(this.element.style.left, 10) - (elementRect.right - viewPortRect.right) + 'px';\n          } else if (viewPortRect.left > elementRect.left) {\n            this.element.style.left = parseInt(this.element.style.left, 10) + (viewPortRect.left - elementRect.left) + 'px';\n          }\n        }\n      }\n    }\n  };\n\n  Popup.prototype.checkCollision = function () {\n    var horz = this.collision.X;\n    var vert = this.collision.Y;\n\n    if (horz === 'none' && vert === 'none') {\n      return;\n    }\n\n    if (horz === 'flip' && vert === 'flip') {\n      this.callFlip({\n        X: true,\n        Y: true\n      });\n    } else if (horz === 'fit' && vert === 'fit') {\n      this.callFit({\n        X: true,\n        Y: true\n      });\n    } else {\n      if (horz === 'flip') {\n        this.callFlip({\n          X: true,\n          Y: false\n        });\n      } else if (vert === 'flip') {\n        this.callFlip({\n          Y: true,\n          X: false\n        });\n      }\n\n      if (horz === 'fit') {\n        this.callFit({\n          X: true,\n          Y: false\n        });\n      } else if (vert === 'fit') {\n        this.callFit({\n          X: false,\n          Y: true\n        });\n      }\n    }\n  };\n  /**\n   * Shows the popup element from screen.\n   * @param { AnimationModel | Function } collisionOrAnimationOptions? - To pass animation options or collision function.\n   * @param { Function } collision? - To pass the collision function.\n   * @param { HTMLElement } relativeElement? - To calculate the zIndex value dynamically.\n   */\n\n\n  Popup.prototype.show = function (animationOptions, relativeElement) {\n    var _this = this;\n\n    this.wireEvents();\n\n    if (this.zIndex === 1000 || !isNullOrUndefined(relativeElement)) {\n      var zIndexElement = isNullOrUndefined(relativeElement) ? this.element : relativeElement;\n      this.zIndex = getZindexPartial(zIndexElement);\n      setStyleAttribute(this.element, {\n        'zIndex': this.zIndex\n      });\n    }\n\n    animationOptions = !isNullOrUndefined(animationOptions) && typeof animationOptions === 'object' ? animationOptions : this.showAnimation;\n\n    if (this.collision.X !== 'none' || this.collision.Y !== 'none') {\n      removeClass([this.element], CLASSNAMES.CLOSE);\n      addClass([this.element], CLASSNAMES.OPEN);\n      this.checkCollision();\n      removeClass([this.element], CLASSNAMES.OPEN);\n      addClass([this.element], CLASSNAMES.CLOSE);\n    }\n\n    if (!isNullOrUndefined(animationOptions)) {\n      animationOptions.begin = function () {\n        if (!_this.isDestroyed) {\n          removeClass([_this.element], CLASSNAMES.CLOSE);\n          addClass([_this.element], CLASSNAMES.OPEN);\n        }\n      };\n\n      animationOptions.end = function () {\n        if (!_this.isDestroyed) {\n          _this.trigger('open');\n        }\n      };\n\n      new Animation(animationOptions).animate(this.element);\n    } else {\n      removeClass([this.element], CLASSNAMES.CLOSE);\n      addClass([this.element], CLASSNAMES.OPEN);\n      this.trigger('open');\n    }\n  };\n  /**\n   * Hides the popup element from screen.\n   * @param { AnimationModel } animationOptions? - To give the animation options.\n   */\n\n\n  Popup.prototype.hide = function (animationOptions) {\n    var _this = this;\n\n    animationOptions = !isNullOrUndefined(animationOptions) && typeof animationOptions === 'object' ? animationOptions : this.hideAnimation;\n\n    if (!isNullOrUndefined(animationOptions)) {\n      animationOptions.end = function () {\n        if (!_this.isDestroyed) {\n          removeClass([_this.element], CLASSNAMES.OPEN);\n          addClass([_this.element], CLASSNAMES.CLOSE);\n\n          _this.trigger('close');\n        }\n      };\n\n      new Animation(animationOptions).animate(this.element);\n    } else {\n      removeClass([this.element], CLASSNAMES.OPEN);\n      addClass([this.element], CLASSNAMES.CLOSE);\n      this.trigger('close');\n    }\n\n    this.unwireEvents();\n  };\n  /**\n   * Gets scrollable parent elements for the given element.\n   * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.\n   */\n\n\n  Popup.prototype.getScrollableParent = function (element) {\n    this.checkFixedParent(element);\n    return getScrollableParent(element, this.fixedParent);\n  };\n\n  Popup.prototype.checkFixedParent = function (element) {\n    var parent = element.parentElement;\n\n    while (parent && parent.tagName !== 'HTML') {\n      var parentStyle = getComputedStyle(parent);\n\n      if (parentStyle.position === 'fixed' && this.element.offsetParent && this.element.offsetParent.tagName === 'BODY') {\n        this.element.style.position = 'fixed';\n        this.fixedParent = true;\n      }\n\n      parent = parent.parentElement;\n\n      if (isNullOrUndefined(this.element.offsetParent) && parentStyle.position === 'fixed' && this.element.style.position === 'fixed') {\n        this.fixedParent = true;\n      }\n    }\n  };\n\n  __decorate([Property('auto')], Popup.prototype, \"height\", void 0);\n\n  __decorate([Property('auto')], Popup.prototype, \"width\", void 0);\n\n  __decorate([Property(null)], Popup.prototype, \"content\", void 0);\n\n  __decorate([Property('container')], Popup.prototype, \"targetType\", void 0);\n\n  __decorate([Property(null)], Popup.prototype, \"viewPortElement\", void 0);\n\n  __decorate([Property({\n    X: 'none',\n    Y: 'none'\n  })], Popup.prototype, \"collision\", void 0);\n\n  __decorate([Property('')], Popup.prototype, \"relateTo\", void 0);\n\n  __decorate([Complex({}, PositionData)], Popup.prototype, \"position\", void 0);\n\n  __decorate([Property(0)], Popup.prototype, \"offsetX\", void 0);\n\n  __decorate([Property(0)], Popup.prototype, \"offsetY\", void 0);\n\n  __decorate([Property(1000)], Popup.prototype, \"zIndex\", void 0);\n\n  __decorate([Property(false)], Popup.prototype, \"enableRtl\", void 0);\n\n  __decorate([Property('reposition')], Popup.prototype, \"actionOnScroll\", void 0);\n\n  __decorate([Property(null)], Popup.prototype, \"showAnimation\", void 0);\n\n  __decorate([Property(null)], Popup.prototype, \"hideAnimation\", void 0);\n\n  __decorate([Event()], Popup.prototype, \"open\", void 0);\n\n  __decorate([Event()], Popup.prototype, \"close\", void 0);\n\n  __decorate([Event()], Popup.prototype, \"targetExitViewport\", void 0);\n\n  Popup = __decorate([NotifyPropertyChanges], Popup);\n  return Popup;\n}(Component);\n\nexport { Popup };\n/**\n * Gets scrollable parent elements for the given element.\n * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.\n * @private\n */\n\nexport function getScrollableParent(element, fixedParent) {\n  var eleStyle = getComputedStyle(element);\n  var scrollParents = [];\n  var overflowRegex = /(auto|scroll)/;\n  var parent = element.parentElement;\n\n  while (parent && parent.tagName !== 'HTML') {\n    var parentStyle = getComputedStyle(parent);\n\n    if (!(eleStyle.position === 'absolute' && parentStyle.position === 'static') && overflowRegex.test(parentStyle.overflow + parentStyle.overflowY + parentStyle.overflowX)) {\n      scrollParents.push(parent);\n    }\n\n    parent = parent.parentElement;\n  }\n\n  if (!fixedParent) {\n    scrollParents.push(document);\n  }\n\n  return scrollParents;\n}\n/**\n * Gets the maximum z-index of the given element.\n * @param { HTMLElement } element - Specify the element to get the maximum z-index of it.\n * @private\n */\n\nexport function getZindexPartial(element) {\n  // upto body traversal\n  var parent = element.parentElement;\n  var parentZindex = [];\n\n  while (parent) {\n    if (parent.tagName !== 'BODY') {\n      var index = document.defaultView.getComputedStyle(parent, null).getPropertyValue('z-index');\n      var position = document.defaultView.getComputedStyle(parent, null).getPropertyValue('position');\n\n      if (index !== 'auto' && position !== 'static') {\n        parentZindex.push(index);\n      }\n\n      parent = parent.parentElement;\n    } else {\n      break;\n    }\n  } //Body direct children element traversal\n\n\n  var childrenZindex = [];\n\n  for (var i = 0; i < document.body.children.length; i++) {\n    if (!element.isEqualNode(document.body.children[i])) {\n      var index = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('z-index');\n      var position = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('position');\n\n      if (index !== 'auto' && position !== 'static') {\n        childrenZindex.push(index);\n      }\n    }\n  }\n\n  childrenZindex.push('999');\n  var siblingsZindex = [];\n\n  if (!isNullOrUndefined(element.parentElement) && element.parentElement.tagName !== 'BODY') {\n    var childNodes = [].slice.call(element.parentElement.children);\n\n    for (var i = 0; i < childNodes.length; i++) {\n      var index = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('z-index');\n      var position = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('position');\n\n      if (index !== 'auto' && position !== 'static') {\n        siblingsZindex.push(index);\n      }\n    }\n  }\n\n  var finalValue = parentZindex.concat(childrenZindex, siblingsZindex);\n  var currentZindexValue = Math.max.apply(Math, finalValue) + 1; // Checking the max-zindex value\n\n  return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;\n}\n/**\n * Gets the maximum z-index of the page.\n * @param { HTMLElement } tagName - Specify the tagName to get the maximum z-index of it.\n * @private\n */\n\nexport function getMaxZindex(tagName) {\n  if (tagName === void 0) {\n    tagName = ['*'];\n  }\n\n  var maxZindex = [];\n\n  for (var i = 0; i < tagName.length; i++) {\n    var elements = document.getElementsByTagName(tagName[i]);\n\n    for (var i_1 = 0; i_1 < elements.length; i_1++) {\n      var index = document.defaultView.getComputedStyle(elements[i_1], null).getPropertyValue('z-index');\n      var position = document.defaultView.getComputedStyle(elements[i_1], null).getPropertyValue('position');\n\n      if (index !== 'auto' && position !== 'static') {\n        maxZindex.push(index);\n      }\n    }\n  }\n\n  var currentZindexValue = Math.max.apply(Math, maxZindex) + 1;\n  return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;\n}","map":null,"metadata":{},"sourceType":"module"}