{"ast":null,"code":"/**\r\n * DevExtreme (animation/fx.js)\r\n * Version: 20.1.6\r\n * Build date: Fri Jul 17 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar $ = require(\"../core/renderer\");\n\nvar window = require(\"../core/utils/window\").getWindow();\n\nvar eventsEngine = require(\"../events/core/events_engine\");\n\nvar errors = require(\"../core/errors\");\n\nvar getPublicElement = require(\"../core/utils/dom\").getPublicElement;\n\nvar extend = require(\"../core/utils/extend\").extend;\n\nvar typeUtils = require(\"../core/utils/type\");\n\nvar iteratorUtils = require(\"../core/utils/iterator\");\n\nvar translator = require(\"./translator\");\n\nvar easing = require(\"./easing\");\n\nvar animationFrame = require(\"./frame\");\n\nvar support = require(\"../core/utils/support\");\n\nvar positionUtils = require(\"./position\");\n\nvar removeEvent = require(\"../core/remove_event\");\n\nvar eventUtils = require(\"../events/utils\");\n\nvar deferredUtils = require(\"../core/utils/deferred\");\n\nvar when = deferredUtils.when;\nvar Deferred = deferredUtils.Deferred;\nvar removeEventName = eventUtils.addNamespace(removeEvent, \"dxFX\");\nvar isFunction = typeUtils.isFunction;\nvar isPlainObject = typeUtils.isPlainObject;\n\nvar noop = require(\"../core/utils/common\").noop;\n\nvar RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;\nvar ANIM_DATA_KEY = \"dxAnimData\";\nvar ANIM_QUEUE_KEY = \"dxAnimQueue\";\nvar TRANSFORM_PROP = \"transform\";\nvar TransitionAnimationStrategy = {\n  initAnimation: function ($element, config) {\n    $element.css({\n      transitionProperty: \"none\"\n    });\n\n    if (\"string\" === typeof config.from) {\n      $element.addClass(config.from);\n    } else {\n      setProps($element, config.from);\n    }\n\n    var that = this;\n    var deferred = new Deferred();\n    var cleanupWhen = config.cleanupWhen;\n    config.transitionAnimation = {\n      deferred: deferred,\n      finish: function () {\n        that._finishTransition($element);\n\n        if (cleanupWhen) {\n          when(deferred, cleanupWhen).always(function () {\n            that._cleanup($element, config);\n          });\n        } else {\n          that._cleanup($element, config);\n        }\n\n        deferred.resolveWith($element, [config, $element]);\n      }\n    };\n\n    this._completeAnimationCallback($element, config).done(function () {\n      config.transitionAnimation.finish();\n    }).fail(function () {\n      deferred.rejectWith($element, [config, $element]);\n    });\n\n    if (!config.duration) {\n      config.transitionAnimation.finish();\n    }\n\n    $element.css(\"transform\");\n  },\n  animate: function ($element, config) {\n    this._startAnimation($element, config);\n\n    return config.transitionAnimation.deferred.promise();\n  },\n  _completeAnimationCallback: function ($element, config) {\n    var that = this;\n    var startTime = Date.now() + config.delay;\n    var deferred = new Deferred();\n    var transitionEndFired = new Deferred();\n    var simulatedTransitionEndFired = new Deferred();\n    var simulatedEndEventTimer;\n    var transitionEndEventName = support.transitionEndEventName() + \".dxFX\";\n\n    config.transitionAnimation.cleanup = function () {\n      clearTimeout(simulatedEndEventTimer);\n      clearTimeout(waitForJSCompleteTimer);\n      eventsEngine.off($element, transitionEndEventName);\n      eventsEngine.off($element, removeEventName);\n    };\n\n    eventsEngine.one($element, transitionEndEventName, function () {\n      if (Date.now() - startTime >= config.duration) {\n        transitionEndFired.reject();\n      }\n    });\n    eventsEngine.off($element, removeEventName);\n    eventsEngine.on($element, removeEventName, function () {\n      that.stop($element, config);\n      deferred.reject();\n    });\n    var waitForJSCompleteTimer = setTimeout(function () {\n      simulatedEndEventTimer = setTimeout(function () {\n        simulatedTransitionEndFired.reject();\n      }, config.duration + config.delay + fx._simulatedTransitionEndDelay);\n      when(transitionEndFired, simulatedTransitionEndFired).fail(function () {\n        deferred.resolve();\n      }.bind(this));\n    });\n    return deferred.promise();\n  },\n  _startAnimation: function ($element, config) {\n    $element.css({\n      transitionProperty: \"all\",\n      transitionDelay: config.delay + \"ms\",\n      transitionDuration: config.duration + \"ms\",\n      transitionTimingFunction: config.easing\n    });\n\n    if (\"string\" === typeof config.to) {\n      $element[0].className += \" \" + config.to;\n    } else {\n      if (config.to) {\n        setProps($element, config.to);\n      }\n    }\n  },\n  _finishTransition: function ($element) {\n    $element.css(\"transition\", \"none\");\n  },\n  _cleanup: function ($element, config) {\n    config.transitionAnimation.cleanup();\n\n    if (\"string\" === typeof config.from) {\n      $element.removeClass(config.from);\n      $element.removeClass(config.to);\n    }\n  },\n  stop: function ($element, config, jumpToEnd) {\n    if (!config) {\n      return;\n    }\n\n    if (jumpToEnd) {\n      config.transitionAnimation.finish();\n    } else {\n      if (isPlainObject(config.to)) {\n        iteratorUtils.each(config.to, function (key) {\n          $element.css(key, $element.css(key));\n        });\n      }\n\n      this._finishTransition($element);\n\n      this._cleanup($element, config);\n    }\n  }\n};\nvar FrameAnimationStrategy = {\n  initAnimation: function ($element, config) {\n    setProps($element, config.from);\n  },\n  animate: function ($element, config) {\n    var deferred = new Deferred();\n    var that = this;\n\n    if (!config) {\n      return deferred.reject().promise();\n    }\n\n    iteratorUtils.each(config.to, function (prop) {\n      if (void 0 === config.from[prop]) {\n        config.from[prop] = that._normalizeValue($element.css(prop));\n      }\n    });\n\n    if (config.to[TRANSFORM_PROP]) {\n      config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);\n      config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP]);\n    }\n\n    config.frameAnimation = {\n      to: config.to,\n      from: config.from,\n      currentValue: config.from,\n      easing: easing.convertTransitionTimingFuncToEasing(config.easing),\n      duration: config.duration,\n      startTime: new Date().valueOf(),\n      finish: function () {\n        this.currentValue = this.to;\n        this.draw();\n        animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId);\n        deferred.resolve();\n      },\n      draw: function () {\n        if (config.draw) {\n          config.draw(this.currentValue);\n          return;\n        }\n\n        var currentValue = extend({}, this.currentValue);\n\n        if (currentValue[TRANSFORM_PROP]) {\n          currentValue[TRANSFORM_PROP] = iteratorUtils.map(currentValue[TRANSFORM_PROP], function (value, prop) {\n            if (\"translate\" === prop) {\n              return translator.getTranslateCss(value);\n            } else {\n              if (\"scale\" === prop) {\n                return \"scale(\" + value + \")\";\n              } else {\n                if (\"rotate\" === prop.substr(0, prop.length - 1)) {\n                  return prop + \"(\" + value + \"deg)\";\n                }\n              }\n            }\n          }).join(\" \");\n        }\n\n        $element.css(currentValue);\n      }\n    };\n\n    if (config.delay) {\n      config.frameAnimation.startTime += config.delay;\n      config.frameAnimation.delayTimeout = setTimeout(function () {\n        that._startAnimation($element, config);\n      }, config.delay);\n    } else {\n      that._startAnimation($element, config);\n    }\n\n    return deferred.promise();\n  },\n  _startAnimation: function ($element, config) {\n    eventsEngine.off($element, removeEventName);\n    eventsEngine.on($element, removeEventName, function () {\n      if (config.frameAnimation) {\n        animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId);\n      }\n    });\n\n    this._animationStep($element, config);\n  },\n  _parseTransform: function (transformString) {\n    var result = {};\n    iteratorUtils.each(transformString.match(/(\\w|\\d)+\\([^)]*\\)\\s*/g), function (i, part) {\n      var translateData = translator.parseTranslate(part);\n      var scaleData = part.match(/scale\\((.+?)\\)/);\n      var rotateData = part.match(/(rotate.)\\((.+)deg\\)/);\n\n      if (translateData) {\n        result.translate = translateData;\n      }\n\n      if (scaleData && scaleData[1]) {\n        result.scale = parseFloat(scaleData[1]);\n      }\n\n      if (rotateData && rotateData[1]) {\n        result[rotateData[1]] = parseFloat(rotateData[2]);\n      }\n    });\n    return result;\n  },\n  stop: function ($element, config, jumpToEnd) {\n    var frameAnimation = config && config.frameAnimation;\n\n    if (!frameAnimation) {\n      return;\n    }\n\n    animationFrame.cancelAnimationFrame(frameAnimation.animationFrameId);\n    clearTimeout(frameAnimation.delayTimeout);\n\n    if (jumpToEnd) {\n      frameAnimation.finish();\n    }\n\n    delete config.frameAnimation;\n  },\n  _animationStep: function ($element, config) {\n    var frameAnimation = config && config.frameAnimation;\n\n    if (!frameAnimation) {\n      return;\n    }\n\n    var now = new Date().valueOf();\n\n    if (now >= frameAnimation.startTime + frameAnimation.duration) {\n      frameAnimation.finish();\n      return;\n    }\n\n    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);\n    frameAnimation.draw();\n    var that = this;\n    frameAnimation.animationFrameId = animationFrame.requestAnimationFrame(function () {\n      that._animationStep($element, config);\n    });\n  },\n  _calcStepValue: function (frameAnimation, currentDuration) {\n    var calcValueRecursively = function calcValueRecursively(from, to) {\n      var result = Array.isArray(to) ? [] : {};\n\n      var calcEasedValue = function (propName) {\n        var x = currentDuration / frameAnimation.duration;\n        var t = currentDuration;\n        var b = 1 * from[propName];\n        var c = to[propName] - from[propName];\n        var d = frameAnimation.duration;\n        return easing.getEasing(frameAnimation.easing)(x, t, b, c, d);\n      };\n\n      iteratorUtils.each(to, function (propName, endPropValue) {\n        if (\"string\" === typeof endPropValue && false === parseFloat(endPropValue, 10)) {\n          return true;\n        }\n\n        result[propName] = \"object\" === _typeof(endPropValue) ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName);\n      });\n      return result;\n    };\n\n    return calcValueRecursively(frameAnimation.from, frameAnimation.to);\n  },\n  _normalizeValue: function (value) {\n    var numericValue = parseFloat(value, 10);\n\n    if (false === numericValue) {\n      return value;\n    }\n\n    return numericValue;\n  }\n};\nvar FallbackToNoAnimationStrategy = {\n  initAnimation: function () {},\n  animate: function () {\n    return new Deferred().resolve().promise();\n  },\n  stop: noop,\n  isSynchronous: true\n};\n\nvar getAnimationStrategy = function (config) {\n  config = config || {};\n  var animationStrategies = {\n    transition: support.transition() ? TransitionAnimationStrategy : FrameAnimationStrategy,\n    frame: FrameAnimationStrategy,\n    noAnimation: FallbackToNoAnimationStrategy\n  };\n  var strategy = config.strategy || \"transition\";\n\n  if (\"css\" === config.type && !support.transition()) {\n    strategy = \"noAnimation\";\n  }\n\n  return animationStrategies[strategy];\n};\n\nvar baseConfigValidator = function (config, animationType, validate, typeMessage) {\n  iteratorUtils.each([\"from\", \"to\"], function () {\n    if (!validate(config[this])) {\n      throw errors.Error(\"E0010\", animationType, this, typeMessage);\n    }\n  });\n};\n\nvar isObjectConfigValidator = function (config, animationType) {\n  return baseConfigValidator(config, animationType, function (target) {\n    return isPlainObject(target);\n  }, \"a plain object\");\n};\n\nvar isStringConfigValidator = function (config, animationType) {\n  return baseConfigValidator(config, animationType, function (target) {\n    return \"string\" === typeof target;\n  }, \"a string\");\n};\n\nvar CustomAnimationConfigurator = {\n  setup: function () {}\n};\nvar CssAnimationConfigurator = {\n  validateConfig: function (config) {\n    isStringConfigValidator(config, \"css\");\n  },\n  setup: function () {}\n};\nvar positionAliases = {\n  top: {\n    my: \"bottom center\",\n    at: \"top center\"\n  },\n  bottom: {\n    my: \"top center\",\n    at: \"bottom center\"\n  },\n  right: {\n    my: \"left center\",\n    at: \"right center\"\n  },\n  left: {\n    my: \"right center\",\n    at: \"left center\"\n  }\n};\nvar SlideAnimationConfigurator = {\n  validateConfig: function (config) {\n    isObjectConfigValidator(config, \"slide\");\n  },\n  setup: function ($element, config) {\n    var location = translator.locate($element);\n\n    if (\"slide\" !== config.type) {\n      var positioningConfig = \"slideIn\" === config.type ? config.from : config.to;\n      positioningConfig.position = extend({\n        of: window\n      }, positionAliases[config.direction]);\n      setupPosition($element, positioningConfig);\n    }\n\n    this._setUpConfig(location, config.from);\n\n    this._setUpConfig(location, config.to);\n\n    translator.clearCache($element);\n  },\n  _setUpConfig: function (location, config) {\n    config.left = \"left\" in config ? config.left : \"+=0\";\n    config.top = \"top\" in config ? config.top : \"+=0\";\n\n    this._initNewPosition(location, config);\n  },\n  _initNewPosition: function (location, config) {\n    var position = {\n      left: config.left,\n      top: config.top\n    };\n    delete config.left;\n    delete config.top;\n\n    var relativeValue = this._getRelativeValue(position.left);\n\n    if (void 0 !== relativeValue) {\n      position.left = relativeValue + location.left;\n    } else {\n      config.left = 0;\n    }\n\n    relativeValue = this._getRelativeValue(position.top);\n\n    if (void 0 !== relativeValue) {\n      position.top = relativeValue + location.top;\n    } else {\n      config.top = 0;\n    }\n\n    config[TRANSFORM_PROP] = translator.getTranslateCss({\n      x: position.left,\n      y: position.top\n    });\n  },\n  _getRelativeValue: function (value) {\n    var relativeValue;\n\n    if (\"string\" === typeof value && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {\n      return parseInt(relativeValue[1] + \"1\") * relativeValue[2];\n    }\n  }\n};\nvar FadeAnimationConfigurator = {\n  setup: function ($element, config) {\n    var from = config.from;\n    var fromOpacity = isPlainObject(from) ? config.skipElementInitialStyles ? 0 : $element.css(\"opacity\") : String(from);\n    var toOpacity;\n\n    switch (config.type) {\n      case \"fadeIn\":\n        toOpacity = 1;\n        break;\n\n      case \"fadeOut\":\n        toOpacity = 0;\n        break;\n\n      default:\n        toOpacity = String(config.to);\n    }\n\n    config.from = {\n      visibility: \"visible\",\n      opacity: fromOpacity\n    };\n    config.to = {\n      opacity: toOpacity\n    };\n  }\n};\nvar PopAnimationConfigurator = {\n  validateConfig: function (config) {\n    isObjectConfigValidator(config, \"pop\");\n  },\n  setup: function ($element, config) {\n    var from = config.from;\n    var to = config.to;\n    var fromOpacity = \"opacity\" in from ? from.opacity : $element.css(\"opacity\");\n    var toOpacity = \"opacity\" in to ? to.opacity : 1;\n    var fromScale = \"scale\" in from ? from.scale : 0;\n    var toScale = \"scale\" in to ? to.scale : 1;\n    config.from = {\n      opacity: fromOpacity\n    };\n    var translate = translator.getTranslate($element);\n    config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);\n    config.to = {\n      opacity: toOpacity\n    };\n    config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale);\n  },\n  _getCssTransform: function (translate, scale) {\n    return translator.getTranslateCss(translate) + \"scale(\" + scale + \")\";\n  }\n};\nvar animationConfigurators = {\n  custom: CustomAnimationConfigurator,\n  slide: SlideAnimationConfigurator,\n  slideIn: SlideAnimationConfigurator,\n  slideOut: SlideAnimationConfigurator,\n  fade: FadeAnimationConfigurator,\n  fadeIn: FadeAnimationConfigurator,\n  fadeOut: FadeAnimationConfigurator,\n  pop: PopAnimationConfigurator,\n  css: CssAnimationConfigurator\n};\n\nvar getAnimationConfigurator = function (config) {\n  var result = animationConfigurators[config.type];\n\n  if (!result) {\n    throw errors.Error(\"E0011\", config.type);\n  }\n\n  return result;\n};\n\nvar defaultJSConfig = {\n  type: \"custom\",\n  from: {},\n  to: {},\n  duration: 400,\n  start: noop,\n  complete: noop,\n  easing: \"ease\",\n  delay: 0\n};\nvar defaultCssConfig = {\n  duration: 400,\n  easing: \"ease\",\n  delay: 0\n};\n\nfunction setupAnimationOnElement() {\n  var animation = this;\n  var $element = animation.element;\n  var config = animation.config;\n  setupPosition($element, config.from);\n  setupPosition($element, config.to);\n  animation.configurator.setup($element, config);\n  $element.data(ANIM_DATA_KEY, animation);\n\n  if (fx.off) {\n    config.duration = 0;\n    config.delay = 0;\n  }\n\n  animation.strategy.initAnimation($element, config);\n\n  if (config.start) {\n    var element = getPublicElement($element);\n    config.start.apply(this, [element, config]);\n  }\n}\n\nvar onElementAnimationComplete = function (animation) {\n  var $element = animation.element;\n  var config = animation.config;\n  $element.removeData(ANIM_DATA_KEY);\n\n  if (config.complete) {\n    var element = getPublicElement($element);\n    config.complete.apply(this, [element, config]);\n  }\n\n  animation.deferred.resolveWith(this, [$element, config]);\n};\n\nvar startAnimationOnElement = function () {\n  var animation = this;\n  var $element = animation.element;\n  var config = animation.config;\n  animation.isStarted = true;\n  return animation.strategy.animate($element, config).done(function () {\n    onElementAnimationComplete(animation);\n  }).fail(function () {\n    animation.deferred.rejectWith(this, [$element, config]);\n  });\n};\n\nvar stopAnimationOnElement = function (jumpToEnd) {\n  var animation = this;\n  var $element = animation.element;\n  var config = animation.config;\n  clearTimeout(animation.startTimeout);\n\n  if (!animation.isStarted) {\n    animation.start();\n  }\n\n  animation.strategy.stop($element, config, jumpToEnd);\n};\n\nvar scopedRemoveEvent = eventUtils.addNamespace(removeEvent, \"dxFXStartAnimation\");\n\nvar subscribeToRemoveEvent = function (animation) {\n  eventsEngine.off(animation.element, scopedRemoveEvent);\n  eventsEngine.on(animation.element, scopedRemoveEvent, function () {\n    fx.stop(animation.element);\n  });\n  animation.deferred.always(function () {\n    eventsEngine.off(animation.element, scopedRemoveEvent);\n  });\n};\n\nvar createAnimation = function (element, initialConfig) {\n  var defaultConfig = \"css\" === initialConfig.type ? defaultCssConfig : defaultJSConfig;\n  var config = extend(true, {}, defaultConfig, initialConfig);\n  var configurator = getAnimationConfigurator(config);\n  var strategy = getAnimationStrategy(config);\n  var animation = {\n    element: $(element),\n    config: config,\n    configurator: configurator,\n    strategy: strategy,\n    isSynchronous: strategy.isSynchronous,\n    setup: setupAnimationOnElement,\n    start: startAnimationOnElement,\n    stop: stopAnimationOnElement,\n    deferred: new Deferred()\n  };\n\n  if (isFunction(configurator.validateConfig)) {\n    configurator.validateConfig(config);\n  }\n\n  subscribeToRemoveEvent(animation);\n  return animation;\n};\n\nvar animate = function (element, config) {\n  var $element = $(element);\n\n  if (!$element.length) {\n    return new Deferred().resolve().promise();\n  }\n\n  var animation = createAnimation($element, config);\n  pushInAnimationQueue($element, animation);\n  return animation.deferred.promise();\n};\n\nfunction pushInAnimationQueue($element, animation) {\n  var queueData = getAnimQueueData($element);\n  writeAnimQueueData($element, queueData);\n  queueData.push(animation);\n\n  if (!isAnimating($element)) {\n    shiftFromAnimationQueue($element, queueData);\n  }\n}\n\nfunction getAnimQueueData($element) {\n  return $element.data(ANIM_QUEUE_KEY) || [];\n}\n\nfunction writeAnimQueueData($element, queueData) {\n  $element.data(ANIM_QUEUE_KEY, queueData);\n}\n\nvar destroyAnimQueueData = function ($element) {\n  $element.removeData(ANIM_QUEUE_KEY);\n};\n\nfunction isAnimating($element) {\n  return !!$element.data(ANIM_DATA_KEY);\n}\n\nfunction shiftFromAnimationQueue($element, queueData) {\n  queueData = getAnimQueueData($element);\n\n  if (!queueData.length) {\n    return;\n  }\n\n  var animation = queueData.shift();\n\n  if (0 === queueData.length) {\n    destroyAnimQueueData($element);\n  }\n\n  executeAnimation(animation).done(function () {\n    if (!isAnimating($element)) {\n      shiftFromAnimationQueue($element);\n    }\n  });\n}\n\nfunction executeAnimation(animation) {\n  animation.setup();\n\n  if (fx.off || animation.isSynchronous) {\n    animation.start();\n  } else {\n    animation.startTimeout = setTimeout(function () {\n      animation.start();\n    });\n  }\n\n  return animation.deferred.promise();\n}\n\nfunction setupPosition($element, config) {\n  if (!config || !config.position) {\n    return;\n  }\n\n  var win = $(window);\n  var left = 0;\n  var top = 0;\n  var position = positionUtils.calculate($element, config.position);\n  var offset = $element.offset();\n  var currentPosition = $element.position();\n\n  if (currentPosition.top > offset.top) {\n    top = win.scrollTop();\n  }\n\n  if (currentPosition.left > offset.left) {\n    left = win.scrollLeft();\n  }\n\n  extend(config, {\n    left: position.h.location - offset.left + currentPosition.left - left,\n    top: position.v.location - offset.top + currentPosition.top - top\n  });\n  delete config.position;\n}\n\nfunction setProps($element, props) {\n  iteratorUtils.each(props, function (key, value) {\n    try {\n      $element.css(key, typeUtils.isFunction(value) ? value() : value);\n    } catch (e) {}\n  });\n}\n\nvar stop = function (element, jumpToEnd) {\n  var $element = $(element);\n  var queueData = getAnimQueueData($element);\n  iteratorUtils.each(queueData, function (_, animation) {\n    animation.config.delay = 0;\n    animation.config.duration = 0;\n    animation.isSynchronous = true;\n  });\n\n  if (!isAnimating($element)) {\n    shiftFromAnimationQueue($element, queueData);\n  }\n\n  var animation = $element.data(ANIM_DATA_KEY);\n\n  if (animation) {\n    animation.stop(jumpToEnd);\n  }\n\n  $element.removeData(ANIM_DATA_KEY);\n  destroyAnimQueueData($element);\n};\n\nvar fx = {\n  off: false,\n  animationTypes: animationConfigurators,\n  animate: animate,\n  createAnimation: createAnimation,\n  isAnimating: isAnimating,\n  stop: stop,\n  _simulatedTransitionEndDelay: 100\n};\nmodule.exports = fx;\nmodule.exports.default = module.exports;","map":null,"metadata":{},"sourceType":"script"}