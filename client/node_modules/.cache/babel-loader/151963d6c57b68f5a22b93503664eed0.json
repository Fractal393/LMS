{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Component, Property, ChildProperty, Event, append, compile, isBlazor } from '@syncfusion/ej2-base';\nimport { EventHandler, Touch, Browser, Animation as PopupAnimation } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined, getUniqueID, formatUnit } from '@syncfusion/ej2-base';\nimport { attributes, closest, removeClass, addClass, remove, updateBlazorTemplate, resetBlazorTemplate } from '@syncfusion/ej2-base';\nimport { NotifyPropertyChanges, Complex, SanitizeHtmlHelper } from '@syncfusion/ej2-base';\nimport { Popup } from '../popup/popup';\nimport { calculatePosition } from '../common/position';\nimport { isCollide, fit } from '../common/collision';\nvar TOUCHEND_HIDE_DELAY = 1500;\nvar TAPHOLD_THRESHOLD = 500;\nvar SHOW_POINTER_TIP_GAP = 0;\nvar HIDE_POINTER_TIP_GAP = 8;\nvar MOUSE_TRAIL_GAP = 2;\nvar POINTER_ADJUST = 2;\nvar ROOT = 'e-tooltip';\nvar RTL = 'e-rtl';\nvar DEVICE = 'e-bigger';\nvar ICON = 'e-icons';\nvar CLOSE = 'e-tooltip-close';\nvar TOOLTIP_WRAP = 'e-tooltip-wrap';\nvar CONTENT = 'e-tip-content';\nvar ARROW_TIP = 'e-arrow-tip';\nvar ARROW_TIP_OUTER = 'e-arrow-tip-outer';\nvar ARROW_TIP_INNER = 'e-arrow-tip-inner';\nvar TIP_BOTTOM = 'e-tip-bottom';\nvar TIP_TOP = 'e-tip-top';\nvar TIP_LEFT = 'e-tip-left';\nvar TIP_RIGHT = 'e-tip-right';\nvar POPUP_ROOT = 'e-popup';\nvar POPUP_OPEN = 'e-popup-open';\nvar POPUP_CLOSE = 'e-popup-close';\nvar POPUP_LIB = 'e-lib';\nvar HIDE_POPUP = 'e-hidden';\n\nvar Animation =\n/** @class */\nfunction (_super) {\n  __extends(Animation, _super);\n\n  function Animation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property({\n    effect: 'FadeIn',\n    duration: 150,\n    delay: 0\n  })], Animation.prototype, \"open\", void 0);\n\n  __decorate([Property({\n    effect: 'FadeOut',\n    duration: 150,\n    delay: 0\n  })], Animation.prototype, \"close\", void 0);\n\n  return Animation;\n}(ChildProperty);\n\nexport { Animation };\n/**\n * Represents the Tooltip component that displays a piece of information about the target element on mouse hover.\n * ```html\n * <div id=\"tooltip\">Show Tooltip</div>\n * ```\n * ```typescript\n * <script>\n *   var tooltipObj = new Tooltip({ content: 'Tooltip text' });\n *   tooltipObj.appendTo(\"#tooltip\");\n * </script>\n * ```\n */\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  __extends(Tooltip, _super);\n  /**\n   * Constructor for creating the Tooltip Component\n   */\n\n\n  function Tooltip(options, element) {\n    var _this = _super.call(this, options, element) || this;\n\n    _this.isBlazorTooltip = false;\n    _this.contentTargetValue = null;\n    _this.contentEvent = null;\n    _this.contentAnimation = null;\n    return _this;\n  }\n\n  Tooltip.prototype.initialize = function () {\n    this.formatPosition();\n\n    if (!this.isServerRender()) {\n      addClass([this.element], ROOT);\n    }\n  };\n\n  Tooltip.prototype.isServerRender = function () {\n    return isBlazor() && this.isServerRendered;\n  };\n\n  Tooltip.prototype.formatPosition = function () {\n    var _a, _b;\n\n    if (this.position.indexOf('Top') === 0 || this.position.indexOf('Bottom') === 0) {\n      _a = this.position.split(/(?=[A-Z])/), this.tooltipPositionY = _a[0], this.tooltipPositionX = _a[1];\n    } else {\n      _b = this.position.split(/(?=[A-Z])/), this.tooltipPositionX = _b[0], this.tooltipPositionY = _b[1];\n    }\n  };\n\n  Tooltip.prototype.renderArrow = function () {\n    this.setTipClass(this.position);\n\n    if (!this.isServerRender()) {\n      var tip = this.createElement('div', {\n        className: ARROW_TIP + ' ' + this.tipClass\n      });\n      tip.appendChild(this.createElement('div', {\n        className: ARROW_TIP_OUTER + ' ' + this.tipClass\n      }));\n      tip.appendChild(this.createElement('div', {\n        className: ARROW_TIP_INNER + ' ' + this.tipClass\n      }));\n      this.tooltipEle.appendChild(tip);\n    } else {\n      var tip = this.tooltipEle.querySelector('.' + ARROW_TIP);\n      addClass([tip.querySelector('.' + ARROW_TIP_OUTER)], this.tipClass);\n      addClass([tip.querySelector('.' + ARROW_TIP_INNER)], this.tipClass);\n      this.tooltipEle.appendChild(tip);\n    }\n  };\n\n  Tooltip.prototype.setTipClass = function (position) {\n    if (position.indexOf('Right') === 0) {\n      this.tipClass = TIP_LEFT;\n    } else if (position.indexOf('Bottom') === 0) {\n      this.tipClass = TIP_TOP;\n    } else if (position.indexOf('Left') === 0) {\n      this.tipClass = TIP_RIGHT;\n    } else {\n      this.tipClass = TIP_BOTTOM;\n    }\n  };\n\n  Tooltip.prototype.renderPopup = function (target) {\n    var elePos = this.mouseTrail ? {\n      top: 0,\n      left: 0\n    } : this.getTooltipPosition(target);\n    this.tooltipEle.classList.remove(POPUP_LIB);\n    this.popupObj = new Popup(this.tooltipEle, {\n      height: this.height,\n      width: this.width,\n      position: {\n        X: elePos.left,\n        Y: elePos.top\n      },\n      enableRtl: this.enableRtl,\n      open: this.openPopupHandler.bind(this),\n      close: this.closePopupHandler.bind(this)\n    });\n  };\n\n  Tooltip.prototype.getTooltipPosition = function (target) {\n    this.tooltipEle.style.display = 'block';\n    var pos = calculatePosition(target, this.tooltipPositionX, this.tooltipPositionY);\n    var offsetPos = this.calculateTooltipOffset(this.position);\n    var elePos = this.collisionFlipFit(target, pos.left + offsetPos.left, pos.top + offsetPos.top);\n    this.tooltipEle.style.display = '';\n    return elePos;\n  };\n\n  Tooltip.prototype.reposition = function (target) {\n    var elePos = this.getTooltipPosition(target);\n    this.popupObj.position = {\n      X: elePos.left,\n      Y: elePos.top\n    };\n    this.popupObj.dataBind();\n  };\n\n  Tooltip.prototype.openPopupHandler = function () {\n    if (!this.mouseTrail && this.needTemplateReposition()) {\n      this.reposition(this.findTarget());\n    }\n\n    this.trigger('afterOpen', this.tooltipEventArgs);\n  };\n\n  Tooltip.prototype.closePopupHandler = function () {\n    resetBlazorTemplate(this.element.id + 'content', 'Content');\n    this.clear();\n    this.trigger('afterClose', this.tooltipEventArgs);\n  };\n\n  Tooltip.prototype.calculateTooltipOffset = function (position) {\n    var pos = {\n      top: 0,\n      left: 0\n    };\n    var tooltipEleWidth = this.tooltipEle.offsetWidth;\n    var tooltipEleHeight = this.tooltipEle.offsetHeight;\n    var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);\n    var tipWidth = arrowEle ? arrowEle.offsetWidth : 0;\n    var tipHeight = arrowEle ? arrowEle.offsetHeight : 0;\n    var tipAdjust = this.showTipPointer ? SHOW_POINTER_TIP_GAP : HIDE_POINTER_TIP_GAP;\n    var tipHeightAdjust = tipHeight / 2 + POINTER_ADJUST + (this.tooltipEle.offsetHeight - this.tooltipEle.clientHeight);\n    var tipWidthAdjust = tipWidth / 2 + POINTER_ADJUST + (this.tooltipEle.offsetWidth - this.tooltipEle.clientWidth);\n\n    if (this.mouseTrail) {\n      tipAdjust += MOUSE_TRAIL_GAP;\n    }\n\n    switch (position) {\n      case 'RightTop':\n        pos.left += tipWidth + tipAdjust;\n        pos.top -= tooltipEleHeight - tipHeightAdjust;\n        break;\n\n      case 'RightCenter':\n        pos.left += tipWidth + tipAdjust;\n        pos.top -= tooltipEleHeight / 2;\n        break;\n\n      case 'RightBottom':\n        pos.left += tipWidth + tipAdjust;\n        pos.top -= tipHeightAdjust;\n        break;\n\n      case 'BottomRight':\n        pos.top += tipHeight + tipAdjust;\n        pos.left -= tipWidthAdjust;\n        break;\n\n      case 'BottomCenter':\n        pos.top += tipHeight + tipAdjust;\n        pos.left -= tooltipEleWidth / 2;\n        break;\n\n      case 'BottomLeft':\n        pos.top += tipHeight + tipAdjust;\n        pos.left -= tooltipEleWidth - tipWidthAdjust;\n        break;\n\n      case 'LeftBottom':\n        pos.left -= tipWidth + tooltipEleWidth + tipAdjust;\n        pos.top -= tipHeightAdjust;\n        break;\n\n      case 'LeftCenter':\n        pos.left -= tipWidth + tooltipEleWidth + tipAdjust;\n        pos.top -= tooltipEleHeight / 2;\n        break;\n\n      case 'LeftTop':\n        pos.left -= tipWidth + tooltipEleWidth + tipAdjust;\n        pos.top -= tooltipEleHeight - tipHeightAdjust;\n        break;\n\n      case 'TopLeft':\n        pos.top -= tooltipEleHeight + tipHeight + tipAdjust;\n        pos.left -= tooltipEleWidth - tipWidthAdjust;\n        break;\n\n      case 'TopRight':\n        pos.top -= tooltipEleHeight + tipHeight + tipAdjust;\n        pos.left -= tipWidthAdjust;\n        break;\n\n      default:\n        pos.top -= tooltipEleHeight + tipHeight + tipAdjust;\n        pos.left -= tooltipEleWidth / 2;\n        break;\n    }\n\n    pos.left += this.offsetX;\n    pos.top += this.offsetY;\n    return pos;\n  };\n\n  Tooltip.prototype.updateTipPosition = function (position) {\n    var selEle = this.tooltipEle.querySelectorAll('.' + ARROW_TIP + ',.' + ARROW_TIP_OUTER + ',.' + ARROW_TIP_INNER);\n    var removeList = [TIP_BOTTOM, TIP_TOP, TIP_LEFT, TIP_RIGHT];\n    removeClass(selEle, removeList);\n    this.setTipClass(position);\n    addClass(selEle, this.tipClass);\n  };\n\n  Tooltip.prototype.adjustArrow = function (target, position, tooltipPositionX, tooltipPositionY) {\n    if (this.showTipPointer === false) {\n      return;\n    }\n\n    this.updateTipPosition(position);\n    var leftValue;\n    var topValue;\n    this.tooltipEle.style.display = 'block';\n    var tooltipWidth = this.tooltipEle.clientWidth;\n    var tooltipHeight = this.tooltipEle.clientHeight;\n    var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);\n    var arrowInnerELe = this.tooltipEle.querySelector('.' + ARROW_TIP_INNER);\n    var tipWidth = arrowEle.offsetWidth;\n    var tipHeight = arrowEle.offsetHeight;\n    this.tooltipEle.style.display = '';\n\n    if (this.tipClass === TIP_BOTTOM || this.tipClass === TIP_TOP) {\n      if (this.tipClass === TIP_BOTTOM) {\n        topValue = '99.9%'; // Arrow icon aligned -2px height from ArrowOuterTip div\n\n        arrowInnerELe.style.top = '-' + (tipHeight - 2) + 'px';\n      } else {\n        topValue = -(tipHeight - 1) + 'px'; // Arrow icon aligned -6px height from ArrowOuterTip div\n\n        arrowInnerELe.style.top = '-' + (tipHeight - 6) + 'px';\n      }\n\n      if (target) {\n        var tipPosExclude = tooltipPositionX !== 'Center' || tooltipWidth > target.offsetWidth || this.mouseTrail;\n\n        if (tipPosExclude && tooltipPositionX === 'Left' || !tipPosExclude && this.tipPointerPosition === 'End') {\n          leftValue = tooltipWidth - tipWidth - POINTER_ADJUST + 'px';\n        } else if (tipPosExclude && tooltipPositionX === 'Right' || !tipPosExclude && this.tipPointerPosition === 'Start') {\n          leftValue = POINTER_ADJUST + 'px';\n        } else {\n          leftValue = tooltipWidth / 2 - tipWidth / 2 + 'px';\n        }\n      }\n    } else {\n      if (this.tipClass === TIP_RIGHT) {\n        leftValue = '99.9%'; // Arrow icon aligned -2px left from ArrowOuterTip div\n\n        arrowInnerELe.style.left = '-' + (tipWidth - 2) + 'px';\n      } else {\n        leftValue = -(tipWidth - 1) + 'px'; // Arrow icon aligned -2px from ArrowOuterTip width\n\n        arrowInnerELe.style.left = -tipWidth + (tipWidth - 2) + 'px';\n      }\n\n      var tipPosExclude = tooltipPositionY !== 'Center' || tooltipHeight > target.offsetHeight || this.mouseTrail;\n\n      if (tipPosExclude && tooltipPositionY === 'Top' || !tipPosExclude && this.tipPointerPosition === 'End') {\n        topValue = tooltipHeight - tipHeight - POINTER_ADJUST + 'px';\n      } else if (tipPosExclude && tooltipPositionY === 'Bottom' || !tipPosExclude && this.tipPointerPosition === 'Start') {\n        topValue = POINTER_ADJUST + 'px';\n      } else {\n        topValue = tooltipHeight / 2 - tipHeight / 2 + 'px';\n      }\n    }\n\n    arrowEle.style.top = topValue;\n    arrowEle.style.left = leftValue;\n  };\n\n  Tooltip.prototype.renderContent = function (target) {\n    var tooltipContent = this.tooltipEle.querySelector('.' + CONTENT);\n\n    if (this.cssClass) {\n      addClass([this.tooltipEle], this.cssClass.split(' '));\n    }\n\n    if (target && !isNullOrUndefined(target.getAttribute('title'))) {\n      target.setAttribute('data-content', target.getAttribute('title'));\n      target.removeAttribute('title');\n    }\n\n    if (!isNullOrUndefined(this.content)) {\n      if (this.isBlazorTooltip || !this.isServerRender()) {\n        tooltipContent.innerHTML = '';\n\n        if (this.content instanceof HTMLElement) {\n          tooltipContent.appendChild(this.content);\n        } else if (typeof this.content === 'string' && this.content.indexOf('<div>Blazor') < 0) {\n          if (this.enableHtmlSanitizer) {\n            this.setProperties({\n              content: SanitizeHtmlHelper.sanitize(this.content)\n            }, true);\n          }\n\n          tooltipContent.innerHTML = this.content;\n        } else {\n          var templateFunction = compile(this.content);\n          append(templateFunction({}, null, null, this.element.id + 'content'), tooltipContent);\n\n          if (typeof this.content === 'string' && this.content.indexOf('<div>Blazor') >= 0) {\n            this.isBlazorTemplate = true;\n            updateBlazorTemplate(this.element.id + 'content', 'Content', this);\n          }\n        }\n      }\n    } else {\n      if (target && !isNullOrUndefined(target.getAttribute('data-content'))) {\n        tooltipContent.innerHTML = target.getAttribute('data-content');\n      }\n    }\n  };\n\n  Tooltip.prototype.renderCloseIcon = function () {\n    if (!this.isSticky) {\n      return;\n    }\n\n    var tipClose = this.createElement('div', {\n      className: ICON + ' ' + CLOSE\n    });\n    this.tooltipEle.appendChild(tipClose);\n    EventHandler.add(tipClose, Browser.touchStartEvent, this.onStickyClose, this);\n  };\n\n  Tooltip.prototype.addDescribedBy = function (target, id) {\n    var describedby = (target.getAttribute('aria-describedby') || '').split(/\\s+/);\n\n    if (describedby.indexOf(id) < 0) {\n      describedby.push(id);\n    }\n\n    attributes(target, {\n      'aria-describedby': describedby.join(' ').trim(),\n      'data-tooltip-id': id\n    });\n  };\n\n  Tooltip.prototype.removeDescribedBy = function (target) {\n    var id = target.getAttribute('data-tooltip-id');\n    var describedby = (target.getAttribute('aria-describedby') || '').split(/\\s+/);\n    var index = describedby.indexOf(id);\n\n    if (index !== -1) {\n      describedby.splice(index, 1);\n    }\n\n    target.removeAttribute('data-tooltip-id');\n    var orgdescribedby = describedby.join(' ').trim();\n\n    if (orgdescribedby) {\n      target.setAttribute('aria-describedby', orgdescribedby);\n    } else {\n      target.removeAttribute('aria-describedby');\n    }\n  };\n\n  Tooltip.prototype.tapHoldHandler = function (evt) {\n    clearTimeout(this.autoCloseTimer);\n    this.targetHover(evt.originalEvent);\n  };\n\n  Tooltip.prototype.touchEndHandler = function (e) {\n    var _this = this;\n\n    if (this.isSticky) {\n      return;\n    }\n\n    var close = function () {\n      _this.close();\n    };\n\n    this.autoCloseTimer = setTimeout(close, TOUCHEND_HIDE_DELAY);\n  };\n\n  Tooltip.prototype.targetClick = function (e) {\n    var target;\n\n    if (this.target) {\n      target = closest(e.target, this.target);\n    } else {\n      target = this.element;\n    }\n\n    if (isNullOrUndefined(target)) {\n      return;\n    }\n\n    if (target.getAttribute('data-tooltip-id') === null) {\n      this.targetHover(e);\n    } else if (!this.isSticky) {\n      this.hideTooltip(this.animation.close, e, target);\n    }\n  };\n\n  Tooltip.prototype.targetHover = function (e) {\n    var target;\n\n    if (this.target) {\n      target = closest(e.target, this.target);\n    } else {\n      target = this.element;\n    }\n\n    if (isNullOrUndefined(target) || target.getAttribute('data-tooltip-id') !== null) {\n      return;\n    }\n\n    var targetList = [].slice.call(document.querySelectorAll('[data-tooltip-id= ' + this.ctrlId + '_content]'));\n\n    for (var _i = 0, targetList_1 = targetList; _i < targetList_1.length; _i++) {\n      var target_1 = targetList_1[_i];\n      this.restoreElement(target_1);\n    }\n\n    this.showTooltip(target, this.animation.open, e);\n  };\n\n  Tooltip.prototype.showTooltip = function (target, showAnimation, e) {\n    var _this = this;\n\n    clearTimeout(this.showTimer);\n    clearTimeout(this.hideTimer);\n    this.tooltipEventArgs = {\n      type: e ? e.type : null,\n      cancel: false,\n      target: target,\n      event: e ? e : null,\n      element: this.tooltipEle,\n      isInteracted: !isNullOrUndefined(e)\n    };\n\n    var observeCallback = function (beforeRenderArgs) {\n      _this.beforeRenderCallback(beforeRenderArgs, target, e, showAnimation);\n    };\n\n    this.trigger('beforeRender', this.tooltipEventArgs, observeCallback.bind(this));\n  };\n\n  Tooltip.prototype.beforeRenderCallback = function (beforeRenderArgs, target, e, showAnimation) {\n    var isBlazorTooltipRendered = false;\n\n    if (beforeRenderArgs.cancel) {\n      this.isHidden = true;\n      this.clear();\n    } else {\n      this.isHidden = false;\n\n      if (isNullOrUndefined(this.tooltipEle)) {\n        if (this.isServerRender()) {\n          this.contentTargetValue = target;\n          this.contentEvent = e;\n          this.contentAnimation = showAnimation;\n          var args = {\n            'enableTooltip': 'true'\n          }; // tslint:disable\n\n          this.interopAdaptor.invokeMethodAsync('OnTooltipServerCall', args); // tslint:enable\n\n          isBlazorTooltipRendered = true;\n        } else {\n          this.ctrlId = this.element.getAttribute('id') ? getUniqueID(this.element.getAttribute('id')) : getUniqueID('tooltip');\n          this.tooltipEle = this.createElement('div', {\n            className: TOOLTIP_WRAP + ' ' + POPUP_ROOT + ' ' + POPUP_LIB,\n            attrs: {\n              role: 'tooltip',\n              'aria-hidden': 'false',\n              'id': this.ctrlId + '_content'\n            },\n            styles: 'width:' + formatUnit(this.width) + ';height:' + formatUnit(this.height) + ';position:absolute;'\n          });\n          this.beforeRenderBlazor(target, this);\n        }\n\n        if (!isBlazorTooltipRendered) {\n          this.afterRenderBlazor(target, e, showAnimation, this);\n        }\n      } else {\n        if (this.isServerRender()) {\n          addClass([this.tooltipEle], POPUP_OPEN);\n          document.body.appendChild(this.tooltipEle);\n          this.renderCloseIcon();\n          this.renderPopup(target);\n        }\n\n        if (target) {\n          this.adjustArrow(target, this.position, this.tooltipPositionX, this.tooltipPositionY);\n          this.addDescribedBy(target, this.ctrlId + '_content');\n          this.renderContent(target);\n          PopupAnimation.stop(this.tooltipEle);\n          this.reposition(target);\n          this.afterRenderBlazor(target, e, showAnimation, this);\n        }\n      }\n    }\n  };\n\n  ;\n\n  Tooltip.prototype.contentUpdated = function (args) {\n    if (isNullOrUndefined(this.tooltipEle)) {\n      if (this.isServerRender()) {\n        this.ctrlId = this.element.id;\n        this.tooltipEle = document.querySelector('#' + this.ctrlId + '_content');\n\n        if (this.tooltipEle) {\n          this.tooltipEle.setAttribute('style', 'width:' + formatUnit(this.width) + ';height:' + formatUnit(this.height) + ';position:absolute;');\n          this.beforeRenderBlazor(this.contentTargetValue, this);\n          this.afterRenderBlazor(this.contentTargetValue, this.contentEvent, this.contentAnimation, this);\n          this.contentTargetValue = this.contentEvent = this.contentAnimation = null;\n        }\n      }\n    }\n  };\n\n  ;\n\n  Tooltip.prototype.beforeRenderBlazor = function (target, ctrlObj) {\n    if (target) {\n      if (Browser.isDevice) {\n        addClass([ctrlObj.tooltipEle], DEVICE);\n      }\n\n      if (ctrlObj.width !== 'auto') {\n        ctrlObj.tooltipEle.style.maxWidth = formatUnit(ctrlObj.width);\n      }\n\n      if (!this.isServerRender()) {\n        ctrlObj.tooltipEle.appendChild(ctrlObj.createElement('div', {\n          className: CONTENT\n        }));\n      }\n\n      document.body.appendChild(ctrlObj.tooltipEle);\n      removeClass([ctrlObj.tooltipEle], HIDE_POPUP);\n      ctrlObj.addDescribedBy(target, ctrlObj.ctrlId + '_content');\n      ctrlObj.renderContent(target);\n      addClass([ctrlObj.tooltipEle], POPUP_OPEN);\n\n      if (ctrlObj.showTipPointer) {\n        ctrlObj.renderArrow();\n      }\n\n      ctrlObj.renderCloseIcon();\n      ctrlObj.renderPopup(target);\n      ctrlObj.adjustArrow(target, ctrlObj.position, ctrlObj.tooltipPositionX, ctrlObj.tooltipPositionY);\n      PopupAnimation.stop(ctrlObj.tooltipEle);\n      ctrlObj.reposition(target);\n    }\n  };\n\n  Tooltip.prototype.afterRenderBlazor = function (target, e, showAnimation, ctrlObj) {\n    if (target) {\n      removeClass([ctrlObj.tooltipEle], POPUP_OPEN);\n      addClass([ctrlObj.tooltipEle], POPUP_CLOSE);\n      ctrlObj.tooltipEventArgs = {\n        type: e ? e.type : null,\n        cancel: false,\n        target: target,\n        event: e ? e : null,\n        element: ctrlObj.tooltipEle,\n        isInteracted: !isNullOrUndefined(e)\n      };\n\n      if (ctrlObj.needTemplateReposition() && !ctrlObj.mouseTrail) {\n        ctrlObj.tooltipEle.style.display = 'none';\n      }\n\n      var observeCallback = function (observedArgs) {\n        ctrlObj.beforeOpenCallback(observedArgs, target, showAnimation, e);\n      };\n\n      ctrlObj.trigger('beforeOpen', ctrlObj.tooltipEventArgs, observeCallback.bind(ctrlObj));\n    }\n  };\n\n  Tooltip.prototype.beforeOpenCallback = function (observedArgs, target, showAnimation, e) {\n    var _this = this;\n\n    if (observedArgs.cancel) {\n      this.isHidden = true;\n      this.clear();\n      this.restoreElement(target);\n    } else {\n      var openAnimation_1 = {\n        name: showAnimation.effect,\n        duration: showAnimation.duration,\n        delay: showAnimation.delay,\n        timingFunction: 'easeOut'\n      };\n\n      if (showAnimation.effect === 'None') {\n        openAnimation_1 = undefined;\n      }\n\n      if (this.openDelay > 0) {\n        var show = function () {\n          if (_this.popupObj) {\n            _this.popupObj.show(openAnimation_1, target);\n          }\n        };\n\n        this.showTimer = setTimeout(show, this.openDelay);\n      } else {\n        if (this.popupObj) {\n          this.popupObj.show(openAnimation_1, target);\n        }\n      }\n    }\n\n    if (e) {\n      this.wireMouseEvents(e, target);\n    }\n  };\n\n  Tooltip.prototype.needTemplateReposition = function () {\n    // tslint:disable-next-line:no-any\n    var tooltip = this;\n    return !isNullOrUndefined(tooltip.viewContainerRef) && typeof tooltip.viewContainerRef !== 'string' || this.isServerRender() && this.isBlazorTemplate;\n  };\n\n  Tooltip.prototype.checkCollision = function (target, x, y) {\n    var elePos = {\n      left: x,\n      top: y,\n      position: this.position,\n      horizontal: this.tooltipPositionX,\n      vertical: this.tooltipPositionY\n    };\n    var affectedPos = isCollide(this.tooltipEle, this.target ? this.element : null, x, y);\n\n    if (affectedPos.length > 0) {\n      elePos.horizontal = affectedPos.indexOf('left') >= 0 ? 'Right' : affectedPos.indexOf('right') >= 0 ? 'Left' : this.tooltipPositionX;\n      elePos.vertical = affectedPos.indexOf('top') >= 0 ? 'Bottom' : affectedPos.indexOf('bottom') >= 0 ? 'Top' : this.tooltipPositionY;\n    }\n\n    return elePos;\n  };\n\n  Tooltip.prototype.collisionFlipFit = function (target, x, y) {\n    var elePos = this.checkCollision(target, x, y);\n    var newpos = elePos.position;\n\n    if (this.tooltipPositionY !== elePos.vertical) {\n      newpos = this.position.indexOf('Bottom') === 0 || this.position.indexOf('Top') === 0 ? elePos.vertical + this.tooltipPositionX : this.tooltipPositionX + elePos.vertical;\n    }\n\n    if (this.tooltipPositionX !== elePos.horizontal) {\n      if (newpos.indexOf('Left') === 0) {\n        elePos.vertical = newpos === 'LeftTop' || newpos === 'LeftCenter' ? 'Top' : 'Bottom';\n        newpos = elePos.vertical + 'Left';\n      }\n\n      if (newpos.indexOf('Right') === 0) {\n        elePos.vertical = newpos === 'RightTop' || newpos === 'RightCenter' ? 'Top' : 'Bottom';\n        newpos = elePos.vertical + 'Right';\n      }\n\n      elePos.horizontal = this.tooltipPositionX;\n    }\n\n    this.tooltipEventArgs = {\n      type: null,\n      cancel: false,\n      target: target,\n      event: null,\n      element: this.tooltipEle,\n      collidedPosition: newpos\n    };\n    this.trigger('beforeCollision', this.tooltipEventArgs);\n\n    if (elePos.position !== newpos) {\n      var pos = calculatePosition(target, elePos.horizontal, elePos.vertical);\n      this.adjustArrow(target, newpos, elePos.horizontal, elePos.vertical);\n      var offsetPos = this.calculateTooltipOffset(newpos);\n      offsetPos.top -= 'TopBottom'.indexOf(this.position.split(/(?=[A-Z])/)[0]) !== -1 && 'TopBottom'.indexOf(newpos.split(/(?=[A-Z])/)[0]) !== -1 ? 2 * this.offsetY : 0;\n      offsetPos.left -= 'RightLeft'.indexOf(this.position.split(/(?=[A-Z])/)[0]) !== -1 && 'RightLeft'.indexOf(newpos.split(/(?=[A-Z])/)[0]) !== -1 ? 2 * this.offsetX : 0;\n      elePos.position = newpos;\n      elePos.left = pos.left + offsetPos.left;\n      elePos.top = pos.top + offsetPos.top;\n    } else {\n      this.adjustArrow(target, newpos, elePos.horizontal, elePos.vertical);\n    }\n\n    var eleOffset = {\n      left: elePos.left,\n      top: elePos.top\n    };\n    var left = fit(this.tooltipEle, this.target ? this.element : null, {\n      X: true,\n      Y: false\n    }, eleOffset).left;\n    this.tooltipEle.style.display = 'block';\n\n    if (this.showTipPointer && (newpos.indexOf('Bottom') === 0 || newpos.indexOf('Top') === 0)) {\n      var arrowEle = this.tooltipEle.querySelector('.' + ARROW_TIP);\n      var arrowleft = parseInt(arrowEle.style.left, 10) - (left - elePos.left);\n\n      if (arrowleft < 0) {\n        arrowleft = 0;\n      } else if (arrowleft + arrowEle.offsetWidth > this.tooltipEle.clientWidth) {\n        arrowleft = this.tooltipEle.clientWidth - arrowEle.offsetWidth;\n      }\n\n      arrowEle.style.left = arrowleft.toString() + 'px';\n    }\n\n    this.tooltipEle.style.display = '';\n    eleOffset.left = left;\n    return eleOffset;\n  };\n\n  Tooltip.prototype.hideTooltip = function (hideAnimation, e, targetElement) {\n    var _this = this;\n\n    var target;\n\n    if (e) {\n      target = this.target ? targetElement || e.target : this.element;\n    } else {\n      target = document.querySelector('[data-tooltip-id= ' + this.ctrlId + '_content]');\n    }\n\n    this.tooltipEventArgs = {\n      type: e ? e.type : null,\n      cancel: false,\n      target: target,\n      event: e ? e : null,\n      element: this.tooltipEle,\n      isInteracted: !isNullOrUndefined(e)\n    }; // this line commented for close the tooltip popup element even the target element destroyed in a page.\n    //if (isNullOrUndefined(target)) { return; }\n\n    this.trigger('beforeClose', this.tooltipEventArgs, function (observedArgs) {\n      if (!observedArgs.cancel) {\n        if (_this.isServerRender()) {\n          _this.blazorHide(hideAnimation, target);\n        } else {\n          _this.popupHide(hideAnimation, target);\n        }\n      } else {\n        _this.isHidden = false;\n      }\n    });\n  };\n  /* istanbul ignore next */\n\n\n  Tooltip.prototype.blazorHide = function (hideAnimation, target) {\n    var proxy = this;\n\n    var hide = function () {\n      proxy.popupHide(hideAnimation, target);\n    };\n\n    if (this.popupObj) {\n      this.popupHide(hideAnimation, target);\n    } else {\n      setTimeout(hide, 200);\n    }\n  };\n\n  Tooltip.prototype.popupHide = function (hideAnimation, target) {\n    var _this = this;\n\n    this.clearTemplate();\n\n    if (target) {\n      this.restoreElement(target);\n    }\n\n    this.isHidden = true;\n    var closeAnimation = {\n      name: hideAnimation.effect,\n      duration: hideAnimation.duration,\n      delay: hideAnimation.delay,\n      timingFunction: 'easeIn'\n    };\n\n    if (hideAnimation.effect === 'None') {\n      closeAnimation = undefined;\n    }\n\n    if (this.closeDelay > 0) {\n      var hide = function () {\n        if (_this.popupObj) {\n          _this.popupObj.hide(closeAnimation);\n        }\n      };\n\n      this.hideTimer = setTimeout(hide, this.closeDelay);\n    } else {\n      if (this.popupObj) {\n        this.popupObj.hide(closeAnimation);\n      }\n    }\n  };\n\n  Tooltip.prototype.restoreElement = function (target) {\n    this.unwireMouseEvents(target);\n\n    if (!isNullOrUndefined(target.getAttribute('data-content'))) {\n      target.setAttribute('title', target.getAttribute('data-content'));\n      target.removeAttribute('data-content');\n    }\n\n    this.removeDescribedBy(target);\n  };\n\n  Tooltip.prototype.clear = function () {\n    if (this.tooltipEle) {\n      removeClass([this.tooltipEle], POPUP_CLOSE);\n      addClass([this.tooltipEle], POPUP_OPEN);\n    }\n\n    if (this.isHidden) {\n      if (this.popupObj) {\n        this.popupObj.destroy();\n      }\n\n      if (this.isServerRender() && this.tooltipEle) {\n        this.tooltipEle.style.display = 'none';\n        var args = {\n          'enableTooltip': 'false'\n        }; // tslint:disable\n\n        this.interopAdaptor.invokeMethodAsync('OnTooltipServerCall', args); // tslint:enable\n\n        remove(this.tooltipEle);\n      } else if (this.tooltipEle) {\n        remove(this.tooltipEle);\n      }\n\n      this.tooltipEle = null;\n      this.popupObj = null;\n    }\n  };\n\n  Tooltip.prototype.onMouseOut = function (e) {\n    var enteredElement = e.relatedTarget; // don't close the tooltip only if it is tooltip content element\n\n    if (enteredElement && !this.mouseTrail) {\n      var checkForTooltipElement = closest(enteredElement, \".\" + TOOLTIP_WRAP + \".\" + POPUP_LIB + \".\" + POPUP_ROOT);\n\n      if (checkForTooltipElement) {\n        EventHandler.add(checkForTooltipElement, 'mouseleave', this.tooltipElementMouseOut, this);\n        this.unwireMouseEvents(e.target);\n      } else {\n        this.hideTooltip(this.animation.close, e, this.findTarget());\n\n        if (this.closeDelay === 0) {\n          this.clear();\n        }\n      }\n    } else {\n      this.hideTooltip(this.animation.close, e, this.findTarget());\n      this.clear();\n    }\n  };\n\n  Tooltip.prototype.tooltipElementMouseOut = function (e) {\n    this.hideTooltip(this.animation.close, e, this.findTarget());\n    EventHandler.remove(this.element, 'mouseleave', this.tooltipElementMouseOut);\n    this.clear();\n  };\n\n  Tooltip.prototype.onStickyClose = function (e) {\n    this.close();\n  };\n\n  Tooltip.prototype.onMouseMove = function (event) {\n    var eventPageX = 0;\n    var eventPageY = 0;\n\n    if (event.type.indexOf('touch') > -1) {\n      event.preventDefault();\n      eventPageX = event.touches[0].pageX;\n      eventPageY = event.touches[0].pageY;\n    } else {\n      eventPageX = event.pageX;\n      eventPageY = event.pageY;\n    }\n\n    PopupAnimation.stop(this.tooltipEle);\n    removeClass([this.tooltipEle], POPUP_CLOSE);\n    addClass([this.tooltipEle], POPUP_OPEN);\n    this.adjustArrow(event.target, this.position, this.tooltipPositionX, this.tooltipPositionY);\n    var pos = this.calculateTooltipOffset(this.position);\n    var x = eventPageX + pos.left + this.offsetX;\n    var y = eventPageY + pos.top + this.offsetY;\n    var elePos = this.checkCollision(event.target, x, y);\n\n    if (this.tooltipPositionX !== elePos.horizontal || this.tooltipPositionY !== elePos.vertical) {\n      var newpos = this.position.indexOf('Bottom') === 0 || this.position.indexOf('Top') === 0 ? elePos.vertical + elePos.horizontal : elePos.horizontal + elePos.vertical;\n      elePos.position = newpos;\n      this.adjustArrow(event.target, elePos.position, elePos.horizontal, elePos.vertical);\n      var colpos = this.calculateTooltipOffset(elePos.position);\n      elePos.left = eventPageX + colpos.left - this.offsetX;\n      elePos.top = eventPageY + colpos.top - this.offsetY;\n    }\n\n    this.tooltipEle.style.left = elePos.left + 'px';\n    this.tooltipEle.style.top = elePos.top + 'px';\n  };\n\n  Tooltip.prototype.keyDown = function (event) {\n    if (this.tooltipEle && event.keyCode === 27) {\n      this.close();\n    }\n  };\n\n  Tooltip.prototype.touchEnd = function (e) {\n    if (this.tooltipEle && closest(e.target, '.' + ROOT) === null) {\n      this.close();\n    }\n  };\n\n  Tooltip.prototype.scrollHandler = function (e) {\n    if (this.tooltipEle) {\n      if (!closest(e.target, \".\" + TOOLTIP_WRAP + \".\" + POPUP_LIB + \".\" + POPUP_ROOT)) {\n        this.close();\n      }\n    }\n  };\n  /**\n   * Core method that initializes the control rendering.\n   * @private\n   */\n\n\n  Tooltip.prototype.render = function () {\n    this.initialize();\n    this.wireEvents(this.opensOn);\n    this.renderComplete();\n  };\n  /**\n   * Initializes the values of private members.\n   * @private\n   */\n\n\n  Tooltip.prototype.preRender = function () {\n    this.tipClass = TIP_BOTTOM;\n    this.tooltipPositionX = 'Center';\n    this.tooltipPositionY = 'Top';\n    this.isHidden = true;\n  };\n  /**\n   * Binding events to the Tooltip element.\n   * @hidden\n   */\n\n\n  Tooltip.prototype.wireEvents = function (trigger) {\n    var triggerList = this.getTriggerList(trigger);\n\n    for (var _i = 0, triggerList_1 = triggerList; _i < triggerList_1.length; _i++) {\n      var opensOn = triggerList_1[_i];\n\n      if (opensOn === 'Custom') {\n        return;\n      }\n\n      if (opensOn === 'Focus') {\n        this.wireFocusEvents();\n      }\n\n      if (opensOn === 'Click') {\n        EventHandler.add(this.element, Browser.touchStartEvent, this.targetClick, this);\n      }\n\n      if (opensOn === 'Hover') {\n        if (Browser.isDevice) {\n          this.touchModule = new Touch(this.element, {\n            tapHoldThreshold: TAPHOLD_THRESHOLD,\n            tapHold: this.tapHoldHandler.bind(this)\n          });\n          EventHandler.add(this.element, Browser.touchEndEvent, this.touchEndHandler, this);\n        } else {\n          EventHandler.add(this.element, 'mouseover', this.targetHover, this);\n\n          if (this.isServerRender() && !this.isSticky) {\n            EventHandler.add(this.element, 'mouseleave', this.onMouseOut, this);\n          }\n        }\n      }\n    }\n\n    EventHandler.add(document, 'touchend', this.touchEnd, this);\n    EventHandler.add(document, 'scroll wheel', this.scrollHandler, this);\n    EventHandler.add(document, 'keydown', this.keyDown, this);\n  };\n\n  Tooltip.prototype.getTriggerList = function (trigger) {\n    if (trigger === 'Auto') {\n      trigger = Browser.isDevice ? 'Hover' : 'Hover Focus';\n    }\n\n    return trigger.split(' ');\n  };\n\n  Tooltip.prototype.wireFocusEvents = function () {\n    if (!isNullOrUndefined(this.target)) {\n      var targetList = [].slice.call(this.element.querySelectorAll(this.target));\n\n      for (var _i = 0, targetList_2 = targetList; _i < targetList_2.length; _i++) {\n        var target = targetList_2[_i];\n        EventHandler.add(target, 'focus', this.targetHover, this);\n      }\n    } else {\n      EventHandler.add(this.element, 'focus', this.targetHover, this);\n    }\n  };\n\n  Tooltip.prototype.wireMouseEvents = function (e, target) {\n    if (this.tooltipEle) {\n      if (!this.isSticky) {\n        if (e.type === 'focus') {\n          EventHandler.add(target, 'blur', this.onMouseOut, this);\n        }\n\n        if (e.type === 'mouseover') {\n          if (!this.isServerRender()) {\n            EventHandler.add(target, 'mouseleave', this.onMouseOut, this);\n          }\n        }\n      }\n\n      if (this.mouseTrail) {\n        EventHandler.add(target, 'mousemove touchstart mouseenter', this.onMouseMove, this);\n      }\n    }\n  };\n  /**\n   * Unbinding events from the element on widget destroy.\n   * @hidden\n   */\n\n\n  Tooltip.prototype.unwireEvents = function (trigger) {\n    var triggerList = this.getTriggerList(trigger);\n\n    for (var _i = 0, triggerList_2 = triggerList; _i < triggerList_2.length; _i++) {\n      var opensOn = triggerList_2[_i];\n\n      if (opensOn === 'Custom') {\n        return;\n      }\n\n      if (opensOn === 'Focus') {\n        this.unwireFocusEvents();\n      }\n\n      if (opensOn === 'Click') {\n        EventHandler.remove(this.element, Browser.touchStartEvent, this.targetClick);\n      }\n\n      if (opensOn === 'Hover') {\n        if (Browser.isDevice) {\n          if (this.touchModule) {\n            this.touchModule.destroy();\n          }\n\n          EventHandler.remove(this.element, Browser.touchEndEvent, this.touchEndHandler);\n        } else {\n          EventHandler.remove(this.element, 'mouseover', this.targetHover);\n\n          if (this.isServerRender() && !this.isSticky) {\n            EventHandler.remove(this.element, 'mouseleave', this.onMouseOut);\n          }\n        }\n      }\n    }\n\n    EventHandler.remove(document, 'touchend', this.touchEnd);\n    EventHandler.remove(document, 'scroll wheel', this.scrollHandler);\n    EventHandler.remove(document, 'keydown', this.keyDown);\n  };\n\n  Tooltip.prototype.unwireFocusEvents = function () {\n    if (!isNullOrUndefined(this.target)) {\n      var targetList = [].slice.call(this.element.querySelectorAll(this.target));\n\n      for (var _i = 0, targetList_3 = targetList; _i < targetList_3.length; _i++) {\n        var target = targetList_3[_i];\n        EventHandler.remove(target, 'focus', this.targetHover);\n      }\n    } else {\n      EventHandler.remove(this.element, 'focus', this.targetHover);\n    }\n  };\n\n  Tooltip.prototype.unwireMouseEvents = function (target) {\n    if (!this.isSticky) {\n      var triggerList = this.getTriggerList(this.opensOn);\n\n      for (var _i = 0, triggerList_3 = triggerList; _i < triggerList_3.length; _i++) {\n        var opensOn = triggerList_3[_i];\n\n        if (opensOn === 'Focus') {\n          EventHandler.remove(target, 'blur', this.onMouseOut);\n        }\n\n        if (opensOn === 'Hover' && !Browser.isDevice) {\n          if (!this.isServerRender()) {\n            EventHandler.remove(target, 'mouseleave', this.onMouseOut);\n          }\n        }\n      }\n    }\n\n    if (this.mouseTrail) {\n      EventHandler.remove(target, 'mousemove touchstart mouseenter', this.onMouseMove);\n    }\n  };\n\n  Tooltip.prototype.findTarget = function () {\n    var target = document.querySelector('[data-tooltip-id= ' + this.ctrlId + '_content]');\n    return target;\n  };\n  /**\n   * Core method to return the component name.\n   * @private\n   */\n\n\n  Tooltip.prototype.getModuleName = function () {\n    return 'tooltip';\n  };\n  /**\n   * Returns the properties to be maintained in the persisted state.\n   * @private\n   */\n\n\n  Tooltip.prototype.getPersistData = function () {\n    return this.addOnPersist([]);\n  };\n  /**\n   * Called internally, if any of the property value changed.\n   * @private\n   */\n\n\n  Tooltip.prototype.onPropertyChanged = function (newProp, oldProp) {\n    var targetElement = this.findTarget();\n\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'width':\n          if (this.tooltipEle && targetElement) {\n            this.tooltipEle.style.width = this.tooltipEle.style.maxWidth = formatUnit(newProp.width);\n            this.reposition(targetElement);\n          }\n\n          break;\n\n        case 'height':\n          if (this.tooltipEle && targetElement) {\n            this.tooltipEle.style.height = formatUnit(newProp.height);\n            this.reposition(targetElement);\n          }\n\n          break;\n\n        case 'content':\n          if (this.tooltipEle) {\n            if (this.isServerRender()) {\n              this.isBlazorTooltip = true;\n            }\n\n            this.renderContent();\n          } else if (this.isServerRender()) {\n            var args = {\n              'content': newProp.content\n            }; // tslint:disable\n\n            this.interopAdaptor.invokeMethodAsync('OnTooltipServerCall', args); // tslint:enable\n          }\n\n          break;\n\n        case 'opensOn':\n          this.unwireEvents(oldProp.opensOn);\n          this.wireEvents(newProp.opensOn);\n          break;\n\n        case 'position':\n          this.formatPosition();\n\n          if (this.tooltipEle && targetElement) {\n            var arrowInnerELe = this.tooltipEle.querySelector('.' + ARROW_TIP_INNER);\n            arrowInnerELe.style.top = arrowInnerELe.style.left = null;\n            this.reposition(targetElement);\n          }\n\n          break;\n\n        case 'tipPointerPosition':\n          if (this.tooltipEle && targetElement) {\n            this.reposition(targetElement);\n          }\n\n          break;\n\n        case 'offsetX':\n          if (this.tooltipEle) {\n            var x = newProp.offsetX - oldProp.offsetX;\n            this.tooltipEle.style.left = (parseInt(this.tooltipEle.style.left, 10) + x).toString() + 'px';\n          }\n\n          break;\n\n        case 'offsetY':\n          if (this.tooltipEle) {\n            var y = newProp.offsetY - oldProp.offsetY;\n            this.tooltipEle.style.top = (parseInt(this.tooltipEle.style.top, 10) + y).toString() + 'px';\n          }\n\n          break;\n\n        case 'cssClass':\n          if (this.tooltipEle) {\n            if (oldProp.cssClass) {\n              removeClass([this.tooltipEle], oldProp.cssClass.split(' '));\n            }\n\n            if (newProp.cssClass) {\n              addClass([this.tooltipEle], newProp.cssClass.split(' '));\n            }\n          }\n\n          break;\n\n        case 'enableRtl':\n          if (this.tooltipEle) {\n            if (this.enableRtl) {\n              addClass([this.tooltipEle], RTL);\n            } else {\n              removeClass([this.tooltipEle], RTL);\n            }\n          }\n\n          break;\n      }\n    }\n  };\n  /**\n   * It is used to show the Tooltip on the specified target with specific animation settings.\n   * @param element Target element where the Tooltip is to be displayed. (It is an optional parameter)\n   * @param animation Sets the specific animation, while showing the Tooltip on the screen. (It is an optional parameter)\n   * @return {void}\n   */\n\n\n  Tooltip.prototype.open = function (element, animation) {\n    if (isNullOrUndefined(animation)) {\n      animation = this.animation.open;\n    }\n\n    if (isNullOrUndefined(element)) {\n      element = this.element;\n    }\n\n    if (element.style.display === 'none') {\n      return;\n    }\n\n    this.showTooltip(element, animation);\n  };\n  /**\n   * It is used to hide the Tooltip with specific animation effect.\n   * @param animation Sets the specific animation when hiding Tooltip from the screen. (It is an optional parameter)\n   * @return {void}\n   */\n\n\n  Tooltip.prototype.close = function (animation) {\n    if (!animation) {\n      animation = this.animation.close;\n    }\n\n    this.hideTooltip(animation);\n  };\n  /**\n   * It is used to refresh the Tooltip content and its position.\n   * @param target Target element where the Tooltip content or position needs to be refreshed.\n   * @return {void}\n   */\n\n\n  Tooltip.prototype.refresh = function (target) {\n    if (this.tooltipEle) {\n      this.renderContent(target);\n    }\n\n    if (this.popupObj && target) {\n      this.reposition(target);\n    }\n  };\n  /**\n   * It is used to destroy the Tooltip component.\n   * @method destroy\n   * @return {void}\n   * @memberof Tooltip\n   */\n\n\n  Tooltip.prototype.destroy = function () {\n    if (!this.isServerRender()) {\n      _super.prototype.destroy.call(this);\n\n      if (this.tooltipEle) {\n        remove(this.tooltipEle);\n      }\n    }\n\n    if (this.isServerRender() && this.tooltipEle) {\n      var placeholder = document.querySelector('#' + this.ctrlId + '_content_placeholder');\n\n      if (placeholder) {\n        placeholder.appendChild(this.tooltipEle);\n      }\n    }\n\n    if (this.popupObj) {\n      this.popupObj.destroy();\n    }\n\n    removeClass([this.element], ROOT);\n    this.unwireEvents(this.opensOn);\n    this.unwireMouseEvents(this.element);\n    this.tooltipEle = null;\n    this.popupObj = null;\n  };\n\n  __decorate([Property('auto')], Tooltip.prototype, \"width\", void 0);\n\n  __decorate([Property('auto')], Tooltip.prototype, \"height\", void 0);\n\n  __decorate([Property()], Tooltip.prototype, \"content\", void 0);\n\n  __decorate([Property()], Tooltip.prototype, \"target\", void 0);\n\n  __decorate([Property('TopCenter')], Tooltip.prototype, \"position\", void 0);\n\n  __decorate([Property(0)], Tooltip.prototype, \"offsetX\", void 0);\n\n  __decorate([Property(0)], Tooltip.prototype, \"offsetY\", void 0);\n\n  __decorate([Property(true)], Tooltip.prototype, \"showTipPointer\", void 0);\n\n  __decorate([Property('Auto')], Tooltip.prototype, \"tipPointerPosition\", void 0);\n\n  __decorate([Property('Auto')], Tooltip.prototype, \"opensOn\", void 0);\n\n  __decorate([Property(false)], Tooltip.prototype, \"mouseTrail\", void 0);\n\n  __decorate([Property(false)], Tooltip.prototype, \"isSticky\", void 0);\n\n  __decorate([Complex({}, Animation)], Tooltip.prototype, \"animation\", void 0);\n\n  __decorate([Property(0)], Tooltip.prototype, \"openDelay\", void 0);\n\n  __decorate([Property(0)], Tooltip.prototype, \"closeDelay\", void 0);\n\n  __decorate([Property()], Tooltip.prototype, \"cssClass\", void 0);\n\n  __decorate([Property(false)], Tooltip.prototype, \"enableHtmlSanitizer\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"beforeRender\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"beforeOpen\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"afterOpen\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"beforeClose\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"afterClose\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"beforeCollision\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"created\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"destroyed\", void 0);\n\n  Tooltip = __decorate([NotifyPropertyChanges], Tooltip);\n  return Tooltip;\n}(Component);\n\nexport { Tooltip };","map":null,"metadata":{},"sourceType":"module"}