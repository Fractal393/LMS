{"ast":null,"code":"/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nvar Encoding =\n/** @class */\nfunction () {\n  /**\n   * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n   * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n   */\n  function Encoding(includeBom) {\n    this.emitBOM = true;\n    this.encodingType = 'Ansi';\n    this.initBOM(includeBom);\n  }\n\n  Object.defineProperty(Encoding.prototype, \"includeBom\", {\n    /**\n     * Gets a value indicating whether to write a Unicode byte order mark\n     * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n     */\n    get: function () {\n      return this.emitBOM;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Encoding.prototype, \"type\", {\n    /**\n     * Gets the encoding type.\n     * @returns EncodingType\n     */\n    get: function () {\n      return this.encodingType;\n    },\n\n    /**\n     * Sets the encoding type.\n     * @param  {EncodingType} value\n     */\n    set: function (value) {\n      this.encodingType = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initialize the includeBom to emit BOM or Not\n   * @param  {boolean} includeBom\n   */\n\n  Encoding.prototype.initBOM = function (includeBom) {\n    if (includeBom === undefined || includeBom === null) {\n      this.emitBOM = true;\n    } else {\n      this.emitBOM = includeBom;\n    }\n  };\n  /**\n   * Calculates the number of bytes produced by encoding the characters in the specified string\n   * @param  {string} chars - The string containing the set of characters to encode\n   * @returns {number} - The number of bytes produced by encoding the specified characters\n   */\n\n\n  Encoding.prototype.getByteCount = function (chars) {\n    var byteCount = 0;\n    validateNullOrUndefined(chars, 'string');\n\n    if (chars === '') {\n      var byte = this.utf8Len(chars.charCodeAt(0));\n      return byte;\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    return this.getByteCountInternal(chars, 0, chars.length);\n  };\n  /**\n   * Return the Byte of character\n   * @param  {number} codePoint\n   * @returns {number}\n   */\n\n\n  Encoding.prototype.utf8Len = function (codePoint) {\n    var bytes = codePoint <= 0x7F ? 1 : codePoint <= 0x7FF ? 2 : codePoint <= 0xFFFF ? 3 : codePoint <= 0x1FFFFF ? 4 : 0;\n    return bytes;\n  };\n  /**\n   * for 4 byte character return surrogate pair true, otherwise false\n   * @param  {number} codeUnit\n   * @returns {boolean}\n   */\n\n\n  Encoding.prototype.isHighSurrogate = function (codeUnit) {\n    return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n  };\n  /**\n   * for 4byte character generate the surrogate pair\n   * @param  {number} highCodeUnit\n   * @param  {number} lowCodeUnit\n   */\n\n\n  Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\n    highCodeUnit = (0x3FF & highCodeUnit) << 10;\n    var u = highCodeUnit | 0x3FF & lowCodeUnit;\n    return u + 0x10000;\n  };\n  /**\n   * private method to get the byte count for specific charindex and count\n   * @param  {string} chars\n   * @param  {number} charIndex\n   * @param  {number} charCount\n   */\n\n\n  Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\n    var byteCount = 0;\n\n    if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n      var isUtf8 = this.encodingType === 'Utf8';\n\n      for (var i = 0; i < charCount; i++) {\n        var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n\n        if (this.isHighSurrogate(charCode)) {\n          if (isUtf8) {\n            var high = charCode;\n            var low = chars.charCodeAt(++charIndex);\n            byteCount += this.utf8Len(this.toCodepoint(high, low));\n          } else {\n            byteCount += 4;\n            ++i;\n          }\n        } else {\n          if (isUtf8) {\n            byteCount += this.utf8Len(charCode);\n          } else {\n            byteCount += 2;\n          }\n        }\n\n        if (isUtf8) {\n          charIndex++;\n        }\n      }\n\n      return byteCount;\n    } else {\n      byteCount = charCount;\n      return byteCount;\n    }\n  };\n  /**\n   * Encodes a set of characters from the specified string into the ArrayBuffer.\n   * @param  {string} s- The string containing the set of characters to encode\n   * @param  {number} charIndex-The index of the first character to encode.\n   * @param  {number} charCount- The number of characters to encode.\n   * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n   */\n\n\n  Encoding.prototype.getBytes = function (s, charIndex, charCount) {\n    validateNullOrUndefined(s, 'string');\n    validateNullOrUndefined(charIndex, 'charIndex');\n    validateNullOrUndefined(charCount, 'charCount');\n\n    if (charIndex < 0 || charCount < 0) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n    }\n\n    if (s.length - charIndex < charCount) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n    }\n\n    var bytes;\n\n    if (s === '') {\n      bytes = new ArrayBuffer(0);\n      return bytes;\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n\n    switch (this.type) {\n      case 'Utf8':\n        bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n        return bytes;\n\n      case 'Unicode':\n        bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n\n      default:\n        bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n    }\n  };\n  /**\n   * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n   * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n   * @param  {number} index- The index of the first byte to decode.\n   * @param  {number} count- The number of bytes to decode.\n   * @returns {string} - The string that contains the resulting set of characters.\n   */\n\n\n  Encoding.prototype.getString = function (bytes, index, count) {\n    validateNullOrUndefined(bytes, 'bytes');\n    validateNullOrUndefined(index, 'index');\n    validateNullOrUndefined(count, 'count');\n\n    if (index < 0 || count < 0) {\n      throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n    }\n\n    if (bytes.byteLength - index < count) {\n      throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n    }\n\n    if (bytes.byteLength === 0 || count === 0) {\n      return '';\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    var out = '';\n    var byteCal = new Uint8Array(bytes);\n\n    switch (this.type) {\n      case 'Utf8':\n        var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n        return s;\n\n      case 'Unicode':\n        var byteUnicode = new Uint16Array(bytes);\n        out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n        return out;\n\n      default:\n        var j = index;\n\n        for (var i = 0; i < count; i++) {\n          var c = byteCal[j];\n          out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n\n          j++;\n        }\n\n        return out;\n    }\n  };\n\n  Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var bufview = new Uint8Array(bytes);\n    var k = 0;\n\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(charIndex++);\n\n      if (charcode < 0x800) {\n        bufview[k] = charcode;\n      } else {\n        bufview[k] = 63; //replacement character '?'\n      }\n\n      k++;\n    }\n\n    return bytes;\n  };\n\n  Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var uint = new Uint8Array(bytes);\n    var index = charIndex;\n    var j = 0;\n\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(index);\n\n      if (charcode <= 0x7F) {\n        // 1 byte character 2^7\n        uint[j] = charcode;\n      } else if (charcode < 0x800) {\n        // 2 byte character 2^11\n        uint[j] = 0xc0 | charcode >> 6;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else if (charcode < 0xd800 || charcode >= 0xe000) {\n        // 3 byte character 2^16        \n        uint[j] = 0xe0 | charcode >> 12;\n        uint[++j] = 0x80 | charcode >> 6 & 0x3f;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else {\n        uint[j] = 0xef;\n        uint[++j] = 0xbf;\n        uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n      }\n\n      ++j;\n      ++index;\n    }\n\n    return bytes;\n  };\n\n  Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var uint16 = new Uint16Array(bytes);\n\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(i);\n      uint16[i] = charcode;\n    }\n\n    return bytes;\n  };\n\n  Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\n    var j = 0;\n    var i = index;\n    var s = '';\n\n    for (j; j < count; j++) {\n      var c = byteCal[i++];\n\n      while (i > byteCal.length) {\n        return s;\n      }\n\n      if (c > 127) {\n        if (c > 191 && c < 224 && i < count) {\n          c = (c & 31) << 6 | byteCal[i] & 63;\n        } else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n          c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n        } else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n          c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n        }\n\n        ++i;\n      }\n\n      s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n    }\n\n    return s;\n  };\n\n  Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\n    if (count > byteUni.length) {\n      throw new RangeError('ArgumentOutOfRange_Count');\n    }\n\n    var byte16 = new Uint16Array(count);\n    var out = '';\n\n    for (var i = 0; i < count && i < byteUni.length; i++) {\n      byte16[i] = byteUni[index++];\n    }\n\n    out = String.fromCharCode.apply(null, byte16);\n    return out;\n  };\n  /**\n   * To clear the encoding instance\n   * @return {void}\n   */\n\n\n  Encoding.prototype.destroy = function () {\n    this.emitBOM = undefined;\n    this.encodingType = undefined;\n  };\n\n  return Encoding;\n}();\n\nexport { Encoding };\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\n\nexport function validateNullOrUndefined(value, message) {\n  if (value === null || value === undefined) {\n    throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}